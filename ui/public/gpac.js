var libgpac = (() => {
    var _scriptDir =
        typeof document !== "undefined" && document.currentScript
            ? document.currentScript.src
            : undefined;
    if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
    return function (libgpac = {}) {
        // include: shell.js
        // The Module object: Our interface to the outside world. We import
        // and export values on it. There are various ways Module can be used:
        // 1. Not defined. We create it here
        // 2. A function parameter, function(Module) { ..generated code.. }
        // 3. pre-run appended it, var Module = {}; ..generated code..
        // 4. External script tag defines var Module.
        // We need to check if Module already exists (e.g. case 3 above).
        // Substitution will be replaced with actual code on later stage of the build,
        // this way Closure Compiler will not mangle it (e.g. case 4. above).
        // Note that if you want to run closure, and also to use Module
        // after the generated code, you will need to define   var Module = {};
        // before the code. Then that object will be used in the code, and you
        // can continue to use Module afterwards as well.
        var Module = typeof libgpac != "undefined" ? libgpac : {};

        // Set up the promise that indicates the Module is initialized
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function (resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
        });
        [
            "_main",
            "_gf_log_tool_level_on",
            "_gf_log_lt",
            "_gf_log",
            "_gpac_em_sig_handler",
            "_gf_fs_abort",
            "_gf_fs_set_ui_callback",
            "_gf_fs_enable_reporting",
            "_gf_log_use_file",
            "_gf_malloc",
            "_gf_log_set_callback",
            "_gf_sys_clock_high_res",
            "_gf_sys_get_rti",
            "_gf_net_get_utc",
            "_gf_fs_lock_filters",
            "_gf_fs_get_filters_count",
            "_gf_fs_get_filter_stats",
            "_gf_stream_type_name",
            "_gf_codecid_name",
            "_fflush",
            "_gpac_has_threads",
            "_gf_sys_init",
            "_gf_log_set_tool_level",
            "_gf_opts_get_key_count",
            "_gf_opts_get_key",
            "_gf_opts_set_key",
            "_gf_sys_set_args",
            "_gf_error_to_string",
            "_gf_sys_mark_arg_used",
            "_gf_fs_new_defaults",
            "_gf_set_progress_callback",
            "_gf_fs_load_filter",
            "_gf_fs_run",
            "_gf_fs_del",
            "_gf_gpac_version",
            "_gf_sys_features",
            "_gf_sys_format_help",
            "_gf_fopen",
            "_gf_enum_directory",
            "_gf_fs_filter_exists",
            "_gf_sys_is_gpac_arg",
            "_gf_fclose",
            "_gf_gpac_copyright",
            "_gf_sys_get_argc",
            "_gf_sys_is_arg_used",
            "_gf_sys_get_arg",
            "_gf_list_count",
            "_gf_list_pop_back",
            "_gf_free",
            "_gf_list_del",
            "_gf_sys_close",
            "_gf_fs_set_separators",
            "_gf_fs_register_test_filters",
            "_gf_fs_get_max_resolution_chain_length",
            "_gf_fs_print_all_connections",
            "_gf_fs_load_script",
            "_gf_list_new",
            "_gf_fs_load_source",
            "_gf_fs_load_destination",
            "_gf_list_add",
            "_gf_dynstrcat",
            "_gf_filter_tag_subsession",
            "_gf_list_pop_front",
            "_gf_list_get",
            "_gf_filter_set_source",
            "_gf_filter_is_source",
            "_gf_filter_is_sink",
            "_gf_gpac_copyright_cite",
            "_gf_opts_get_bool",
            "_gf_fs_post_user_task_main",
            "_gf_fs_post_user_task",
            "_gf_fs_get_last_connect_error",
            "_gf_fs_get_last_process_error",
            "_gf_fs_print_non_connected_ex",
            "_gf_fs_print_stats",
            "_gf_fs_print_connections",
            "_gf_fileio_get_udta",
            "_gf_fileio_del",
            "_gf_log_reset_file",
            "_gf_fs_stop",
            "_gf_url_colon_suffix",
            "_gf_strdup",
            "_gf_fileio_new",
            "_gf_fileio_url",
            "_gf_fs_new_filter",
            "_gf_filter_push_caps",
            "_gf_filter_set_configure_ckb",
            "_gf_filter_set_process_ckb",
            "_gf_filter_set_process_event_ckb",
            "_gf_filter_set_reconfigure_output_ckb",
            "_gf_filter_set_probe_data_cbk",
            "_gf_prompt_has_input",
            "_gf_prompt_get_char",
            "_gf_fs_send_update",
            "_gf_filter_remove",
            "_gf_filter_reconnect_output",
            "_gf_sleep",
            "_gf_fs_is_last_task",
            "_gf_getch",
            "_gf_fs_print_debug_info",
            "_gf_file_exists",
            "_gf_fsize",
            "_gf_fileio_set_stats",
            "_gf_url_concatenate",
            "_gf_list_del_item",
            "_gf_fseek",
            "_gf_fread",
            "_gf_fwrite",
            "_gf_ftell",
            "_gf_filter_pid_send_event",
            "_gf_filter_pid_set_framing_mode",
            "_gf_filter_get_ipid_count",
            "_gf_filter_get_ipid",
            "_gf_filter_pid_get_name",
            "_gf_filter_pid_get_packet",
            "_gf_filter_pck_get_cts",
            "_gf_filter_pid_drop_packet",
            "_gf_realloc",
            "_gf_gmtime",
            "_gf_sys_print_arg",
            "_gf_sc_user_event",
            "_gf_set_progress",
            "_gf_sc_get_option",
            "_gf_sc_set_option",
            "_gf_sc_get_fps",
            "_gf_sc_get_time_in_ms",
            "_gf_sc_switch_quality",
            "_gf_sc_toggle_addons",
            "_gf_sc_set_speed",
            "_gf_sc_set_size",
            "_gf_sc_scene_update",
            "_gf_sc_navigate_to",
            "_gf_sc_is_supported_url",
            "_gf_read_line_input",
            "_gf_filter_get_udta",
            "_gf_sc_connect_from_time",
            "_gf_opts_discard_changes",
            "_gf_sys_clock",
            "_gf_sc_disconnect",
            "_gf_sc_play_from_time",
            "_gf_sc_get_url",
            "_gf_sc_select_service",
            "_gf_sc_dump_scene",
            "_gf_log_get_tools_levels",
            "_gf_log_modify_tools_levels",
            "_gf_sc_get_offscreen_buffer",
            "_gf_sc_get_screen_buffer",
            "_gf_img_png_enc",
            "_gf_sc_release_screen_buffer",
            "_gf_sc_get_main_pid",
            "_gf_filter_pid_get_info_str",
            "_gf_filter_pid_get_property",
            "_gf_file_basename",
            "_gf_sys_localized",
            "_gf_modules_load_by_name",
            "_gf_modules_close_interface",
            "_gf_modules_count",
            "_gf_modules_get_file_name",
            "_gf_opts_get_key_name",
            "_gf_sys_print_core_help",
            "_gf_opts_get_filename",
            "_gf_cfg_force_new",
            "_gf_cfg_get_key",
            "_gf_cfg_del",
            "_gf_cfg_del_section",
            "_gf_cfg_set_key",
            "_gf_fs_new",
            "_gf_fs_filters_registers_count",
            "_gf_fs_get_filter_register",
            "_gf_sys_word_match",
            "_gf_sys_get_options",
            "_gf_props_get_description",
            "_gf_fs_enum_unmapped_options",
            "_gf_cfg_new",
            "_gf_cfg_get_key_count",
            "_gf_cfg_get_key_name",
            "_gf_filter_get_register",
            "_gf_file_ext_start",
            "_gf_log_set_tools_levels",
            "_gf_opts_default_shared_directory",
            "_my_str_lwr",
            "_gf_filter_get_description",
            "_gf_filter_get_help",
            "_gf_fgets",
            "_gf_filter_get_version",
            "_gf_filter_get_author",
            "_gf_filter_get_args",
            "_gf_filter_get_caps",
            "_gf_filter_get_name",
            "_gf_props_get_type_name",
            "_gf_props_get_type_desc",
            "_gf_4cc_to_str",
            "_gf_strnistr",
            "_gf_pixel_fmt_all_names",
            "_gf_pixel_fmt_all_shortnames",
            "_gf_audio_fmt_all_names",
            "_gf_audio_fmt_all_shortnames",
            "_gf_props_type_is_enum",
            "_gf_props_enum_all_names",
            "_gf_pixel_fmt_enum",
            "_gf_pixel_fmt_to_qt_type",
            "_gf_audio_fmt_enum",
            "_gf_stream_types_enum",
            "_gf_codecid_enum",
            "_gf_audio_fmt_cicp_enum",
            "_gf_cicp_color_primaries_name",
            "_gf_cicp_color_transfer_name",
            "_gf_cicp_color_matrix_name",
            "_gf_color_enum",
            "_gf_list_find",
            "_gf_codecid_type",
            "_gf_codecid_alt",
            "_gf_fs_check_filter_register_cap",
            "_gf_codecid_mime",
            "_gf_codecid_4cc_type",
            "_gf_list_rem",
            "_gf_list_enum",
            "_gf_cfg_discard_changes",
            "_gf_crc_32",
            "_gf_props_4cc_get_name",
            "_gf_props_dump_val",
            "_gf_parse_frac",
            "_gf_file_load_data",
            "_gf_itags_get_type",
            "_gf_itags_get_name",
            "_gf_itags_get_itag",
            "_gf_itags_get_alt_name",
            "_gf_parse_lfrac",
            "_gf_isom_probe_file",
            "_gf_isom_get_track_count",
            "_gf_isom_set_pl_indication",
            "_gf_isom_get_media_type",
            "_gf_isom_get_media_subtype",
            "_gf_isom_remove_track_from_root_od",
            "_gf_isom_get_esd",
            "_gf_isom_get_pl_indication",
            "_gf_m4v_get_config",
            "_gf_m4a_get_config",
            "_gf_odf_desc_del",
            "_gf_isom_remove_track",
            "_gf_isom_open",
            "_gf_isom_open_segment",
            "_gf_isom_delete",
            "_gf_isom_last_error",
            "_gf_isom_open_progressive",
            "_gf_media_import",
            "_gf_file_delete",
            "_gf_isom_freeze_order",
            "_gf_isom_keep_utc_times",
            "_gf_strlcpy",
            "_gf_isom_get_track_id",
            "_gf_media_export",
            "_gf_isom_reset_switch_parameters",
            "_gf_isom_remove_root_od",
            "_gf_isom_get_timescale",
            "_gf_isom_set_timescale",
            "_gf_isom_is_inplace_rewrite",
            "_gf_media_make_isma",
            "_gf_media_make_3gpp",
            "_gf_media_make_psp",
            "_gf_media_check_qt_prores",
            "_gf_isom_set_copyright",
            "_gf_media_import_chapters",
            "_gf_isom_set_brand_info",
            "_gf_isom_modify_alternate_brand",
            "_gf_isom_apply_box_patch",
            "_gf_crypt_fragment",
            "_gf_crypt_file",
            "_gf_decrypt_fragment",
            "_gf_decrypt_file",
            "_gf_isom_get_filename",
            "_gf_file_move",
            "_gf_media_fragment_file",
            "_gf_isom_force_64bit_chunk_offset",
            "_gf_isom_enable_compression",
            "_gf_isom_disable_inplace_rewrite",
            "_gf_isom_set_inplace_padding",
            "_gf_isom_set_final_name",
            "_gf_isom_set_storage_mode",
            "_gf_isom_make_interleave",
            "_gf_sys_is_quiet",
            "_gf_isom_close",
            "_gf_bs_from_file",
            "_gf_bs_available",
            "_gf_bs_read_u32",
            "_gf_bs_read_u64",
            "_gf_bs_skip_bytes",
            "_gf_bs_del",
            "_gf_bs_get_size",
            "_gf_bs_write_u32",
            "_gf_bs_read_data",
            "_gf_bs_write_data",
            "_gf_gz_compress_payload",
            "_gf_bs_get_position",
            "_gf_isom_get_duration",
            "_gf_isom_get_sample_count",
            "_gf_fs_print_non_connected",
            "_gf_xml_dom_new",
            "_gf_xml_dom_parse",
            "_gf_xml_dom_del",
            "_gf_xml_dom_get_root_idx",
            "_gf_xml_parse_bit_sequence",
            "_gf_media_get_file_hash",
            "_gf_isom_is_video_handler_type",
            "_gf_mpd_new",
            "_gf_m3u8_to_mpd",
            "_gf_mpd_smooth_to_mpd",
            "_gf_mpd_write_file",
            "_gf_mpd_del",
            "_gf_url_get_resource_name",
            "_gf_rand",
            "_gf_get_default_cache_directory",
            "_gf_dasher_new",
            "_gf_dasher_set_info",
            "_gf_dasher_del",
            "_gf_dasher_set_start_date",
            "_gf_dasher_set_location",
            "_gf_dasher_add_base_url",
            "_gf_dasher_enable_url_template",
            "_gf_dasher_enable_segment_timeline",
            "_gf_dasher_enable_single_segment",
            "_gf_dasher_enable_single_file",
            "_gf_dasher_set_switch_mode",
            "_gf_dasher_set_durations",
            "_gf_dasher_enable_rap_splitting",
            "_gf_dasher_set_segment_marker",
            "_gf_dasher_enable_sidx",
            "_gf_dasher_set_dynamic_mode",
            "_gf_dasher_set_min_buffer",
            "_gf_dasher_set_ast_offset",
            "_gf_dasher_enable_memory_fragmenting",
            "_gf_dasher_set_initial_isobmf",
            "_gf_dasher_configure_isobmf_default",
            "_gf_dasher_enable_utc_ref",
            "_gf_dasher_enable_real_time",
            "_gf_dasher_set_content_protection_location_mode",
            "_gf_dasher_set_profile_extension",
            "_gf_dasher_enable_cached_inputs",
            "_gf_dasher_enable_loop_inputs",
            "_gf_dasher_set_split_mode",
            "_gf_dasher_set_last_segment_merge",
            "_gf_dasher_set_hls_clock",
            "_gf_dasher_set_cues",
            "_gf_dasher_print_session_info",
            "_gf_dasher_keep_source_utc",
            "_gf_dasher_add_input",
            "_gf_dasher_process",
            "_gf_dasher_next_update_time",
            "_gf_sys_is_test_mode",
            "_gf_isom_get_root_od",
            "_gf_odf_desc_write",
            "_gf_isom_get_track_by_id",
            "_gf_isom_set_meta_type",
            "_gf_isom_get_meta_item_by_id",
            "_gf_isom_remove_meta_item",
            "_gf_isom_add_meta_item",
            "_gf_isom_meta_add_item_ref",
            "_gf_isom_get_meta_type",
            "_gf_isom_meta_get_next_item_id",
            "_gf_isom_iff_create_image_overlay_item",
            "_gf_isom_iff_create_image_grid_item",
            "_gf_isom_iff_create_image_identity_item",
            "_gf_isom_set_meta_primary_item",
            "_gf_isom_set_meta_xml",
            "_gf_isom_get_meta_item_count",
            "_gf_isom_remove_meta_xml",
            "_gf_isom_extract_meta_item",
            "_gf_isom_has_meta_xml",
            "_gf_isom_extract_meta_xml",
            "_gf_isom_disable_brand_rewrite",
            "_gf_isom_iff_create_image_item_from_track",
            "_gf_isom_meta_add_item_group",
            "_gf_isom_set_track_switch_parameter",
            "_gf_isom_get_track_switch_group_count",
            "_gf_isom_reset_track_switch_parameter",
            "_gf_isom_set_ipod_compatible",
            "_gf_isom_get_reference_count",
            "_gf_isom_get_reference",
            "_gf_isom_set_media_type",
            "_gf_isom_set_media_creation_time",
            "_gf_isom_is_media_encrypted",
            "_gf_isom_is_ismacryp_media",
            "_gf_isom_change_ismacryp_protection",
            "_gf_isom_remove_track_kind",
            "_gf_isom_add_track_kind",
            "_gf_isom_set_media_language",
            "_gf_isom_remove_edits",
            "_gf_isom_get_track_duration",
            "_gf_isom_get_edits_count",
            "_gf_isom_append_edit",
            "_gf_isom_get_media_timescale",
            "_gf_isom_set_track_id",
            "_gf_isom_set_clean_aperture",
            "_gf_isom_set_track_matrix",
            "_gf_isom_set_handler_name",
            "_gf_isom_is_track_enabled",
            "_gf_isom_set_track_enabled",
            "_gf_isom_set_track_reference",
            "_gf_isom_remove_track_reference",
            "_gf_media_remove_non_rap",
            "_gf_isom_set_creation_time",
            "_gf_isom_set_track_creation_time",
            "_gf_media_change_par",
            "_gf_itags_find_by_name",
            "_gf_media_isom_apply_qt_key",
            "_gf_isom_apple_set_tag",
            "_gf_isom_set_qt_key",
            "_gf_isom_wma_set_tag",
            "_gf_lang_get_count",
            "_gf_lang_get_2cc",
            "_gf_lang_get_name",
            "_gf_lang_get_3cc",
            "_gf_isom_apple_get_tag",
            "_gf_sg_new",
            "_gf_sm_new",
            "_gf_sm_del",
            "_gf_sg_del",
            "_gf_isom_disable_odf_conversion",
            "_gf_sm_load_init",
            "_gf_sm_load_run",
            "_gf_sm_load_done",
            "_gf_sm_dump",
            "_gf_sm_stats_new",
            "_gf_sm_stats_for_scene",
            "_gf_sm_stats_get",
            "_gf_list_insert",
            "_gf_sm_stats_for_command",
            "_gf_sg_command_apply",
            "_gf_sm_stats_for_graph",
            "_gf_sm_stats_reset",
            "_gf_sm_stats_del",
            "_gf_node_x3d_type_by_class_name",
            "_gf_node_mpeg4_type_by_class_name",
            "_gf_node_new",
            "_gf_node_register",
            "_gf_node_get_class_name",
            "_gf_node_unregister",
            "_gf_node_get_field_count",
            "_gf_node_get_field_by_name",
            "_gf_node_in_table_by_tag",
            "_gf_bifs_get_child_table",
            "_gf_node_get_num_fields_in_mode",
            "_gf_sg_script_get_field_index",
            "_gf_node_get_tag",
            "_gf_node_get_field",
            "_gf_sg_vrml_get_event_type_name",
            "_gf_sg_vrml_get_field_type_name",
            "_gf_sg_vrml_is_sf_field",
            "_gf_sg_vrml_get_sf_type",
            "_gf_sg_vrml_mf_get_item",
            "_gf_bifs_get_aq_info",
            "_gf_sg_vrml_field_pointer_new",
            "_gf_sg_vrml_field_pointer_del",
            "_gf_isom_get_num_supported_boxes",
            "_gf_isom_dump_supported_box",
            "_gf_isom_get_supported_box_type",
            "_gf_isom_box_new",
            "_gf_isom_clone_box",
            "_gf_isom_box_del",
            "_gf_isom_is_fragmented",
            "_gf_isom_get_cts_to_dts_shift",
            "_gf_isom_has_time_offset",
            "_gf_isom_get_sample_info",
            "_gf_isom_get_sample_flags",
            "_gf_isom_get_sample_rap_roll_info",
            "_gf_isom_sample_del",
            "_gf_isom_sample_is_fragment_start",
            "_gf_xml_dom_get_line",
            "_gf_xml_dom_get_error",
            "_gf_av1_init_state",
            "_gf_isom_av1_config_get",
            "_gf_bs_new",
            "_gf_av1_parse_obu",
            "_gf_odf_av1_cfg_del",
            "_gf_av1_reset_state",
            "_gf_inspect_dump_obu",
            "_gf_isom_get_sample",
            "_gf_inspect_dump_prores",
            "_gf_isom_opus_config_get_desc",
            "_gf_inspect_dump_opus",
            "_gf_isom_get_nalu_extract_mode",
            "_gf_isom_get_sample_description_count",
            "_gf_isom_avc_config_get",
            "_gf_isom_svc_config_get",
            "_gf_isom_mvc_config_get",
            "_gf_isom_hevc_config_get",
            "_gf_isom_lhvc_config_get",
            "_gf_isom_vvc_config_get",
            "_gf_inspect_dump_nalu",
            "_gf_odf_avc_cfg_del",
            "_gf_odf_hevc_cfg_del",
            "_gf_odf_vvc_cfg_del",
            "_gf_isom_get_reference_ID",
            "_gf_isom_set_nalu_extract_mode",
            "_gf_isom_is_adobe_protection_media",
            "_gf_isom_is_cenc_media",
            "_gf_isom_get_sample_cenc_info",
            "_gf_isom_get_edit_list_type",
            "_gf_isom_get_chunk_count",
            "_gf_isom_get_media_duration",
            "_gf_isom_get_constant_sample_size",
            "_gf_isom_enable_raw_pack",
            "_gf_isom_get_chunk_info",
            "_gf_isom_get_sample_size",
            "_gf_isom_get_first_mdat_start",
            "_gf_isom_get_unused_box_bytes",
            "_gf_isom_dump_ismacryp_protection",
            "_gf_isom_dump_ismacryp_sample",
            "_gf_isom_text_dump",
            "_gf_isom_dump",
            "_gf_isom_get_avc_svc_type",
            "_gf_isom_get_hevc_lhvc_type",
            "_gf_isom_get_vvc_type",
            "_gf_webvtt_dump_iso_track",
            "_gf_isom_get_udta_count",
            "_gf_isom_get_udta_type",
            "_gf_isom_get_user_data_count",
            "_gf_itags_find_by_itag",
            "_gf_isom_get_user_data",
            "_gf_utf8_is_legal",
            "_gf_isom_get_chapter_count",
            "_gf_isom_get_chapter",
            "_gf_hevc_get_profile_name",
            "_gf_avc_hevc_get_chroma_format_name",
            "_gf_hevc_read_vps",
            "_gf_hevc_get_sps_info_with_state",
            "_gf_isom_get_track_layout_info",
            "_gf_sha1_csum",
            "_gf_vvc_get_sps_info",
            "_gf_isom_get_media_original_duration",
            "_gf_isom_check_data_reference",
            "_gf_isom_get_composition_offset_shift",
            "_gf_isom_is_track_in_root_od",
            "_gf_isom_get_track_flags",
            "_gf_isom_get_media_language",
            "_gf_isom_get_mpeg4_subtype",
            "_gf_isom_is_track_referenced",
            "_gf_isom_get_constant_sample_duration",
            "_gf_media_get_reduced_frame_rate",
            "_gf_isom_enum_track_group",
            "_gf_isom_get_track_kind_count",
            "_gf_isom_get_track_kind",
            "_gf_isom_is_track_fragmented",
            "_gf_isom_get_fragmented_samples_info",
            "_gf_isom_get_fragment_defaults",
            "_gf_isom_get_handler_name",
            "_gf_isom_enum_track_references",
            "_gf_isom_get_track_switch_parameter",
            "_gf_isom_has_sync_points",
            "_gf_isom_get_sync_point_count",
            "_gf_isom_get_max_sample_delta",
            "_gf_isom_get_chunks_infos",
            "_gf_lang_find",
            "_gf_isom_get_meta_primary_item_id",
            "_gf_isom_get_meta_item_info",
            "_gf_isom_get_meta_image_props",
            "_gf_isom_extract_meta_item_get_cenc_info",
            "_gf_isom_get_original_format_type",
            "_gf_pixel_fmt_from_qt_type",
            "_gf_codec_id_from_isobmf",
            "_gf_isom_get_generic_sample_description",
            "_gf_bs_read_utf8",
            "_gf_isom_is_self_contained",
            "_gf_isom_get_data_reference",
            "_gf_isom_get_visual_info",
            "_gf_isom_get_visual_bit_depth",
            "_gf_isom_dovi_config_get",
            "_gf_odf_dovi_cfg_del",
            "_gf_isom_get_audio_info",
            "_gf_isom_get_dims_description",
            "_gf_isom_ac3_config_get",
            "_gf_av1_get_obu_name",
            "_gf_ac3_get_total_channels",
            "_gf_eac3_get_chan_loc_count",
            "_gf_ac3_get_bitrate",
            "_gf_m4v_get_profile_name",
            "_gf_avc_get_profile_name",
            "_gf_avc_get_sps_info",
            "_gf_isom_get_tile_info",
            "_gf_isom_get_sample_group_info",
            "_gf_isom_get_oinf_info",
            "_gf_codecid_from_oti",
            "_gf_m4a_object_type_name",
            "_gf_mp3_version_name",
            "_gf_mp3_num_channels",
            "_gf_mp3_sampling_rate",
            "_gf_mp3_layer",
            "_gf_odf_get_bifs_config",
            "_gf_stream_type_afx_name",
            "_gf_odf_get_laser_config",
            "_gf_isom_get_rvc_config",
            "_gf_isom_stxt_get_description",
            "_gf_isom_xml_subtitle_get_description",
            "_gf_isom_get_text_description",
            "_gf_isom_get_xml_metadata_description",
            "_gf_isom_get_lpcm_config",
            "_gf_media_map_esd",
            "_gf_mpegh_get_mhas_pl",
            "_gf_audio_fmt_get_layout_name",
            "_gf_audio_fmt_get_layout_name_from_cicp",
            "_gf_isom_get_mpegh_compatible_profiles",
            "_gf_isom_truehd_config_get",
            "_gf_isom_get_pcm_config",
            "_gf_pixel_fmt_name",
            "_gf_isom_get_tmcd_config",
            "_gf_inspect_format_timecode",
            "_gf_isom_is_track_encrypted",
            "_gf_isom_get_ismacryp_info",
            "_gf_isom_is_omadrm_media",
            "_gf_isom_get_omadrm_info",
            "_gf_isom_get_cenc_info",
            "_gf_isom_cenc_get_default_info",
            "_gf_isom_get_adobe_protection_info",
            "_gf_media_get_rfc_6381_codec_name",
            "_gf_isom_has_movie",
            "_gf_isom_has_segment",
            "_gf_isom_segment_get_fragment_count",
            "_gf_isom_segment_get_track_fragment_count",
            "_gf_isom_segment_get_fragment_size",
            "_gf_isom_segment_get_track_fragment_decode_time",
            "_gf_isom_get_original_duration",
            "_gf_isom_get_fragmented_duration",
            "_gf_isom_get_fragments_count",
            "_gf_isom_moov_first",
            "_gf_isom_get_brand_info",
            "_gf_isom_get_alternate_brand",
            "_gf_isom_get_creation_time",
            "_gf_odf_desc_size",
            "_gf_m4a_get_profile_name",
            "_gf_isom_is_JPEG2000",
            "_gf_isom_get_copyright_count",
            "_gf_isom_get_copyright",
            "_gf_isom_parse_text_sample",
            "_gf_isom_delete_text_sample",
            "_gf_isom_apple_enum_tag",
            "_gf_id3_get_genre",
            "_gf_isom_enum_udta_keys",
            "_gf_isom_wma_enum_tag",
            "_gf_utf8_wcslen",
            "_gf_utf8_wcstombs",
            "_gf_m2ts_demux_new",
            "_gf_m2ts_process_data",
            "_gf_m2ts_reset_parsers",
            "_gf_m2ts_demux_del",
            "_gf_m2ts_set_pes_framing",
            "_gf_m2ts_get_stream_name",
            "_gf_isom_remove_user_data",
            "_gf_base64_decode",
            "_gf_isom_add_user_data_boxes",
            "_gf_isom_add_user_data",
            "_gf_cicp_parse_color_primaries",
            "_gf_cicp_parse_color_transfer",
            "_gf_cicp_parse_color_matrix",
            "_gf_isom_set_edit",
            "_gf_isom_set_edit_with_rate",
            "_gf_calloc",
            "_gf_isom_get_next_alternate_group_id",
            "_gf_sys_old_arch_compat",
            "_gf_isom_get_track_magic",
            "_gf_isom_set_track_flags",
            "_gf_media_change_color",
            "_gf_isom_set_visual_bit_depth",
            "_gf_isom_set_visual_color_info",
            "_gf_isom_set_image_sequence_coding_constraints",
            "_gf_isom_use_compact_size",
            "_gf_isom_set_alternate_group_id",
            "_gf_isom_set_track_group",
            "_gf_isom_set_track_layout_info",
            "_gf_isom_set_media_subtype",
            "_gf_media_change_pl",
            "_gf_isom_set_audio_info",
            "_gf_isom_set_sample_roll_group",
            "_gf_isom_set_media_timescale",
            "_gf_isom_set_last_sample_duration_ex",
            "_gf_isom_set_rvc_config",
            "_gf_isom_set_composition_offset_mode",
            "_gf_isom_text_set_display_flags",
            "_gf_isom_update_bitrate",
            "_gf_eac3_parser",
            "_gf_isom_ac3_config_update",
            "_gf_isom_set_track_index",
            "_gf_isom_add_chapter",
            "_gf_isom_rewrite_track_dependencies",
            "_gf_media_filter_hevc",
            "_gf_media_split_svc",
            "_gf_media_merge_svc",
            "_gf_media_split_lhvc",
            "_gf_media_split_hevc_tiles",
            "_gf_isom_new_track",
            "_gf_isom_tmcd_config_new",
            "_gf_isom_sample_new",
            "_gf_bs_get_content",
            "_gf_isom_add_sample",
            "_gf_isom_set_last_sample_duration",
            "_gf_isom_set_high_dynamic_range_info",
            "_gf_xml_dom_get_root",
            "_gf_isom_set_dolby_vision_profile",
            "_gf_bs_read_int",
            "_gf_bs_read_u8",
            "_gf_av1_parse_obu_header",
            "_gf_av1_leb128_read",
            "_gf_bs_seek",
            "_gf_dolby_vision_level",
            "_gf_isom_get_sample_duration",
            "_gf_sys_find_global_arg",
            "_gf_dir_exists",
            "_gf_log_get_tool_level",
            "_gf_isom_get_sample_dts",
            "_gf_timestamp_less",
            "_gf_isom_get_track_original_id",
            "_gf_isom_is_same_sample_description",
            "_gf_isom_clone_sample_description",
            "_gf_isom_clone_track",
            "_gf_isom_clone_pl_indications",
            "_gf_isom_get_edit",
            "_gf_bs_write_int",
            "_gf_isom_add_sample_reference",
            "_gf_isom_copy_sample_info",
            "_gf_isom_update_duration",
            "_gf_timestamp_rescale",
            "_gf_isom_modify_edit",
            "_gf_media_update_bitrate",
            "_gf_media_nal_rewrite_samples",
            "_gf_isom_avc_config_update",
            "_gf_isom_avc_set_inband_config",
            "_gf_isom_hevc_config_update",
            "_gf_isom_hevc_set_inband_config",
            "_gf_sg_command_new",
            "_gf_sg_command_field_new",
            "_gf_sm_encode_to_file",
            "_gf_bifs_encoder_new",
            "_gf_odf_desc_esd_new",
            "_gf_odf_desc_new",
            "_gf_bifs_encoder_new_stream",
            "_gf_bifs_encoder_get_config",
            "_gf_bifs_encoder_get_version",
            "_gf_bifs_encode_au",
            "_gf_bifs_encoder_del",
            "_gf_sm_aggregate",
            "_gf_xml_get_root_type",
            "_gf_xml_sax_new",
            "_gf_xml_sax_parse_file",
            "_gf_xml_sax_binary_file",
            "_gf_xml_sax_del",
            "_gf_list_last",
            "_gf_list_rem_last",
            "_gf_gpac_abi_major",
            "_gf_gpac_abi_minor",
            "_gf_gpac_abi_micro",
            "_gf_rand_init",
            "_gf_utc_time_since_1970",
            "_gf_get_user_name",
            "_my_str_upr",
            "_gf_prompt_set_echo_off",
            "_gf_prompt_get_size",
            "_gf_net_set_ntp_shift",
            "_gf_sys_get_argv",
            "_gf_sys_profiler_set_callback",
            "_gf_sys_profiler_send",
            "_gf_sys_profiler_enable_sampling",
            "_gf_sys_profiler_sampling_enabled",
            "_gf_blob_get",
            "_gf_blob_release",
            "_gf_blob_register",
            "_gf_blob_unregister",
            "_gf_opts_get_section_count",
            "_gf_opts_get_section_name",
            "_gf_opts_del_section",
            "_gf_mkdir",
            "_gf_sys_get_battery_state",
            "_gf_net_get_ntp",
            "_gf_net_get_ntp_ts",
            "_gf_net_ntp_diff_ms",
            "_gf_net_get_ntp_diff_ms",
            "_gf_net_get_ntp_ms",
            "_gf_net_get_timezone",
            "_gf_net_time_is_dst",
            "_gf_net_parse_date",
            "_gf_net_get_utc_ts",
            "_gf_net_ntp_to_utc",
            "_gf_bin128_parse",
            "_gf_file_load_data_filep",
            "_gf_sys_get_process_id",
            "_gf_creds_check_password",
            "_gf_sha256_csum",
            "_gf_cfg_save",
            "_gf_creds_check_membership",
            "_gf_token_find_word",
            "_gf_rmdir",
            "_gf_dir_cleanup",
            "_gf_file_exists_ex",
            "_gf_fileio_from_url",
            "_gf_fileio_open_url",
            "_gf_fileio_resource_url",
            "_gf_file_modification_time",
            "_gf_file_handles_count",
            "_gf_file_temp",
            "_gf_fopen_ex",
            "_gf_fileio_check",
            "_gf_fileio_write_ready",
            "_gf_fileio_write_mode",
            "_gf_fileio_read_mode",
            "_gf_fileio_translate_url",
            "_gf_fileio_factory",
            "_gf_fileio_set_write_state",
            "_gf_fileio_get_stats",
            "_gf_fileio_tag_main_thread",
            "_gf_fileio_is_main_thread",
            "_gf_fgetc",
            "_gf_fputc",
            "_gf_fputs",
            "_gf_fprintf",
            "_gf_vfprintf",
            "_gf_fflush",
            "_gf_feof",
            "_gf_ferror",
            "_gf_list_reset",
            "_gf_list_swap",
            "_gf_list_transfer",
            "_gf_list_clone",
            "_gf_opts_get_int",
            "_gf_bs_from_fd",
            "_gf_bs_enable_emulation_byte_removal",
            "_gf_bs_get_emulation_byte_removed",
            "_gf_bs_read_bit",
            "_gf_bs_read_u16",
            "_gf_bs_read_u24",
            "_gf_bs_read_long_int",
            "_gf_bs_read_float",
            "_gf_bs_read_double",
            "_gf_bs_write_long_int",
            "_gf_bs_write_u8",
            "_gf_bs_write_u16",
            "_gf_bs_write_u24",
            "_gf_bs_write_u64",
            "_gf_bs_write_byte",
            "_gf_bs_write_float",
            "_gf_bs_write_double",
            "_gf_bs_align",
            "_gf_bs_get_content_no_truncate",
            "_gf_bs_peek_bits",
            "_gf_bs_get_refreshed_size",
            "_gf_bs_bits_available",
            "_gf_bs_set_eos_callback",
            "_gf_bs_read_u64_le",
            "_gf_bs_read_u32_le",
            "_gf_bs_read_u16_le",
            "_gf_bs_write_u64_le",
            "_gf_bs_write_u32_le",
            "_gf_bs_write_u16_le",
            "_gf_bs_get_bit_offset",
            "_gf_bs_get_bit_position",
            "_gf_bs_read_vluimsbf5",
            "_gf_bs_truncate",
            "_gf_bs_transfer",
            "_gf_bs_flush",
            "_gf_bs_insert_data",
            "_gf_bs_write_utf8",
            "_gf_codecid_parse",
            "_gf_codecid_file_ext",
            "_gf_codecid_oti",
            "_gf_codecid_has_unframer",
            "_gf_stream_type_short_name",
            "_gf_stream_type_by_name",
            "_gf_audio_fmt_parse",
            "_gf_audio_fmt_name",
            "_gf_audio_fmt_sname",
            "_gf_audio_fmt_bit_depth",
            "_gf_audio_fmt_is_planar",
            "_gf_audio_fmt_from_isobmf",
            "_gf_audio_fmt_to_isobmf",
            "_gf_audio_fmt_get_cicp_layout",
            "_gf_audio_fmt_get_layout_from_cicp",
            "_gf_audio_fmt_get_layout_from_name",
            "_gf_audio_fmt_get_cicp_from_layout",
            "_gf_audio_fmt_get_num_channels_from_layout",
            "_gf_audio_fmt_get_dolby_chanmap",
            "_gf_pixel_fmt_parse",
            "_gf_pixel_fmt_probe",
            "_gf_pixel_fmt_sname",
            "_gf_pixel_fmt_is_yuv",
            "_gf_pixel_get_size_info",
            "_gf_pixel_fmt_is_transparent",
            "_gf_pixel_is_wide_depth",
            "_gf_pixel_get_bytes_per_pixel",
            "_gf_pixel_get_nb_comp",
            "_gf_itags_find_by_id3tag",
            "_gf_itags_get_id3tag",
            "_gf_itags_enum_tags",
            "_gf_id3_get_genre_tag",
            "_gf_cicp_color_primaries_all_names",
            "_gf_cicp_color_transfer_all_names",
            "_gf_cicp_color_matrix_all_names",
            "_gf_timestamp_rescale_signed",
            "_gf_timestamp_less_or_equal",
            "_gf_timestamp_greater",
            "_gf_timestamp_greater_or_equal",
            "_gf_timestamp_equal",
            "_gf_pixel_fmt_get_uncc",
            "_gf_4cc_to_str_safe",
            "_gf_4cc_parse",
            "_gf_log_set_strict_error",
            "_gf_sys_set_console_code",
            "_gf_log_tool_name",
            "_gf_log_use_color",
            "_gf_log_va_list",
            "_gf_url_is_local",
            "_gf_url_is_relative",
            "_gf_url_get_absolute_path",
            "_gf_url_concatenate_parent",
            "_gf_url_to_fs_path",
            "_gf_url_get_path",
            "_gf_url_free",
            "_gf_cfg_get_filename",
            "_gf_cfg_get_section_count",
            "_gf_cfg_get_section_name",
            "_gf_gzopen",
            "_gf_gzread",
            "_gf_gzgetc",
            "_gf_gzgets",
            "_gf_gzrewind",
            "_gf_gzseek",
            "_gf_gztell",
            "_gf_gzeof",
            "_gf_gzdirect",
            "_gf_gzclose",
            "_gf_gzerror",
            "_gf_gzclearerr",
            "_gf_xml_sax_parse",
            "_gf_xml_sax_init",
            "_gf_xml_sax_suspend",
            "_gf_xml_sax_get_line",
            "_gf_xml_sax_peek_node",
            "_gf_xml_sax_get_error",
            "_gf_xml_sax_get_node_start_pos",
            "_gf_xml_sax_get_node_end_pos",
            "_gf_xml_dom_node_reset",
            "_gf_xml_dom_node_del",
            "_gf_xml_dom_detach_root",
            "_gf_xml_dom_parse_string",
            "_gf_xml_dom_get_root_nodes_count",
            "_gf_xml_dom_serialize",
            "_gf_xml_dom_serialize_root",
            "_gf_xml_dom_create_attribute",
            "_gf_xml_dom_append_child",
            "_gf_base64_encode",
            "_gf_sha1_file_ptr",
            "_gf_sha1_file",
            "_gf_base16_encode",
            "_gf_base16_decode",
            "_gf_gz_compress_payload_ex",
            "_gf_gz_decompress_payload_ex",
            "_gf_gz_decompress_payload",
            "_gf_lz_decompress_payload",
            "_gf_lz_compress_payload",
            "_gf_get_bit_size",
            "_gf_irect_union",
            "_gf_v2d_from_polar",
            "_gf_v2d_len",
            "_gf_v2d_distance",
            "_gf_angle_diff",
            "_gf_mx2d_add_matrix",
            "_gf_mx2d_pre_multiply",
            "_gf_mx2d_add_translation",
            "_gf_mx2d_add_rotation",
            "_gf_mx2d_add_scale",
            "_gf_mx2d_add_scale_at",
            "_gf_mx2d_add_skew",
            "_gf_mx2d_add_skew_x",
            "_gf_mx2d_add_skew_y",
            "_gf_mx2d_inverse",
            "_gf_mx2d_decompose",
            "_gf_mx2d_apply_coords",
            "_gf_mx2d_apply_point",
            "_gf_mx2d_apply_rect",
            "_gf_rect_pixelize",
            "_gf_rect_union",
            "_gf_rect_center",
            "_gf_rect_overlaps",
            "_gf_rect_equal",
            "_gf_rect_intersect",
            "_gf_vec_len_p",
            "_gf_vec_len",
            "_gf_vec_lensq_p",
            "_gf_vec_lensq",
            "_gf_vec_dot_p",
            "_gf_vec_dot",
            "_gf_vec_norm",
            "_gf_vec_scale_p",
            "_gf_vec_scale",
            "_gf_vec_cross_p",
            "_gf_vec_cross",
            "_gf_mx2d_from_mx",
            "_gf_mx_apply_rect",
            "_gf_mx_add_matrix",
            "_gf_mx_add_matrix_2d",
            "_gf_mx_add_translation",
            "_gf_mx_add_scale",
            "_gf_mx_add_rotation",
            "_gf_mx_from_mx2d",
            "_gf_mx_equal",
            "_gf_mx_inverse",
            "_gf_mx_transpose",
            "_gf_mx_apply_vec",
            "_gf_mx_ortho",
            "_gf_mx_ortho_reverse_z",
            "_gf_mx_perspective",
            "_gf_mx_perspective_reverse_z",
            "_gf_mx_lookat",
            "_gf_mx_get_yaw_pitch_roll",
            "_gf_mx_decompose",
            "_gf_quat_from_matrix",
            "_gf_quat_to_rotation",
            "_gf_mx_apply_bbox_sphere",
            "_gf_bbox_refresh",
            "_gf_mx_apply_bbox",
            "_gf_mx_apply_bbox_4x4",
            "_gf_mx_apply_vec_4x4",
            "_gf_mx_rotate_vector",
            "_gf_mx_rotation_matrix_from_vectors",
            "_gf_mx_add_matrix_4x4",
            "_gf_mx_inverse_4x4",
            "_gf_plane_intersect_line",
            "_gf_ray",
            "_gf_mx_apply_ray",
            "_gf_ray_hit_box",
            "_gf_ray_hit_sphere",
            "_gf_ray_hit_triangle",
            "_gf_closest_point_to_line",
            "_gf_quat_from_rotation",
            "_gf_quat_from_axis_cos",
            "_gf_quat_get_inv",
            "_gf_quat_multiply",
            "_gf_quat_rotate",
            "_gf_quat_slerp",
            "_gf_bbox_from_rect",
            "_gf_rect_from_bbox",
            "_gf_bbox_grow_point",
            "_gf_bbox_union",
            "_gf_bbox_equal",
            "_gf_bbox_point_inside",
            "_gf_bbox_get_vertices",
            "_gf_mx_apply_plane",
            "_gf_plane_get_distance",
            "_gf_plane_get_p_vertex_idx",
            "_gf_bbox_plane_relation",
            "_gf_get_next_pow2",
            "_gf_htonl",
            "_gf_ntohl",
            "_gf_htons",
            "_gf_ntohs",
            "_gf_errno_str",
            "_gf_get_default_font_dir",
            "_gf_opts_get_key_restricted",
            "_gf_opts_save",
            "_gf_sys_set_cfg_option",
            "_gf_dm_sess_new",
            "_gf_dm_sess_push_header",
            "_gf_dm_sess_async_reply",
            "_gf_utf8_mbstowcs",
            "_gf_utf_get_utf8_string_from_bom",
            "_gf_token_get",
            "_gf_token_get_strip",
            "_gf_token_get_line",
            "_gf_token_find",
            "_gf_stretch_bits",
            "_gf_cmx_apply_argb",
            "_gf_cmx_init",
            "_gf_cmx_set",
            "_gf_cmx_copy",
            "_gf_cmx_multiply",
            "_gf_cmx_apply",
            "_gf_cmx_apply_wide",
            "_gf_cmx_apply_fixed",
            "_gf_color_parse",
            "_gf_color_get_name",
            "_gf_utf8_is_right_to_left",
            "_gf_utf8_reorder_bidi",
            "_utf8_to_ucs4",
            "_gf_modules_refresh",
            "_gf_module_load_static",
            "_gf_modules_load",
            "_gf_module_get_file_name",
            "_gf_module_get_key",
            "_gf_module_get_bool",
            "_gf_module_get_int",
            "_gf_path_new",
            "_gf_path_reset",
            "_gf_path_clone",
            "_gf_path_del",
            "_gf_path_add_move_to",
            "_gf_path_add_move_to_vec",
            "_gf_path_add_line_to",
            "_gf_path_add_line_to_vec",
            "_gf_path_close",
            "_gf_path_add_cubic_to",
            "_gf_path_add_cubic_to_vec",
            "_gf_path_add_quadratic_to",
            "_gf_path_add_quadratic_to_vec",
            "_gf_path_add_rect_center",
            "_gf_path_add_rect",
            "_gf_path_add_ellipse",
            "_gf_path_add_bezier",
            "_gf_path_add_arc_to",
            "_gf_path_add_svg_arc_to",
            "_gf_path_add_arc",
            "_gf_path_get_control_bounds",
            "_gf_path_get_bounds",
            "_gf_path_get_flatten",
            "_gf_path_flatten",
            "_gf_path_point_over",
            "_gf_path_is_empty",
            "_gf_path_iterator_new",
            "_gf_path_iterator_get_length",
            "_gf_path_iterator_get_transform",
            "_gf_path_iterator_del",
            "_gf_polygone2d_get_convexity",
            "_gf_path_get_outline",
            "_gf_crypt_open",
            "_gf_crypt_close",
            "_gf_crypt_set_key",
            "_gf_crypt_set_IV",
            "_gf_crypt_get_IV",
            "_gf_crypt_init",
            "_gf_crypt_encrypt",
            "_gf_crypt_decrypt",
            "_gf_sg_new_subscene",
            "_gf_sg_set_node_callback",
            "_gf_sg_set_scene_time_callback",
            "_gf_node_get_scene_time",
            "_gf_sg_reset",
            "_gf_sg_route_del",
            "_gf_node_replace",
            "_gf_sg_proto_del",
            "_gf_dom_event_fire",
            "_gf_sg_vrml_mf_remove",
            "_gf_sg_set_private",
            "_gf_sg_get_private",
            "_gf_sg_set_scene_size_info",
            "_gf_sg_use_pixel_metrics",
            "_gf_sg_get_scene_size_info",
            "_gf_sg_get_root_node",
            "_gf_sg_set_root_node",
            "_gf_sg_command_del",
            "_gf_node_changed",
            "_gf_node_set_id",
            "_gf_node_remove_id",
            "_gf_node_traverse",
            "_gf_node_get_name",
            "_gf_node_dirty_clear",
            "_gf_node_dirty_set",
            "_gf_node_allow_cyclic_traverse",
            "_gf_node_set_cyclic_traverse_flag",
            "_gf_node_traverse_children",
            "_gf_node_get_graph",
            "_gf_sg_find_node",
            "_gf_sg_find_node_by_name",
            "_gf_sg_get_next_available_node_id",
            "_gf_sg_get_max_node_id",
            "_gf_node_get_id",
            "_gf_node_get_name_and_id",
            "_gf_node_get_private",
            "_gf_node_set_private",
            "_gf_node_set_callback_function",
            "_gf_node_unregister_children",
            "_gf_node_list_insert_child",
            "_gf_node_list_get_child",
            "_gf_node_list_find_child",
            "_gf_node_list_add_child",
            "_gf_node_list_add_child_last",
            "_gf_node_list_del_child",
            "_gf_node_list_del_child_idx",
            "_gf_node_list_get_count",
            "_gf_node_get_parent_count",
            "_gf_node_get_parent",
            "_gf_node_dirty_parent_graph",
            "_gf_node_dirty_parents",
            "_gf_node_dirty_get",
            "_gf_node_dirty_reset",
            "_gf_node_init",
            "_gf_node_get_attribute_by_name",
            "_gf_node_clone",
            "_gf_sg_add_namespace",
            "_gf_node_replace_child",
            "_gf_node_parent_of",
            "_gf_dom_add_text_node",
            "_gf_svg_create_attribute_value",
            "_gf_sg_find_proto",
            "_gf_sg_vrml_mf_reset",
            "_gf_sg_vrml_field_copy",
            "_gf_sg_script_event_in",
            "_gf_node_event_out",
            "_gf_node_get_attribute_by_tag",
            "_gf_svg_attributes_copy",
            "_gf_sg_vrml_mf_alloc",
            "_gf_sg_vrml_field_clone",
            "_gf_sg_vrml_mf_append",
            "_gf_sg_vrml_mf_insert",
            "_gf_sg_route_new",
            "_gf_sg_route_set_id",
            "_gf_sg_route_set_name",
            "_gf_node_insert_child",
            "_gf_sg_route_del_by_id",
            "_gf_sg_route_find",
            "_gf_sg_script_load",
            "_gf_sg_command_apply_list",
            "_gf_sg_mfurl_del",
            "_gf_sg_sfrotation_interpolate",
            "_gf_sg_proto_new",
            "_gf_sg_proto_get_graph",
            "_gf_sg_proto_get_extern_url",
            "_gf_sg_proto_add_node_code",
            "_gf_sg_proto_field_find_by_name",
            "_gf_sg_proto_field_new",
            "_gf_sg_proto_field_get_field",
            "_gf_sg_proto_field_is_sftime_offset",
            "_gf_sg_proto_create_instance",
            "_gf_sg_proto_load_code",
            "_gf_sg_proto_field_set_ised",
            "_gf_sg_proto_instance_set_ised",
            "_gf_sg_proto_get_field_count",
            "_gf_sg_proto_field_find",
            "_gf_node_get_proto",
            "_gf_sg_proto_get_id",
            "_gf_sg_proto_get_class_name",
            "_gf_node_proto_set_grouping",
            "_gf_node_proto_is_grouping",
            "_gf_node_get_proto_root",
            "_gf_node_set_proto_eventin_handler",
            "_gf_sg_activate_routes",
            "_gf_sg_vrml_field_equal",
            "_gf_sg_route_find_by_name",
            "_gf_sg_route_get_name",
            "_gf_node_event_out_str",
            "_gf_sg_route_new_to_callback",
            "_gf_sg_script_field_new",
            "_gf_sg_script_field_get_info",
            "_gf_js_vrml_flush_event_out",
            "_gf_sg_handle_dom_event_for_vrml",
            "_gf_sg_js_get_node",
            "_gf_sg_has_scripting",
            "_gf_x3d_get_node_type",
            "_gf_sg_delete_all_protos",
            "_gf_sg_set_proto_loader",
            "_gf_sg_get_next_available_route_id",
            "_gf_sg_set_max_defined_route_id",
            "_gf_sg_get_next_available_proto_id",
            "_gf_sg_sfcolor_to_rgba",
            "_gf_dom_event_type_by_name",
            "_gf_dom_event_get_name",
            "_gf_dom_get_key_name",
            "_gf_dom_get_friendly_name",
            "_gf_dom_get_key_type",
            "_gf_svg_parse_attribute",
            "_gf_svg_parse_element_id",
            "_gf_node_register_iri",
            "_gf_svg_parse_style",
            "_gf_svg_is_animation_tag",
            "_gf_dom_listener_count",
            "_gf_sg_handle_dom_event",
            "_gf_smil_timing_init_runtime_info",
            "_gf_node_unregister_iri",
            "_gf_js_lock",
            "_gf_sg_js_dom_pre_destroy",
            "_gf_sm_load_bt_from_string",
            "_gf_dom_flatten_textContent",
            "_gf_svg_apply_animations",
            "_gf_svg_flatten_attributes",
            "_gf_smil_set_media_duration",
            "_gf_dom_listener_del",
            "_gf_smil_timing_is_active",
            "_gf_smil_timing_insert_clock",
            "_gf_svg_properties_init_pointers",
            "_gf_svg_properties_reset_pointers",
            "_gf_svg_apply_inheritance",
            "_gf_node_dom_listener_add",
            "_gf_dom_listener_get",
            "_gf_sg_fire_dom_event",
            "_gf_dom_event_fire_ex",
            "_gf_dom_listener_build",
            "_gf_dom_set_textContent",
            "_gf_xml_get_element_tag",
            "_gf_node_store_embedded_data",
            "_gf_bifs_decoder_new",
            "_gf_bifs_decoder_configure_stream",
            "_gf_bifs_decoder_del",
            "_gf_bifs_decode_has_conditionnals",
            "_gf_bifs_decode_au",
            "_gf_bifs_encoder_set_source_url",
            "_gf_bifs_encoder_get_rap",
            "_gf_bifs_decode_command_list",
            "_gf_isom_avc_config_new",
            "_gf_isom_get_sample_ex",
            "_gf_odf_hevc_cfg_write_bs",
            "_gf_odf_hevc_cfg_read_bs",
            "_gf_odf_vvc_cfg_write_bs",
            "_gf_odf_vvc_cfg_read_bs",
            "_gf_odf_desc_copy",
            "_gf_odf_desc_add_desc",
            "_gf_odf_avc_cfg_write",
            "_gf_odf_avc_cfg_new",
            "_gf_odf_hevc_cfg_write",
            "_gf_odf_hevc_cfg_read",
            "_gf_odf_avc_cfg_read",
            "_gf_odf_av1_cfg_write",
            "_gf_odf_vp_cfg_new",
            "_gf_odf_vp_cfg_write",
            "_gf_odf_vp_cfg_del",
            "_gf_isom_svc_config_update",
            "_gf_isom_svc_config_new",
            "_gf_isom_mvc_config_new",
            "_gf_isom_hevc_config_new",
            "_gf_isom_vvc_config_new",
            "_gf_isom_vp_config_new",
            "_gf_isom_av1_config_new",
            "_gf_isom_lhvc_force_inband_config",
            "_gf_isom_hevc_set_tile_config",
            "_gf_isom_lhvc_config_update",
            "_gf_isom_vvc_set_inband_config",
            "_gf_isom_vvc_config_update",
            "_gf_isom_box_size",
            "_gf_isom_box_write",
            "_gf_isom_box_parse",
            "_gf_odf_vvc_cfg_new",
            "_gf_isom_vp_config_get",
            "_gf_isom_box_write_header",
            "_gf_odf_desc_list_del",
            "_gf_odf_desc_list_read",
            "_gf_odf_desc_list_write",
            "_gf_odf_desc_list_size",
            "_gf_avc_read_sps",
            "_gf_odf_av1_cfg_read_bs_size",
            "_gf_odf_av1_cfg_write_bs",
            "_gf_odf_vp_cfg_read_bs",
            "_gf_odf_vp_cfg_write_bs",
            "_gf_odf_dump_desc",
            "_gf_webvtt_parse_cues_from_data",
            "_gf_webvtt_cue_del",
            "_gf_isom_get_ismacryp_sample",
            "_gf_isom_ismacryp_delete_sample",
            "_gf_isom_cenc_samp_aux_info_del",
            "_gf_odf_desc_read",
            "_gf_odf_slc_set_pref",
            "_gf_isom_set_ismacryp_protection",
            "_gf_isom_cenc_get_sample_aux_info",
            "_gf_isom_get_mode",
            "_gf_isom_probe_file_range",
            "_gf_isom_probe_data",
            "_gf_isom_open_progressive_ex",
            "_gf_media_nalu_next_start_code",
            "_gf_m4a_write_config",
            "_gf_isom_write",
            "_gf_isom_close_fragments",
            "_gf_isom_get_track_creation_time",
            "_gf_isom_get_track_duration_orig",
            "_gf_isom_has_track_reference",
            "_gf_isom_get_media_time",
            "_gf_isom_get_sample_description_index",
            "_gf_isom_get_decoder_config",
            "_gf_isom_has_sync_shadows",
            "_gf_isom_has_sample_dependency",
            "_gf_isom_get_max_sample_size",
            "_gf_isom_get_avg_sample_size",
            "_gf_isom_get_avg_sample_delta",
            "_gf_isom_get_max_sample_cts_offset",
            "_gf_isom_get_sample_sync",
            "_gf_isom_get_sample_info_ex",
            "_gf_isom_get_sample_from_dts",
            "_gf_isom_get_sample_for_media_time",
            "_gf_isom_get_sample_for_movie_time",
            "_gf_isom_get_missing_bytes",
            "_gf_isom_set_sample_padding",
            "_gf_isom_get_brands",
            "_gf_isom_get_sample_padding_bits",
            "_gf_isom_has_padding_bits",
            "_gf_isom_refresh_fragmented",
            "_gf_isom_set_single_moof_mode",
            "_gf_isom_reset_data_offset",
            "_gf_isom_get_current_top_box_offset",
            "_gf_isom_set_removed_bytes",
            "_gf_isom_reset_tables",
            "_gf_isom_release_segment",
            "_gf_isom_needs_layer_reconstruction",
            "_gf_isom_get_highest_track_in_scalable_segment",
            "_gf_isom_text_set_streaming_mode",
            "_gf_isom_get_audio_layout",
            "_gf_isom_get_pixel_aspect_ratio",
            "_gf_isom_get_color_info",
            "_gf_isom_get_icc_profile",
            "_gf_isom_get_track_matrix",
            "_gf_isom_get_media_data_size",
            "_gf_isom_set_default_sync_track",
            "_gf_isom_is_single_av",
            "_gf_isom_guess_specification",
            "_gf_isom_sample_get_subsamples_buffer",
            "_gf_isom_sample_has_subsamples",
            "_gf_isom_sample_get_subsample",
            "_gf_isom_extract_meta_item_mem",
            "_gf_isom_reset_fragment_info",
            "_gf_isom_reset_seq_num",
            "_gf_isom_reset_sample_count",
            "_gf_isom_has_cenc_sample_group",
            "_gf_isom_get_sample_to_group_info",
            "_gf_isom_has_keep_utc_times",
            "_gf_isom_get_pssh_count",
            "_gf_isom_get_pssh_info",
            "_gf_isom_get_last_producer_time_box",
            "_gf_isom_get_current_tfdt",
            "_gf_isom_get_smooth_next_tfdt",
            "_gf_isom_is_smooth_streaming_moov",
            "_gf_isom_set_byte_offset",
            "_gf_isom_get_nalu_length_field",
            "_gf_isom_get_bitrate",
            "_gf_isom_get_root_sidx_offsets",
            "_gf_isom_get_jp2_config",
            "_gf_isom_get_file_offset_for_time",
            "_gf_isom_get_sidx_duration",
            "_gf_isom_get_clean_aperture",
            "_gf_isom_get_track_group",
            "_gf_isom_get_mastering_display_colour_info",
            "_gf_isom_get_content_light_level_info",
            "_gf_isom_add_track_to_root_od",
            "_gf_isom_add_desc_to_root_od",
            "_gf_isom_set_root_od_id",
            "_gf_isom_set_root_od_url",
            "_gf_isom_get_last_created_track_id",
            "_gf_isom_load_extra_boxes",
            "_gf_isom_new_track_from_template",
            "_gf_isom_remove_stream_description",
            "_gf_isom_new_mpeg4_description",
            "_gf_isom_add_sample_shadow",
            "_gf_isom_append_sample_data",
            "_gf_isom_patch_last_sample_duration",
            "_gf_isom_update_sample",
            "_gf_isom_update_sample_reference",
            "_gf_isom_remove_sample",
            "_gf_isom_add_desc_to_description",
            "_gf_isom_change_mpeg4_description",
            "_gf_isom_set_visual_info",
            "_gf_isom_set_pixel_aspect_ratio",
            "_gf_isom_set_image_sequence_alpha",
            "_gf_isom_set_audio_layout",
            "_gf_isom_remove_edit",
            "_gf_isom_remove_chapter",
            "_gf_isom_set_interleave_time",
            "_gf_isom_reset_alt_brands",
            "_gf_isom_remove_user_data_item",
            "_gf_isom_get_raw_user_data",
            "_gf_isom_get_track_template",
            "_gf_isom_get_trex_template",
            "_gf_isom_get_stsd_template",
            "_gf_isom_new_generic_sample_description",
            "_gf_isom_purge_track_reference",
            "_gf_isom_remove_track_references",
            "_gf_isom_shift_cts_offset",
            "_gf_isom_set_cts_packing",
            "_gf_isom_box_equal",
            "_gf_isom_estimate_size",
            "_gf_isom_set_track_interleaving_group",
            "_gf_isom_set_track_priority_in_group",
            "_gf_isom_hint_max_chunk_size",
            "_gf_isom_hint_max_chunk_duration",
            "_gf_isom_set_extraction_slc",
            "_gf_isom_make_interleave_ex",
            "_gf_isom_add_uuid",
            "_gf_isom_add_meta_item_memory",
            "_gf_isom_add_sample_group_info",
            "_gf_isom_remove_sample_group",
            "_gf_isom_add_sample_info",
            "_gf_isom_set_sample_rap_group",
            "_gf_isom_fragment_set_sample_roll_group",
            "_gf_isom_set_sample_cenc_group",
            "_gf_isom_set_sample_cenc_default_group",
            "_gf_isom_update_edit_list_duration",
            "_gf_isom_clone_pssh",
            "_gf_isom_set_nalu_length_field",
            "_gf_isom_set_progress_callback",
            "_gf_isom_set_track_magic",
            "_gf_isom_set_mpegh_compatible_profiles",
            "_gf_odf_codec_new",
            "_gf_odf_codec_set_au",
            "_gf_odf_codec_decode",
            "_gf_odf_codec_get_com",
            "_gf_odf_com_new",
            "_gf_odf_com_del",
            "_gf_odf_codec_add_com",
            "_gf_odf_codec_encode",
            "_gf_odf_codec_get_au",
            "_gf_odf_codec_del",
            "_gf_isom_find_od_id_for_track",
            "_gf_isom_get_meta_item_flags",
            "_gf_odf_avc_cfg_write_bs",
            "_gf_isom_add_meta_item_sample_ref",
            "_gf_isom_meta_get_item_ref_count",
            "_gf_isom_meta_item_has_ref",
            "_gf_isom_meta_get_item_ref_id",
            "_gf_isom_finalize_for_fragment",
            "_gf_isom_setup_track_fragment",
            "_gf_isom_setup_track_fragment_template",
            "_gf_isom_set_fragment_option",
            "_gf_isom_flush_fragments",
            "_gf_isom_close_segment",
            "_gf_isom_flush_sidx",
            "_gf_isom_start_segment",
            "_gf_isom_set_fragment_reference_time",
            "_gf_isom_set_traf_mss_timeext",
            "_gf_isom_start_fragment",
            "_gf_isom_fragment_add_sample_ex",
            "_gf_isom_fragment_add_sample",
            "_gf_isom_fragment_set_cenc_sai",
            "_gf_isom_fragment_append_data_ex",
            "_gf_isom_fragment_append_data",
            "_gf_isom_set_traf_base_media_decode_time",
            "_gf_isom_set_next_moof_number",
            "_gf_isom_get_next_moof_number",
            "_gf_isom_3gp_config_get",
            "_gf_isom_flac_config_get",
            "_gf_isom_opus_config_new",
            "_gf_isom_opus_config_get",
            "_gf_isom_3gp_config_new",
            "_gf_isom_3gp_config_update",
            "_gf_isom_ac3_config_new",
            "_gf_isom_flac_config_new",
            "_gf_isom_new_mj2k_description",
            "_gf_isom_new_dims_description",
            "_gf_isom_subtitle_get_mime",
            "_gf_isom_subtitle_set_mime",
            "_gf_isom_new_xml_subtitle_description",
            "_gf_isom_get_webvtt_config",
            "_gf_isom_refresh_size_info",
            "_gf_isom_new_text_description",
            "_gf_isom_text_add_text",
            "_gf_isom_text_add_style",
            "_gf_isom_text_add_highlight",
            "_gf_isom_text_set_highlight_color",
            "_gf_isom_text_add_karaoke",
            "_gf_isom_text_set_karaoke_segment",
            "_gf_isom_text_set_scroll_delay",
            "_gf_isom_text_add_hyperlink",
            "_gf_isom_text_set_box",
            "_gf_isom_text_add_blink",
            "_gf_isom_text_set_wrap",
            "_gf_isom_text_set_forced",
            "_gf_isom_text_sample_write_bs",
            "_gf_isom_text_to_sample",
            "_gf_isom_new_text_sample",
            "_gf_isom_text_reset_styles",
            "_gf_isom_text_reset",
            "_gf_odf_write_descriptor",
            "_gf_odf_parse_descriptor",
            "_gf_odf_encode_ui_config",
            "_gf_odf_tx3g_read",
            "_gf_odf_get_text_config",
            "_gf_odf_hevc_cfg_new",
            "_gf_odf_vvc_cfg_write",
            "_gf_odf_vvc_cfg_read",
            "_gf_odf_av1_cfg_new",
            "_gf_odf_vp_cfg_read",
            "_gf_odf_av1_cfg_read_bs",
            "_gf_odf_av1_cfg_read",
            "_gf_odf_desc_write_bs",
            "_gf_sl_packetize",
            "_gf_sl_get_header_size",
            "_gf_sl_depacketize",
            "_gf_odf_dump_com",
            "_gf_odf_dump_com_list",
            "_gf_odf_dump_txtcfg",
            "_gf_avc_change_par",
            "_gf_hevc_get_sps_info",
            "_gf_hevc_change_par",
            "_gf_vvc_change_par",
            "_gf_avc_change_color",
            "_gf_hevc_change_color",
            "_gf_vvc_change_color",
            "_gf_hevc_read_sps",
            "_gf_media_map_item_esd",
            "_gf_avc_read_pps",
            "_gf_avc_parse_nalu",
            "_gf_hevc_read_pps",
            "_gf_hevc_parse_nalu",
            "_gf_dasher_clean_inputs",
            "_gf_fs_print_unused_args",
            "_gf_filter_send_update",
            "_gf_filter_send_event",
            "_gf_media_reduce_aspect_ratio",
            "_gf_m4v_parser_new",
            "_gf_m4v_parser_del",
            "_gf_m4v_parser_del_no_bs",
            "_gf_m4v_parser_set_inspect",
            "_gf_m4v_parser_get_obj_type",
            "_gf_m4v_rewrite_pl",
            "_gf_m4v_parse_config",
            "_gf_m4v_parse_frame",
            "_gf_m4v_get_object_start",
            "_gf_mpegv12_get_config",
            "_gf_m4a_get_profile",
            "_gf_m4a_parse_program_config_element",
            "_gf_m4a_parse_config",
            "_gf_m4a_get_channel_cfg",
            "_gf_m4a_write_program_config_element_bs",
            "_gf_m4a_write_config_bs",
            "_gf_media_prores_parse_bs",
            "_gf_mp3_version",
            "_gf_mp3_window_size",
            "_gf_mp3_object_type_indication",
            "_gf_mp3_frame_size",
            "_gf_mp3_get_next_header",
            "_gf_mp3_get_next_header_mem",
            "_gf_media_nalu_remove_emulation_bytes",
            "_gf_avc_read_sps_bs",
            "_gf_avc_read_pps_bs",
            "_gf_avc_get_pps_info",
            "_gf_hevc_read_vps_ex",
            "_gf_hevc_read_vps_bs",
            "_gf_hevc_read_sps_ex",
            "_gf_hevc_read_sps_bs",
            "_gf_hevc_read_pps_bs",
            "_gf_hevc_parse_nalu_bs",
            "_gf_hevc_change_vui",
            "_gf_ac3_get_surround_channels",
            "_gf_ac3_parser_bs",
            "_gf_eac3_parser_bs",
            "_gf_vorbis_parse_header",
            "_gf_vorbis_check_frame",
            "_gf_opus_parse_packet_header",
            "_gf_vvc_parse_sei",
            "_gf_vvc_parse_nalu_bs",
            "_gf_vvc_parse_nalu",
            "_gf_vvc_change_vui",
            "_gf_vvc_get_profile_name",
            "_gf_img_parse",
            "_gf_img_jpeg_dec",
            "_gf_img_png_dec",
            "_gf_media_import_chapters_file",
            "_gf_filter_set_setup_failure_callback",
            "_gf_filter_get_id",
            "_gf_filter_assign_id",
            "_gf_m2ts_get_sdt_info",
            "_gf_m2ts_reset_parsers_for_program",
            "_gf_m2ts_demux_dmscc_init",
            "_gf_m2ts_probe_file",
            "_gf_m2ts_probe_data",
            "_gf_m2ts_restamp",
            "_gf_m3u8_parse_master_playlist",
            "_gf_mpd_complete_from_dom",
            "_gf_mpd_init_from_dom",
            "_gf_m3u8_solve_representation_xlink",
            "_gf_mpd_solve_segment_list_xlink",
            "_gf_mpd_delete_segment_list",
            "_gf_mpd_get_base_url_count",
            "_gf_mpd_resolve_url",
            "_gf_mpd_resolve_segment_duration",
            "_gf_mpd_get_duration",
            "_gf_mpd_get_segment_start_time_with_timescale",
            "_gf_mpd_seek_in_period",
            "_gf_mpd_init_smooth_from_dom",
            "_gf_media_mpd_format_segment_name",
            "_gf_dash_group_check_bandwidth",
            "_gf_dash_group_has_dependent_group",
            "_gf_dash_group_get_num_groups_depending_on",
            "_gf_dash_get_dependent_group_index",
            "_gf_dash_get_base_group_index",
            "_gf_dash_open",
            "_gf_dash_group_seek",
            "_gf_dash_close",
            "_gf_dash_set_algo",
            "_gf_dash_set_algo_custom",
            "_gf_dash_new",
            "_gf_dash_del",
            "_gf_dash_enable_utc_drift_compensation",
            "_gf_dash_set_switching_probe_count",
            "_gf_dash_enable_single_range_llhls",
            "_gf_dash_enable_group_selection",
            "_gf_dash_set_agressive_adaptation",
            "_gf_dash_set_auto_switch",
            "_gf_dash_get_group_count",
            "_gf_dash_get_group_udta",
            "_gf_dash_set_group_udta",
            "_gf_dash_is_group_selected",
            "_gf_dash_is_group_selectable",
            "_gf_dash_get_info",
            "_gf_dash_switch_quality",
            "_gf_dash_get_duration",
            "_gf_dash_group_get_time_shift_buffer_depth",
            "_gf_dash_get_url",
            "_gf_dash_is_m3u8",
            "_gf_dash_is_smooth_streaming",
            "_gf_dash_group_get_segment_mime",
            "_gf_dash_group_get_segment_init_url",
            "_gf_dash_group_get_segment_init_keys",
            "_gf_dash_group_get_id",
            "_gf_dash_get_period_id",
            "_gf_dash_group_select",
            "_gf_dash_groups_set_language",
            "_gf_dash_is_running",
            "_gf_dash_is_in_setup",
            "_gf_dash_get_period_switch_status",
            "_gf_dash_request_period_switch",
            "_gf_dash_in_last_period",
            "_gf_dash_in_period_setup",
            "_gf_dash_set_speed",
            "_gf_dash_group_get_segment_duration",
            "_gf_dash_group_next_seg_info",
            "_gf_dash_group_get_representation_id",
            "_gf_dash_group_discard_segment",
            "_gf_dash_set_group_done",
            "_gf_dash_get_group_done",
            "_gf_dash_group_get_presentation_time_offset",
            "_gf_dash_group_get_next_segment_location",
            "_gf_dash_seek",
            "_gf_dash_group_segment_switch_forced",
            "_gf_dash_set_utc_shift",
            "_gf_dash_group_get_video_info",
            "_gf_dash_group_get_srd_max_size_info",
            "_gf_dash_set_min_timeout_between_404",
            "_gf_dash_set_segment_expiration_threshold",
            "_gf_dash_group_loop_detected",
            "_gf_dash_group_get_start_range",
            "_gf_dash_is_dynamic_mpd",
            "_gf_dash_get_min_buffer_time",
            "_gf_dash_set_max_resolution",
            "_gf_dash_debug_groups",
            "_gf_dash_split_adaptation_sets",
            "_gf_dash_set_low_latency_mode",
            "_gf_dash_set_user_buffer",
            "_gf_dash_get_period_start",
            "_gf_dash_get_period_duration",
            "_gf_dash_group_get_language",
            "_gf_dash_group_get_audio_channels",
            "_gf_dash_group_get_num_qualities",
            "_gf_dash_group_get_num_components",
            "_gf_dash_group_get_template",
            "_gf_dash_group_get_quality_info",
            "_gf_dash_group_enum_descriptor",
            "_gf_dash_get_automatic_switching",
            "_gf_dash_set_automatic_switching",
            "_gf_dash_group_select_quality",
            "_gf_dash_group_get_active_quality",
            "_gf_dash_set_timeshift",
            "_gf_dash_get_timeshift_buffer_pos",
            "_gf_dash_group_set_codec_stat",
            "_gf_dash_group_set_buffer_levels",
            "_gf_dash_disable_speed_adaptation",
            "_gf_dash_override_ntp",
            "_gf_dash_get_utc_drift_estimate",
            "_gf_dash_get_tile_adaptation_mode",
            "_gf_dash_set_tile_adaptation_mode",
            "_gf_dash_disable_low_quality_tiles",
            "_gf_dash_set_chaining_mode",
            "_gf_dash_group_get_srd_info",
            "_gf_dash_ignore_xlink",
            "_gf_dash_set_suggested_presentation_delay",
            "_gf_dash_set_route_ast_shift",
            "_gf_dash_group_set_max_buffer_playout",
            "_gf_dash_group_set_quality_degradation_hint",
            "_gf_dash_group_set_visible_rect",
            "_gf_dash_all_groups_done",
            "_gf_dash_set_period_xlink_query_string",
            "_gf_dash_group_get_as_id",
            "_gf_m2ts_mux_program_get_pmt_pid",
            "_gf_m2ts_mux_program_get_pcr_pid",
            "_gf_m2ts_mux_program_get_stream_count",
            "_gf_m2ts_program_stream_add",
            "_gf_m2ts_mux_program_find",
            "_gf_m2ts_mux_program_count",
            "_gf_m2ts_mux_program_add",
            "_gf_m2ts_mux_program_set_name",
            "_gf_m2ts_mux_new",
            "_gf_m2ts_mux_enable_sdt",
            "_gf_m2ts_mux_set_pcr_max_interval",
            "_gf_m2ts_program_stream_remove",
            "_gf_m2ts_mux_del",
            "_gf_m2ts_mux_update_config",
            "_gf_m2ts_get_sys_clock",
            "_gf_m2ts_get_ts_clock",
            "_gf_m2ts_get_ts_clock_90k",
            "_gf_m2ts_mux_use_single_au_pes_mode",
            "_gf_m2ts_mux_set_initial_pcr",
            "_gf_m2ts_mux_enable_pcr_only_packets",
            "_gf_m2ts_mux_process",
            "_AVI_open_output_file",
            "_AVI_set_video",
            "_AVI_set_audio",
            "_AVI_write_frame",
            "_AVI_write_audio",
            "_AVI_close",
            "_gf_webvtt_parse_iso_cues",
            "_gf_sm_stream_new",
            "_gf_sm_get_mux_info",
            "_gf_sm_stream_au_new",
            "_gf_sm_load_string",
            "_gf_sm_import_bifs_subtitle",
            "_gf_laser_decoder_new",
            "_gf_laser_decoder_configure_stream",
            "_gf_laser_decode_command_list",
            "_gf_laser_decoder_del",
            "_gf_sm_dumper_new",
            "_gf_sm_dumper_set_extra_graph",
            "_gf_sm_dumper_del",
            "_gf_sm_dump_command_list",
            "_gf_sm_dump_graph",
            "_gf_laser_encoder_new",
            "_gf_laser_encoder_new_stream",
            "_gf_laser_encoder_get_config",
            "_gf_laser_encoder_get_rap",
            "_gf_laser_encode_au",
            "_gf_laser_encoder_del",
            "_gf_mixer_new",
            "_gf_mixer_del",
            "_gf_mixer_lock",
            "_gf_mixer_empty",
            "_gf_mixer_buffering",
            "_gf_mixer_is_eos",
            "_gf_mixer_add_input",
            "_gf_mixer_get_config",
            "_gf_mixer_set_config",
            "_gf_mixer_reconfig",
            "_gf_mixer_get_output",
            "_gf_font_manager_new",
            "_gf_font_manager_set_font_ex",
            "_gf_font_manager_create_span",
            "_gf_font_manager_refresh_span_bounds",
            "_gf_sc_audio_setup",
            "_gf_sc_audio_stop",
            "_gf_sc_audio_unregister",
            "_gf_sc_audio_open",
            "_gf_sc_audio_restart",
            "_gf_sc_audio_check_url",
            "_gf_sc_audio_register",
            "_gf_sc_send_event",
            "_gf_filter_forward_gf_event",
            "_gf_sc_draw_frame",
            "_gf_filter_pck_get_data",
            "_gf_filter_pid_set_property",
            "_gf_filter_pid_set_max_buffer",
            "_gf_filter_pck_new_shared",
            "_gf_filter_pck_set_readonly",
            "_gf_filter_pck_send",
            "_gf_filter_pid_would_block",
            "_gf_filter_pck_new_alloc_destructor",
            "_gf_filter_get_clock_hint",
            "_gf_filter_pck_truncate",
            "_gf_filter_pck_discard",
            "_gf_filter_pid_set_eos",
            "_gf_filter_pck_set_sap",
            "_gf_filter_pck_set_cts",
            "_gf_filter_pck_set_duration",
            "_gf_filter_pid_get_udta",
            "_gf_mo_get_min_frame_dur",
            "_gf_mo_map_timestamp_to_sys_clock",
            "_gf_sc_texture_release_stream",
            "_gf_filter_request_opengl",
            "_gf_sc_get_clock",
            "_gf_filter_pck_new_frame_interface",
            "_gf_filter_pck_new_alloc",
            "_gf_filter_pck_merge_properties",
            "_gf_filter_pck_get_duration",
            "_gf_sc_reset_graphics",
            "_gf_filter_pck_new_clone",
            "_gf_filter_pck_get_timescale",
            "_gf_filter_pid_copy_properties",
            "_gf_sc_reload_config",
            "_gf_sc_lock",
            "_gf_sc_set_scene_size",
            "_gf_sc_svg_convert_length_to_display",
            "_gf_evg_surface_delete",
            "_gf_sc_focus_switch_ring",
            "_gf_sc_navigation_supported",
            "_gf_sc_is_over",
            "_gf_sc_map_point",
            "_gf_sc_register_time_node",
            "_gf_sc_unregister_time_node",
            "_gf_sc_invalidate_next_frame",
            "_gf_sc_frame_was_produced",
            "_gf_filter_pck_get_frame_interface",
            "_gf_sc_on_event",
            "_gf_sc_input_sensor_keyboard_input",
            "_gf_sc_input_sensor_string_input",
            "_gf_sc_paste_text",
            "_gf_sc_get_selected_text",
            "_gf_sc_register_extra_graph",
            "_gf_sc_has_text_selection",
            "_gf_sc_get_compositor",
            "_gf_filter_post_process_task",
            "_gf_filter_ask_rt_reschedule",
            "_gf_clock_time",
            "_gf_scene_switch_quality",
            "_gf_filter_is_supported_source",
            "_gf_scene_disconnect",
            "_gf_scene_new",
            "_gf_odm_new",
            "_gf_odm_disconnect",
            "_gf_sc_dump_scene_ex",
            "_gf_scene_register_associated_media",
            "_gf_scene_select_object",
            "_gf_scene_get_time",
            "_gf_scene_attach_to_compositor",
            "_gf_scene_set_service_id",
            "_gf_sc_get_world_info",
            "_gf_sc_add_object",
            "_gf_sc_get_simulation_frame_rate",
            "_gf_sc_get_elapsed_time_in_ms",
            "_gf_sc_get_current_service_id",
            "_gf_sc_input_sensor_mouse_input",
            "_gf_evg_surface_clear",
            "_gf_evg_surface_attach_to_buffer",
            "_gf_mo_get_object_time",
            "_gf_sc_invalidate",
            "_gf_mo_register",
            "_gf_sc_texture_get_handler",
            "_gf_sc_texture_setup",
            "_gf_sc_texture_destroy",
            "_gf_sc_texture_play_from_to",
            "_gf_sc_texture_stop_no_unregister",
            "_gf_mo_get_speed",
            "_gf_mo_is_done",
            "_gf_mo_get_loop",
            "_gf_mo_restart",
            "_gf_mo_should_deactivate",
            "_gf_mo_play",
            "_gf_mo_set_speed",
            "_gf_mo_set_flag",
            "_gf_mo_stop",
            "_gf_mo_url_changed",
            "_gf_mo_unregister",
            "_gf_mo_fetch_data",
            "_gf_mo_is_started",
            "_gf_mo_adjust_clock",
            "_gf_mo_release_data",
            "_gf_mo_get_current_speed",
            "_gf_mo_get_audio_info",
            "_gf_mo_is_muted",
            "_gf_mo_get_duration",
            "_gf_sc_texture_update_frame",
            "_gf_sc_texture_restart",
            "_gf_sc_texture_play",
            "_gf_sc_texture_check_url_change",
            "_gf_sc_texture_stop",
            "_gf_mo_get_visual_info_ex",
            "_gf_evg_surface_attach_to_texture",
            "_gf_evg_surface_new",
            "_gf_evg_stencil_new",
            "_gf_evg_stencil_set_texture",
            "_gf_evg_stencil_set_linear_gradient",
            "_gf_evg_stencil_set_gradient_interpolation",
            "_gf_evg_stencil_set_matrix",
            "_gf_evg_stencil_set_auto_matrix",
            "_gf_evg_stencil_delete",
            "_gf_evg_stencil_set_gradient_mode",
            "_gf_evg_stencil_set_radial_gradient",
            "_gf_evg_surface_set_raster_level",
            "_gf_evg_surface_set_path",
            "_gf_evg_surface_fill",
            "_gf_scene_process_anchor",
            "_gf_evg_stencil_set_brush_color",
            "_gf_evg_surface_set_matrix",
            "_gf_mo_pause",
            "_gf_mo_resume",
            "_gf_sc_get_viewpoint",
            "_gf_sc_set_viewpoint",
            "_gf_mo_load_xlink_resource",
            "_gf_mo_get_scenegraph",
            "_gf_mo_unload_xlink_resource",
            "_gf_filter_is_supported_mime",
            "_gf_sc_texture_open",
            "_gf_mo_has_audio",
            "_gf_sc_get_mfurl_from_xlink",
            "_gf_filter_pid_query_buffer_duration",
            "_gf_evg_stencil_set_texture_planes",
            "_gf_mo_get_nb_views",
            "_gf_evg_surface_set_clipper",
            "_gf_evg_stencil_set_alpha",
            "_gf_evg_stencil_set_color_matrix",
            "_gf_evg_stencil_set_mapping",
            "_gf_scene_get_media_object_ex",
            "_gf_mo_event_target_remove_by_node",
            "_gf_filter_pck_unref",
            "_gf_filter_pck_ref",
            "_gf_filter_pid_get_first_packet_cts",
            "_gf_filter_pid_is_eos",
            "_gf_filter_pid_try_pull",
            "_gf_filter_pid_first_packet_is_empty",
            "_gf_filter_pid_get_packet_count",
            "_gf_filter_pck_get_property",
            "_gf_filter_release_property",
            "_gf_filter_pck_enum_properties",
            "_gf_filter_pck_is_blocking_ref",
            "_gf_mo_event_target_add_node",
            "_gf_event_target_get_node",
            "_gf_mo_event_target_get",
            "_gf_filter_send_gf_event",
            "_gf_filter_remove_src",
            "_gf_filter_pid_is_filter_in_parents",
            "_gf_filter_pid_is_sparse",
            "_gf_filter_pid_set_udta",
            "_gf_odm_setup_object",
            "_gf_filter_get_sep",
            "_gf_filter_lock_all",
            "_gf_filter_connect_source",
            "_gf_filter_post_task",
            "_gf_filter_set_source_restricted",
            "_gf_odm_setup_pid",
            "_gf_scene_set_timeshift_depth",
            "_gf_scene_setup_object",
            "_gf_filter_pid_exec_event",
            "_gf_scene_del",
            "_gf_filter_pid_get_info",
            "_gf_scene_set_duration",
            "_gf_filter_pid_get_clock_info",
            "_gf_filter_pid_get_timescale",
            "_gf_filter_pid_first_packet_is_blocking_ref",
            "_gf_filter_pid_has_seen_eos",
            "_gf_odm_get_object_info",
            "_gf_filter_pid_get_filter_name",
            "_gf_filter_pid_get_buffer_occupancy",
            "_gf_filter_pid_get_statistics",
            "_gf_filter_ui_event",
            "_gf_scene_node_callback",
            "_gf_filter_get_download_manager",
            "_gf_filter_relocate_url",
            "_gf_scene_find_odm",
            "_gf_scene_force_size",
            "_gf_scene_register_extra_graph",
            "_gf_filter_pid_get_property_str",
            "_gf_scene_set_addon_layout_info",
            "_gf_scene_resume_live",
            "_gf_laser_decoder_remove_stream",
            "_gf_laser_decode_has_conditionnals",
            "_gf_laser_decode_au",
            "_gf_laser_decoder_set_clock",
            "_gf_evg_surface_clear_depth",
            "_gf_evg_surface_viewport",
            "_gf_evg_set_depth_test",
            "_gf_evg_stencil_push_gradient_interpolation",
            "_gf_evg_stencil_get_auto_matrix",
            "_gf_evg_stencil_get_matrix",
            "_gf_evg_stencil_type",
            "_gf_evg_stencil_get_brush_color",
            "_gf_evg_texture_format_ok",
            "_gf_evg_stencil_set_palette",
            "_gf_evg_stencil_get_texture_planes",
            "_gf_evg_stencil_set_texture_parametric",
            "_gf_evg_stencil_set_pad_color",
            "_gf_evg_stencil_get_pad_color",
            "_gf_evg_stencil_set_filter",
            "_gf_evg_stencil_get_color_matrix",
            "_gf_evg_stencil_get_pixel",
            "_gf_evg_stencil_get_pixel_yuv",
            "_gf_evg_stencil_get_pixel_wide",
            "_gf_evg_stencil_get_pixel_yuv_wide",
            "_gf_evg_stencil_get_pixel_f",
            "_gf_evg_stencil_get_pixel_yuv_f",
            "_gf_evg_stencil_get_alpha",
            "_gf_evg_surface_enable_3d",
            "_gf_evg_enable_threading",
            "_gf_evg_surface_set_center_coords",
            "_gf_evg_surface_set_matrix_3d",
            "_gf_evg_surface_format_ok",
            "_gf_evg_surface_get_raster_level",
            "_gf_evg_surface_force_aa",
            "_gf_evg_surface_use_clipper",
            "_gf_evg_surface_multi_fill",
            "_gf_filter_pck_merge_properties_filter",
            "_gf_filter_pck_dangling_copy",
            "_gf_filter_pck_new_shared_internal",
            "_gf_filter_pck_new_copy",
            "_gf_filter_pck_new_ref_destructor",
            "_gf_filter_pck_new_ref",
            "_gf_filter_pck_forward",
            "_gf_filter_pck_ref_ex",
            "_gf_filter_pck_ref_props",
            "_gf_filter_pck_set_property",
            "_gf_filter_pck_set_property_str",
            "_gf_filter_pck_set_property_dyn",
            "_gf_filter_pck_has_properties",
            "_gf_filter_pck_get_property_str",
            "_gf_filter_pck_set_framing",
            "_gf_filter_pck_get_framing",
            "_gf_filter_pck_set_dts",
            "_gf_filter_pck_get_dts",
            "_gf_filter_pck_get_sap",
            "_gf_filter_pck_set_roll_info",
            "_gf_filter_pck_get_roll_info",
            "_gf_filter_pck_set_interlaced",
            "_gf_filter_pck_get_interlaced",
            "_gf_filter_pck_set_corrupted",
            "_gf_filter_pck_get_corrupted",
            "_gf_filter_pck_set_seek_flag",
            "_gf_filter_pck_get_seek_flag",
            "_gf_filter_pck_set_dependency_flags",
            "_gf_filter_pck_get_dependency_flags",
            "_gf_filter_pck_set_carousel_version",
            "_gf_filter_pck_get_carousel_version",
            "_gf_filter_pck_set_byte_offset",
            "_gf_filter_pck_get_byte_offset",
            "_gf_filter_pck_set_crypt_flags",
            "_gf_filter_pck_get_crypt_flags",
            "_gf_filter_pck_set_seq_num",
            "_gf_filter_pck_get_seq_num",
            "_gf_filter_pck_set_clock_type",
            "_gf_filter_pck_get_clock_type",
            "_gf_filter_pck_expand",
            "_gf_filter_pck_check_realloc",
            "_gf_filter_pid_remove",
            "_gf_filter_notification_failure",
            "_gf_filter_pid_set_name",
            "_gf_filter_pid_orig_src_args",
            "_gf_filter_pid_get_source_filter_name",
            "_gf_filter_in_parent_chain",
            "_gf_filter_pid_check_caps",
            "_gf_filter_pid_push_properties",
            "_gf_props_4cc_get_type",
            "_gf_props_get_id",
            "_gf_props_reset_single",
            "_gf_props_parse_type",
            "_gf_filter_setup_failure",
            "_gf_filter_set_name",
            "_gf_filter_pid_new",
            "_gf_filter_pid_set_property_str",
            "_gf_filter_pid_set_property_dyn",
            "_gf_filter_pid_set_info",
            "_gf_filter_pid_set_info_str",
            "_gf_filter_pid_set_info_dyn",
            "_gf_filter_pid_negociate_property",
            "_gf_props_dump",
            "_gf_filter_pid_negociate_property_str",
            "_gf_filter_pid_negociate_property_dyn",
            "_gf_filter_pid_get_property_entry_str",
            "_gf_filter_pid_enum_info",
            "_gf_filter_get_info",
            "_gf_filter_get_info_str",
            "_gf_filter_pid_reset_properties",
            "_gf_filter_pid_merge_properties",
            "_gf_filter_pid_is_flush_eos",
            "_gf_filter_pid_enum_properties",
            "_gf_filter_pid_eos_received",
            "_gf_filter_event_name",
            "_gf_filter_pid_set_discard",
            "_gf_filter_pid_share_origin",
            "_gf_filter_pid_clear_eos",
            "_gf_filter_pid_set_clock_mode",
            "_gf_filter_pid_get_args",
            "_gf_filter_pid_get_max_buffer",
            "_gf_filter_pid_set_loose_connect",
            "_gf_filter_pid_caps_query",
            "_gf_filter_pid_caps_query_str",
            "_gf_filter_pid_resolve_file_template_ex",
            "_gf_filter_pid_resolve_file_template",
            "_gf_filter_pid_get_destination_ex",
            "_gf_filter_pid_get_destination",
            "_gf_filter_pid_get_source",
            "_gf_filter_pid_discard_block",
            "_gf_filter_pid_require_source_id",
            "_gf_filter_pid_get_min_pck_duration",
            "_gf_filter_pid_recompute_dts",
            "_gf_filter_pid_is_playing",
            "_gf_filter_pid_allow_direct_dispatch",
            "_gf_filter_pid_get_alias_udta",
            "_gf_filter_pid_get_source_filter",
            "_gf_filter_pid_enum_destinations",
            "_gf_filter_pid_ignore_blocking",
            "_gf_filter_pid_get_next_ts",
            "_gf_filter_pid_get_udta_flags",
            "_gf_filter_pid_set_udta_flags",
            "_gf_filter_pid_has_decoder",
            "_gf_filter_pid_set_rt_stats",
            "_gf_filter_pid_send_flush",
            "_gf_props_parse_enum",
            "_gf_props_enum_name",
            "_gf_props_4cc_get_flags",
            "_gf_fs_add_filter_register",
            "_gf_fs_set_max_resolution_chain_length",
            "_gf_fs_set_max_sleep_time",
            "_gf_fs_remove_filter_register",
            "_gf_filter_add_event_listener",
            "_gf_filter_remove_event_listener",
            "_gf_fs_forward_gf_event",
            "_gf_filter_print_all_connections",
            "_gf_filter_get_session_caps",
            "_gf_filter_set_session_caps",
            "_gf_fs_get_font_manager",
            "_gf_filter_get_font_manager",
            "_gf_fs_in_final_flush",
            "_gf_fs_is_supported_mime",
            "_gf_fs_get_filter",
            "_gf_filter_get_stats",
            "_gf_fs_get_http_max_rate",
            "_gf_fs_set_http_max_rate",
            "_gf_fs_get_http_rate",
            "_gf_fs_is_supported_source",
            "_gf_fs_fire_event",
            "_gf_fs_set_filter_creation_callback",
            "_gf_fs_get_rt_udta",
            "_gf_fs_set_external_gl_provider",
            "_gf_filter_force_main_thread",
            "_gf_filter_reset_source",
            "_gf_filter_connections_pending",
            "_gf_filter_get_opid_count",
            "_gf_filter_get_opid",
            "_gf_filter_url_is_filter",
            "_gf_filter_connect_destination",
            "_gf_filter_get_output_buffer_max",
            "_gf_filter_make_sticky",
            "_gf_filter_get_num_events_queued",
            "_gf_filter_hint_single_clock",
            "_gf_filter_override_caps",
            "_gf_filter_act_as_sink",
            "_gf_filter_pid_init_play_event",
            "_gf_filter_set_max_extra_input_pids",
            "_gf_filter_get_max_extra_input_pids",
            "_gf_filter_block_enabled",
            "_gf_filter_pid_raw_new",
            "_gf_filter_probe_data",
            "_gf_filter_get_arg_str",
            "_gf_filter_get_arg",
            "_gf_filter_all_sinks_done",
            "_gf_filter_register_opengl_provider",
            "_gf_filter_set_active_opengl_context",
            "_gf_filter_count_source_by_protocol",
            "_gf_filter_disable_probe",
            "_gf_filter_disable_inputs",
            "_gf_filter_has_pid_connection_pending",
            "_gf_filter_reporting_enabled",
            "_gf_filter_update_status",
            "_gf_filter_load_filter",
            "_gf_filter_end_of_session",
            "_gf_filter_is_alias",
            "_gf_filter_prevent_blocking",
            "_gf_filter_is_dynamic",
            "_gf_filter_block_eos",
            "_gf_filter_set_event_target",
            "_gf_filter_enumerate_args",
            "_gf_filter_set_rt_udta",
            "_gf_filter_get_rt_udta",
            "_gf_filter_abort",
            "_gf_filter_lock",
            "_gf_filter_require_source_id",
            "_gf_filter_has_connect_errors",
            "_gf_filter_is_temporary",
            "_gf_filter_meta_set_instances",
            "_gf_filter_meta_get_instances",
            "_gf_filter_bind_dash_algo_callbacks",
            "_wcdec_on_error",
            "_wcdec_on_frame_copy",
            "_wcdec_on_video",
            "_wcdec_on_audio",
            "_wcdec_on_flush",
            "_wcenc_on_error",
            "_wcenc_on_flush",
            "_wcenc_on_config",
            "_wcenc_on_frame",
            "_webgrab_on_error",
            "_webgrab_on_frame_copy",
            "_webgrab_on_video_frame",
            "_webgrab_on_audio_data",
            "_gf_js_try_lock",
            "onRuntimeInitialized"
        ].forEach((prop) => {
            if (!Object.getOwnPropertyDescriptor(Module["ready"], prop)) {
                Object.defineProperty(Module["ready"], prop, {
                    get: () =>
                        abort(
                            "You are getting " +
                                prop +
                                " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"
                        ),
                    set: () =>
                        abort(
                            "You are setting " +
                                prop +
                                " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"
                        )
                });
            }
        });

        // --pre-jses are emitted after the Module integration code, so that they can
        // refer to Module (if they choose; they can also define Module)

        // Sometimes an existing Module object exists with properties
        // meant to overwrite the default module functionality. Here
        // we collect those properties and reapply _after_ we configure
        // the current environment's defaults to avoid having to be so
        // defensive during initialization.
        var moduleOverrides = Object.assign({}, Module);

        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow) => {
            throw toThrow;
        };

        // Determine the runtime environment we are in. You can customize this by
        // setting the ENVIRONMENT setting at compile time (see settings.js).

        // Attempt to auto-detect the environment
        var ENVIRONMENT_IS_WEB = typeof window == "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
        // N.b. Electron.js environment is simultaneously a NODE-environment, but
        // also a web environment.
        var ENVIRONMENT_IS_NODE =
            typeof process == "object" &&
            typeof process.versions == "object" &&
            typeof process.versions.node == "string";
        var ENVIRONMENT_IS_SHELL =
            !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

        if (Module["ENVIRONMENT"]) {
            throw new Error(
                "Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)"
            );
        }

        // `/` should be present at the end if `scriptDirectory` is not empty
        var scriptDirectory = "";
        function locateFile(path) {
            if (Module["locateFile"]) {
                return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
        }

        // Hooks that are implemented differently in different runtime environments.
        var read_, readAsync, readBinary, setWindowTitle;

        // Normally we don't log exceptions but instead let them bubble out the top
        // level where the embedding environment (e.g. the browser) can handle
        // them.
        // However under v8 and node we sometimes exit the process direcly in which case
        // its up to use us to log the exception before exiting.
        // If we fix https://github.com/emscripten-core/emscripten/issues/15080
        // this may no longer be needed under node.
        function logExceptionOnExit(e) {
            if (e instanceof ExitStatus) return;
            let toLog = e;
            if (e && typeof e == "object" && e.stack) {
                toLog = [e, e.stack];
            }
            err("exiting due to exception: " + toLog);
        }

        if (ENVIRONMENT_IS_NODE) {
            if (
                typeof process == "undefined" ||
                !process.release ||
                process.release.name !== "node"
            )
                throw new Error(
                    "not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"
                );
            // `require()` is no-op in an ESM module, use `createRequire()` to construct
            // the require()` function.  This is only necessary for multi-environment
            // builds, `-sENVIRONMENT=node` emits a static import declaration instead.
            // TODO: Swap all `require()`'s with `import()`'s?
            // These modules will usually be used on Node.js. Load them eagerly to avoid
            // the complexity of lazy-loading.
            var fs = require("fs");
            var nodePath = require("path");

            if (ENVIRONMENT_IS_WORKER) {
                scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
            } else {
                scriptDirectory = __dirname + "/";
            }

            // include: node_shell_read.js
            read_ = (filename, binary) => {
                // We need to re-wrap `file://` strings to URLs. Normalizing isn't
                // necessary in that case, the path should already be absolute.
                filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
                return fs.readFileSync(filename, binary ? undefined : "utf8");
            };

            readBinary = (filename) => {
                var ret = read_(filename, true);
                if (!ret.buffer) {
                    ret = new Uint8Array(ret);
                }
                assert(ret.buffer);
                return ret;
            };

            readAsync = (filename, onload, onerror) => {
                // See the comment in the `read_` function.
                filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
                fs.readFile(filename, function (err, data) {
                    if (err) onerror(err);
                    else onload(data.buffer);
                });
            };

            // end include: node_shell_read.js
            if (process.argv.length > 1) {
                thisProgram = process.argv[1].replace(/\\/g, "/");
            }

            arguments_ = process.argv.slice(2);

            // MODULARIZE will export the module in the proper place outside, we don't need to export here

            process.on("uncaughtException", function (ex) {
                // suppress ExitStatus exceptions from showing an error
                if (!(ex instanceof ExitStatus)) {
                    throw ex;
                }
            });

            // Without this older versions of node (< v15) will log unhandled rejections
            // but return 0, which is not normally the desired behaviour.  This is
            // not be needed with node v15 and about because it is now the default
            // behaviour:
            // See https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode
            var nodeMajor = process.versions.node.split(".")[0];
            if (nodeMajor < 15) {
                process.on("unhandledRejection", function (reason) {
                    throw reason;
                });
            }

            quit_ = (status, toThrow) => {
                if (keepRuntimeAlive()) {
                    process.exitCode = status;
                    throw toThrow;
                }
                logExceptionOnExit(toThrow);
                process.exit(status);
            };

            Module["inspect"] = function () {
                return "[Emscripten Module object]";
            };
        } else if (ENVIRONMENT_IS_SHELL) {
            if (
                (typeof process == "object" && typeof require === "function") ||
                typeof window == "object" ||
                typeof importScripts == "function"
            )
                throw new Error(
                    "not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"
                );

            if (typeof read != "undefined") {
                read_ = function shell_read(f) {
                    return read(f);
                };
            }

            readBinary = function readBinary(f) {
                let data;
                if (typeof readbuffer == "function") {
                    return new Uint8Array(readbuffer(f));
                }
                data = read(f, "binary");
                assert(typeof data == "object");
                return data;
            };

            readAsync = function readAsync(f, onload, onerror) {
                setTimeout(() => onload(readBinary(f)), 0);
            };

            if (typeof clearTimeout == "undefined") {
                globalThis.clearTimeout = (id) => {};
            }

            if (typeof scriptArgs != "undefined") {
                arguments_ = scriptArgs;
            } else if (typeof arguments != "undefined") {
                arguments_ = arguments;
            }

            if (typeof quit == "function") {
                quit_ = (status, toThrow) => {
                    logExceptionOnExit(toThrow);
                    quit(status);
                };
            }

            if (typeof print != "undefined") {
                // Prefer to use print/printErr where they exist, as they usually work better.
                if (typeof console == "undefined") console = /** @type{!Console} */ ({});
                console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
                console.warn = console.error =
                    /** @type{!function(this:Console, ...*): undefined} */ (
                        typeof printErr != "undefined" ? printErr : print
                    );
            }
        }

        // Note that this includes Node.js workers when relevant (pthreads is enabled).
        // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
        // ENVIRONMENT_IS_NODE.
        else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
                // Check worker, not web, since window could be polyfilled
                scriptDirectory = self.location.href;
            } else if (typeof document != "undefined" && document.currentScript) {
                // web
                scriptDirectory = document.currentScript.src;
            }
            // When MODULARIZE, this JS may be executed later, after document.currentScript
            // is gone, so we saved it, and we use it here instead of any other info.
            if (_scriptDir) {
                scriptDirectory = _scriptDir;
            }
            // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
            // otherwise, slice off the final part of the url to find the script directory.
            // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
            // and scriptDirectory will correctly be replaced with an empty string.
            // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
            // they are removed because they could contain a slash.
            if (scriptDirectory.indexOf("blob:") !== 0) {
                scriptDirectory = scriptDirectory.substr(
                    0,
                    scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
                );
            } else {
                scriptDirectory = "";
            }

            if (!(typeof window == "object" || typeof importScripts == "function"))
                throw new Error(
                    "not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"
                );

            // Differentiate the Web Worker from the Node Worker case, as reading must
            // be done differently.
            {
                // include: web_or_worker_shell_read.js
                read_ = (url) => {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, false);
                    xhr.send(null);
                    return xhr.responseText;
                };

                if (ENVIRONMENT_IS_WORKER) {
                    readBinary = (url) => {
                        var xhr = new XMLHttpRequest();
                        xhr.open("GET", url, false);
                        xhr.responseType = "arraybuffer";
                        xhr.send(null);
                        return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));
                    };
                }

                readAsync = (url, onload, onerror) => {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, true);
                    xhr.responseType = "arraybuffer";
                    xhr.onload = () => {
                        if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
                            // file URLs can return 0
                            onload(xhr.response);
                            return;
                        }
                        onerror();
                    };
                    xhr.onerror = onerror;
                    xhr.send(null);
                };

                // end include: web_or_worker_shell_read.js
            }

            setWindowTitle = (title) => (document.title = title);
        } else {
            throw new Error("environment detection error");
        }

        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);

        // Merge back in the overrides
        Object.assign(Module, moduleOverrides);
        // Free the object hierarchy contained in the overrides, this lets the GC
        // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
        moduleOverrides = null;
        checkIncomingModuleAPI();

        // Emit code to handle expected values on the Module object. This applies Module.x
        // to the proper local x. This has two benefits: first, we only emit it if it is
        // expected to arrive, and second, by using a local everywhere else that can be
        // minified.

        if (Module["arguments"]) arguments_ = Module["arguments"];
        legacyModuleProp("arguments", "arguments_");

        if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
        legacyModuleProp("thisProgram", "thisProgram");

        if (Module["quit"]) quit_ = Module["quit"];
        legacyModuleProp("quit", "quit_");

        // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
        // Assertions on removed incoming Module JS APIs.
        assert(
            typeof Module["memoryInitializerPrefixURL"] == "undefined",
            "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"
        );
        assert(
            typeof Module["pthreadMainPrefixURL"] == "undefined",
            "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"
        );
        assert(
            typeof Module["cdInitializerPrefixURL"] == "undefined",
            "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"
        );
        assert(
            typeof Module["filePackagePrefixURL"] == "undefined",
            "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"
        );
        assert(
            typeof Module["read"] == "undefined",
            "Module.read option was removed (modify read_ in JS)"
        );
        assert(
            typeof Module["readAsync"] == "undefined",
            "Module.readAsync option was removed (modify readAsync in JS)"
        );
        assert(
            typeof Module["readBinary"] == "undefined",
            "Module.readBinary option was removed (modify readBinary in JS)"
        );
        assert(
            typeof Module["setWindowTitle"] == "undefined",
            "Module.setWindowTitle option was removed (modify setWindowTitle in JS)"
        );
        assert(
            typeof Module["TOTAL_MEMORY"] == "undefined",
            "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"
        );
        legacyModuleProp("read", "read_");
        legacyModuleProp("readAsync", "readAsync");
        legacyModuleProp("readBinary", "readBinary");
        legacyModuleProp("setWindowTitle", "setWindowTitle");

        var PROXYFS = "PROXYFS is no longer included by default; build with -lproxyfs.js";
        var WORKERFS = "WORKERFS is no longer included by default; build with -lworkerfs.js";
        var NODEFS = "NODEFS is no longer included by default; build with -lnodefs.js";

        assert(
            !ENVIRONMENT_IS_SHELL,
            "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable."
        );

        // end include: shell.js
        // include: preamble.js
        // === Preamble library stuff ===

        // Documentation for the public APIs defined in this file must be updated in:
        //    site/source/docs/api_reference/preamble.js.rst
        // A prebuilt local version of the documentation is available at:
        //    site/build/text/docs/api_reference/preamble.js.txt
        // You can also build docs locally as HTML or other formats in site/
        // An online HTML version (which may be of a different version of Emscripten)
        //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

        var wasmBinary;
        if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
        legacyModuleProp("wasmBinary", "wasmBinary");
        var noExitRuntime = Module["noExitRuntime"] || true;
        legacyModuleProp("noExitRuntime", "noExitRuntime");

        if (typeof WebAssembly != "object") {
            abort("no native wasm support detected");
        }

        // Wasm globals

        var wasmMemory;

        //========================================
        // Runtime essentials
        //========================================

        // whether we are quitting the application. no code should run after this.
        // set in exit() and abort()
        var ABORT = false;

        // set by exit() and abort().  Passed to 'onExit' handler.
        // NOTE: This is also used as the process return code code in shell environments
        // but only when noExitRuntime is false.
        var EXITSTATUS;

        /** @type {function(*, string=)} */
        function assert(condition, text) {
            if (!condition) {
                abort("Assertion failed" + (text ? ": " + text : ""));
            }
        }

        // We used to include malloc/free by default in the past. Show a helpful error in
        // builds with assertions.

        // include: runtime_strings.js
        // runtime_strings.js: String related runtime functions that are part of both
        // MINIMAL_RUNTIME and regular runtime.

        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;

        /**
         * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
         * array that contains uint8 values, returns a copy of that string as a
         * Javascript String object.
         * heapOrArray is either a regular array, or a JavaScript typed array view.
         * @param {number} idx
         * @param {number=} maxBytesToRead
         * @return {string}
         */
        function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            // TextDecoder needs to know the byte length in advance, it doesn't stop on
            // null terminator by itself.  Also, use the length info to avoid running tiny
            // strings through TextDecoder, since .subarray() allocates garbage.
            // (As a tiny code save trick, compare endPtr against endIdx using a negation,
            // so that undefined means Infinity)
            while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
                return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
            }
            var str = "";
            // If building with TextDecoder, we have already computed the string length
            // above, so test loop end condition against that
            while (idx < endPtr) {
                // For UTF8 byte structure, see:
                // http://en.wikipedia.org/wiki/UTF-8#Description
                // https://www.ietf.org/rfc/rfc2279.txt
                // https://tools.ietf.org/html/rfc3629
                var u0 = heapOrArray[idx++];
                if (!(u0 & 0x80)) {
                    str += String.fromCharCode(u0);
                    continue;
                }
                var u1 = heapOrArray[idx++] & 63;
                if ((u0 & 0xe0) == 0xc0) {
                    str += String.fromCharCode(((u0 & 31) << 6) | u1);
                    continue;
                }
                var u2 = heapOrArray[idx++] & 63;
                if ((u0 & 0xf0) == 0xe0) {
                    u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
                } else {
                    if ((u0 & 0xf8) != 0xf0)
                        warnOnce(
                            "Invalid UTF-8 leading byte " +
                                ptrToString(u0) +
                                " encountered when deserializing a UTF-8 string in wasm memory to a JS string!"
                        );
                    u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
                }

                if (u0 < 0x10000) {
                    str += String.fromCharCode(u0);
                } else {
                    var ch = u0 - 0x10000;
                    str += String.fromCharCode(0xd800 | (ch >> 10), 0xdc00 | (ch & 0x3ff));
                }
            }
            return str;
        }

        /**
         * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
         * emscripten HEAP, returns a copy of that string as a Javascript String object.
         *
         * @param {number} ptr
         * @param {number=} maxBytesToRead - An optional length that specifies the
         *   maximum number of bytes to read. You can omit this parameter to scan the
         *   string until the first \0 byte. If maxBytesToRead is passed, and the string
         *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
         *   string will cut short at that byte index (i.e. maxBytesToRead will not
         *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
         *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
         *   JS JIT optimizations off, so it is worth to consider consistently using one
         * @return {string}
         */
        function UTF8ToString(ptr, maxBytesToRead) {
            assert(typeof ptr == "number");
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }

        /**
         * Copies the given Javascript String object 'str' to the given byte array at
         * address 'outIdx', encoded in UTF8 form and null-terminated. The copy will
         * require at most str.length*4+1 bytes of space in the HEAP.  Use the function
         * lengthBytesUTF8 to compute the exact number of bytes (excluding null
         * terminator) that this function will write.
         *
         * @param {string} str - The Javascript string to copy.
         * @param {ArrayBufferView|Array<number>} heap - The array to copy to. Each
         *                                               index in this array is assumed
         *                                               to be one 8-byte element.
         * @param {number} outIdx - The starting offset in the array to begin the copying.
         * @param {number} maxBytesToWrite - The maximum number of bytes this function
         *                                   can write to the array.  This count should
         *                                   include the null terminator, i.e. if
         *                                   maxBytesToWrite=1, only the null terminator
         *                                   will be written and nothing else.
         *                                   maxBytesToWrite=0 does not write any bytes
         *                                   to the output, not even the null
         *                                   terminator.
         * @return {number} The number of bytes written, EXCLUDING the null terminator.
         */
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
            // undefined and false each don't write out any bytes.
            if (!(maxBytesToWrite > 0)) return 0;

            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
            for (var i = 0; i < str.length; ++i) {
                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                // unit, not a Unicode code point of the character! So decode
                // UTF16->UTF32->UTF8.
                // See http://unicode.org/faq/utf_bom.html#utf16-3
                // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
                // and https://www.ietf.org/rfc/rfc2279.txt
                // and https://tools.ietf.org/html/rfc3629
                var u = str.charCodeAt(i); // possibly a lead surrogate
                if (u >= 0xd800 && u <= 0xdfff) {
                    var u1 = str.charCodeAt(++i);
                    u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);
                }
                if (u <= 0x7f) {
                    if (outIdx >= endIdx) break;
                    heap[outIdx++] = u;
                } else if (u <= 0x7ff) {
                    if (outIdx + 1 >= endIdx) break;
                    heap[outIdx++] = 0xc0 | (u >> 6);
                    heap[outIdx++] = 0x80 | (u & 63);
                } else if (u <= 0xffff) {
                    if (outIdx + 2 >= endIdx) break;
                    heap[outIdx++] = 0xe0 | (u >> 12);
                    heap[outIdx++] = 0x80 | ((u >> 6) & 63);
                    heap[outIdx++] = 0x80 | (u & 63);
                } else {
                    if (outIdx + 3 >= endIdx) break;
                    if (u > 0x10ffff)
                        warnOnce(
                            "Invalid Unicode code point " +
                                ptrToString(u) +
                                " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF)."
                        );
                    heap[outIdx++] = 0xf0 | (u >> 18);
                    heap[outIdx++] = 0x80 | ((u >> 12) & 63);
                    heap[outIdx++] = 0x80 | ((u >> 6) & 63);
                    heap[outIdx++] = 0x80 | (u & 63);
                }
            }
            // Null-terminate the pointer to the buffer.
            heap[outIdx] = 0;
            return outIdx - startIdx;
        }

        /**
         * Copies the given Javascript String object 'str' to the emscripten HEAP at
         * address 'outPtr', null-terminated and encoded in UTF8 form. The copy will
         * require at most str.length*4+1 bytes of space in the HEAP.
         * Use the function lengthBytesUTF8 to compute the exact number of bytes
         * (excluding null terminator) that this function will write.
         *
         * @return {number} The number of bytes written, EXCLUDING the null terminator.
         */
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
            assert(
                typeof maxBytesToWrite == "number",
                "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"
            );
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }

        /**
         * Returns the number of bytes the given Javascript string takes if encoded as a
         * UTF8 byte array, EXCLUDING the null terminator byte.
         *
         * @param {string} str - JavaScript string to operator on
         * @return {number} Length, in bytes, of the UTF8 encoded string.
         */
        function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                // unit, not a Unicode code point of the character! So decode
                // UTF16->UTF32->UTF8.
                // See http://unicode.org/faq/utf_bom.html#utf16-3
                var c = str.charCodeAt(i); // possibly a lead surrogate
                if (c <= 0x7f) {
                    len++;
                } else if (c <= 0x7ff) {
                    len += 2;
                } else if (c >= 0xd800 && c <= 0xdfff) {
                    len += 4;
                    ++i;
                } else {
                    len += 3;
                }
            }
            return len;
        }

        // end include: runtime_strings.js
        // Memory management

        var HEAP,
            /** @type {!Int8Array} */
            HEAP8,
            /** @type {!Uint8Array} */
            HEAPU8,
            /** @type {!Int16Array} */
            HEAP16,
            /** @type {!Uint16Array} */
            HEAPU16,
            /** @type {!Int32Array} */
            HEAP32,
            /** @type {!Uint32Array} */
            HEAPU32,
            /** @type {!Float32Array} */
            HEAPF32,
            /* BigInt64Array type is not correctly defined in closure
/** not-@type {!BigInt64Array} */
            HEAP64,
            /* BigUInt64Array type is not correctly defined in closure
/** not-t@type {!BigUint64Array} */
            HEAPU64,
            /** @type {!Float64Array} */
            HEAPF64;

        function updateMemoryViews() {
            var b = wasmMemory.buffer;
            Module["HEAP8"] = HEAP8 = new Int8Array(b);
            Module["HEAP16"] = HEAP16 = new Int16Array(b);
            Module["HEAP32"] = HEAP32 = new Int32Array(b);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
            Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
            Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
        }

        assert(
            !Module["STACK_SIZE"],
            "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time"
        );

        assert(
            typeof Int32Array != "undefined" &&
                typeof Float64Array !== "undefined" &&
                Int32Array.prototype.subarray != undefined &&
                Int32Array.prototype.set != undefined,
            "JS engine does not provide full typed array support"
        );

        // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
        assert(
            !Module["wasmMemory"],
            "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"
        );
        assert(
            !Module["INITIAL_MEMORY"],
            "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically"
        );

        // include: runtime_init_table.js
        // In regular non-RELOCATABLE mode the table is exported
        // from the wasm module and this will be assigned once
        // the exports are available.
        var wasmTable;

        // end include: runtime_init_table.js
        // include: runtime_stack_check.js
        // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
        function writeStackCookie() {
            var max = _emscripten_stack_get_end();
            assert((max & 3) == 0);
            // If the stack ends at address zero we write our cookies 4 bytes into the
            // stack.  This prevents interference with the (separate) address-zero check
            // below.
            if (max == 0) {
                max += 4;
            }
            // The stack grow downwards towards _emscripten_stack_get_end.
            // We write cookies to the final two words in the stack and detect if they are
            // ever overwritten.
            HEAPU32[max >> 2] = 0x02135467;
            HEAPU32[(max + 4) >> 2] = 0x89bacdfe;
            // Also test the global address 0 for integrity.
            HEAPU32[0] = 0x63736d65; /* 'emsc' */
        }

        function checkStackCookie() {
            if (ABORT) return;
            var max = _emscripten_stack_get_end();
            // See writeStackCookie().
            if (max == 0) {
                max += 4;
            }
            var cookie1 = HEAPU32[max >> 2];
            var cookie2 = HEAPU32[(max + 4) >> 2];
            if (cookie1 != 0x02135467 || cookie2 != 0x89bacdfe) {
                abort(
                    "Stack overflow! Stack cookie has been overwritten at " +
                        ptrToString(max) +
                        ", expected hex dwords 0x89BACDFE and 0x2135467, but received " +
                        ptrToString(cookie2) +
                        " " +
                        ptrToString(cookie1)
                );
            }
            // Also test the global address 0 for integrity.
            if (HEAPU32[0] !== 0x63736d65 /* 'emsc' */) {
                abort(
                    "Runtime error: The application has corrupted its heap memory area (address zero)!"
                );
            }
        }

        // end include: runtime_stack_check.js
        // include: runtime_assertions.js
        // Endianness check
        (function () {
            var h16 = new Int16Array(1);
            var h8 = new Int8Array(h16.buffer);
            h16[0] = 0x6373;
            if (h8[0] !== 0x73 || h8[1] !== 0x63)
                throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
        })();

        // end include: runtime_assertions.js
        var __ATPRERUN__ = []; // functions called before the runtime is initialized
        var __ATINIT__ = []; // functions called during startup
        var __ATMAIN__ = []; // functions called when main() is to be run
        var __ATEXIT__ = []; // functions called during shutdown
        var __ATPOSTRUN__ = []; // functions called after the main() is called

        var runtimeInitialized = false;

        function keepRuntimeAlive() {
            return noExitRuntime;
        }

        function preRun() {
            if (Module["preRun"]) {
                if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
                while (Module["preRun"].length) {
                    addOnPreRun(Module["preRun"].shift());
                }
            }
            callRuntimeCallbacks(__ATPRERUN__);
        }

        function initRuntime() {
            assert(!runtimeInitialized);
            runtimeInitialized = true;

            checkStackCookie();

            if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
            FS.ignorePermissions = false;

            TTY.init();
            SOCKFS.root = FS.mount(SOCKFS, {}, null);
            PIPEFS.root = FS.mount(PIPEFS, {}, null);
            callRuntimeCallbacks(__ATINIT__);
        }

        function preMain() {
            checkStackCookie();

            callRuntimeCallbacks(__ATMAIN__);
        }

        function postRun() {
            checkStackCookie();

            if (Module["postRun"]) {
                if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
                while (Module["postRun"].length) {
                    addOnPostRun(Module["postRun"].shift());
                }
            }

            callRuntimeCallbacks(__ATPOSTRUN__);
        }

        function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
        }

        function addOnInit(cb) {
            __ATINIT__.unshift(cb);
        }

        function addOnPreMain(cb) {
            __ATMAIN__.unshift(cb);
        }

        function addOnExit(cb) {}

        function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
        }

        // include: runtime_math.js
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

        assert(
            Math.imul,
            "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"
        );
        assert(
            Math.fround,
            "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"
        );
        assert(
            Math.clz32,
            "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"
        );
        assert(
            Math.trunc,
            "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"
        );

        // end include: runtime_math.js
        // A counter of dependencies for calling run(). If we need to
        // do asynchronous work before running, increment this and
        // decrement it. Incrementing must happen in a place like
        // Module.preRun (used by emcc to add file preloading).
        // Note that you can add dependencies in preRun, even though
        // it happens right before run - run will be postponed until
        // the dependencies are met.
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
        var runDependencyTracking = {};

        function getUniqueRunDependency(id) {
            var orig = id;
            while (1) {
                if (!runDependencyTracking[id]) return id;
                id = orig + Math.random();
            }
        }

        function addRunDependency(id) {
            runDependencies++;

            if (Module["monitorRunDependencies"]) {
                Module["monitorRunDependencies"](runDependencies);
            }

            if (id) {
                assert(!runDependencyTracking[id]);
                runDependencyTracking[id] = 1;
                if (runDependencyWatcher === null && typeof setInterval != "undefined") {
                    // Check for missing dependencies every few seconds
                    runDependencyWatcher = setInterval(function () {
                        if (ABORT) {
                            clearInterval(runDependencyWatcher);
                            runDependencyWatcher = null;
                            return;
                        }
                        var shown = false;
                        for (var dep in runDependencyTracking) {
                            if (!shown) {
                                shown = true;
                                err("still waiting on run dependencies:");
                            }
                            err("dependency: " + dep);
                        }
                        if (shown) {
                            err("(end of list)");
                        }
                    }, 10000);
                }
            } else {
                err("warning: run dependency added without ID");
            }
        }

        function removeRunDependency(id) {
            runDependencies--;

            if (Module["monitorRunDependencies"]) {
                Module["monitorRunDependencies"](runDependencies);
            }

            if (id) {
                assert(runDependencyTracking[id]);
                delete runDependencyTracking[id];
            } else {
                err("warning: run dependency removed without ID");
            }
            if (runDependencies == 0) {
                if (runDependencyWatcher !== null) {
                    clearInterval(runDependencyWatcher);
                    runDependencyWatcher = null;
                }
                if (dependenciesFulfilled) {
                    var callback = dependenciesFulfilled;
                    dependenciesFulfilled = null;
                    callback(); // can add another dependenciesFulfilled
                }
            }
        }

        /** @param {string|number=} what */
        function abort(what) {
            if (Module["onAbort"]) {
                Module["onAbort"](what);
            }

            what = "Aborted(" + what + ")";
            // TODO(sbc): Should we remove printing and leave it up to whoever
            // catches the exception?
            err(what);

            ABORT = true;
            EXITSTATUS = 1;

            // Use a wasm runtime error, because a JS error might be seen as a foreign
            // exception, which means we'd run destructors on it. We need the error to
            // simply make the program stop.
            // FIXME This approach does not work in Wasm EH because it currently does not assume
            // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
            // a trap or not based on a hidden field within the object. So at the moment
            // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
            // allows this in the wasm spec.

            // Suppress closure compiler warning here. Closure compiler's builtin extern
            // defintion for WebAssembly.RuntimeError claims it takes no arguments even
            // though it can.
            // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
            /** @suppress {checkTypes} */
            var e = new WebAssembly.RuntimeError(what);

            readyPromiseReject(e);
            // Throw the error whether or not MODULARIZE is set because abort is used
            // in code paths apart from instantiation where an exception is expected
            // to be thrown when abort is called.
            throw e;
        }

        // include: memoryprofiler.js
        // end include: memoryprofiler.js
        // include: URIUtils.js
        // Prefix of data URIs emitted by SINGLE_FILE and related options.
        var dataURIPrefix = "data:application/octet-stream;base64,";

        // Indicates whether filename is a base64 data URI.
        function isDataURI(filename) {
            // Prefix of data URIs emitted by SINGLE_FILE and related options.
            return filename.startsWith(dataURIPrefix);
        }

        // Indicates whether filename is delivered via file protocol (as opposed to http/https)
        function isFileURI(filename) {
            return filename.startsWith("file://");
        }

        // end include: URIUtils.js
        /** @param {boolean=} fixedasm */
        function createExportWrapper(name, fixedasm) {
            return function () {
                var displayName = name;
                var asm = fixedasm;
                if (!fixedasm) {
                    asm = Module["asm"];
                }
                assert(
                    runtimeInitialized,
                    "native function `" + displayName + "` called before runtime initialization"
                );
                if (!asm[name]) {
                    assert(asm[name], "exported native function `" + displayName + "` not found");
                }
                return asm[name].apply(null, arguments);
            };
        }

        // include: runtime_exceptions.js
        // end include: runtime_exceptions.js
        var wasmBinaryFile;
        wasmBinaryFile = "gpac.wasm";
        if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
        }

        function getBinary(file) {
            try {
                if (file == wasmBinaryFile && wasmBinary) {
                    return new Uint8Array(wasmBinary);
                }
                if (readBinary) {
                    return readBinary(file);
                }
                throw "both async and sync fetching of the wasm failed";
            } catch (err) {
                abort(err);
            }
        }

        function getBinaryPromise(binaryFile) {
            // If we don't have the binary yet, try to to load it asynchronously.
            // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
            // See https://github.com/github/fetch/pull/92#issuecomment-140665932
            // Cordova or Electron apps are typically loaded from a file:// url.
            // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                if (typeof fetch == "function" && !isFileURI(binaryFile)) {
                    return fetch(binaryFile, { credentials: "same-origin" })
                        .then(function (response) {
                            if (!response["ok"]) {
                                throw "failed to load wasm binary file at '" + binaryFile + "'";
                            }
                            return response["arrayBuffer"]();
                        })
                        .catch(function () {
                            return getBinary(binaryFile);
                        });
                } else {
                    if (readAsync) {
                        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
                        return new Promise(function (resolve, reject) {
                            readAsync(
                                binaryFile,
                                function (response) {
                                    resolve(new Uint8Array(/** @type{!ArrayBuffer} */ (response)));
                                },
                                reject
                            );
                        });
                    }
                }
            }

            // Otherwise, getBinary should be able to get it synchronously
            return Promise.resolve().then(function () {
                return getBinary(binaryFile);
            });
        }

        function instantiateArrayBuffer(binaryFile, imports, receiver) {
            return getBinaryPromise(binaryFile)
                .then(function (binary) {
                    return WebAssembly.instantiate(binary, imports);
                })
                .then(function (instance) {
                    return instance;
                })
                .then(receiver, function (reason) {
                    err("failed to asynchronously prepare wasm: " + reason);

                    // Warn on some common problems.
                    if (isFileURI(wasmBinaryFile)) {
                        err(
                            "warning: Loading from a file URI (" +
                                wasmBinaryFile +
                                ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing"
                        );
                    }
                    abort(reason);
                });
        }

        function instantiateAsync(binary, binaryFile, imports, callback) {
            if (
                !binary &&
                typeof WebAssembly.instantiateStreaming == "function" &&
                !isDataURI(binaryFile) &&
                // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
                !isFileURI(binaryFile) &&
                // Avoid instantiateStreaming() on Node.js environment for now, as while
                // Node.js v18.1.0 implements it, it does not have a full fetch()
                // implementation yet.
                //
                // Reference:
                //   https://github.com/emscripten-core/emscripten/pull/16917
                !ENVIRONMENT_IS_NODE &&
                typeof fetch == "function"
            ) {
                return fetch(binaryFile, { credentials: "same-origin" }).then(function (response) {
                    // Suppress closure warning here since the upstream definition for
                    // instantiateStreaming only allows Promise<Repsponse> rather than
                    // an actual Response.
                    // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
                    /** @suppress {checkTypes} */
                    var result = WebAssembly.instantiateStreaming(response, imports);

                    return result.then(callback, function (reason) {
                        // We expect the most common failure cause to be a bad MIME type for the binary,
                        // in which case falling back to ArrayBuffer instantiation should work.
                        err("wasm streaming compile failed: " + reason);
                        err("falling back to ArrayBuffer instantiation");
                        return instantiateArrayBuffer(binaryFile, imports, callback);
                    });
                });
            } else {
                return instantiateArrayBuffer(binaryFile, imports, callback);
            }
        }

        // Create the wasm instance.
        // Receives the wasm imports, returns the exports.
        function createWasm() {
            // prepare imports
            var info = {
                env: wasmImports,
                wasi_snapshot_preview1: wasmImports
            };
            // Load the wasm module and create an instance of using native support in the JS engine.
            // handle a generated wasm instance, receiving its exports and
            // performing other necessary setup
            /** @param {WebAssembly.Module=} module*/
            function receiveInstance(instance, module) {
                var exports = instance.exports;

                Module["asm"] = exports;

                wasmMemory = Module["asm"]["memory"];
                assert(wasmMemory, "memory not found in wasm exports");
                // This assertion doesn't hold when emscripten is run in --post-link
                // mode.
                // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.
                //assert(wasmMemory.buffer.byteLength === 16777216);
                updateMemoryViews();

                wasmTable = Module["asm"]["__indirect_function_table"];
                assert(wasmTable, "table not found in wasm exports");

                addOnInit(Module["asm"]["__wasm_call_ctors"]);

                removeRunDependency("wasm-instantiate");

                return exports;
            }
            // wait for the pthread pool (if any)
            addRunDependency("wasm-instantiate");

            // Prefer streaming instantiation if available.
            // Async compilation can be confusing when an error on the page overwrites Module
            // (for example, if the order of elements is wrong, and the one defining Module is
            // later), so we save Module and check it later.
            var trueModule = Module;
            function receiveInstantiationResult(result) {
                // 'result' is a ResultObject object which has both the module and instance.
                // receiveInstance() will swap in the exports (to Module.asm) so they can be called
                assert(
                    Module === trueModule,
                    "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"
                );
                trueModule = null;
                // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
                // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
                receiveInstance(result["instance"]);
            }

            // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
            // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
            // to any other async startup actions they are performing.
            // Also pthreads and wasm workers initialize the wasm instance through this path.
            if (Module["instantiateWasm"]) {
                try {
                    return Module["instantiateWasm"](info, receiveInstance);
                } catch (e) {
                    err("Module.instantiateWasm callback failed with error: " + e);
                    // If instantiation fails, reject the module ready promise.
                    readyPromiseReject(e);
                }
            }

            // If instantiation fails, reject the module ready promise.
            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(
                readyPromiseReject
            );
            return {}; // no exports yet; we'll fill them in later
        }

        // Globals used by JS i64 conversions (see makeSetValue)
        var tempDouble;
        var tempI64;

        // include: runtime_debug.js
        function legacyModuleProp(prop, newName) {
            if (!Object.getOwnPropertyDescriptor(Module, prop)) {
                Object.defineProperty(Module, prop, {
                    configurable: true,
                    get: function () {
                        abort(
                            "Module." +
                                prop +
                                " has been replaced with plain " +
                                newName +
                                " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)"
                        );
                    }
                });
            }
        }

        function ignoredModuleProp(prop) {
            if (Object.getOwnPropertyDescriptor(Module, prop)) {
                abort(
                    "`Module." +
                        prop +
                        "` was supplied but `" +
                        prop +
                        "` not included in INCOMING_MODULE_JS_API"
                );
            }
        }

        // forcing the filesystem exports a few things by default
        function isExportedByForceFilesystem(name) {
            return (
                name === "FS_createPath" ||
                name === "FS_createDataFile" ||
                name === "FS_createPreloadedFile" ||
                name === "FS_unlink" ||
                name === "addRunDependency" ||
                // The old FS has some functionality that WasmFS lacks.
                name === "FS_createLazyFile" ||
                name === "FS_createDevice" ||
                name === "removeRunDependency"
            );
        }

        function missingGlobal(sym, msg) {
            if (typeof globalThis !== "undefined") {
                Object.defineProperty(globalThis, sym, {
                    configurable: true,
                    get: function () {
                        warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
                        return undefined;
                    }
                });
            }
        }

        missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");

        function missingLibrarySymbol(sym) {
            if (
                typeof globalThis !== "undefined" &&
                !Object.getOwnPropertyDescriptor(globalThis, sym)
            ) {
                Object.defineProperty(globalThis, sym, {
                    configurable: true,
                    get: function () {
                        // Can't `abort()` here because it would break code that does runtime
                        // checks.  e.g. `if (typeof SDL === 'undefined')`.
                        var msg =
                            "`" +
                            sym +
                            "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
                        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
                        // library.js, which means $name for a JS name with no prefix, or name
                        // for a JS name like _name.
                        var librarySymbol = sym;
                        if (!librarySymbol.startsWith("_")) {
                            librarySymbol = "$" + sym;
                        }
                        msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + librarySymbol + ")";
                        if (isExportedByForceFilesystem(sym)) {
                            msg +=
                                ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
                        }
                        warnOnce(msg);
                        return undefined;
                    }
                });
            }
            // Any symbol that is not included from the JS libary is also (by definition)
            // not exported on the Module object.
            unexportedRuntimeSymbol(sym);
        }

        function unexportedRuntimeSymbol(sym) {
            if (!Object.getOwnPropertyDescriptor(Module, sym)) {
                Object.defineProperty(Module, sym, {
                    configurable: true,
                    get: function () {
                        var msg =
                            "'" +
                            sym +
                            "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
                        if (isExportedByForceFilesystem(sym)) {
                            msg +=
                                ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
                        }
                        abort(msg);
                    }
                });
            }
        }

        // Used by XXXXX_DEBUG settings to output debug messages.
        function dbg(text) {
            // TODO(sbc): Make this configurable somehow.  Its not always convenient for
            // logging to show up as errors.
            console.error(text);
        }

        // end include: runtime_debug.js
        // === Body ===

        var ASM_CONSTS = {
            6433760: ($0) => {
                libgpac.gpac_set_console($0);
            },
            6433794: () => {
                if (typeof libgpac.gpac_set_console == "function") return 1;
                return 0;
            },
            6433869: ($0) => {
                if (typeof libgpac.gpac_done == "function") libgpac.gpac_done($0);
            },
            6433940: ($0) => {
                if (typeof libgpac.gpac_done == "function") libgpac.gpac_done($0);
            },
            6434011: () => {
                return HEAP8.length;
            },
            6434031: () => {
                if (typeof VideoDecoder == "undefined") return 0;
                return 1;
            },
            6434095: () => {
                if (typeof AudioDecoder == "undefined") return 0;
                return 1;
            },
            6434159: () => {
                if (typeof VideoEncoder == "undefined") return 0;
                return 1;
            },
            6434223: () => {
                if (typeof AudioEncoder == "undefined") return 0;
                return 1;
            },
            6434287: () => {
                if (typeof MediaStreamTrackProcessor == "undefined") return 0;
                return 1;
            },
            6434364: ($0) => {
                var str = UTF8ToString($0) + "\n\n" + "Abort/Retry/Ignore/AlwaysIgnore? [ariA] :";
                var reply = window.prompt(str, "i");
                if (reply === null) {
                    reply = "i";
                }
                return allocate(intArrayFromString(reply), "i8", ALLOC_NORMAL);
            },
            6434589: () => {
                if (typeof AudioContext !== "undefined") {
                    return true;
                } else if (typeof webkitAudioContext !== "undefined") {
                    return true;
                }
                return false;
            },
            6434736: () => {
                if (
                    typeof navigator.mediaDevices !== "undefined" &&
                    typeof navigator.mediaDevices.getUserMedia !== "undefined"
                ) {
                    return true;
                } else if (typeof navigator.webkitGetUserMedia !== "undefined") {
                    return true;
                }
                return false;
            },
            6434970: ($0) => {
                if (typeof Module["SDL2"] === "undefined") {
                    Module["SDL2"] = {};
                }
                var SDL2 = Module["SDL2"];
                if (!$0) {
                    SDL2.audio = {};
                } else {
                    SDL2.capture = {};
                }
                if (!SDL2.audioContext) {
                    if (typeof AudioContext !== "undefined") {
                        SDL2.audioContext = new AudioContext();
                    } else if (typeof webkitAudioContext !== "undefined") {
                        SDL2.audioContext = new webkitAudioContext();
                    }
                    if (SDL2.audioContext) {
                        autoResumeAudioContext(SDL2.audioContext);
                    }
                }
                return SDL2.audioContext === undefined ? -1 : 0;
            },
            6435463: () => {
                var SDL2 = Module["SDL2"];
                return SDL2.audioContext.sampleRate;
            },
            6435531: ($0, $1, $2, $3) => {
                var SDL2 = Module["SDL2"];
                var have_microphone = function (stream) {
                    if (SDL2.capture.silenceTimer !== undefined) {
                        clearTimeout(SDL2.capture.silenceTimer);
                        SDL2.capture.silenceTimer = undefined;
                    }
                    SDL2.capture.mediaStreamNode =
                        SDL2.audioContext.createMediaStreamSource(stream);
                    SDL2.capture.scriptProcessorNode = SDL2.audioContext.createScriptProcessor(
                        $1,
                        $0,
                        1
                    );
                    SDL2.capture.scriptProcessorNode.onaudioprocess = function (
                        audioProcessingEvent
                    ) {
                        if (SDL2 === undefined || SDL2.capture === undefined) {
                            return;
                        }
                        audioProcessingEvent.outputBuffer.getChannelData(0).fill(0.0);
                        SDL2.capture.currentCaptureBuffer = audioProcessingEvent.inputBuffer;
                        dynCall("vi", $2, [$3]);
                    };
                    SDL2.capture.mediaStreamNode.connect(SDL2.capture.scriptProcessorNode);
                    SDL2.capture.scriptProcessorNode.connect(SDL2.audioContext.destination);
                    SDL2.capture.stream = stream;
                };
                var no_microphone = function (error) {};
                SDL2.capture.silenceBuffer = SDL2.audioContext.createBuffer(
                    $0,
                    $1,
                    SDL2.audioContext.sampleRate
                );
                SDL2.capture.silenceBuffer.getChannelData(0).fill(0.0);
                var silence_callback = function () {
                    SDL2.capture.currentCaptureBuffer = SDL2.capture.silenceBuffer;
                    dynCall("vi", $2, [$3]);
                };
                SDL2.capture.silenceTimer = setTimeout(
                    silence_callback,
                    ($1 / SDL2.audioContext.sampleRate) * 1000
                );
                if (
                    navigator.mediaDevices !== undefined &&
                    navigator.mediaDevices.getUserMedia !== undefined
                ) {
                    navigator.mediaDevices
                        .getUserMedia({ audio: true, video: false })
                        .then(have_microphone)
                        .catch(no_microphone);
                } else if (navigator.webkitGetUserMedia !== undefined) {
                    navigator.webkitGetUserMedia(
                        { audio: true, video: false },
                        have_microphone,
                        no_microphone
                    );
                }
            },
            6437183: ($0, $1, $2, $3) => {
                var SDL2 = Module["SDL2"];
                SDL2.audio.scriptProcessorNode = SDL2.audioContext["createScriptProcessor"](
                    $1,
                    0,
                    $0
                );
                SDL2.audio.scriptProcessorNode["onaudioprocess"] = function (e) {
                    if (SDL2 === undefined || SDL2.audio === undefined) {
                        return;
                    }
                    SDL2.audio.currentOutputBuffer = e["outputBuffer"];
                    dynCall("vi", $2, [$3]);
                };
                SDL2.audio.scriptProcessorNode["connect"](SDL2.audioContext["destination"]);
            },
            6437593: ($0, $1) => {
                var SDL2 = Module["SDL2"];
                var numChannels = SDL2.capture.currentCaptureBuffer.numberOfChannels;
                for (var c = 0; c < numChannels; ++c) {
                    var channelData = SDL2.capture.currentCaptureBuffer.getChannelData(c);
                    if (channelData.length != $1) {
                        throw (
                            "Web Audio capture buffer length mismatch! Destination size: " +
                            channelData.length +
                            " samples vs expected " +
                            $1 +
                            " samples!"
                        );
                    }
                    if (numChannels == 1) {
                        for (var j = 0; j < $1; ++j) {
                            setValue($0 + j * 4, channelData[j], "float");
                        }
                    } else {
                        for (var j = 0; j < $1; ++j) {
                            setValue($0 + (j * numChannels + c) * 4, channelData[j], "float");
                        }
                    }
                }
            },
            6438198: ($0, $1) => {
                var SDL2 = Module["SDL2"];
                var numChannels = SDL2.audio.currentOutputBuffer["numberOfChannels"];
                for (var c = 0; c < numChannels; ++c) {
                    var channelData = SDL2.audio.currentOutputBuffer["getChannelData"](c);
                    if (channelData.length != $1) {
                        throw (
                            "Web Audio output buffer length mismatch! Destination size: " +
                            channelData.length +
                            " samples vs expected " +
                            $1 +
                            " samples!"
                        );
                    }
                    for (var j = 0; j < $1; ++j) {
                        channelData[j] = HEAPF32[($0 + ((j * numChannels + c) << 2)) >> 2];
                    }
                }
            },
            6438678: ($0) => {
                var SDL2 = Module["SDL2"];
                if ($0) {
                    if (SDL2.capture.silenceTimer !== undefined) {
                        clearTimeout(SDL2.capture.silenceTimer);
                    }
                    if (SDL2.capture.stream !== undefined) {
                        var tracks = SDL2.capture.stream.getAudioTracks();
                        for (var i = 0; i < tracks.length; i++) {
                            SDL2.capture.stream.removeTrack(tracks[i]);
                        }
                        SDL2.capture.stream = undefined;
                    }
                    if (SDL2.capture.scriptProcessorNode !== undefined) {
                        SDL2.capture.scriptProcessorNode.onaudioprocess = function (
                            audioProcessingEvent
                        ) {};
                        SDL2.capture.scriptProcessorNode.disconnect();
                        SDL2.capture.scriptProcessorNode = undefined;
                    }
                    if (SDL2.capture.mediaStreamNode !== undefined) {
                        SDL2.capture.mediaStreamNode.disconnect();
                        SDL2.capture.mediaStreamNode = undefined;
                    }
                    if (SDL2.capture.silenceBuffer !== undefined) {
                        SDL2.capture.silenceBuffer = undefined;
                    }
                    SDL2.capture = undefined;
                } else {
                    if (SDL2.audio.scriptProcessorNode != undefined) {
                        SDL2.audio.scriptProcessorNode.disconnect();
                        SDL2.audio.scriptProcessorNode = undefined;
                    }
                    SDL2.audio = undefined;
                }
                if (
                    SDL2.audioContext !== undefined &&
                    SDL2.audio === undefined &&
                    SDL2.capture === undefined
                ) {
                    SDL2.audioContext.close();
                    SDL2.audioContext = undefined;
                }
            },
            6439850: ($0, $1, $2) => {
                var w = $0;
                var h = $1;
                var pixels = $2;
                if (!Module["SDL2"]) Module["SDL2"] = {};
                var SDL2 = Module["SDL2"];
                if (SDL2.ctxCanvas !== Module["canvas"]) {
                    SDL2.ctx = Module["createContext"](Module["canvas"], false, true);
                    SDL2.ctxCanvas = Module["canvas"];
                }
                if (SDL2.w !== w || SDL2.h !== h || SDL2.imageCtx !== SDL2.ctx) {
                    SDL2.image = SDL2.ctx.createImageData(w, h);
                    SDL2.w = w;
                    SDL2.h = h;
                    SDL2.imageCtx = SDL2.ctx;
                }
                var data = SDL2.image.data;
                var src = pixels >> 2;
                var dst = 0;
                var num;
                if (typeof CanvasPixelArray !== "undefined" && data instanceof CanvasPixelArray) {
                    num = data.length;
                    while (dst < num) {
                        var val = HEAP32[src];
                        data[dst] = val & 0xff;
                        data[dst + 1] = (val >> 8) & 0xff;
                        data[dst + 2] = (val >> 16) & 0xff;
                        data[dst + 3] = 0xff;
                        src++;
                        dst += 4;
                    }
                } else {
                    if (SDL2.data32Data !== data) {
                        SDL2.data32 = new Int32Array(data.buffer);
                        SDL2.data8 = new Uint8Array(data.buffer);
                        SDL2.data32Data = data;
                    }
                    var data32 = SDL2.data32;
                    num = data32.length;
                    data32.set(HEAP32.subarray(src, src + num));
                    var data8 = SDL2.data8;
                    var i = 3;
                    var j = i + 4 * num;
                    if (num % 8 == 0) {
                        while (i < j) {
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                        }
                    } else {
                        while (i < j) {
                            data8[i] = 0xff;
                            i = (i + 4) | 0;
                        }
                    }
                }
                SDL2.ctx.putImageData(SDL2.image, 0, 0);
            },
            6441319: ($0, $1, $2, $3, $4) => {
                var w = $0;
                var h = $1;
                var hot_x = $2;
                var hot_y = $3;
                var pixels = $4;
                var canvas = document.createElement("canvas");
                canvas.width = w;
                canvas.height = h;
                var ctx = canvas.getContext("2d");
                var image = ctx.createImageData(w, h);
                var data = image.data;
                var src = pixels >> 2;
                var dst = 0;
                var num;
                if (typeof CanvasPixelArray !== "undefined" && data instanceof CanvasPixelArray) {
                    num = data.length;
                    while (dst < num) {
                        var val = HEAP32[src];
                        data[dst] = val & 0xff;
                        data[dst + 1] = (val >> 8) & 0xff;
                        data[dst + 2] = (val >> 16) & 0xff;
                        data[dst + 3] = (val >> 24) & 0xff;
                        src++;
                        dst += 4;
                    }
                } else {
                    var data32 = new Int32Array(data.buffer);
                    num = data32.length;
                    data32.set(HEAP32.subarray(src, src + num));
                }
                ctx.putImageData(image, 0, 0);
                var url =
                    hot_x === 0 && hot_y === 0
                        ? "url(" + canvas.toDataURL() + "), auto"
                        : "url(" + canvas.toDataURL() + ") " + hot_x + " " + hot_y + ", auto";
                var urlBuf = _malloc(url.length + 1);
                stringToUTF8(url, urlBuf, url.length + 1);
                return urlBuf;
            },
            6442308: ($0) => {
                if (Module["canvas"]) {
                    Module["canvas"].style["cursor"] = UTF8ToString($0);
                }
            },
            6442391: () => {
                if (Module["canvas"]) {
                    Module["canvas"].style["cursor"] = "none";
                }
            },
            6442460: () => {
                return window.innerWidth;
            },
            6442490: () => {
                return window.innerHeight;
            }
        };
        function dm_fetch_cancel(sess) {
            let fetcher = libgpac._get_fetcher(sess);
            if (!fetcher) return -1;
            fetcher._controller.abort();
            libgpac._del_fetcher(fetcher);
            return 0;
        }
        function fs_fetch_setup() {
            if (typeof libgpac.gpac_fetch == "boolean" && !libgpac.gpac_fetch) return 2;
            if (typeof libgpac._fetcher_set_header == "function") return 1;
            try {
                libgpac._fetchers = [];
                libgpac._get_fetcher = (sess) => {
                    for (let i = 0; i < libgpac._fetchers.length; i++) {
                        if (libgpac._fetchers[i].sess == sess) return libgpac._fetchers[i];
                    }
                    return null;
                };
                libgpac._del_fetcher = (fetcher) => {
                    let i = libgpac._fetchers.indexOf(fetcher);
                    if (i >= 0) libgpac._fetchers.splice(i, 1);
                };
                libgpac._fetcher_set_header = libgpac.cwrap("gf_dm_sess_push_header", null, [
                    "number",
                    "string",
                    "string"
                ]);
                libgpac._fetcher_set_reply = libgpac.cwrap("gf_dm_sess_async_reply", null, [
                    "number",
                    "number",
                    "string"
                ]);
            } catch (e) {
                return 0;
            }
            return 1;
        }
        function dm_fetch_init(sess, _url, _method, _headers, nb_headers, req_body, req_body_size) {
            let url = _url ? libgpac.UTF8ToString(_url) : null;
            ret = GPAC.OK;
            let fetcher = libgpac._get_fetcher(sess);
            if (!fetcher) {
                fetcher = {};
                fetcher.sess = sess;
                libgpac._fetchers.push(fetcher);
            }
            fetcher._controller = new AbortController();
            let options = {
                signal: fetcher._controller.signal,
                method: _method ? libgpac.UTF8ToString(_method) : "GET",
                mode: libgpac.gpac_fetch_mode || "cors"
            };
            let mime_type = "application/octet-stream";
            options.headers = {};
            if (_headers) {
                for (let i = 0; i < nb_headers; i += 2) {
                    let _s = libgpac.getValue(_headers + i * 4, "i32");
                    let h_name = _s ? libgpac.UTF8ToString(_s).toLowerCase() : "";
                    _s = libgpac.getValue(_headers + (i + 1) * 4, "i32");
                    let h_val = _s ? libgpac.UTF8ToString(_s) : "";
                    if (h_name.length && h_val.length) {
                        options.headers[h_name] = h_val;
                        if (h_name == "content-type") mime_type = h_val;
                    }
                }
            }
            if (typeof libgpac.gpac_extra_headers == "object") {
                for (const hdr in libgpac.gpac_extra_headers) {
                    options.headers[hdr] = object[hdr];
                }
            }
            if (req_body) {
                let body_ab = new Uint8Array(libgpac.HEAPU8.buffer, req_body, req_body_size);
                options.body = new Blob(body_ab, { type: mime_type });
            }
            fetcher._state = 0;
            fetch(url, options)
                .then((response) => {
                    if (response.ok) {
                        fetcher._state = 1;
                        fetcher._bytes = 0;
                        fetcher._reader = response.body.getReader();
                        let final_url = null;
                        if (response.redirected) final_url = response.url;
                        libgpac._fetcher_set_reply(fetcher.sess, response.status, final_url);
                        response.headers.forEach((value, key) => {
                            libgpac._fetcher_set_header(fetcher.sess, key, value);
                        });
                        libgpac._fetcher_set_header(fetcher.sess, 0, 0);
                    } else {
                        libgpac._fetcher_set_reply(fetcher.sess, response.status, null);
                        do_log_err("fetcher for " + url + " failed " + response.status);
                        fetcher._state = 3;
                    }
                })
                .catch((e) => {
                    do_log_err("fetcher exception " + e);
                    ret = GPAC.REMOTE_SERVICE_ERROR;
                    libgpac._del_fetcher(fetcher);
                });
            return ret;
        }
        function dm_fetch_data(sess, buffer, buffer_size, read_size) {
            let f = libgpac._get_fetcher(sess);
            if (!f) return -1;
            if (f._state == 0) return -44;
            if (f._state == 3) return -12;
            if (f._state == 4) return 1;
            if (f._state == 1) {
                f._state = 0;
                f._reader
                    .read()
                    .then((block) => {
                        if (block.done) {
                            f._state = 4;
                        } else {
                            f._ab = block.value;
                            f._bytes += f._ab.byteLength;
                            f._block_pos = 0;
                            f._state = 2;
                        }
                    })
                    .catch((e) => {
                        f._state = 0;
                    });
                if (f._state == 0) return -44;
            }
            let avail = f._ab.byteLength - f._block_pos;
            if (avail < buffer_size) buffer_size = avail;
            let src = f._ab.subarray(f._block_pos, f._block_pos + buffer_size);
            let dst = new Uint8Array(libgpac.HEAPU8.buffer, buffer, buffer_size);
            dst.set(src);
            libgpac.setValue(read_size, buffer_size, "i32");
            f._block_pos += buffer_size;
            if (f._ab.byteLength == f._block_pos) {
                f._ab = null;
                f._state = 1;
            }
            return 0;
        }
        function wcdec_init(
            wc_ctx,
            _codec_str,
            width,
            height,
            sample_rate,
            num_channels,
            dsi,
            dsi_size
        ) {
            let codec_str = _codec_str ? libgpac.UTF8ToString(_codec_str) : null;
            let config = {};
            config.codec = codec_str;
            let dec_class = null;
            if (width) {
                config.codedWidth = width;
                config.codedHeight = height;
                dec_class = VideoDecoder;
            } else {
                config.sampleRate = sample_rate;
                config.numberOfChannels = num_channels;
                dec_class = AudioDecoder;
            }
            if (dsi_size) {
                config.description = new Uint8Array(libgpac.HEAPU8.buffer, dsi, dsi_size);
            }
            if (typeof libgpac._to_webdec != "function") {
                libgpac._web_decs = [];
                libgpac._to_webdec = (ctx) => {
                    for (let i = 0; i < libgpac._web_decs.length; i++) {
                        if (libgpac._web_decs[i]._wc_ctx == ctx) return libgpac._web_decs[i];
                    }
                    return null;
                };
                libgpac._on_wcdec_error = libgpac.cwrap("wcdec_on_error", null, [
                    "number",
                    "number",
                    "string"
                ]);
                libgpac._on_wcdec_frame = libgpac.cwrap("wcdec_on_video", null, [
                    "number",
                    "bigint",
                    "string",
                    "number",
                    "number"
                ]);
                libgpac._on_wcdec_audio = libgpac.cwrap("wcdec_on_audio", null, [
                    "number",
                    "bigint",
                    "string",
                    "number",
                    "number",
                    "number"
                ]);
                libgpac._on_wcdec_flush = libgpac.cwrap("wcdec_on_flush", null, ["number"]);
                libgpac._on_wcdec_frame_copy = libgpac.cwrap("wcdec_on_frame_copy", null, [
                    "number",
                    "number",
                    "number"
                ]);
            }
            let c = libgpac._to_webdec(wc_ctx);
            if (!c) {
                c = { _wc_ctx: wc_ctx, dec: null, _frame: null };
                libgpac._web_decs.push(c);
            }
            dec_class
                .isConfigSupported(config)
                .then((supported) => {
                    if (supported.supported) {
                        if (!c.dec) {
                            let init_info = {
                                error: (e) => {
                                    libgpac._on_wcdec_error(c._wc_ctx, 1, "" + e);
                                }
                            };
                            if (width && height) {
                                init_info.output = (frame) => {
                                    c._frame = frame;
                                    libgpac._on_wcdec_frame(
                                        c._wc_ctx,
                                        BigInt(frame.timestamp),
                                        frame.format,
                                        frame.codedWidth,
                                        frame.codedHeight
                                    );
                                    if (c._frame) frame.close();
                                };
                            } else {
                                init_info.output = (frame) => {
                                    c._frame = frame;
                                    libgpac._on_wcdec_audio(
                                        c._wc_ctx,
                                        BigInt(frame.timestamp),
                                        frame.format,
                                        frame.numberOfFrames,
                                        frame.numberOfChannels,
                                        frame.sampleRate
                                    );
                                    if (c._frame) frame.close();
                                };
                            }
                            c.dec = new dec_class(init_info);
                        }
                        c.dec.configure(config);
                        libgpac._on_wcdec_error(c._wc_ctx, 0, null);
                    } else {
                        libgpac._on_wcdec_error(c._wc_ctx, 1, null);
                    }
                })
                .catch((e) => {
                    libgpac._on_wcdec_error(c._wc_ctx, 1, "" + e);
                });
        }
        function wcdec_push_frame(wc_ctx, buf, buf_size, key, ts) {
            let c = libgpac._to_webdec(wc_ctx);
            if (!c || !c.dec) return;
            const chunk = new EncodedVideoChunk({
                timestamp: Number(ts),
                type: key ? "key" : "delta",
                data: new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size)
            });
            c.dec.decode(chunk);
        }
        function wcdec_push_audio(wc_ctx, buf, buf_size, key, ts) {
            let c = libgpac._to_webdec(wc_ctx);
            if (!c || !c.dec) return;
            const chunk = new EncodedAudioChunk({
                timestamp: Number(ts),
                type: key ? "key" : "delta",
                data: new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size)
            });
            c.dec.decode(chunk);
        }
        function wcdec_copy_frame(wc_ctx, dst_pck, buf, buf_size) {
            let c = libgpac._to_webdec(wc_ctx);
            if (!c || !c._frame || !dst_pck) return;
            let ab = new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size);
            let frame = c._frame;
            c._frame = null;
            frame
                .copyTo(ab)
                .then((layout) => {
                    libgpac._on_wcdec_frame_copy(c._wc_ctx, dst_pck, 1);
                    frame.close();
                })
                .catch((e) => {
                    libgpac._on_wcdec_frame_copy(c._wc_ctx, dst_pck, 0);
                    frame.close();
                });
        }
        function wcdec_copy_audio(wc_ctx, buf, buf_size, plane_index) {
            let c = libgpac._to_webdec(wc_ctx);
            if (!c || !c._frame) return;
            let ab = new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size);
            c._frame.copyTo(ab, { planeIndex: plane_index });
        }
        function wcdec_flush(wc_ctx) {
            let c = libgpac._to_webdec(wc_ctx);
            if (!c || !c.dec) return;
            c.dec
                .flush()
                .then(() => {
                    libgpac._on_wcdec_flush(c._wc_ctx);
                })
                .catch((e) => {
                    libgpac._on_wcdec_flush(c._wc_ctx);
                });
        }
        function wcdec_del(wc_ctx) {
            if (!Array.isArray(libgpac._web_decs)) return;
            for (let i = 0; i < libgpac._web_decs.length; i++) {
                if (libgpac._web_decs[i]._wc_ctx == wc_ctx) {
                    libgpac._web_decs[i]._wc_ctx = null;
                    libgpac._web_decs.splice(i, 1);
                    return;
                }
            }
        }
        function wcenc_init(
            wc_ctx,
            _codec_str,
            bitrate,
            width,
            height,
            FPS,
            realtime,
            sample_rate,
            num_channels
        ) {
            let codec_str = _codec_str ? libgpac.UTF8ToString(_codec_str) : null;
            let config = {};
            config.codec = codec_str;
            let enc_class = null;
            if (width) {
                config.width = width;
                config.height = height;
                config.framerate = FPS;
                config.latency = realtime ? "realtime" : "quality";
                enc_class = VideoEncoder;
                if (codec_str.startsWith("avc")) {
                    config.avc = { format: "annexb" };
                } else if (codec_str.startsWith("hvc1") || codec_str.startsWith("hev1")) {
                    config.hevc = { format: "annexb" };
                }
            } else {
                config.sampleRate = sample_rate;
                config.numberOfChannels = num_channels;
                enc_class = AudioEncoder;
            }
            config.bitrate = bitrate;
            if (typeof libgpac._to_webenc != "function") {
                libgpac._web_encs = [];
                libgpac._to_webenc = (ctx) => {
                    for (let i = 0; i < libgpac._web_encs.length; i++) {
                        if (libgpac._web_encs[i]._wc_ctx == ctx) return libgpac._web_encs[i];
                    }
                    return null;
                };
                libgpac._on_wcenc_error = libgpac.cwrap("wcenc_on_error", null, [
                    "number",
                    "number",
                    "string"
                ]);
                libgpac._on_wcenc_config = libgpac.cwrap("wcenc_on_config", null, [
                    "number",
                    "number"
                ]);
                libgpac._on_wcenc_frame = libgpac.cwrap("wcenc_on_frame", null, [
                    "number",
                    "bigint",
                    "number",
                    "number",
                    "number"
                ]);
                libgpac._on_wcenc_flush = libgpac.cwrap("wcenc_on_flush", null, ["number"]);
            }
            enc_class
                .isConfigSupported(config)
                .then((supported) => {
                    if (supported.supported) {
                        let c = libgpac._to_webenc(wc_ctx);
                        if (!c) {
                            c = { _wc_ctx: wc_ctx, enc: null, _frame: null };
                            libgpac._web_encs.push(c);
                        }
                        if (!c.enc) {
                            let init_info = {
                                error: (e) => {
                                    console.log(e.message);
                                }
                            };
                            init_info.output = (chunk, metadata) => {
                                let dsize = metadata.decoderConfig || null;
                                if (dsize) dsize = dsize.description || null;
                                if (dsize) dsize = dsize.byteLength || 0;
                                if (dsize) {
                                    c.decoderConfig = metadata.decoderConfig.description;
                                    libgpac._on_wcenc_config(c._wc_ctx, c.decoderConfig.byteLength);
                                    c.decoderConfig = null;
                                }
                                c.chunk = chunk;
                                let sap = 1;
                                if (typeof chunk.type != "undefined")
                                    sap = chunk.type == "key" ? 1 : 0;
                                libgpac._on_wcenc_frame(
                                    c._wc_ctx,
                                    BigInt(chunk.timestamp),
                                    chunk.duration,
                                    chunk.byteLength,
                                    sap
                                );
                                c.chunk = null;
                            };
                            c.enc = new enc_class(init_info);
                        }
                        c.enc.configure(config);
                        libgpac._on_wcenc_error(wc_ctx, 0, null);
                    } else {
                        libgpac._on_wcenc_error(wc_ctx, 1, "Not Supported");
                    }
                })
                .catch((e) => {
                    libgpac._on_wcenc_error(wc_ctx, 1, "" + e);
                });
        }
        function wcenc_encode_frame(
            wc_ctx,
            w,
            h,
            uv_h,
            _format,
            ts,
            dur,
            planes,
            stride1,
            stride2,
            sap,
            buf,
            buf_size
        ) {
            let c = libgpac._to_webenc(wc_ctx);
            if (!c || !buf || !_format) return;
            let format = libgpac.UTF8ToString(_format);
            let ab = new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size);
            let vbinit = {
                format: format,
                layout: [],
                codedWidth: w,
                codedHeight: h,
                timestamp: Number(ts),
                duration: dur
            };
            let offset = 0;
            for (let i = 0; i < planes; i++) {
                let l = {};
                let p_h = h;
                l.offset = offset;
                l.stride = stride1;
                if (i == 4) l.stride = stride1;
                else if (i) {
                    l.stride = stride2;
                    p_h = uv_h;
                }
                offset += l.stride * p_h;
                vbinit.layout.push(l);
            }
            let vframe = new VideoFrame(ab, vbinit);
            c.enc.encode(vframe, { keyFrame: sap ? true : false });
            vframe.close();
        }
        function wcenc_encode_audio(wc_ctx, sr, ch, frames, _format, ts, buf, buf_size) {
            let c = libgpac._to_webenc(wc_ctx);
            if (!c || !buf || !_format) return;
            let format = libgpac.UTF8ToString(_format);
            let adinit = {
                format: format,
                sampleRate: sr,
                numberOfChannels: ch,
                numberOfFrames: frames,
                timestamp: Number(ts),
                data: new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size)
            };
            let adata = new AudioData(adinit);
            c.enc.encode(adata);
            adata.close();
        }
        function wcenc_flush(wc_ctx) {
            let c = libgpac._to_webenc(wc_ctx);
            if (!c || !c.enc) return;
            c.enc
                .flush()
                .then(() => {
                    libgpac._on_wcenc_flush(c._wc_ctx);
                })
                .catch((e) => {
                    libgpac._on_wcenc_flush(c._wc_ctx);
                });
        }
        function wcenc_get_config(wc_ctx, buf, buf_size) {
            let c = libgpac._to_webenc(wc_ctx);
            if (!c || !c.decoderConfig) {
                throw "Bad Param";
                return;
            }
            let dst = new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size);
            dst.set(c.decoderConfig);
        }
        function wcenc_get_frame(wc_ctx, buf, buf_size) {
            let c = libgpac._to_webenc(wc_ctx);
            if (!c || !c.chunk) {
                throw "Bad Param";
                return;
            }
            let dst = new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size);
            c.chunk.copyTo(dst);
        }
        function wcenc_del(wc_ctx) {
            if (typeof libgpac._web_encs != "array") return;
            for (let i = 0; i < libgpac._web_encs.length; i++) {
                if (libgpac._web_encs[i]._wc_ctx == wc_ctx) {
                    libgpac._web_encs[i].enc.close();
                    libgpac._web_encs.splice(i, 1);
                    return;
                }
            }
        }
        function webgrab_next_video(wg_ctx) {
            let c = libgpac._to_webgrab(wg_ctx);
            if (!c) {
                libgpac._on_wgrab_error(c._wg_ctx, 2, "Invalid source");
                return;
            }
            if (c.canvas) {
                try {
                    c._frame = new VideoFrame(c.canvas, {
                        timestamp: 0,
                        alpha: c.keep_alpha ? "keep" : "discard"
                    });
                    libgpac._on_wgrab_video_frame(
                        c._wg_ctx,
                        c._frame.codedWidth,
                        c._frame.codedHeight,
                        c._frame.format,
                        BigInt(c._frame.timestamp)
                    );
                } catch (e) {
                    libgpac._on_wgrab_error(wg_ctx, 2, "" + e);
                }
                return;
            }
            if (c.video_reader == null) return;
            c.video_reader
                .read()
                .then((result) => {
                    if (result.done) {
                        libgpac._on_wgrab_error(c._wg_ctx, 3, null);
                        return;
                    }
                    c._frame = result.value;
                    libgpac._on_wgrab_video_frame(
                        c._wg_ctx,
                        c._frame.codedWidth,
                        c._frame.codedHeight,
                        c._frame.format,
                        BigInt(c._frame.timestamp)
                    );
                })
                .catch((e) => {
                    libgpac._on_wgrab_error(wg_ctx, 2, "" + e);
                });
        }
        function webgrab_next_audio(wg_ctx) {
            let c = libgpac._to_webgrab(wg_ctx);
            if (!c) {
                libgpac._on_wgrab_error(c._wg_ctx, 2, "Invalid source");
                return;
            }
            if (c.audio_reader == null) return;
            c.audio_reader
                .read()
                .then((result) => {
                    if (result.done) {
                        libgpac._on_wgrab_error(c._wg_ctx, 3, null);
                        return;
                    }
                    c._frame = result.value;
                    libgpac._on_wgrab_audio_data(
                        c._wg_ctx,
                        c._frame.sampleRate,
                        c._frame.numberOfChannels,
                        c._frame.format,
                        c._frame.numberOfFrames,
                        BigInt(c._frame.timestamp)
                    );
                    c._frame.close();
                    c._frame = null;
                })
                .catch((e) => {
                    libgpac._on_wgrab_error(wg_ctx, 2, "" + e);
                });
        }
        function wgrab_copy_frame(wg_ctx, dst_pck, buf, buf_size) {
            let c = libgpac._to_webgrab(wg_ctx);
            if (!c || !c._frame || !dst_pck) return;
            let ab = new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size);
            let frame = c._frame;
            c._frame = null;
            frame
                .copyTo(ab)
                .then((layout) => {
                    libgpac._on_wgrab_frame_copy(c._wg_ctx, dst_pck, 1);
                    frame.close();
                })
                .catch((e) => {
                    libgpac._on_wgrab_frame_copy(c._wg_ctx, dst_pck, 0);
                    frame.close();
                });
        }
        function wgrab_copy_audio(wg_ctx, buf, buf_size, plane_index) {
            let c = libgpac._to_webgrab(wg_ctx);
            if (!c || !c._frame) return;
            let ab = new Uint8Array(libgpac.HEAPU8.buffer, buf, buf_size);
            c._frame.copyTo(ab, { planeIndex: plane_index });
        }
        function webgrab_start_usermedia(wg_ctx, vid, aud, canv_id, w, h, back, alpha) {
            if (typeof libgpac._to_webgrab != "function") {
                libgpac._web_grabs = [];
                libgpac._to_webgrab = (ctx) => {
                    for (let i = 0; i < libgpac._web_grabs.length; i++) {
                        if (libgpac._web_grabs[i]._wg_ctx == ctx) return libgpac._web_grabs[i];
                    }
                    return null;
                };
                libgpac._on_wgrab_error = libgpac.cwrap("webgrab_on_error", null, [
                    "number",
                    "number",
                    "string"
                ]);
                libgpac._on_wgrab_video_frame = libgpac.cwrap("webgrab_on_video_frame", null, [
                    "number",
                    "number",
                    "number",
                    "string",
                    "bigint"
                ]);
                libgpac._on_wgrab_audio_data = libgpac.cwrap("webgrab_on_audio_data", null, [
                    "number",
                    "number",
                    "number",
                    "string",
                    "number",
                    "bigint"
                ]);
                libgpac._on_wgrab_frame_copy = libgpac.cwrap("webgrab_on_frame_copy", null, [
                    "number",
                    "number",
                    "number"
                ]);
            }
            let c = libgpac._to_webgrab(wg_ctx);
            if (!c) {
                c = {
                    _wg_ctx: wg_ctx,
                    stream: null,
                    canvas: null,
                    video_reader: null,
                    audio_reader: null,
                    _frame: null
                };
                libgpac._web_grabs.push(c);
            }
            if (canv_id) {
                let canvas_id = libgpac.UTF8ToString(canv_id);
                c.canvas = document.getElementById(canvas_id);
                c.keep_alpha = alpha;
                if (!c.canvas) {
                    libgpac._on_wgrab_error(wg_ctx, 1, "No such element " + canvas_id);
                    return;
                }
                try {
                    let frame = new VideoFrame(c.canvas, {
                        timestamp: 0,
                        alpha: c.keep_alpha ? "keep" : "discard"
                    });
                    libgpac._on_wgrab_video_frame(
                        c._wg_ctx,
                        frame.codedWidth,
                        frame.codedHeight,
                        frame.format,
                        BigInt(frame.timestamp)
                    );
                    frame.close();
                } catch (e) {
                    libgpac._on_wgrab_error(wg_ctx, 1, "" + e);
                }
                return;
            }
            let constraints = { audio: aud ? true : false, video: vid ? true : false };
            if (w || h || back) {
                constraints.video = {};
                if (w) constraints.video.width = { ideal: w };
                if (h) constraints.video.height = { ideal: h };
                if (back) constraints.video.facingMode = { ideal: "environment" };
            }
            navigator.mediaDevices
                .getUserMedia(constraints)
                .then((stream) => {
                    c.stream = stream;
                    stream.getTracks().forEach((track) => {
                        if (track.kind == "audio") {
                            let trackProcessor = new MediaStreamTrackProcessor(track);
                            c.audio_reader = trackProcessor.readable.getReader();
                            c.audio_reader
                                .read()
                                .then((result) => {
                                    if (result.done) return;
                                    const frame = result.value;
                                    libgpac._on_wgrab_audio_data(
                                        c._wg_ctx,
                                        frame.sampleRate,
                                        frame.numberOfChannels,
                                        frame.format,
                                        frame.numberOfFrames,
                                        BigInt(frame.timestamp)
                                    );
                                    frame.close();
                                })
                                .catch((e) => {
                                    libgpac._on_wgrab_error(wg_ctx, 2, "" + e);
                                });
                        } else if (track.kind == "video") {
                            let trackProcessor = new MediaStreamTrackProcessor(track);
                            c.video_reader = trackProcessor.readable.getReader();
                            c.video_reader
                                .read()
                                .then((result) => {
                                    if (result.done) return;
                                    const frame = result.value;
                                    libgpac._on_wgrab_video_frame(
                                        c._wg_ctx,
                                        frame.codedWidth,
                                        frame.codedHeight,
                                        frame.format,
                                        BigInt(frame.timestamp)
                                    );
                                    frame.close();
                                })
                                .catch((e) => {
                                    libgpac._on_wgrab_error(wg_ctx, 2, "" + e);
                                });
                        }
                    });
                })
                .catch((e) => {
                    libgpac._on_wgrab_error(wg_ctx, 1, "" + e);
                });
        }
        function wgrab_del(wg_ctx) {
            if (!Array.isArray(libgpac._web_grabs)) return;
            for (let i = 0; i < libgpac._web_grabs.length; i++) {
                if (libgpac._web_grabs[i]._wg_ctx == wg_ctx) {
                    libgpac._web_grabs[i]._wg_ctx = null;
                    if (libgpac._web_grabs[i].stream) {
                        libgpac._web_grabs[i].stream.getTracks().forEach(function (track) {
                            track.stop();
                        });
                    }
                    libgpac._web_grabs.splice(i, 1);
                    return;
                }
            }
        }

        // end include: preamble.js

        /** @constructor */
        function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
        }

        function listenOnce(object, event, func) {
            object.addEventListener(event, func, { once: true });
        }
        /** @param {Object=} elements */
        function autoResumeAudioContext(ctx, elements) {
            if (!elements) {
                elements = [document, document.getElementById("canvas")];
            }
            ["keydown", "mousedown", "touchstart"].forEach(function (event) {
                elements.forEach(function (element) {
                    if (element) {
                        listenOnce(element, event, () => {
                            if (ctx.state === "suspended") ctx.resume();
                        });
                    }
                });
            });
        }

        function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
                // Pass the module as the first argument.
                callbacks.shift()(Module);
            }
        }

        var wasmTableMirror = [];

        function getWasmTableEntry(funcPtr) {
            var func = wasmTableMirror[funcPtr];
            if (!func) {
                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
            }
            assert(
                wasmTable.get(funcPtr) == func,
                "JavaScript-side Wasm function table mirror is out of date!"
            );
            return func;
        }
        /** @param {Object=} args */
        function dynCall(sig, ptr, args) {
            assert(getWasmTableEntry(ptr), "missing table entry in dynCall: " + ptr);
            var rtn = getWasmTableEntry(ptr).apply(null, args);
            return rtn;
        }

        /**
         * @param {number} ptr
         * @param {string} type
         */
        function getValue(ptr, type = "i8") {
            if (type.endsWith("*")) type = "*";
            switch (type) {
                case "i1":
                    return HEAP8[ptr >> 0];
                case "i8":
                    return HEAP8[ptr >> 0];
                case "i16":
                    return HEAP16[ptr >> 1];
                case "i32":
                    return HEAP32[ptr >> 2];
                case "i64":
                    return HEAP64[ptr >> 3];
                case "float":
                    return HEAPF32[ptr >> 2];
                case "double":
                    return HEAPF64[ptr >> 3];
                case "*":
                    return HEAPU32[ptr >> 2];
                default:
                    abort("invalid type for getValue: " + type);
            }
        }

        function ptrToString(ptr) {
            assert(typeof ptr === "number");
            return "0x" + ptr.toString(16).padStart(8, "0");
        }

        /**
         * @param {number} ptr
         * @param {number} value
         * @param {string} type
         */
        function setValue(ptr, value, type = "i8") {
            if (type.endsWith("*")) type = "*";
            switch (type) {
                case "i1":
                    HEAP8[ptr >> 0] = value;
                    break;
                case "i8":
                    HEAP8[ptr >> 0] = value;
                    break;
                case "i16":
                    HEAP16[ptr >> 1] = value;
                    break;
                case "i32":
                    HEAP32[ptr >> 2] = value;
                    break;
                case "i64":
                    (tempI64 = [
                        value >>> 0,
                        ((tempDouble = value),
                        +Math.abs(tempDouble) >= 1.0
                            ? tempDouble > 0.0
                                ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                      0) >>>
                                  0
                                : ~~+Math.ceil(
                                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0
                                  ) >>> 0
                            : 0)
                    ]),
                        (HEAP32[ptr >> 2] = tempI64[0]),
                        (HEAP32[(ptr + 4) >> 2] = tempI64[1]);
                    break;
                case "float":
                    HEAPF32[ptr >> 2] = value;
                    break;
                case "double":
                    HEAPF64[ptr >> 3] = value;
                    break;
                case "*":
                    HEAPU32[ptr >> 2] = value;
                    break;
                default:
                    abort("invalid type for setValue: " + type);
            }
        }

        function warnOnce(text) {
            if (!warnOnce.shown) warnOnce.shown = {};
            if (!warnOnce.shown[text]) {
                warnOnce.shown[text] = 1;
                if (ENVIRONMENT_IS_NODE) text = "warning: " + text;
                err(text);
            }
        }

        function ___assert_fail(condition, filename, line, func) {
            abort(
                "Assertion failed: " +
                    UTF8ToString(condition) +
                    ", at: " +
                    [
                        filename ? UTF8ToString(filename) : "unknown filename",
                        line,
                        func ? UTF8ToString(func) : "unknown function"
                    ]
            );
        }

        function ___call_sighandler(fp, sig) {
            getWasmTableEntry(fp)(sig);
        }

        var dlopenMissingError =
            "To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking";
        function ___dlsym(handle, symbol) {
            abort(dlopenMissingError);
        }

        var PATH = {
            isAbs: (path) => path.charAt(0) === "/",
            splitPath: (filename) => {
                var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
                return splitPathRe.exec(filename).slice(1);
            },
            normalizeArray: (parts, allowAboveRoot) => {
                // if the path tries to go above the root, `up` ends up > 0
                var up = 0;
                for (var i = parts.length - 1; i >= 0; i--) {
                    var last = parts[i];
                    if (last === ".") {
                        parts.splice(i, 1);
                    } else if (last === "..") {
                        parts.splice(i, 1);
                        up++;
                    } else if (up) {
                        parts.splice(i, 1);
                        up--;
                    }
                }
                // if the path is allowed to go above the root, restore leading ..s
                if (allowAboveRoot) {
                    for (; up; up--) {
                        parts.unshift("..");
                    }
                }
                return parts;
            },
            normalize: (path) => {
                var isAbsolute = PATH.isAbs(path),
                    trailingSlash = path.substr(-1) === "/";
                // Normalize the path
                path = PATH.normalizeArray(
                    path.split("/").filter((p) => !!p),
                    !isAbsolute
                ).join("/");
                if (!path && !isAbsolute) {
                    path = ".";
                }
                if (path && trailingSlash) {
                    path += "/";
                }
                return (isAbsolute ? "/" : "") + path;
            },
            dirname: (path) => {
                var result = PATH.splitPath(path),
                    root = result[0],
                    dir = result[1];
                if (!root && !dir) {
                    // No dirname whatsoever
                    return ".";
                }
                if (dir) {
                    // It has a dirname, strip trailing slash
                    dir = dir.substr(0, dir.length - 1);
                }
                return root + dir;
            },
            basename: (path) => {
                // EMSCRIPTEN return '/'' for '/', not an empty string
                if (path === "/") return "/";
                path = PATH.normalize(path);
                path = path.replace(/\/$/, "");
                var lastSlash = path.lastIndexOf("/");
                if (lastSlash === -1) return path;
                return path.substr(lastSlash + 1);
            },
            join: function () {
                var paths = Array.prototype.slice.call(arguments);
                return PATH.normalize(paths.join("/"));
            },
            join2: (l, r) => {
                return PATH.normalize(l + "/" + r);
            }
        };

        function getRandomDevice() {
            if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
                // for modern web browsers
                var randomBuffer = new Uint8Array(1);
                return () => {
                    crypto.getRandomValues(randomBuffer);
                    return randomBuffer[0];
                };
            } else if (ENVIRONMENT_IS_NODE) {
                // for nodejs with or without crypto support included
                try {
                    var crypto_module = require("crypto");
                    // nodejs has crypto support
                    return () => crypto_module["randomBytes"](1)[0];
                } catch (e) {
                    // nodejs doesn't have crypto support
                }
            }
            // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
            return () =>
                abort(
                    "no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"
                );
        }

        var PATH_FS = {
            resolve: function () {
                var resolvedPath = "",
                    resolvedAbsolute = false;
                for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                    var path = i >= 0 ? arguments[i] : FS.cwd();
                    // Skip empty and invalid entries
                    if (typeof path != "string") {
                        throw new TypeError("Arguments to path.resolve must be strings");
                    } else if (!path) {
                        return ""; // an invalid portion invalidates the whole thing
                    }
                    resolvedPath = path + "/" + resolvedPath;
                    resolvedAbsolute = PATH.isAbs(path);
                }
                // At this point the path should be resolved to a full absolute path, but
                // handle relative paths to be safe (might happen when process.cwd() fails)
                resolvedPath = PATH.normalizeArray(
                    resolvedPath.split("/").filter((p) => !!p),
                    !resolvedAbsolute
                ).join("/");
                return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
            },
            relative: (from, to) => {
                from = PATH_FS.resolve(from).substr(1);
                to = PATH_FS.resolve(to).substr(1);
                function trim(arr) {
                    var start = 0;
                    for (; start < arr.length; start++) {
                        if (arr[start] !== "") break;
                    }
                    var end = arr.length - 1;
                    for (; end >= 0; end--) {
                        if (arr[end] !== "") break;
                    }
                    if (start > end) return [];
                    return arr.slice(start, end - start + 1);
                }
                var fromParts = trim(from.split("/"));
                var toParts = trim(to.split("/"));
                var length = Math.min(fromParts.length, toParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                    if (fromParts[i] !== toParts[i]) {
                        samePartsLength = i;
                        break;
                    }
                }
                var outputParts = [];
                for (var i = samePartsLength; i < fromParts.length; i++) {
                    outputParts.push("..");
                }
                outputParts = outputParts.concat(toParts.slice(samePartsLength));
                return outputParts.join("/");
            }
        };

        /** @type {function(string, boolean=, number=)} */
        function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull) u8array.length = numBytesWritten;
            return u8array;
        }
        var TTY = {
            ttys: [],
            init: function () {
                // https://github.com/emscripten-core/emscripten/pull/1555
                // if (ENVIRONMENT_IS_NODE) {
                //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
                //   // device, it always assumes it's a TTY device. because of this, we're forcing
                //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
                //   // with text files until FS.init can be refactored.
                //   process.stdin.setEncoding('utf8');
                // }
            },
            shutdown: function () {
                // https://github.com/emscripten-core/emscripten/pull/1555
                // if (ENVIRONMENT_IS_NODE) {
                //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
                //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
                //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
                //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
                //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
                //   process.stdin.pause();
                // }
            },
            register: function (dev, ops) {
                TTY.ttys[dev] = { input: [], output: [], ops: ops };
                FS.registerDevice(dev, TTY.stream_ops);
            },
            stream_ops: {
                open: function (stream) {
                    var tty = TTY.ttys[stream.node.rdev];
                    if (!tty) {
                        throw new FS.ErrnoError(43);
                    }
                    stream.tty = tty;
                    stream.seekable = false;
                },
                close: function (stream) {
                    // flush any pending line data
                    stream.tty.ops.fsync(stream.tty);
                },
                fsync: function (stream) {
                    stream.tty.ops.fsync(stream.tty);
                },
                read: function (stream, buffer, offset, length, pos /* ignored */) {
                    if (!stream.tty || !stream.tty.ops.get_char) {
                        throw new FS.ErrnoError(60);
                    }
                    var bytesRead = 0;
                    for (var i = 0; i < length; i++) {
                        var result;
                        try {
                            result = stream.tty.ops.get_char(stream.tty);
                        } catch (e) {
                            throw new FS.ErrnoError(29);
                        }
                        if (result === undefined && bytesRead === 0) {
                            throw new FS.ErrnoError(6);
                        }
                        if (result === null || result === undefined) break;
                        bytesRead++;
                        buffer[offset + i] = result;
                    }
                    if (bytesRead) {
                        stream.node.timestamp = Date.now();
                    }
                    return bytesRead;
                },
                write: function (stream, buffer, offset, length, pos) {
                    if (!stream.tty || !stream.tty.ops.put_char) {
                        throw new FS.ErrnoError(60);
                    }
                    try {
                        for (var i = 0; i < length; i++) {
                            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
                        }
                    } catch (e) {
                        throw new FS.ErrnoError(29);
                    }
                    if (length) {
                        stream.node.timestamp = Date.now();
                    }
                    return i;
                }
            },
            default_tty_ops: {
                get_char: function (tty) {
                    if (!tty.input.length) {
                        var result = null;
                        if (ENVIRONMENT_IS_NODE) {
                            // we will read data by chunks of BUFSIZE
                            var BUFSIZE = 256;
                            var buf = Buffer.alloc(BUFSIZE);
                            var bytesRead = 0;

                            try {
                                bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1);
                            } catch (e) {
                                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                                if (e.toString().includes("EOF")) bytesRead = 0;
                                else throw e;
                            }

                            if (bytesRead > 0) {
                                result = buf.slice(0, bytesRead).toString("utf-8");
                            } else {
                                result = null;
                            }
                        } else if (
                            typeof window != "undefined" &&
                            typeof window.prompt == "function"
                        ) {
                            // Browser.
                            result = window.prompt("Input: "); // returns null on cancel
                            if (result !== null) {
                                result += "\n";
                            }
                        } else if (typeof readline == "function") {
                            // Command line.
                            result = readline();
                            if (result !== null) {
                                result += "\n";
                            }
                        }
                        if (!result) {
                            return null;
                        }
                        tty.input = intArrayFromString(result, true);
                    }
                    return tty.input.shift();
                },
                put_char: function (tty, val) {
                    if (val === null || val === 10) {
                        out(UTF8ArrayToString(tty.output, 0));
                        tty.output = [];
                    } else {
                        if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
                    }
                },
                fsync: function (tty) {
                    if (tty.output && tty.output.length > 0) {
                        out(UTF8ArrayToString(tty.output, 0));
                        tty.output = [];
                    }
                }
            },
            default_tty1_ops: {
                put_char: function (tty, val) {
                    if (val === null || val === 10) {
                        err(UTF8ArrayToString(tty.output, 0));
                        tty.output = [];
                    } else {
                        if (val != 0) tty.output.push(val);
                    }
                },
                fsync: function (tty) {
                    if (tty.output && tty.output.length > 0) {
                        err(UTF8ArrayToString(tty.output, 0));
                        tty.output = [];
                    }
                }
            }
        };

        function zeroMemory(address, size) {
            HEAPU8.fill(0, address, address + size);
            return address;
        }

        function alignMemory(size, alignment) {
            assert(alignment, "alignment argument is required");
            return Math.ceil(size / alignment) * alignment;
        }
        function mmapAlloc(size) {
            size = alignMemory(size, 65536);
            var ptr = _emscripten_builtin_memalign(65536, size);
            if (!ptr) return 0;
            return zeroMemory(ptr, size);
        }
        var MEMFS = {
            ops_table: null,
            mount: function (mount) {
                return MEMFS.createNode(null, "/", 16384 | 511 /* 0777 */, 0);
            },
            createNode: function (parent, name, mode, dev) {
                if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
                    // no supported
                    throw new FS.ErrnoError(63);
                }
                if (!MEMFS.ops_table) {
                    MEMFS.ops_table = {
                        dir: {
                            node: {
                                getattr: MEMFS.node_ops.getattr,
                                setattr: MEMFS.node_ops.setattr,
                                lookup: MEMFS.node_ops.lookup,
                                mknod: MEMFS.node_ops.mknod,
                                rename: MEMFS.node_ops.rename,
                                unlink: MEMFS.node_ops.unlink,
                                rmdir: MEMFS.node_ops.rmdir,
                                readdir: MEMFS.node_ops.readdir,
                                symlink: MEMFS.node_ops.symlink
                            },
                            stream: {
                                llseek: MEMFS.stream_ops.llseek
                            }
                        },
                        file: {
                            node: {
                                getattr: MEMFS.node_ops.getattr,
                                setattr: MEMFS.node_ops.setattr
                            },
                            stream: {
                                llseek: MEMFS.stream_ops.llseek,
                                read: MEMFS.stream_ops.read,
                                write: MEMFS.stream_ops.write,
                                allocate: MEMFS.stream_ops.allocate,
                                mmap: MEMFS.stream_ops.mmap,
                                msync: MEMFS.stream_ops.msync
                            }
                        },
                        link: {
                            node: {
                                getattr: MEMFS.node_ops.getattr,
                                setattr: MEMFS.node_ops.setattr,
                                readlink: MEMFS.node_ops.readlink
                            },
                            stream: {}
                        },
                        chrdev: {
                            node: {
                                getattr: MEMFS.node_ops.getattr,
                                setattr: MEMFS.node_ops.setattr
                            },
                            stream: FS.chrdev_stream_ops
                        }
                    };
                }
                var node = FS.createNode(parent, name, mode, dev);
                if (FS.isDir(node.mode)) {
                    node.node_ops = MEMFS.ops_table.dir.node;
                    node.stream_ops = MEMFS.ops_table.dir.stream;
                    node.contents = {};
                } else if (FS.isFile(node.mode)) {
                    node.node_ops = MEMFS.ops_table.file.node;
                    node.stream_ops = MEMFS.ops_table.file.stream;
                    node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
                    // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
                    // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
                    // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
                    node.contents = null;
                } else if (FS.isLink(node.mode)) {
                    node.node_ops = MEMFS.ops_table.link.node;
                    node.stream_ops = MEMFS.ops_table.link.stream;
                } else if (FS.isChrdev(node.mode)) {
                    node.node_ops = MEMFS.ops_table.chrdev.node;
                    node.stream_ops = MEMFS.ops_table.chrdev.stream;
                }
                node.timestamp = Date.now();
                // add the new node to the parent
                if (parent) {
                    parent.contents[name] = node;
                    parent.timestamp = node.timestamp;
                }
                return node;
            },
            getFileDataAsTypedArray: function (node) {
                if (!node.contents) return new Uint8Array(0);
                if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
                return new Uint8Array(node.contents);
            },
            expandFileStorage: function (node, newCapacity) {
                var prevCapacity = node.contents ? node.contents.length : 0;
                if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
                // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
                // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
                // avoid overshooting the allocation cap by a very large margin.
                var CAPACITY_DOUBLING_MAX = 1024 * 1024;
                newCapacity = Math.max(
                    newCapacity,
                    (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0
                );
                if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
                var oldContents = node.contents;
                node.contents = new Uint8Array(newCapacity); // Allocate new storage.
                if (node.usedBytes > 0)
                    node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
            },
            resizeFileStorage: function (node, newSize) {
                if (node.usedBytes == newSize) return;
                if (newSize == 0) {
                    node.contents = null; // Fully decommit when requesting a resize to zero.
                    node.usedBytes = 0;
                } else {
                    var oldContents = node.contents;
                    node.contents = new Uint8Array(newSize); // Allocate new storage.
                    if (oldContents) {
                        node.contents.set(
                            oldContents.subarray(0, Math.min(newSize, node.usedBytes))
                        ); // Copy old data over to the new storage.
                    }
                    node.usedBytes = newSize;
                }
            },
            node_ops: {
                getattr: function (node) {
                    var attr = {};
                    // device numbers reuse inode numbers.
                    attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
                    attr.ino = node.id;
                    attr.mode = node.mode;
                    attr.nlink = 1;
                    attr.uid = 0;
                    attr.gid = 0;
                    attr.rdev = node.rdev;
                    if (FS.isDir(node.mode)) {
                        attr.size = 4096;
                    } else if (FS.isFile(node.mode)) {
                        attr.size = node.usedBytes;
                    } else if (FS.isLink(node.mode)) {
                        attr.size = node.link.length;
                    } else {
                        attr.size = 0;
                    }
                    attr.atime = new Date(node.timestamp);
                    attr.mtime = new Date(node.timestamp);
                    attr.ctime = new Date(node.timestamp);
                    // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
                    //       but this is not required by the standard.
                    attr.blksize = 4096;
                    attr.blocks = Math.ceil(attr.size / attr.blksize);
                    return attr;
                },
                setattr: function (node, attr) {
                    if (attr.mode !== undefined) {
                        node.mode = attr.mode;
                    }
                    if (attr.timestamp !== undefined) {
                        node.timestamp = attr.timestamp;
                    }
                    if (attr.size !== undefined) {
                        MEMFS.resizeFileStorage(node, attr.size);
                    }
                },
                lookup: function (parent, name) {
                    throw FS.genericErrors[44];
                },
                mknod: function (parent, name, mode, dev) {
                    return MEMFS.createNode(parent, name, mode, dev);
                },
                rename: function (old_node, new_dir, new_name) {
                    // if we're overwriting a directory at new_name, make sure it's empty.
                    if (FS.isDir(old_node.mode)) {
                        var new_node;
                        try {
                            new_node = FS.lookupNode(new_dir, new_name);
                        } catch (e) {}
                        if (new_node) {
                            for (var i in new_node.contents) {
                                throw new FS.ErrnoError(55);
                            }
                        }
                    }
                    // do the internal rewiring
                    delete old_node.parent.contents[old_node.name];
                    old_node.parent.timestamp = Date.now();
                    old_node.name = new_name;
                    new_dir.contents[new_name] = old_node;
                    new_dir.timestamp = old_node.parent.timestamp;
                    old_node.parent = new_dir;
                },
                unlink: function (parent, name) {
                    delete parent.contents[name];
                    parent.timestamp = Date.now();
                },
                rmdir: function (parent, name) {
                    var node = FS.lookupNode(parent, name);
                    for (var i in node.contents) {
                        throw new FS.ErrnoError(55);
                    }
                    delete parent.contents[name];
                    parent.timestamp = Date.now();
                },
                readdir: function (node) {
                    var entries = [".", ".."];
                    for (var key in node.contents) {
                        if (!node.contents.hasOwnProperty(key)) {
                            continue;
                        }
                        entries.push(key);
                    }
                    return entries;
                },
                symlink: function (parent, newname, oldpath) {
                    var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
                    node.link = oldpath;
                    return node;
                },
                readlink: function (node) {
                    if (!FS.isLink(node.mode)) {
                        throw new FS.ErrnoError(28);
                    }
                    return node.link;
                }
            },
            stream_ops: {
                read: function (stream, buffer, offset, length, position) {
                    var contents = stream.node.contents;
                    if (position >= stream.node.usedBytes) return 0;
                    var size = Math.min(stream.node.usedBytes - position, length);
                    assert(size >= 0);
                    if (size > 8 && contents.subarray) {
                        // non-trivial, and typed array
                        buffer.set(contents.subarray(position, position + size), offset);
                    } else {
                        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
                    }
                    return size;
                },
                write: function (stream, buffer, offset, length, position, canOwn) {
                    // The data buffer should be a typed array view
                    assert(!(buffer instanceof ArrayBuffer));
                    // If the buffer is located in main memory (HEAP), and if
                    // memory can grow, we can't hold on to references of the
                    // memory buffer, as they may get invalidated. That means we
                    // need to do copy its contents.
                    if (buffer.buffer === HEAP8.buffer) {
                        canOwn = false;
                    }

                    if (!length) return 0;
                    var node = stream.node;
                    node.timestamp = Date.now();

                    if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                        // This write is from a typed array to a typed array?
                        if (canOwn) {
                            assert(
                                position === 0,
                                "canOwn must imply no weird position inside the file"
                            );
                            node.contents = buffer.subarray(offset, offset + length);
                            node.usedBytes = length;
                            return length;
                        } else if (node.usedBytes === 0 && position === 0) {
                            // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
                            node.contents = buffer.slice(offset, offset + length);
                            node.usedBytes = length;
                            return length;
                        } else if (position + length <= node.usedBytes) {
                            // Writing to an already allocated and used subrange of the file?
                            node.contents.set(buffer.subarray(offset, offset + length), position);
                            return length;
                        }
                    }

                    // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
                    MEMFS.expandFileStorage(node, position + length);
                    if (node.contents.subarray && buffer.subarray) {
                        // Use typed array write which is available.
                        node.contents.set(buffer.subarray(offset, offset + length), position);
                    } else {
                        for (var i = 0; i < length; i++) {
                            node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
                        }
                    }
                    node.usedBytes = Math.max(node.usedBytes, position + length);
                    return length;
                },
                llseek: function (stream, offset, whence) {
                    var position = offset;
                    if (whence === 1) {
                        position += stream.position;
                    } else if (whence === 2) {
                        if (FS.isFile(stream.node.mode)) {
                            position += stream.node.usedBytes;
                        }
                    }
                    if (position < 0) {
                        throw new FS.ErrnoError(28);
                    }
                    return position;
                },
                allocate: function (stream, offset, length) {
                    MEMFS.expandFileStorage(stream.node, offset + length);
                    stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
                },
                mmap: function (stream, length, position, prot, flags) {
                    if (!FS.isFile(stream.node.mode)) {
                        throw new FS.ErrnoError(43);
                    }
                    var ptr;
                    var allocated;
                    var contents = stream.node.contents;
                    // Only make a new copy when MAP_PRIVATE is specified.
                    if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
                        // We can't emulate MAP_SHARED when the file is not backed by the
                        // buffer we're mapping to (e.g. the HEAP buffer).
                        allocated = false;
                        ptr = contents.byteOffset;
                    } else {
                        // Try to avoid unnecessary slices.
                        if (position > 0 || position + length < contents.length) {
                            if (contents.subarray) {
                                contents = contents.subarray(position, position + length);
                            } else {
                                contents = Array.prototype.slice.call(
                                    contents,
                                    position,
                                    position + length
                                );
                            }
                        }
                        allocated = true;
                        ptr = mmapAlloc(length);
                        if (!ptr) {
                            throw new FS.ErrnoError(48);
                        }
                        HEAP8.set(contents, ptr);
                    }
                    return { ptr: ptr, allocated: allocated };
                },
                msync: function (stream, buffer, offset, length, mmapFlags) {
                    MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
                    // should we check if bytesWritten and length are the same?
                    return 0;
                }
            }
        };

        /** @param {boolean=} noRunDep */
        function asyncLoad(url, onload, onerror, noRunDep) {
            var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
            readAsync(
                url,
                (arrayBuffer) => {
                    assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
                    onload(new Uint8Array(arrayBuffer));
                    if (dep) removeRunDependency(dep);
                },
                (event) => {
                    if (onerror) {
                        onerror();
                    } else {
                        throw 'Loading data file "' + url + '" failed.';
                    }
                }
            );
            if (dep) addRunDependency(dep);
        }

        var IDBFS = {
            dbs: {},
            indexedDB: () => {
                if (typeof indexedDB != "undefined") return indexedDB;
                var ret = null;
                if (typeof window == "object")
                    ret =
                        window.indexedDB ||
                        window.mozIndexedDB ||
                        window.webkitIndexedDB ||
                        window.msIndexedDB;
                assert(ret, "IDBFS used, but indexedDB not supported");
                return ret;
            },
            DB_VERSION: 21,
            DB_STORE_NAME: "FILE_DATA",
            mount: function (mount) {
                // reuse all of the core MEMFS functionality
                return MEMFS.mount.apply(null, arguments);
            },
            syncfs: (mount, populate, callback) => {
                IDBFS.getLocalSet(mount, (err, local) => {
                    if (err) return callback(err);

                    IDBFS.getRemoteSet(mount, (err, remote) => {
                        if (err) return callback(err);

                        var src = populate ? remote : local;
                        var dst = populate ? local : remote;

                        IDBFS.reconcile(src, dst, callback);
                    });
                });
            },
            quit: () => {
                Object.values(IDBFS.dbs).forEach((value) => value.close());
                IDBFS.dbs = {};
            },
            getDB: (name, callback) => {
                // check the cache first
                var db = IDBFS.dbs[name];
                if (db) {
                    return callback(null, db);
                }

                var req;
                try {
                    req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
                } catch (e) {
                    return callback(e);
                }
                if (!req) {
                    return callback("Unable to connect to IndexedDB");
                }
                req.onupgradeneeded = (e) => {
                    var db = /** @type {IDBDatabase} */ (e.target.result);
                    var transaction = e.target.transaction;

                    var fileStore;

                    if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
                        fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
                    } else {
                        fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
                    }

                    if (!fileStore.indexNames.contains("timestamp")) {
                        fileStore.createIndex("timestamp", "timestamp", { unique: false });
                    }
                };
                req.onsuccess = () => {
                    db = /** @type {IDBDatabase} */ (req.result);

                    // add to the cache
                    IDBFS.dbs[name] = db;
                    callback(null, db);
                };
                req.onerror = (e) => {
                    callback(this.error);
                    e.preventDefault();
                };
            },
            getLocalSet: (mount, callback) => {
                var entries = {};

                function isRealDir(p) {
                    return p !== "." && p !== "..";
                }
                function toAbsolute(root) {
                    return (p) => {
                        return PATH.join2(root, p);
                    };
                }

                var check = FS.readdir(mount.mountpoint)
                    .filter(isRealDir)
                    .map(toAbsolute(mount.mountpoint));

                while (check.length) {
                    var path = check.pop();
                    var stat;

                    try {
                        stat = FS.stat(path);
                    } catch (e) {
                        return callback(e);
                    }

                    if (FS.isDir(stat.mode)) {
                        check.push.apply(
                            check,
                            FS.readdir(path).filter(isRealDir).map(toAbsolute(path))
                        );
                    }

                    entries[path] = { timestamp: stat.mtime };
                }

                return callback(null, { type: "local", entries: entries });
            },
            getRemoteSet: (mount, callback) => {
                var entries = {};

                IDBFS.getDB(mount.mountpoint, (err, db) => {
                    if (err) return callback(err);

                    try {
                        var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readonly");
                        transaction.onerror = (e) => {
                            callback(this.error);
                            e.preventDefault();
                        };

                        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
                        var index = store.index("timestamp");

                        index.openKeyCursor().onsuccess = (event) => {
                            var cursor = event.target.result;

                            if (!cursor) {
                                return callback(null, { type: "remote", db: db, entries: entries });
                            }

                            entries[cursor.primaryKey] = { timestamp: cursor.key };

                            cursor.continue();
                        };
                    } catch (e) {
                        return callback(e);
                    }
                });
            },
            loadLocalEntry: (path, callback) => {
                var stat, node;

                try {
                    var lookup = FS.lookupPath(path);
                    node = lookup.node;
                    stat = FS.stat(path);
                } catch (e) {
                    return callback(e);
                }

                if (FS.isDir(stat.mode)) {
                    return callback(null, { timestamp: stat.mtime, mode: stat.mode });
                } else if (FS.isFile(stat.mode)) {
                    // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
                    // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
                    node.contents = MEMFS.getFileDataAsTypedArray(node);
                    return callback(null, {
                        timestamp: stat.mtime,
                        mode: stat.mode,
                        contents: node.contents
                    });
                } else {
                    return callback(new Error("node type not supported"));
                }
            },
            storeLocalEntry: (path, entry, callback) => {
                try {
                    if (FS.isDir(entry["mode"])) {
                        FS.mkdirTree(path, entry["mode"]);
                    } else if (FS.isFile(entry["mode"])) {
                        FS.writeFile(path, entry["contents"], { canOwn: true });
                    } else {
                        return callback(new Error("node type not supported"));
                    }

                    FS.chmod(path, entry["mode"]);
                    FS.utime(path, entry["timestamp"], entry["timestamp"]);
                } catch (e) {
                    return callback(e);
                }

                callback(null);
            },
            removeLocalEntry: (path, callback) => {
                try {
                    var stat = FS.stat(path);

                    if (FS.isDir(stat.mode)) {
                        FS.rmdir(path);
                    } else if (FS.isFile(stat.mode)) {
                        FS.unlink(path);
                    }
                } catch (e) {
                    return callback(e);
                }

                callback(null);
            },
            loadRemoteEntry: (store, path, callback) => {
                var req = store.get(path);
                req.onsuccess = (event) => {
                    callback(null, event.target.result);
                };
                req.onerror = (e) => {
                    callback(this.error);
                    e.preventDefault();
                };
            },
            storeRemoteEntry: (store, path, entry, callback) => {
                try {
                    var req = store.put(entry, path);
                } catch (e) {
                    callback(e);
                    return;
                }
                req.onsuccess = () => {
                    callback(null);
                };
                req.onerror = (e) => {
                    callback(this.error);
                    e.preventDefault();
                };
            },
            removeRemoteEntry: (store, path, callback) => {
                var req = store.delete(path);
                req.onsuccess = () => {
                    callback(null);
                };
                req.onerror = (e) => {
                    callback(this.error);
                    e.preventDefault();
                };
            },
            reconcile: (src, dst, callback) => {
                var total = 0;

                var create = [];
                Object.keys(src.entries).forEach(function (key) {
                    var e = src.entries[key];
                    var e2 = dst.entries[key];
                    if (!e2 || e["timestamp"].getTime() != e2["timestamp"].getTime()) {
                        create.push(key);
                        total++;
                    }
                });

                var remove = [];
                Object.keys(dst.entries).forEach(function (key) {
                    if (!src.entries[key]) {
                        remove.push(key);
                        total++;
                    }
                });

                if (!total) {
                    return callback(null);
                }

                var errored = false;
                var db = src.type === "remote" ? src.db : dst.db;
                var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readwrite");
                var store = transaction.objectStore(IDBFS.DB_STORE_NAME);

                function done(err) {
                    if (err && !errored) {
                        errored = true;
                        return callback(err);
                    }
                }

                transaction.onerror = (e) => {
                    done(this.error);
                    e.preventDefault();
                };

                transaction.oncomplete = (e) => {
                    if (!errored) {
                        callback(null);
                    }
                };

                // sort paths in ascending order so directory entries are created
                // before the files inside them
                create.sort().forEach((path) => {
                    if (dst.type === "local") {
                        IDBFS.loadRemoteEntry(store, path, (err, entry) => {
                            if (err) return done(err);
                            IDBFS.storeLocalEntry(path, entry, done);
                        });
                    } else {
                        IDBFS.loadLocalEntry(path, (err, entry) => {
                            if (err) return done(err);
                            IDBFS.storeRemoteEntry(store, path, entry, done);
                        });
                    }
                });

                // sort paths in descending order so files are deleted before their
                // parent directories
                remove
                    .sort()
                    .reverse()
                    .forEach((path) => {
                        if (dst.type === "local") {
                            IDBFS.removeLocalEntry(path, done);
                        } else {
                            IDBFS.removeRemoteEntry(store, path, done);
                        }
                    });
            }
        };

        var ERRNO_MESSAGES = {
            0: "Success",
            1: "Arg list too long",
            2: "Permission denied",
            3: "Address already in use",
            4: "Address not available",
            5: "Address family not supported by protocol family",
            6: "No more processes",
            7: "Socket already connected",
            8: "Bad file number",
            9: "Trying to read unreadable message",
            10: "Mount device busy",
            11: "Operation canceled",
            12: "No children",
            13: "Connection aborted",
            14: "Connection refused",
            15: "Connection reset by peer",
            16: "File locking deadlock error",
            17: "Destination address required",
            18: "Math arg out of domain of func",
            19: "Quota exceeded",
            20: "File exists",
            21: "Bad address",
            22: "File too large",
            23: "Host is unreachable",
            24: "Identifier removed",
            25: "Illegal byte sequence",
            26: "Connection already in progress",
            27: "Interrupted system call",
            28: "Invalid argument",
            29: "I/O error",
            30: "Socket is already connected",
            31: "Is a directory",
            32: "Too many symbolic links",
            33: "Too many open files",
            34: "Too many links",
            35: "Message too long",
            36: "Multihop attempted",
            37: "File or path name too long",
            38: "Network interface is not configured",
            39: "Connection reset by network",
            40: "Network is unreachable",
            41: "Too many open files in system",
            42: "No buffer space available",
            43: "No such device",
            44: "No such file or directory",
            45: "Exec format error",
            46: "No record locks available",
            47: "The link has been severed",
            48: "Not enough core",
            49: "No message of desired type",
            50: "Protocol not available",
            51: "No space left on device",
            52: "Function not implemented",
            53: "Socket is not connected",
            54: "Not a directory",
            55: "Directory not empty",
            56: "State not recoverable",
            57: "Socket operation on non-socket",
            59: "Not a typewriter",
            60: "No such device or address",
            61: "Value too large for defined data type",
            62: "Previous owner died",
            63: "Not super-user",
            64: "Broken pipe",
            65: "Protocol error",
            66: "Unknown protocol",
            67: "Protocol wrong type for socket",
            68: "Math result not representable",
            69: "Read only file system",
            70: "Illegal seek",
            71: "No such process",
            72: "Stale file handle",
            73: "Connection timed out",
            74: "Text file busy",
            75: "Cross-device link",
            100: "Device not a stream",
            101: "Bad font file fmt",
            102: "Invalid slot",
            103: "Invalid request code",
            104: "No anode",
            105: "Block device required",
            106: "Channel number out of range",
            107: "Level 3 halted",
            108: "Level 3 reset",
            109: "Link number out of range",
            110: "Protocol driver not attached",
            111: "No CSI structure available",
            112: "Level 2 halted",
            113: "Invalid exchange",
            114: "Invalid request descriptor",
            115: "Exchange full",
            116: "No data (for no delay io)",
            117: "Timer expired",
            118: "Out of streams resources",
            119: "Machine is not on the network",
            120: "Package not installed",
            121: "The object is remote",
            122: "Advertise error",
            123: "Srmount error",
            124: "Communication error on send",
            125: "Cross mount point (not really error)",
            126: "Given log. name not unique",
            127: "f.d. invalid for this operation",
            128: "Remote address changed",
            129: "Can   access a needed shared lib",
            130: "Accessing a corrupted shared lib",
            131: ".lib section in a.out corrupted",
            132: "Attempting to link in too many libs",
            133: "Attempting to exec a shared library",
            135: "Streams pipe error",
            136: "Too many users",
            137: "Socket type not supported",
            138: "Not supported",
            139: "Protocol family not supported",
            140: "Can't send after socket shutdown",
            141: "Too many references",
            142: "Host is down",
            148: "No medium (in tape drive)",
            156: "Level 2 not synchronized"
        };

        var ERRNO_CODES = {};

        function demangle(func) {
            warnOnce("warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling");
            return func;
        }
        function demangleAll(text) {
            var regex = /\b_Z[\w\d_]+/g;
            return text.replace(regex, function (x) {
                var y = demangle(x);
                return x === y ? x : y + " [" + x + "]";
            });
        }
        var FS = {
            root: null,
            mounts: [],
            devices: {},
            streams: [],
            nextInode: 1,
            nameTable: null,
            currentPath: "/",
            initialized: false,
            ignorePermissions: true,
            ErrnoError: null,
            genericErrors: {},
            filesystems: null,
            syncFSRequests: 0,
            lookupPath: (path, opts = {}) => {
                path = PATH_FS.resolve(path);

                if (!path) return { path: "", node: null };

                var defaults = {
                    follow_mount: true,
                    recurse_count: 0
                };
                opts = Object.assign(defaults, opts);

                if (opts.recurse_count > 8) {
                    // max recursive lookup of 8
                    throw new FS.ErrnoError(32);
                }

                // split the absolute path
                var parts = path.split("/").filter((p) => !!p);

                // start at the root
                var current = FS.root;
                var current_path = "/";

                for (var i = 0; i < parts.length; i++) {
                    var islast = i === parts.length - 1;
                    if (islast && opts.parent) {
                        // stop resolving
                        break;
                    }

                    current = FS.lookupNode(current, parts[i]);
                    current_path = PATH.join2(current_path, parts[i]);

                    // jump to the mount's root node if this is a mountpoint
                    if (FS.isMountpoint(current)) {
                        if (!islast || (islast && opts.follow_mount)) {
                            current = current.mounted.root;
                        }
                    }

                    // by default, lookupPath will not follow a symlink if it is the final path component.
                    // setting opts.follow = true will override this behavior.
                    if (!islast || opts.follow) {
                        var count = 0;
                        while (FS.isLink(current.mode)) {
                            var link = FS.readlink(current_path);
                            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);

                            var lookup = FS.lookupPath(current_path, {
                                recurse_count: opts.recurse_count + 1
                            });
                            current = lookup.node;

                            if (count++ > 40) {
                                // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                                throw new FS.ErrnoError(32);
                            }
                        }
                    }
                }

                return { path: current_path, node: current };
            },
            getPath: (node) => {
                var path;
                while (true) {
                    if (FS.isRoot(node)) {
                        var mount = node.mount.mountpoint;
                        if (!path) return mount;
                        return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
                    }
                    path = path ? node.name + "/" + path : node.name;
                    node = node.parent;
                }
            },
            hashName: (parentid, name) => {
                var hash = 0;

                for (var i = 0; i < name.length; i++) {
                    hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
                }
                return ((parentid + hash) >>> 0) % FS.nameTable.length;
            },
            hashAddNode: (node) => {
                var hash = FS.hashName(node.parent.id, node.name);
                node.name_next = FS.nameTable[hash];
                FS.nameTable[hash] = node;
            },
            hashRemoveNode: (node) => {
                var hash = FS.hashName(node.parent.id, node.name);
                if (FS.nameTable[hash] === node) {
                    FS.nameTable[hash] = node.name_next;
                } else {
                    var current = FS.nameTable[hash];
                    while (current) {
                        if (current.name_next === node) {
                            current.name_next = node.name_next;
                            break;
                        }
                        current = current.name_next;
                    }
                }
            },
            lookupNode: (parent, name) => {
                var errCode = FS.mayLookup(parent);
                if (errCode) {
                    throw new FS.ErrnoError(errCode, parent);
                }
                var hash = FS.hashName(parent.id, name);
                for (var node = FS.nameTable[hash]; node; node = node.name_next) {
                    var nodeName = node.name;
                    if (node.parent.id === parent.id && nodeName === name) {
                        return node;
                    }
                }
                // if we failed to find it in the cache, call into the VFS
                return FS.lookup(parent, name);
            },
            createNode: (parent, name, mode, rdev) => {
                assert(typeof parent == "object");
                var node = new FS.FSNode(parent, name, mode, rdev);

                FS.hashAddNode(node);

                return node;
            },
            destroyNode: (node) => {
                FS.hashRemoveNode(node);
            },
            isRoot: (node) => {
                return node === node.parent;
            },
            isMountpoint: (node) => {
                return !!node.mounted;
            },
            isFile: (mode) => {
                return (mode & 61440) === 32768;
            },
            isDir: (mode) => {
                return (mode & 61440) === 16384;
            },
            isLink: (mode) => {
                return (mode & 61440) === 40960;
            },
            isChrdev: (mode) => {
                return (mode & 61440) === 8192;
            },
            isBlkdev: (mode) => {
                return (mode & 61440) === 24576;
            },
            isFIFO: (mode) => {
                return (mode & 61440) === 4096;
            },
            isSocket: (mode) => {
                return (mode & 49152) === 49152;
            },
            flagModes: { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 },
            modeStringToFlags: (str) => {
                var flags = FS.flagModes[str];
                if (typeof flags == "undefined") {
                    throw new Error("Unknown file open mode: " + str);
                }
                return flags;
            },
            flagsToPermissionString: (flag) => {
                var perms = ["r", "w", "rw"][flag & 3];
                if (flag & 512) {
                    perms += "w";
                }
                return perms;
            },
            nodePermissions: (node, perms) => {
                if (FS.ignorePermissions) {
                    return 0;
                }
                // return 0 if any user, group or owner bits are set.
                if (perms.includes("r") && !(node.mode & 292)) {
                    return 2;
                } else if (perms.includes("w") && !(node.mode & 146)) {
                    return 2;
                } else if (perms.includes("x") && !(node.mode & 73)) {
                    return 2;
                }
                return 0;
            },
            mayLookup: (dir) => {
                var errCode = FS.nodePermissions(dir, "x");
                if (errCode) return errCode;
                if (!dir.node_ops.lookup) return 2;
                return 0;
            },
            mayCreate: (dir, name) => {
                try {
                    var node = FS.lookupNode(dir, name);
                    return 20;
                } catch (e) {}
                return FS.nodePermissions(dir, "wx");
            },
            mayDelete: (dir, name, isdir) => {
                var node;
                try {
                    node = FS.lookupNode(dir, name);
                } catch (e) {
                    return e.errno;
                }
                var errCode = FS.nodePermissions(dir, "wx");
                if (errCode) {
                    return errCode;
                }
                if (isdir) {
                    if (!FS.isDir(node.mode)) {
                        return 54;
                    }
                    if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                        return 10;
                    }
                } else {
                    if (FS.isDir(node.mode)) {
                        return 31;
                    }
                }
                return 0;
            },
            mayOpen: (node, flags) => {
                if (!node) {
                    return 44;
                }
                if (FS.isLink(node.mode)) {
                    return 32;
                } else if (FS.isDir(node.mode)) {
                    if (
                        FS.flagsToPermissionString(flags) !== "r" || // opening for write
                        flags & 512
                    ) {
                        // TODO: check for O_SEARCH? (== search for dir only)
                        return 31;
                    }
                }
                return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
            },
            MAX_OPEN_FDS: 4096,
            nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
                for (var fd = fd_start; fd <= fd_end; fd++) {
                    if (!FS.streams[fd]) {
                        return fd;
                    }
                }
                throw new FS.ErrnoError(33);
            },
            getStream: (fd) => FS.streams[fd],
            createStream: (stream, fd_start, fd_end) => {
                if (!FS.FSStream) {
                    FS.FSStream = /** @constructor */ function () {
                        this.shared = {};
                    };
                    FS.FSStream.prototype = {};
                    Object.defineProperties(FS.FSStream.prototype, {
                        object: {
                            /** @this {FS.FSStream} */
                            get: function () {
                                return this.node;
                            },
                            /** @this {FS.FSStream} */
                            set: function (val) {
                                this.node = val;
                            }
                        },
                        isRead: {
                            /** @this {FS.FSStream} */
                            get: function () {
                                return (this.flags & 2097155) !== 1;
                            }
                        },
                        isWrite: {
                            /** @this {FS.FSStream} */
                            get: function () {
                                return (this.flags & 2097155) !== 0;
                            }
                        },
                        isAppend: {
                            /** @this {FS.FSStream} */
                            get: function () {
                                return this.flags & 1024;
                            }
                        },
                        flags: {
                            /** @this {FS.FSStream} */
                            get: function () {
                                return this.shared.flags;
                            },
                            /** @this {FS.FSStream} */
                            set: function (val) {
                                this.shared.flags = val;
                            }
                        },
                        position: {
                            /** @this {FS.FSStream} */
                            get: function () {
                                return this.shared.position;
                            },
                            /** @this {FS.FSStream} */
                            set: function (val) {
                                this.shared.position = val;
                            }
                        }
                    });
                }
                // clone it, so we can return an instance of FSStream
                stream = Object.assign(new FS.FSStream(), stream);
                var fd = FS.nextfd(fd_start, fd_end);
                stream.fd = fd;
                FS.streams[fd] = stream;
                return stream;
            },
            closeStream: (fd) => {
                FS.streams[fd] = null;
            },
            chrdev_stream_ops: {
                open: (stream) => {
                    var device = FS.getDevice(stream.node.rdev);
                    // override node's stream ops with the device's
                    stream.stream_ops = device.stream_ops;
                    // forward the open call
                    if (stream.stream_ops.open) {
                        stream.stream_ops.open(stream);
                    }
                },
                llseek: () => {
                    throw new FS.ErrnoError(70);
                }
            },
            major: (dev) => dev >> 8,
            minor: (dev) => dev & 0xff,
            makedev: (ma, mi) => (ma << 8) | mi,
            registerDevice: (dev, ops) => {
                FS.devices[dev] = { stream_ops: ops };
            },
            getDevice: (dev) => FS.devices[dev],
            getMounts: (mount) => {
                var mounts = [];
                var check = [mount];

                while (check.length) {
                    var m = check.pop();

                    mounts.push(m);

                    check.push.apply(check, m.mounts);
                }

                return mounts;
            },
            syncfs: (populate, callback) => {
                if (typeof populate == "function") {
                    callback = populate;
                    populate = false;
                }

                FS.syncFSRequests++;

                if (FS.syncFSRequests > 1) {
                    err(
                        "warning: " +
                            FS.syncFSRequests +
                            " FS.syncfs operations in flight at once, probably just doing extra work"
                    );
                }

                var mounts = FS.getMounts(FS.root.mount);
                var completed = 0;

                function doCallback(errCode) {
                    assert(FS.syncFSRequests > 0);
                    FS.syncFSRequests--;
                    return callback(errCode);
                }

                function done(errCode) {
                    if (errCode) {
                        if (!done.errored) {
                            done.errored = true;
                            return doCallback(errCode);
                        }
                        return;
                    }
                    if (++completed >= mounts.length) {
                        doCallback(null);
                    }
                }

                // sync all mounts
                mounts.forEach((mount) => {
                    if (!mount.type.syncfs) {
                        return done(null);
                    }
                    mount.type.syncfs(mount, populate, done);
                });
            },
            mount: (type, opts, mountpoint) => {
                if (typeof type == "string") {
                    // The filesystem was not included, and instead we have an error
                    // message stored in the variable.
                    throw type;
                }
                var root = mountpoint === "/";
                var pseudo = !mountpoint;
                var node;

                if (root && FS.root) {
                    throw new FS.ErrnoError(10);
                } else if (!root && !pseudo) {
                    var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

                    mountpoint = lookup.path; // use the absolute path
                    node = lookup.node;

                    if (FS.isMountpoint(node)) {
                        throw new FS.ErrnoError(10);
                    }

                    if (!FS.isDir(node.mode)) {
                        throw new FS.ErrnoError(54);
                    }
                }

                var mount = {
                    type: type,
                    opts: opts,
                    mountpoint: mountpoint,
                    mounts: []
                };

                // create a root node for the fs
                var mountRoot = type.mount(mount);
                mountRoot.mount = mount;
                mount.root = mountRoot;

                if (root) {
                    FS.root = mountRoot;
                } else if (node) {
                    // set as a mountpoint
                    node.mounted = mount;

                    // add the new mount to the current mount's children
                    if (node.mount) {
                        node.mount.mounts.push(mount);
                    }
                }

                return mountRoot;
            },
            unmount: (mountpoint) => {
                var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

                if (!FS.isMountpoint(lookup.node)) {
                    throw new FS.ErrnoError(28);
                }

                // destroy the nodes for this mount, and all its child mounts
                var node = lookup.node;
                var mount = node.mounted;
                var mounts = FS.getMounts(mount);

                Object.keys(FS.nameTable).forEach((hash) => {
                    var current = FS.nameTable[hash];

                    while (current) {
                        var next = current.name_next;

                        if (mounts.includes(current.mount)) {
                            FS.destroyNode(current);
                        }

                        current = next;
                    }
                });

                // no longer a mountpoint
                node.mounted = null;

                // remove this mount from the child mounts
                var idx = node.mount.mounts.indexOf(mount);
                assert(idx !== -1);
                node.mount.mounts.splice(idx, 1);
            },
            lookup: (parent, name) => {
                return parent.node_ops.lookup(parent, name);
            },
            mknod: (path, mode, dev) => {
                var lookup = FS.lookupPath(path, { parent: true });
                var parent = lookup.node;
                var name = PATH.basename(path);
                if (!name || name === "." || name === "..") {
                    throw new FS.ErrnoError(28);
                }
                var errCode = FS.mayCreate(parent, name);
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
                if (!parent.node_ops.mknod) {
                    throw new FS.ErrnoError(63);
                }
                return parent.node_ops.mknod(parent, name, mode, dev);
            },
            create: (path, mode) => {
                mode = mode !== undefined ? mode : 438 /* 0666 */;
                mode &= 4095;
                mode |= 32768;
                return FS.mknod(path, mode, 0);
            },
            mkdir: (path, mode) => {
                mode = mode !== undefined ? mode : 511 /* 0777 */;
                mode &= 511 | 512;
                mode |= 16384;
                return FS.mknod(path, mode, 0);
            },
            mkdirTree: (path, mode) => {
                var dirs = path.split("/");
                var d = "";
                for (var i = 0; i < dirs.length; ++i) {
                    if (!dirs[i]) continue;
                    d += "/" + dirs[i];
                    try {
                        FS.mkdir(d, mode);
                    } catch (e) {
                        if (e.errno != 20) throw e;
                    }
                }
            },
            mkdev: (path, mode, dev) => {
                if (typeof dev == "undefined") {
                    dev = mode;
                    mode = 438 /* 0666 */;
                }
                mode |= 8192;
                return FS.mknod(path, mode, dev);
            },
            symlink: (oldpath, newpath) => {
                if (!PATH_FS.resolve(oldpath)) {
                    throw new FS.ErrnoError(44);
                }
                var lookup = FS.lookupPath(newpath, { parent: true });
                var parent = lookup.node;
                if (!parent) {
                    throw new FS.ErrnoError(44);
                }
                var newname = PATH.basename(newpath);
                var errCode = FS.mayCreate(parent, newname);
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
                if (!parent.node_ops.symlink) {
                    throw new FS.ErrnoError(63);
                }
                return parent.node_ops.symlink(parent, newname, oldpath);
            },
            rename: (old_path, new_path) => {
                var old_dirname = PATH.dirname(old_path);
                var new_dirname = PATH.dirname(new_path);
                var old_name = PATH.basename(old_path);
                var new_name = PATH.basename(new_path);
                // parents must exist
                var lookup, old_dir, new_dir;

                // let the errors from non existant directories percolate up
                lookup = FS.lookupPath(old_path, { parent: true });
                old_dir = lookup.node;
                lookup = FS.lookupPath(new_path, { parent: true });
                new_dir = lookup.node;

                if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
                // need to be part of the same mount
                if (old_dir.mount !== new_dir.mount) {
                    throw new FS.ErrnoError(75);
                }
                // source must exist
                var old_node = FS.lookupNode(old_dir, old_name);
                // old path should not be an ancestor of the new path
                var relative = PATH_FS.relative(old_path, new_dirname);
                if (relative.charAt(0) !== ".") {
                    throw new FS.ErrnoError(28);
                }
                // new path should not be an ancestor of the old path
                relative = PATH_FS.relative(new_path, old_dirname);
                if (relative.charAt(0) !== ".") {
                    throw new FS.ErrnoError(55);
                }
                // see if the new path already exists
                var new_node;
                try {
                    new_node = FS.lookupNode(new_dir, new_name);
                } catch (e) {
                    // not fatal
                }
                // early out if nothing needs to change
                if (old_node === new_node) {
                    return;
                }
                // we'll need to delete the old entry
                var isdir = FS.isDir(old_node.mode);
                var errCode = FS.mayDelete(old_dir, old_name, isdir);
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
                // need delete permissions if we'll be overwriting.
                // need create permissions if new doesn't already exist.
                errCode = new_node
                    ? FS.mayDelete(new_dir, new_name, isdir)
                    : FS.mayCreate(new_dir, new_name);
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
                if (!old_dir.node_ops.rename) {
                    throw new FS.ErrnoError(63);
                }
                if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
                    throw new FS.ErrnoError(10);
                }
                // if we are going to change the parent, check write permissions
                if (new_dir !== old_dir) {
                    errCode = FS.nodePermissions(old_dir, "w");
                    if (errCode) {
                        throw new FS.ErrnoError(errCode);
                    }
                }
                // remove the node from the lookup hash
                FS.hashRemoveNode(old_node);
                // do the underlying fs rename
                try {
                    old_dir.node_ops.rename(old_node, new_dir, new_name);
                } catch (e) {
                    throw e;
                } finally {
                    // add the node back to the hash (in case node_ops.rename
                    // changed its name)
                    FS.hashAddNode(old_node);
                }
            },
            rmdir: (path) => {
                var lookup = FS.lookupPath(path, { parent: true });
                var parent = lookup.node;
                var name = PATH.basename(path);
                var node = FS.lookupNode(parent, name);
                var errCode = FS.mayDelete(parent, name, true);
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
                if (!parent.node_ops.rmdir) {
                    throw new FS.ErrnoError(63);
                }
                if (FS.isMountpoint(node)) {
                    throw new FS.ErrnoError(10);
                }
                parent.node_ops.rmdir(parent, name);
                FS.destroyNode(node);
            },
            readdir: (path) => {
                var lookup = FS.lookupPath(path, { follow: true });
                var node = lookup.node;
                if (!node.node_ops.readdir) {
                    throw new FS.ErrnoError(54);
                }
                return node.node_ops.readdir(node);
            },
            unlink: (path) => {
                var lookup = FS.lookupPath(path, { parent: true });
                var parent = lookup.node;
                if (!parent) {
                    throw new FS.ErrnoError(44);
                }
                var name = PATH.basename(path);
                var node = FS.lookupNode(parent, name);
                var errCode = FS.mayDelete(parent, name, false);
                if (errCode) {
                    // According to POSIX, we should map EISDIR to EPERM, but
                    // we instead do what Linux does (and we must, as we use
                    // the musl linux libc).
                    throw new FS.ErrnoError(errCode);
                }
                if (!parent.node_ops.unlink) {
                    throw new FS.ErrnoError(63);
                }
                if (FS.isMountpoint(node)) {
                    throw new FS.ErrnoError(10);
                }
                parent.node_ops.unlink(parent, name);
                FS.destroyNode(node);
            },
            readlink: (path) => {
                var lookup = FS.lookupPath(path);
                var link = lookup.node;
                if (!link) {
                    throw new FS.ErrnoError(44);
                }
                if (!link.node_ops.readlink) {
                    throw new FS.ErrnoError(28);
                }
                return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
            },
            stat: (path, dontFollow) => {
                var lookup = FS.lookupPath(path, { follow: !dontFollow });
                var node = lookup.node;
                if (!node) {
                    throw new FS.ErrnoError(44);
                }
                if (!node.node_ops.getattr) {
                    throw new FS.ErrnoError(63);
                }
                return node.node_ops.getattr(node);
            },
            lstat: (path) => {
                return FS.stat(path, true);
            },
            chmod: (path, mode, dontFollow) => {
                var node;
                if (typeof path == "string") {
                    var lookup = FS.lookupPath(path, { follow: !dontFollow });
                    node = lookup.node;
                } else {
                    node = path;
                }
                if (!node.node_ops.setattr) {
                    throw new FS.ErrnoError(63);
                }
                node.node_ops.setattr(node, {
                    mode: (mode & 4095) | (node.mode & ~4095),
                    timestamp: Date.now()
                });
            },
            lchmod: (path, mode) => {
                FS.chmod(path, mode, true);
            },
            fchmod: (fd, mode) => {
                var stream = FS.getStream(fd);
                if (!stream) {
                    throw new FS.ErrnoError(8);
                }
                FS.chmod(stream.node, mode);
            },
            chown: (path, uid, gid, dontFollow) => {
                var node;
                if (typeof path == "string") {
                    var lookup = FS.lookupPath(path, { follow: !dontFollow });
                    node = lookup.node;
                } else {
                    node = path;
                }
                if (!node.node_ops.setattr) {
                    throw new FS.ErrnoError(63);
                }
                node.node_ops.setattr(node, {
                    timestamp: Date.now()
                    // we ignore the uid / gid for now
                });
            },
            lchown: (path, uid, gid) => {
                FS.chown(path, uid, gid, true);
            },
            fchown: (fd, uid, gid) => {
                var stream = FS.getStream(fd);
                if (!stream) {
                    throw new FS.ErrnoError(8);
                }
                FS.chown(stream.node, uid, gid);
            },
            truncate: (path, len) => {
                if (len < 0) {
                    throw new FS.ErrnoError(28);
                }
                var node;
                if (typeof path == "string") {
                    var lookup = FS.lookupPath(path, { follow: true });
                    node = lookup.node;
                } else {
                    node = path;
                }
                if (!node.node_ops.setattr) {
                    throw new FS.ErrnoError(63);
                }
                if (FS.isDir(node.mode)) {
                    throw new FS.ErrnoError(31);
                }
                if (!FS.isFile(node.mode)) {
                    throw new FS.ErrnoError(28);
                }
                var errCode = FS.nodePermissions(node, "w");
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
                node.node_ops.setattr(node, {
                    size: len,
                    timestamp: Date.now()
                });
            },
            ftruncate: (fd, len) => {
                var stream = FS.getStream(fd);
                if (!stream) {
                    throw new FS.ErrnoError(8);
                }
                if ((stream.flags & 2097155) === 0) {
                    throw new FS.ErrnoError(28);
                }
                FS.truncate(stream.node, len);
            },
            utime: (path, atime, mtime) => {
                var lookup = FS.lookupPath(path, { follow: true });
                var node = lookup.node;
                node.node_ops.setattr(node, {
                    timestamp: Math.max(atime, mtime)
                });
            },
            open: (path, flags, mode) => {
                if (path === "") {
                    throw new FS.ErrnoError(44);
                }
                flags = typeof flags == "string" ? FS.modeStringToFlags(flags) : flags;
                mode = typeof mode == "undefined" ? 438 /* 0666 */ : mode;
                if (flags & 64) {
                    mode = (mode & 4095) | 32768;
                } else {
                    mode = 0;
                }
                var node;
                if (typeof path == "object") {
                    node = path;
                } else {
                    path = PATH.normalize(path);
                    try {
                        var lookup = FS.lookupPath(path, {
                            follow: !(flags & 131072)
                        });
                        node = lookup.node;
                    } catch (e) {
                        // ignore
                    }
                }
                // perhaps we need to create the node
                var created = false;
                if (flags & 64) {
                    if (node) {
                        // if O_CREAT and O_EXCL are set, error out if the node already exists
                        if (flags & 128) {
                            throw new FS.ErrnoError(20);
                        }
                    } else {
                        // node doesn't exist, try to create it
                        node = FS.mknod(path, mode, 0);
                        created = true;
                    }
                }
                if (!node) {
                    throw new FS.ErrnoError(44);
                }
                // can't truncate a device
                if (FS.isChrdev(node.mode)) {
                    flags &= ~512;
                }
                // if asked only for a directory, then this must be one
                if (flags & 65536 && !FS.isDir(node.mode)) {
                    throw new FS.ErrnoError(54);
                }
                // check permissions, if this is not a file we just created now (it is ok to
                // create and write to a file with read-only permissions; it is read-only
                // for later use)
                if (!created) {
                    var errCode = FS.mayOpen(node, flags);
                    if (errCode) {
                        throw new FS.ErrnoError(errCode);
                    }
                }
                // do truncation if necessary
                if (flags & 512 && !created) {
                    FS.truncate(node, 0);
                }
                // we've already handled these, don't pass down to the underlying vfs
                flags &= ~(128 | 512 | 131072);

                // register the stream with the filesystem
                var stream = FS.createStream({
                    node: node,
                    path: FS.getPath(node), // we want the absolute path to the node
                    flags: flags,
                    seekable: true,
                    position: 0,
                    stream_ops: node.stream_ops,
                    // used by the file family libc calls (fopen, fwrite, ferror, etc.)
                    ungotten: [],
                    error: false
                });
                // call the new stream's open function
                if (stream.stream_ops.open) {
                    stream.stream_ops.open(stream);
                }
                if (Module["logReadFiles"] && !(flags & 1)) {
                    if (!FS.readFiles) FS.readFiles = {};
                    if (!(path in FS.readFiles)) {
                        FS.readFiles[path] = 1;
                    }
                }
                return stream;
            },
            close: (stream) => {
                if (FS.isClosed(stream)) {
                    throw new FS.ErrnoError(8);
                }
                if (stream.getdents) stream.getdents = null; // free readdir state
                try {
                    if (stream.stream_ops.close) {
                        stream.stream_ops.close(stream);
                    }
                } catch (e) {
                    throw e;
                } finally {
                    FS.closeStream(stream.fd);
                }
                stream.fd = null;
            },
            isClosed: (stream) => {
                return stream.fd === null;
            },
            llseek: (stream, offset, whence) => {
                if (FS.isClosed(stream)) {
                    throw new FS.ErrnoError(8);
                }
                if (!stream.seekable || !stream.stream_ops.llseek) {
                    throw new FS.ErrnoError(70);
                }
                if (whence != 0 && whence != 1 && whence != 2) {
                    throw new FS.ErrnoError(28);
                }
                stream.position = stream.stream_ops.llseek(stream, offset, whence);
                stream.ungotten = [];
                return stream.position;
            },
            read: (stream, buffer, offset, length, position) => {
                if (length < 0 || position < 0) {
                    throw new FS.ErrnoError(28);
                }
                if (FS.isClosed(stream)) {
                    throw new FS.ErrnoError(8);
                }
                if ((stream.flags & 2097155) === 1) {
                    throw new FS.ErrnoError(8);
                }
                if (FS.isDir(stream.node.mode)) {
                    throw new FS.ErrnoError(31);
                }
                if (!stream.stream_ops.read) {
                    throw new FS.ErrnoError(28);
                }
                var seeking = typeof position != "undefined";
                if (!seeking) {
                    position = stream.position;
                } else if (!stream.seekable) {
                    throw new FS.ErrnoError(70);
                }
                var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
                if (!seeking) stream.position += bytesRead;
                return bytesRead;
            },
            write: (stream, buffer, offset, length, position, canOwn) => {
                if (length < 0 || position < 0) {
                    throw new FS.ErrnoError(28);
                }
                if (FS.isClosed(stream)) {
                    throw new FS.ErrnoError(8);
                }
                if ((stream.flags & 2097155) === 0) {
                    throw new FS.ErrnoError(8);
                }
                if (FS.isDir(stream.node.mode)) {
                    throw new FS.ErrnoError(31);
                }
                if (!stream.stream_ops.write) {
                    throw new FS.ErrnoError(28);
                }
                if (stream.seekable && stream.flags & 1024) {
                    // seek to the end before writing in append mode
                    FS.llseek(stream, 0, 2);
                }
                var seeking = typeof position != "undefined";
                if (!seeking) {
                    position = stream.position;
                } else if (!stream.seekable) {
                    throw new FS.ErrnoError(70);
                }
                var bytesWritten = stream.stream_ops.write(
                    stream,
                    buffer,
                    offset,
                    length,
                    position,
                    canOwn
                );
                if (!seeking) stream.position += bytesWritten;
                return bytesWritten;
            },
            allocate: (stream, offset, length) => {
                if (FS.isClosed(stream)) {
                    throw new FS.ErrnoError(8);
                }
                if (offset < 0 || length <= 0) {
                    throw new FS.ErrnoError(28);
                }
                if ((stream.flags & 2097155) === 0) {
                    throw new FS.ErrnoError(8);
                }
                if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
                    throw new FS.ErrnoError(43);
                }
                if (!stream.stream_ops.allocate) {
                    throw new FS.ErrnoError(138);
                }
                stream.stream_ops.allocate(stream, offset, length);
            },
            mmap: (stream, length, position, prot, flags) => {
                // User requests writing to file (prot & PROT_WRITE != 0).
                // Checking if we have permissions to write to the file unless
                // MAP_PRIVATE flag is set. According to POSIX spec it is possible
                // to write to file opened in read-only mode with MAP_PRIVATE flag,
                // as all modifications will be visible only in the memory of
                // the current process.
                if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
                    throw new FS.ErrnoError(2);
                }
                if ((stream.flags & 2097155) === 1) {
                    throw new FS.ErrnoError(2);
                }
                if (!stream.stream_ops.mmap) {
                    throw new FS.ErrnoError(43);
                }
                return stream.stream_ops.mmap(stream, length, position, prot, flags);
            },
            msync: (stream, buffer, offset, length, mmapFlags) => {
                if (!stream.stream_ops.msync) {
                    return 0;
                }
                return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
            },
            munmap: (stream) => 0,
            ioctl: (stream, cmd, arg) => {
                if (!stream.stream_ops.ioctl) {
                    throw new FS.ErrnoError(59);
                }
                return stream.stream_ops.ioctl(stream, cmd, arg);
            },
            readFile: (path, opts = {}) => {
                opts.flags = opts.flags || 0;
                opts.encoding = opts.encoding || "binary";
                if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
                    throw new Error('Invalid encoding type "' + opts.encoding + '"');
                }
                var ret;
                var stream = FS.open(path, opts.flags);
                var stat = FS.stat(path);
                var length = stat.size;
                var buf = new Uint8Array(length);
                FS.read(stream, buf, 0, length, 0);
                if (opts.encoding === "utf8") {
                    ret = UTF8ArrayToString(buf, 0);
                } else if (opts.encoding === "binary") {
                    ret = buf;
                }
                FS.close(stream);
                return ret;
            },
            writeFile: (path, data, opts = {}) => {
                opts.flags = opts.flags || 577;
                var stream = FS.open(path, opts.flags, opts.mode);
                if (typeof data == "string") {
                    var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
                    var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
                    FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
                } else if (ArrayBuffer.isView(data)) {
                    FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
                } else {
                    throw new Error("Unsupported data type");
                }
                FS.close(stream);
            },
            cwd: () => FS.currentPath,
            chdir: (path) => {
                var lookup = FS.lookupPath(path, { follow: true });
                if (lookup.node === null) {
                    throw new FS.ErrnoError(44);
                }
                if (!FS.isDir(lookup.node.mode)) {
                    throw new FS.ErrnoError(54);
                }
                var errCode = FS.nodePermissions(lookup.node, "x");
                if (errCode) {
                    throw new FS.ErrnoError(errCode);
                }
                FS.currentPath = lookup.path;
            },
            createDefaultDirectories: () => {
                FS.mkdir("/tmp");
                FS.mkdir("/home");
                FS.mkdir("/home/web_user");
            },
            createDefaultDevices: () => {
                // create /dev
                FS.mkdir("/dev");
                // setup /dev/null
                FS.registerDevice(FS.makedev(1, 3), {
                    read: () => 0,
                    write: (stream, buffer, offset, length, pos) => length
                });
                FS.mkdev("/dev/null", FS.makedev(1, 3));
                // setup /dev/tty and /dev/tty1
                // stderr needs to print output using err() rather than out()
                // so we register a second tty just for it.
                TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
                TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
                FS.mkdev("/dev/tty", FS.makedev(5, 0));
                FS.mkdev("/dev/tty1", FS.makedev(6, 0));
                // setup /dev/[u]random
                var random_device = getRandomDevice();
                FS.createDevice("/dev", "random", random_device);
                FS.createDevice("/dev", "urandom", random_device);
                // we're not going to emulate the actual shm device,
                // just create the tmp dirs that reside in it commonly
                FS.mkdir("/dev/shm");
                FS.mkdir("/dev/shm/tmp");
            },
            createSpecialDirectories: () => {
                // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
                // name of the stream for fd 6 (see test_unistd_ttyname)
                FS.mkdir("/proc");
                var proc_self = FS.mkdir("/proc/self");
                FS.mkdir("/proc/self/fd");
                FS.mount(
                    {
                        mount: () => {
                            var node = FS.createNode(proc_self, "fd", 16384 | 511 /* 0777 */, 73);
                            node.node_ops = {
                                lookup: (parent, name) => {
                                    var fd = +name;
                                    var stream = FS.getStream(fd);
                                    if (!stream) throw new FS.ErrnoError(8);
                                    var ret = {
                                        parent: null,
                                        mount: { mountpoint: "fake" },
                                        node_ops: { readlink: () => stream.path }
                                    };
                                    ret.parent = ret; // make it look like a simple root node
                                    return ret;
                                }
                            };
                            return node;
                        }
                    },
                    {},
                    "/proc/self/fd"
                );
            },
            createStandardStreams: () => {
                // TODO deprecate the old functionality of a single
                // input / output callback and that utilizes FS.createDevice
                // and instead require a unique set of stream ops

                // by default, we symlink the standard streams to the
                // default tty devices. however, if the standard streams
                // have been overwritten we create a unique device for
                // them instead.
                if (Module["stdin"]) {
                    FS.createDevice("/dev", "stdin", Module["stdin"]);
                } else {
                    FS.symlink("/dev/tty", "/dev/stdin");
                }
                if (Module["stdout"]) {
                    FS.createDevice("/dev", "stdout", null, Module["stdout"]);
                } else {
                    FS.symlink("/dev/tty", "/dev/stdout");
                }
                if (Module["stderr"]) {
                    FS.createDevice("/dev", "stderr", null, Module["stderr"]);
                } else {
                    FS.symlink("/dev/tty1", "/dev/stderr");
                }

                // open default streams for the stdin, stdout and stderr devices
                var stdin = FS.open("/dev/stdin", 0);
                var stdout = FS.open("/dev/stdout", 1);
                var stderr = FS.open("/dev/stderr", 1);
                assert(stdin.fd === 0, "invalid handle for stdin (" + stdin.fd + ")");
                assert(stdout.fd === 1, "invalid handle for stdout (" + stdout.fd + ")");
                assert(stderr.fd === 2, "invalid handle for stderr (" + stderr.fd + ")");
            },
            ensureErrnoError: () => {
                if (FS.ErrnoError) return;
                FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
                    // We set the `name` property to be able to identify `FS.ErrnoError`
                    // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
                    // - when using PROXYFS, an error can come from an underlying FS
                    // as different FS objects have their own FS.ErrnoError each,
                    // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
                    // we'll use the reliable test `err.name == "ErrnoError"` instead
                    this.name = "ErrnoError";
                    this.node = node;
                    this.setErrno = /** @this{Object} */ function (errno) {
                        this.errno = errno;
                        for (var key in ERRNO_CODES) {
                            if (ERRNO_CODES[key] === errno) {
                                this.code = key;
                                break;
                            }
                        }
                    };
                    this.setErrno(errno);
                    this.message = ERRNO_MESSAGES[errno];

                    // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack
                    // now ensures it shows what we want.
                    if (this.stack) {
                        // Define the stack property for Node.js 4, which otherwise errors on the next line.
                        Object.defineProperty(this, "stack", {
                            value: new Error().stack,
                            writable: true
                        });
                        this.stack = demangleAll(this.stack);
                    }
                };
                FS.ErrnoError.prototype = new Error();
                FS.ErrnoError.prototype.constructor = FS.ErrnoError;
                // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
                [44].forEach((code) => {
                    FS.genericErrors[code] = new FS.ErrnoError(code);
                    FS.genericErrors[code].stack = "<generic error, no stack>";
                });
            },
            staticInit: () => {
                FS.ensureErrnoError();

                FS.nameTable = new Array(4096);

                FS.mount(MEMFS, {}, "/");

                FS.createDefaultDirectories();
                FS.createDefaultDevices();
                FS.createSpecialDirectories();

                FS.filesystems = {
                    MEMFS: MEMFS,
                    IDBFS: IDBFS
                };
            },
            init: (input, output, error) => {
                assert(
                    !FS.init.initialized,
                    "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)"
                );
                FS.init.initialized = true;

                FS.ensureErrnoError();

                // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
                Module["stdin"] = input || Module["stdin"];
                Module["stdout"] = output || Module["stdout"];
                Module["stderr"] = error || Module["stderr"];

                FS.createStandardStreams();
            },
            quit: () => {
                FS.init.initialized = false;
                // force-flush all streams, so we get musl std streams printed out
                _fflush(0);
                // close all of our streams
                for (var i = 0; i < FS.streams.length; i++) {
                    var stream = FS.streams[i];
                    if (!stream) {
                        continue;
                    }
                    FS.close(stream);
                }
            },
            getMode: (canRead, canWrite) => {
                var mode = 0;
                if (canRead) mode |= 292 | 73;
                if (canWrite) mode |= 146;
                return mode;
            },
            findObject: (path, dontResolveLastLink) => {
                var ret = FS.analyzePath(path, dontResolveLastLink);
                if (!ret.exists) {
                    return null;
                }
                return ret.object;
            },
            analyzePath: (path, dontResolveLastLink) => {
                // operate from within the context of the symlink's target
                try {
                    var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
                    path = lookup.path;
                } catch (e) {}
                var ret = {
                    isRoot: false,
                    exists: false,
                    error: 0,
                    name: null,
                    path: null,
                    object: null,
                    parentExists: false,
                    parentPath: null,
                    parentObject: null
                };
                try {
                    var lookup = FS.lookupPath(path, { parent: true });
                    ret.parentExists = true;
                    ret.parentPath = lookup.path;
                    ret.parentObject = lookup.node;
                    ret.name = PATH.basename(path);
                    lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
                    ret.exists = true;
                    ret.path = lookup.path;
                    ret.object = lookup.node;
                    ret.name = lookup.node.name;
                    ret.isRoot = lookup.path === "/";
                } catch (e) {
                    ret.error = e.errno;
                }
                return ret;
            },
            createPath: (parent, path, canRead, canWrite) => {
                parent = typeof parent == "string" ? parent : FS.getPath(parent);
                var parts = path.split("/").reverse();
                while (parts.length) {
                    var part = parts.pop();
                    if (!part) continue;
                    var current = PATH.join2(parent, part);
                    try {
                        FS.mkdir(current);
                    } catch (e) {
                        // ignore EEXIST
                    }
                    parent = current;
                }
                return current;
            },
            createFile: (parent, name, properties, canRead, canWrite) => {
                var path = PATH.join2(
                    typeof parent == "string" ? parent : FS.getPath(parent),
                    name
                );
                var mode = FS.getMode(canRead, canWrite);
                return FS.create(path, mode);
            },
            createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
                var path = name;
                if (parent) {
                    parent = typeof parent == "string" ? parent : FS.getPath(parent);
                    path = name ? PATH.join2(parent, name) : parent;
                }
                var mode = FS.getMode(canRead, canWrite);
                var node = FS.create(path, mode);
                if (data) {
                    if (typeof data == "string") {
                        var arr = new Array(data.length);
                        for (var i = 0, len = data.length; i < len; ++i)
                            arr[i] = data.charCodeAt(i);
                        data = arr;
                    }
                    // make sure we can write to the file
                    FS.chmod(node, mode | 146);
                    var stream = FS.open(node, 577);
                    FS.write(stream, data, 0, data.length, 0, canOwn);
                    FS.close(stream);
                    FS.chmod(node, mode);
                }
                return node;
            },
            createDevice: (parent, name, input, output) => {
                var path = PATH.join2(
                    typeof parent == "string" ? parent : FS.getPath(parent),
                    name
                );
                var mode = FS.getMode(!!input, !!output);
                if (!FS.createDevice.major) FS.createDevice.major = 64;
                var dev = FS.makedev(FS.createDevice.major++, 0);
                // Create a fake device that a set of stream ops to emulate
                // the old behavior.
                FS.registerDevice(dev, {
                    open: (stream) => {
                        stream.seekable = false;
                    },
                    close: (stream) => {
                        // flush any pending line data
                        if (output && output.buffer && output.buffer.length) {
                            output(10);
                        }
                    },
                    read: (stream, buffer, offset, length, pos /* ignored */) => {
                        var bytesRead = 0;
                        for (var i = 0; i < length; i++) {
                            var result;
                            try {
                                result = input();
                            } catch (e) {
                                throw new FS.ErrnoError(29);
                            }
                            if (result === undefined && bytesRead === 0) {
                                throw new FS.ErrnoError(6);
                            }
                            if (result === null || result === undefined) break;
                            bytesRead++;
                            buffer[offset + i] = result;
                        }
                        if (bytesRead) {
                            stream.node.timestamp = Date.now();
                        }
                        return bytesRead;
                    },
                    write: (stream, buffer, offset, length, pos) => {
                        for (var i = 0; i < length; i++) {
                            try {
                                output(buffer[offset + i]);
                            } catch (e) {
                                throw new FS.ErrnoError(29);
                            }
                        }
                        if (length) {
                            stream.node.timestamp = Date.now();
                        }
                        return i;
                    }
                });
                return FS.mkdev(path, mode, dev);
            },
            forceLoadFile: (obj) => {
                if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
                if (typeof XMLHttpRequest != "undefined") {
                    throw new Error(
                        "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
                    );
                } else if (read_) {
                    // Command-line.
                    try {
                        // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
                        //          read() will try to parse UTF8.
                        obj.contents = intArrayFromString(read_(obj.url), true);
                        obj.usedBytes = obj.contents.length;
                    } catch (e) {
                        throw new FS.ErrnoError(29);
                    }
                } else {
                    throw new Error("Cannot load without read() or XMLHttpRequest.");
                }
            },
            createLazyFile: (parent, name, url, canRead, canWrite) => {
                // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
                /** @constructor */
                function LazyUint8Array() {
                    this.lengthKnown = false;
                    this.chunks = []; // Loaded chunks. Index is the chunk number
                }
                LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(
                    idx
                ) {
                    if (idx > this.length - 1 || idx < 0) {
                        return undefined;
                    }
                    var chunkOffset = idx % this.chunkSize;
                    var chunkNum = (idx / this.chunkSize) | 0;
                    return this.getter(chunkNum)[chunkOffset];
                };
                LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(
                    getter
                ) {
                    this.getter = getter;
                };
                LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
                    // Find length
                    var xhr = new XMLHttpRequest();
                    xhr.open("HEAD", url, false);
                    xhr.send(null);
                    if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
                        throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
                    var datalength = Number(xhr.getResponseHeader("Content-length"));
                    var header;
                    var hasByteServing =
                        (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
                    var usesGzip =
                        (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";

                    var chunkSize = 1024 * 1024; // Chunk size in bytes

                    if (!hasByteServing) chunkSize = datalength;

                    // Function to get a range from the remote URL.
                    var doXHR = (from, to) => {
                        if (from > to)
                            throw new Error(
                                "invalid range (" + from + ", " + to + ") or no bytes requested!"
                            );
                        if (to > datalength - 1)
                            throw new Error(
                                "only " + datalength + " bytes available! programmer error!"
                            );

                        // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
                        var xhr = new XMLHttpRequest();
                        xhr.open("GET", url, false);
                        if (datalength !== chunkSize)
                            xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);

                        // Some hints to the browser that we want binary data.
                        xhr.responseType = "arraybuffer";
                        if (xhr.overrideMimeType) {
                            xhr.overrideMimeType("text/plain; charset=x-user-defined");
                        }

                        xhr.send(null);
                        if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
                            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
                        if (xhr.response !== undefined) {
                            return new Uint8Array(/** @type{Array<number>} */ (xhr.response || []));
                        }
                        return intArrayFromString(xhr.responseText || "", true);
                    };
                    var lazyArray = this;
                    lazyArray.setDataGetter((chunkNum) => {
                        var start = chunkNum * chunkSize;
                        var end = (chunkNum + 1) * chunkSize - 1; // including this byte
                        end = Math.min(end, datalength - 1); // if datalength-1 is selected, this is the last block
                        if (typeof lazyArray.chunks[chunkNum] == "undefined") {
                            lazyArray.chunks[chunkNum] = doXHR(start, end);
                        }
                        if (typeof lazyArray.chunks[chunkNum] == "undefined")
                            throw new Error("doXHR failed!");
                        return lazyArray.chunks[chunkNum];
                    });

                    if (usesGzip || !datalength) {
                        // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
                        chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
                        datalength = this.getter(0).length;
                        chunkSize = datalength;
                        out(
                            "LazyFiles on gzip forces download of the whole file when length is accessed"
                        );
                    }

                    this._length = datalength;
                    this._chunkSize = chunkSize;
                    this.lengthKnown = true;
                };
                if (typeof XMLHttpRequest != "undefined") {
                    if (!ENVIRONMENT_IS_WORKER)
                        throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                    var lazyArray = new LazyUint8Array();
                    Object.defineProperties(lazyArray, {
                        length: {
                            get: /** @this{Object} */ function () {
                                if (!this.lengthKnown) {
                                    this.cacheLength();
                                }
                                return this._length;
                            }
                        },
                        chunkSize: {
                            get: /** @this{Object} */ function () {
                                if (!this.lengthKnown) {
                                    this.cacheLength();
                                }
                                return this._chunkSize;
                            }
                        }
                    });

                    var properties = { isDevice: false, contents: lazyArray };
                } else {
                    var properties = { isDevice: false, url: url };
                }

                var node = FS.createFile(parent, name, properties, canRead, canWrite);
                // This is a total hack, but I want to get this lazy file code out of the
                // core of MEMFS. If we want to keep this lazy file concept I feel it should
                // be its own thin LAZYFS proxying calls to MEMFS.
                if (properties.contents) {
                    node.contents = properties.contents;
                } else if (properties.url) {
                    node.contents = null;
                    node.url = properties.url;
                }
                // Add a function that defers querying the file size until it is asked the first time.
                Object.defineProperties(node, {
                    usedBytes: {
                        get: /** @this {FSNode} */ function () {
                            return this.contents.length;
                        }
                    }
                });
                // override each stream op with one that tries to force load the lazy file first
                var stream_ops = {};
                var keys = Object.keys(node.stream_ops);
                keys.forEach((key) => {
                    var fn = node.stream_ops[key];
                    stream_ops[key] = function forceLoadLazyFile() {
                        FS.forceLoadFile(node);
                        return fn.apply(null, arguments);
                    };
                });
                function writeChunks(stream, buffer, offset, length, position) {
                    var contents = stream.node.contents;
                    if (position >= contents.length) return 0;
                    var size = Math.min(contents.length - position, length);
                    assert(size >= 0);
                    if (contents.slice) {
                        // normal array
                        for (var i = 0; i < size; i++) {
                            buffer[offset + i] = contents[position + i];
                        }
                    } else {
                        for (var i = 0; i < size; i++) {
                            // LazyUint8Array from sync binary XHR
                            buffer[offset + i] = contents.get(position + i);
                        }
                    }
                    return size;
                }
                // use a custom read function
                stream_ops.read = (stream, buffer, offset, length, position) => {
                    FS.forceLoadFile(node);
                    return writeChunks(stream, buffer, offset, length, position);
                };
                // use a custom mmap function
                stream_ops.mmap = (stream, length, position, prot, flags) => {
                    FS.forceLoadFile(node);
                    var ptr = mmapAlloc(length);
                    if (!ptr) {
                        throw new FS.ErrnoError(48);
                    }
                    writeChunks(stream, HEAP8, ptr, length, position);
                    return { ptr: ptr, allocated: true };
                };
                node.stream_ops = stream_ops;
                return node;
            },
            createPreloadedFile: (
                parent,
                name,
                url,
                canRead,
                canWrite,
                onload,
                onerror,
                dontCreateFile,
                canOwn,
                preFinish
            ) => {
                // TODO we should allow people to just pass in a complete filename instead
                // of parent and name being that we just join them anyways
                var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
                var dep = getUniqueRunDependency("cp " + fullname); // might have several active requests for the same fullname
                function processData(byteArray) {
                    function finish(byteArray) {
                        if (preFinish) preFinish();
                        if (!dontCreateFile) {
                            FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
                        }
                        if (onload) onload();
                        removeRunDependency(dep);
                    }
                    if (
                        Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
                            if (onerror) onerror();
                            removeRunDependency(dep);
                        })
                    ) {
                        return;
                    }
                    finish(byteArray);
                }
                addRunDependency(dep);
                if (typeof url == "string") {
                    asyncLoad(url, (byteArray) => processData(byteArray), onerror);
                } else {
                    processData(url);
                }
            },
            indexedDB: () => {
                return (
                    window.indexedDB ||
                    window.mozIndexedDB ||
                    window.webkitIndexedDB ||
                    window.msIndexedDB
                );
            },
            DB_NAME: () => {
                return "EM_FS_" + window.location.pathname;
            },
            DB_VERSION: 20,
            DB_STORE_NAME: "FILE_DATA",
            saveFilesToDB: (paths, onload = () => {}, onerror = () => {}) => {
                var indexedDB = FS.indexedDB();
                try {
                    var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
                } catch (e) {
                    return onerror(e);
                }
                openRequest.onupgradeneeded = () => {
                    out("creating db");
                    var db = openRequest.result;
                    db.createObjectStore(FS.DB_STORE_NAME);
                };
                openRequest.onsuccess = () => {
                    var db = openRequest.result;
                    var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
                    var files = transaction.objectStore(FS.DB_STORE_NAME);
                    var ok = 0,
                        fail = 0,
                        total = paths.length;
                    function finish() {
                        if (fail == 0) onload();
                        else onerror();
                    }
                    paths.forEach((path) => {
                        var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                        putRequest.onsuccess = () => {
                            ok++;
                            if (ok + fail == total) finish();
                        };
                        putRequest.onerror = () => {
                            fail++;
                            if (ok + fail == total) finish();
                        };
                    });
                    transaction.onerror = onerror;
                };
                openRequest.onerror = onerror;
            },
            loadFilesFromDB: (paths, onload = () => {}, onerror = () => {}) => {
                var indexedDB = FS.indexedDB();
                try {
                    var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
                } catch (e) {
                    return onerror(e);
                }
                openRequest.onupgradeneeded = onerror; // no database to load from
                openRequest.onsuccess = () => {
                    var db = openRequest.result;
                    try {
                        var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
                    } catch (e) {
                        onerror(e);
                        return;
                    }
                    var files = transaction.objectStore(FS.DB_STORE_NAME);
                    var ok = 0,
                        fail = 0,
                        total = paths.length;
                    function finish() {
                        if (fail == 0) onload();
                        else onerror();
                    }
                    paths.forEach((path) => {
                        var getRequest = files.get(path);
                        getRequest.onsuccess = () => {
                            if (FS.analyzePath(path).exists) {
                                FS.unlink(path);
                            }
                            FS.createDataFile(
                                PATH.dirname(path),
                                PATH.basename(path),
                                getRequest.result,
                                true,
                                true,
                                true
                            );
                            ok++;
                            if (ok + fail == total) finish();
                        };
                        getRequest.onerror = () => {
                            fail++;
                            if (ok + fail == total) finish();
                        };
                    });
                    transaction.onerror = onerror;
                };
                openRequest.onerror = onerror;
            },
            absolutePath: () => {
                abort("FS.absolutePath has been removed; use PATH_FS.resolve instead");
            },
            createFolder: () => {
                abort("FS.createFolder has been removed; use FS.mkdir instead");
            },
            createLink: () => {
                abort("FS.createLink has been removed; use FS.symlink instead");
            },
            joinPath: () => {
                abort("FS.joinPath has been removed; use PATH.join instead");
            },
            mmapAlloc: () => {
                abort("FS.mmapAlloc has been replaced by the top level function mmapAlloc");
            },
            standardizePath: () => {
                abort("FS.standardizePath has been removed; use PATH.normalize instead");
            }
        };
        var SYSCALLS = {
            DEFAULT_POLLMASK: 5,
            calculateAt: function (dirfd, path, allowEmpty) {
                if (PATH.isAbs(path)) {
                    return path;
                }
                // relative path
                var dir;
                if (dirfd === -100) {
                    dir = FS.cwd();
                } else {
                    var dirstream = SYSCALLS.getStreamFromFD(dirfd);
                    dir = dirstream.path;
                }
                if (path.length == 0) {
                    if (!allowEmpty) {
                        throw new FS.ErrnoError(44);
                    }
                    return dir;
                }
                return PATH.join2(dir, path);
            },
            doStat: function (func, path, buf) {
                try {
                    var stat = func(path);
                } catch (e) {
                    if (
                        e &&
                        e.node &&
                        PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))
                    ) {
                        // an error occurred while trying to look up the path; we should just report ENOTDIR
                        return -54;
                    }
                    throw e;
                }
                HEAP32[buf >> 2] = stat.dev;
                HEAP32[(buf + 8) >> 2] = stat.ino;
                HEAP32[(buf + 12) >> 2] = stat.mode;
                HEAPU32[(buf + 16) >> 2] = stat.nlink;
                HEAP32[(buf + 20) >> 2] = stat.uid;
                HEAP32[(buf + 24) >> 2] = stat.gid;
                HEAP32[(buf + 28) >> 2] = stat.rdev;
                (tempI64 = [
                    stat.size >>> 0,
                    ((tempDouble = stat.size),
                    +Math.abs(tempDouble) >= 1.0
                        ? tempDouble > 0.0
                            ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                  0) >>>
                              0
                            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>>
                              0
                        : 0)
                ]),
                    (HEAP32[(buf + 40) >> 2] = tempI64[0]),
                    (HEAP32[(buf + 44) >> 2] = tempI64[1]);
                HEAP32[(buf + 48) >> 2] = 4096;
                HEAP32[(buf + 52) >> 2] = stat.blocks;
                var atime = stat.atime.getTime();
                var mtime = stat.mtime.getTime();
                var ctime = stat.ctime.getTime();
                (tempI64 = [
                    Math.floor(atime / 1000) >>> 0,
                    ((tempDouble = Math.floor(atime / 1000)),
                    +Math.abs(tempDouble) >= 1.0
                        ? tempDouble > 0.0
                            ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                  0) >>>
                              0
                            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>>
                              0
                        : 0)
                ]),
                    (HEAP32[(buf + 56) >> 2] = tempI64[0]),
                    (HEAP32[(buf + 60) >> 2] = tempI64[1]);
                HEAPU32[(buf + 64) >> 2] = (atime % 1000) * 1000;
                (tempI64 = [
                    Math.floor(mtime / 1000) >>> 0,
                    ((tempDouble = Math.floor(mtime / 1000)),
                    +Math.abs(tempDouble) >= 1.0
                        ? tempDouble > 0.0
                            ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                  0) >>>
                              0
                            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>>
                              0
                        : 0)
                ]),
                    (HEAP32[(buf + 72) >> 2] = tempI64[0]),
                    (HEAP32[(buf + 76) >> 2] = tempI64[1]);
                HEAPU32[(buf + 80) >> 2] = (mtime % 1000) * 1000;
                (tempI64 = [
                    Math.floor(ctime / 1000) >>> 0,
                    ((tempDouble = Math.floor(ctime / 1000)),
                    +Math.abs(tempDouble) >= 1.0
                        ? tempDouble > 0.0
                            ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                  0) >>>
                              0
                            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>>
                              0
                        : 0)
                ]),
                    (HEAP32[(buf + 88) >> 2] = tempI64[0]),
                    (HEAP32[(buf + 92) >> 2] = tempI64[1]);
                HEAPU32[(buf + 96) >> 2] = (ctime % 1000) * 1000;
                (tempI64 = [
                    stat.ino >>> 0,
                    ((tempDouble = stat.ino),
                    +Math.abs(tempDouble) >= 1.0
                        ? tempDouble > 0.0
                            ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                  0) >>>
                              0
                            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>>
                              0
                        : 0)
                ]),
                    (HEAP32[(buf + 104) >> 2] = tempI64[0]),
                    (HEAP32[(buf + 108) >> 2] = tempI64[1]);
                return 0;
            },
            doMsync: function (addr, stream, len, flags, offset) {
                if (!FS.isFile(stream.node.mode)) {
                    throw new FS.ErrnoError(43);
                }
                if (flags & 2) {
                    // MAP_PRIVATE calls need not to be synced back to underlying fs
                    return 0;
                }
                var buffer = HEAPU8.slice(addr, addr + len);
                FS.msync(stream, buffer, offset, len, flags);
            },
            varargs: undefined,
            get: function () {
                assert(SYSCALLS.varargs != undefined);
                SYSCALLS.varargs += 4;
                var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
                return ret;
            },
            getStr: function (ptr) {
                var ret = UTF8ToString(ptr);
                return ret;
            },
            getStreamFromFD: function (fd) {
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                return stream;
            }
        };
        function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
            try {
                // readfds are supported,
                // writefds checks socket open status
                // exceptfds not supported
                // timeout is always 0 - fully async
                assert(nfds <= 64, "nfds must be less than or equal to 64"); // fd sets have 64 bits // TODO: this could be 1024 based on current musl headers
                assert(!exceptfds, "exceptfds not supported");

                var total = 0;

                var srcReadLow = readfds ? HEAP32[readfds >> 2] : 0,
                    srcReadHigh = readfds ? HEAP32[(readfds + 4) >> 2] : 0;
                var srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0,
                    srcWriteHigh = writefds ? HEAP32[(writefds + 4) >> 2] : 0;
                var srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0,
                    srcExceptHigh = exceptfds ? HEAP32[(exceptfds + 4) >> 2] : 0;

                var dstReadLow = 0,
                    dstReadHigh = 0;
                var dstWriteLow = 0,
                    dstWriteHigh = 0;
                var dstExceptLow = 0,
                    dstExceptHigh = 0;

                var allLow =
                    (readfds ? HEAP32[readfds >> 2] : 0) |
                    (writefds ? HEAP32[writefds >> 2] : 0) |
                    (exceptfds ? HEAP32[exceptfds >> 2] : 0);
                var allHigh =
                    (readfds ? HEAP32[(readfds + 4) >> 2] : 0) |
                    (writefds ? HEAP32[(writefds + 4) >> 2] : 0) |
                    (exceptfds ? HEAP32[(exceptfds + 4) >> 2] : 0);

                var check = function (fd, low, high, val) {
                    return fd < 32 ? low & val : high & val;
                };

                for (var fd = 0; fd < nfds; fd++) {
                    var mask = 1 << fd % 32;
                    if (!check(fd, allLow, allHigh, mask)) {
                        continue; // index isn't in the set
                    }

                    var stream = SYSCALLS.getStreamFromFD(fd);

                    var flags = SYSCALLS.DEFAULT_POLLMASK;

                    if (stream.stream_ops.poll) {
                        flags = stream.stream_ops.poll(stream);
                    }

                    if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
                        fd < 32
                            ? (dstReadLow = dstReadLow | mask)
                            : (dstReadHigh = dstReadHigh | mask);
                        total++;
                    }
                    if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
                        fd < 32
                            ? (dstWriteLow = dstWriteLow | mask)
                            : (dstWriteHigh = dstWriteHigh | mask);
                        total++;
                    }
                    if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
                        fd < 32
                            ? (dstExceptLow = dstExceptLow | mask)
                            : (dstExceptHigh = dstExceptHigh | mask);
                        total++;
                    }
                }

                if (readfds) {
                    HEAP32[readfds >> 2] = dstReadLow;
                    HEAP32[(readfds + 4) >> 2] = dstReadHigh;
                }
                if (writefds) {
                    HEAP32[writefds >> 2] = dstWriteLow;
                    HEAP32[(writefds + 4) >> 2] = dstWriteHigh;
                }
                if (exceptfds) {
                    HEAP32[exceptfds >> 2] = dstExceptLow;
                    HEAP32[(exceptfds + 4) >> 2] = dstExceptHigh;
                }

                return total;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        var SOCKFS = {
            mount: function (mount) {
                // If Module['websocket'] has already been defined (e.g. for configuring
                // the subprotocol/url) use that, if not initialise it to a new object.
                Module["websocket"] =
                    Module["websocket"] && "object" === typeof Module["websocket"]
                        ? Module["websocket"]
                        : {};

                // Add the Event registration mechanism to the exported websocket configuration
                // object so we can register network callbacks from native JavaScript too.
                // For more documentation see system/include/emscripten/emscripten.h
                Module["websocket"]._callbacks = {};
                Module["websocket"]["on"] = /** @this{Object} */ function (event, callback) {
                    if ("function" === typeof callback) {
                        this._callbacks[event] = callback;
                    }
                    return this;
                };

                Module["websocket"].emit = /** @this{Object} */ function (event, param) {
                    if ("function" === typeof this._callbacks[event]) {
                        this._callbacks[event].call(this, param);
                    }
                };

                // If debug is enabled register simple default logging callbacks for each Event.

                return FS.createNode(null, "/", 16384 | 511 /* 0777 */, 0);
            },
            createSocket: function (family, type, protocol) {
                type &= ~526336; // Some applications may pass it; it makes no sense for a single process.
                var streaming = type == 1;
                if (streaming && protocol && protocol != 6) {
                    throw new FS.ErrnoError(66); // if SOCK_STREAM, must be tcp or 0.
                }

                // create our internal socket structure
                var sock = {
                    family: family,
                    type: type,
                    protocol: protocol,
                    server: null,
                    error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
                    peers: {},
                    pending: [],
                    recv_queue: [],
                    sock_ops: SOCKFS.websocket_sock_ops
                };

                // create the filesystem node to store the socket structure
                var name = SOCKFS.nextname();
                var node = FS.createNode(SOCKFS.root, name, 49152, 0);
                node.sock = sock;

                // and the wrapping stream that enables library functions such
                // as read and write to indirectly interact with the socket
                var stream = FS.createStream({
                    path: name,
                    node: node,
                    flags: 2,
                    seekable: false,
                    stream_ops: SOCKFS.stream_ops
                });

                // map the new stream to the socket structure (sockets have a 1:1
                // relationship with a stream)
                sock.stream = stream;

                return sock;
            },
            getSocket: function (fd) {
                var stream = FS.getStream(fd);
                if (!stream || !FS.isSocket(stream.node.mode)) {
                    return null;
                }
                return stream.node.sock;
            },
            stream_ops: {
                poll: function (stream) {
                    var sock = stream.node.sock;
                    return sock.sock_ops.poll(sock);
                },
                ioctl: function (stream, request, varargs) {
                    var sock = stream.node.sock;
                    return sock.sock_ops.ioctl(sock, request, varargs);
                },
                read: function (stream, buffer, offset, length, position /* ignored */) {
                    var sock = stream.node.sock;
                    var msg = sock.sock_ops.recvmsg(sock, length);
                    if (!msg) {
                        // socket is closed
                        return 0;
                    }
                    buffer.set(msg.buffer, offset);
                    return msg.buffer.length;
                },
                write: function (stream, buffer, offset, length, position /* ignored */) {
                    var sock = stream.node.sock;
                    return sock.sock_ops.sendmsg(sock, buffer, offset, length);
                },
                close: function (stream) {
                    var sock = stream.node.sock;
                    sock.sock_ops.close(sock);
                }
            },
            nextname: function () {
                if (!SOCKFS.nextname.current) {
                    SOCKFS.nextname.current = 0;
                }
                return "socket[" + SOCKFS.nextname.current++ + "]";
            },
            websocket_sock_ops: {
                createPeer: function (sock, addr, port) {
                    var ws;

                    if (typeof addr == "object") {
                        ws = addr;
                        addr = null;
                        port = null;
                    }

                    if (ws) {
                        // for sockets that've already connected (e.g. we're the server)
                        // we can inspect the _socket property for the address
                        if (ws._socket) {
                            addr = ws._socket.remoteAddress;
                            port = ws._socket.remotePort;
                        }
                        // if we're just now initializing a connection to the remote,
                        // inspect the url property
                        else {
                            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
                            if (!result) {
                                throw new Error(
                                    "WebSocket URL must be in the format ws(s)://address:port"
                                );
                            }
                            addr = result[1];
                            port = parseInt(result[2], 10);
                        }
                    } else {
                        // create the actual websocket object and connect
                        try {
                            // runtimeConfig gets set to true if WebSocket runtime configuration is available.
                            var runtimeConfig =
                                Module["websocket"] && "object" === typeof Module["websocket"];

                            // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
                            // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
                            var url = "ws:#".replace("#", "//");

                            if (runtimeConfig) {
                                if ("string" === typeof Module["websocket"]["url"]) {
                                    url = Module["websocket"]["url"]; // Fetch runtime WebSocket URL config.
                                }
                            }

                            if (url === "ws://" || url === "wss://") {
                                // Is the supplied URL config just a prefix, if so complete it.
                                var parts = addr.split("/");
                                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
                            }

                            // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
                            var subProtocols = "binary"; // The default value is 'binary'

                            if (runtimeConfig) {
                                if ("string" === typeof Module["websocket"]["subprotocol"]) {
                                    subProtocols = Module["websocket"]["subprotocol"]; // Fetch runtime WebSocket subprotocol config.
                                }
                            }

                            // The default WebSocket options
                            var opts = undefined;

                            if (subProtocols !== "null") {
                                // The regex trims the string (removes spaces at the beginning and end, then splits the string by
                                // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
                                subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);

                                opts = subProtocols;
                            }

                            // some webservers (azure) does not support subprotocol header
                            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
                                subProtocols = "null";
                                opts = undefined;
                            }

                            // If node we use the ws library.
                            var WebSocketConstructor;
                            if (ENVIRONMENT_IS_NODE) {
                                WebSocketConstructor = /** @type{(typeof WebSocket)} */ (
                                    require("ws")
                                );
                            } else {
                                WebSocketConstructor = WebSocket;
                            }
                            ws = new WebSocketConstructor(url, opts);
                            ws.binaryType = "arraybuffer";
                        } catch (e) {
                            throw new FS.ErrnoError(23);
                        }
                    }

                    var peer = {
                        addr: addr,
                        port: port,
                        socket: ws,
                        dgram_send_queue: []
                    };

                    SOCKFS.websocket_sock_ops.addPeer(sock, peer);
                    SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);

                    // if this is a bound dgram socket, send the port number first to allow
                    // us to override the ephemeral port reported to us by remotePort on the
                    // remote end.
                    if (sock.type === 2 && typeof sock.sport != "undefined") {
                        peer.dgram_send_queue.push(
                            new Uint8Array([
                                255,
                                255,
                                255,
                                255,
                                "p".charCodeAt(0),
                                "o".charCodeAt(0),
                                "r".charCodeAt(0),
                                "t".charCodeAt(0),
                                (sock.sport & 0xff00) >> 8,
                                sock.sport & 0xff
                            ])
                        );
                    }

                    return peer;
                },
                getPeer: function (sock, addr, port) {
                    return sock.peers[addr + ":" + port];
                },
                addPeer: function (sock, peer) {
                    sock.peers[peer.addr + ":" + peer.port] = peer;
                },
                removePeer: function (sock, peer) {
                    delete sock.peers[peer.addr + ":" + peer.port];
                },
                handlePeerEvents: function (sock, peer) {
                    var first = true;

                    var handleOpen = function () {
                        Module["websocket"].emit("open", sock.stream.fd);

                        try {
                            var queued = peer.dgram_send_queue.shift();
                            while (queued) {
                                peer.socket.send(queued);
                                queued = peer.dgram_send_queue.shift();
                            }
                        } catch (e) {
                            // not much we can do here in the way of proper error handling as we've already
                            // lied and said this data was sent. shut it down.
                            peer.socket.close();
                        }
                    };

                    function handleMessage(data) {
                        if (typeof data == "string") {
                            var encoder = new TextEncoder(); // should be utf-8
                            data = encoder.encode(data); // make a typed array from the string
                        } else {
                            assert(data.byteLength !== undefined); // must receive an ArrayBuffer
                            if (data.byteLength == 0) {
                                // An empty ArrayBuffer will emit a pseudo disconnect event
                                // as recv/recvmsg will return zero which indicates that a socket
                                // has performed a shutdown although the connection has not been disconnected yet.
                                return;
                            }
                            data = new Uint8Array(data); // make a typed array view on the array buffer
                        }

                        // if this is the port message, override the peer's port with it
                        var wasfirst = first;
                        first = false;
                        if (
                            wasfirst &&
                            data.length === 10 &&
                            data[0] === 255 &&
                            data[1] === 255 &&
                            data[2] === 255 &&
                            data[3] === 255 &&
                            data[4] === "p".charCodeAt(0) &&
                            data[5] === "o".charCodeAt(0) &&
                            data[6] === "r".charCodeAt(0) &&
                            data[7] === "t".charCodeAt(0)
                        ) {
                            // update the peer's port and it's key in the peer map
                            var newport = (data[8] << 8) | data[9];
                            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
                            peer.port = newport;
                            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
                            return;
                        }

                        sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
                        Module["websocket"].emit("message", sock.stream.fd);
                    }

                    if (ENVIRONMENT_IS_NODE) {
                        peer.socket.on("open", handleOpen);
                        peer.socket.on("message", function (data, isBinary) {
                            if (!isBinary) {
                                return;
                            }
                            handleMessage(new Uint8Array(data).buffer); // copy from node Buffer -> ArrayBuffer
                        });
                        peer.socket.on("close", function () {
                            Module["websocket"].emit("close", sock.stream.fd);
                        });
                        peer.socket.on("error", function (error) {
                            // Although the ws library may pass errors that may be more descriptive than
                            // ECONNREFUSED they are not necessarily the expected error code e.g.
                            // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
                            // is still probably the most useful thing to do.
                            sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
                            Module["websocket"].emit("error", [
                                sock.stream.fd,
                                sock.error,
                                "ECONNREFUSED: Connection refused"
                            ]);
                            // don't throw
                        });
                    } else {
                        peer.socket.onopen = handleOpen;
                        peer.socket.onclose = function () {
                            Module["websocket"].emit("close", sock.stream.fd);
                        };
                        peer.socket.onmessage = function peer_socket_onmessage(event) {
                            handleMessage(event.data);
                        };
                        peer.socket.onerror = function (error) {
                            // The WebSocket spec only allows a 'simple event' to be thrown on error,
                            // so we only really know as much as ECONNREFUSED.
                            sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
                            Module["websocket"].emit("error", [
                                sock.stream.fd,
                                sock.error,
                                "ECONNREFUSED: Connection refused"
                            ]);
                        };
                    }
                },
                poll: function (sock) {
                    if (sock.type === 1 && sock.server) {
                        // listen sockets should only say they're available for reading
                        // if there are pending clients.
                        return sock.pending.length ? 64 | 1 : 0;
                    }

                    var mask = 0;
                    var dest =
                        sock.type === 1 // we only care about the socket state for connection-based sockets
                            ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport)
                            : null;

                    if (
                        sock.recv_queue.length ||
                        !dest || // connection-less sockets are always ready to read
                        (dest && dest.socket.readyState === dest.socket.CLOSING) ||
                        (dest && dest.socket.readyState === dest.socket.CLOSED)
                    ) {
                        // let recv return 0 once closed
                        mask |= 64 | 1;
                    }

                    if (
                        !dest || // connection-less sockets are always ready to write
                        (dest && dest.socket.readyState === dest.socket.OPEN)
                    ) {
                        mask |= 4;
                    }

                    if (
                        (dest && dest.socket.readyState === dest.socket.CLOSING) ||
                        (dest && dest.socket.readyState === dest.socket.CLOSED)
                    ) {
                        mask |= 16;
                    }

                    return mask;
                },
                ioctl: function (sock, request, arg) {
                    switch (request) {
                        case 21531:
                            var bytes = 0;
                            if (sock.recv_queue.length) {
                                bytes = sock.recv_queue[0].data.length;
                            }
                            HEAP32[arg >> 2] = bytes;
                            return 0;
                        default:
                            return 28;
                    }
                },
                close: function (sock) {
                    // if we've spawned a listen server, close it
                    if (sock.server) {
                        try {
                            sock.server.close();
                        } catch (e) {}
                        sock.server = null;
                    }
                    // close any peer connections
                    var peers = Object.keys(sock.peers);
                    for (var i = 0; i < peers.length; i++) {
                        var peer = sock.peers[peers[i]];
                        try {
                            peer.socket.close();
                        } catch (e) {}
                        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
                    }
                    return 0;
                },
                bind: function (sock, addr, port) {
                    if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
                        throw new FS.ErrnoError(28); // already bound
                    }
                    sock.saddr = addr;
                    sock.sport = port;
                    // in order to emulate dgram sockets, we need to launch a listen server when
                    // binding on a connection-less socket
                    // note: this is only required on the server side
                    if (sock.type === 2) {
                        // close the existing server if it exists
                        if (sock.server) {
                            sock.server.close();
                            sock.server = null;
                        }
                        // swallow error operation not supported error that occurs when binding in the
                        // browser where this isn't supported
                        try {
                            sock.sock_ops.listen(sock, 0);
                        } catch (e) {
                            if (!(e.name === "ErrnoError")) throw e;
                            if (e.errno !== 138) throw e;
                        }
                    }
                },
                connect: function (sock, addr, port) {
                    if (sock.server) {
                        throw new FS.ErrnoError(138);
                    }

                    // TODO autobind
                    // if (!sock.addr && sock.type == 2) {
                    // }

                    // early out if we're already connected / in the middle of connecting
                    if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
                        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
                        if (dest) {
                            if (dest.socket.readyState === dest.socket.CONNECTING) {
                                throw new FS.ErrnoError(7);
                            } else {
                                throw new FS.ErrnoError(30);
                            }
                        }
                    }

                    // add the socket to our peer list and set our
                    // destination address / port to match
                    var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
                    sock.daddr = peer.addr;
                    sock.dport = peer.port;

                    // always "fail" in non-blocking mode
                    throw new FS.ErrnoError(26);
                },
                listen: function (sock, backlog) {
                    if (!ENVIRONMENT_IS_NODE) {
                        throw new FS.ErrnoError(138);
                    }
                    if (sock.server) {
                        throw new FS.ErrnoError(28); // already listening
                    }
                    var WebSocketServer = require("ws").Server;
                    var host = sock.saddr;
                    sock.server = new WebSocketServer({
                        host: host,
                        port: sock.sport
                        // TODO support backlog
                    });
                    Module["websocket"].emit("listen", sock.stream.fd); // Send Event with listen fd.

                    sock.server.on("connection", function (ws) {
                        if (sock.type === 1) {
                            var newsock = SOCKFS.createSocket(
                                sock.family,
                                sock.type,
                                sock.protocol
                            );

                            // create a peer on the new socket
                            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
                            newsock.daddr = peer.addr;
                            newsock.dport = peer.port;

                            // push to queue for accept to pick up
                            sock.pending.push(newsock);
                            Module["websocket"].emit("connection", newsock.stream.fd);
                        } else {
                            // create a peer on the listen socket so calling sendto
                            // with the listen socket and an address will resolve
                            // to the correct client
                            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
                            Module["websocket"].emit("connection", sock.stream.fd);
                        }
                    });
                    sock.server.on("close", function () {
                        Module["websocket"].emit("close", sock.stream.fd);
                        sock.server = null;
                    });
                    sock.server.on("error", function (error) {
                        // Although the ws library may pass errors that may be more descriptive than
                        // ECONNREFUSED they are not necessarily the expected error code e.g.
                        // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
                        // is still probably the most useful thing to do. This error shouldn't
                        // occur in a well written app as errors should get trapped in the compiled
                        // app's own getaddrinfo call.
                        sock.error = 23; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
                        Module["websocket"].emit("error", [
                            sock.stream.fd,
                            sock.error,
                            "EHOSTUNREACH: Host is unreachable"
                        ]);
                        // don't throw
                    });
                },
                accept: function (listensock) {
                    if (!listensock.server || !listensock.pending.length) {
                        throw new FS.ErrnoError(28);
                    }
                    var newsock = listensock.pending.shift();
                    newsock.stream.flags = listensock.stream.flags;
                    return newsock;
                },
                getname: function (sock, peer) {
                    var addr, port;
                    if (peer) {
                        if (sock.daddr === undefined || sock.dport === undefined) {
                            throw new FS.ErrnoError(53);
                        }
                        addr = sock.daddr;
                        port = sock.dport;
                    } else {
                        // TODO saddr and sport will be set for bind()'d UDP sockets, but what
                        // should we be returning for TCP sockets that've been connect()'d?
                        addr = sock.saddr || 0;
                        port = sock.sport || 0;
                    }
                    return { addr: addr, port: port };
                },
                sendmsg: function (sock, buffer, offset, length, addr, port) {
                    if (sock.type === 2) {
                        // connection-less sockets will honor the message address,
                        // and otherwise fall back to the bound destination address
                        if (addr === undefined || port === undefined) {
                            addr = sock.daddr;
                            port = sock.dport;
                        }
                        // if there was no address to fall back to, error out
                        if (addr === undefined || port === undefined) {
                            throw new FS.ErrnoError(17);
                        }
                    } else {
                        // connection-based sockets will only use the bound
                        addr = sock.daddr;
                        port = sock.dport;
                    }

                    // find the peer for the destination address
                    var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);

                    // early out if not connected with a connection-based socket
                    if (sock.type === 1) {
                        if (
                            !dest ||
                            dest.socket.readyState === dest.socket.CLOSING ||
                            dest.socket.readyState === dest.socket.CLOSED
                        ) {
                            throw new FS.ErrnoError(53);
                        } else if (dest.socket.readyState === dest.socket.CONNECTING) {
                            throw new FS.ErrnoError(6);
                        }
                    }

                    // create a copy of the incoming data to send, as the WebSocket API
                    // doesn't work entirely with an ArrayBufferView, it'll just send
                    // the entire underlying buffer
                    if (ArrayBuffer.isView(buffer)) {
                        offset += buffer.byteOffset;
                        buffer = buffer.buffer;
                    }

                    var data;
                    data = buffer.slice(offset, offset + length);

                    // if we're emulating a connection-less dgram socket and don't have
                    // a cached connection, queue the buffer to send upon connect and
                    // lie, saying the data was sent now.
                    if (sock.type === 2) {
                        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
                            // if we're not connected, open a new connection
                            if (
                                !dest ||
                                dest.socket.readyState === dest.socket.CLOSING ||
                                dest.socket.readyState === dest.socket.CLOSED
                            ) {
                                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
                            }
                            dest.dgram_send_queue.push(data);
                            return length;
                        }
                    }

                    try {
                        // send the actual data
                        dest.socket.send(data);
                        return length;
                    } catch (e) {
                        throw new FS.ErrnoError(28);
                    }
                },
                recvmsg: function (sock, length) {
                    // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
                    if (sock.type === 1 && sock.server) {
                        // tcp servers should not be recv()'ing on the listen socket
                        throw new FS.ErrnoError(53);
                    }

                    var queued = sock.recv_queue.shift();
                    if (!queued) {
                        if (sock.type === 1) {
                            var dest = SOCKFS.websocket_sock_ops.getPeer(
                                sock,
                                sock.daddr,
                                sock.dport
                            );

                            if (!dest) {
                                // if we have a destination address but are not connected, error out
                                throw new FS.ErrnoError(53);
                            }
                            if (
                                dest.socket.readyState === dest.socket.CLOSING ||
                                dest.socket.readyState === dest.socket.CLOSED
                            ) {
                                // return null if the socket has closed
                                return null;
                            }
                            // else, our socket is in a valid state but truly has nothing available
                            throw new FS.ErrnoError(6);
                        }
                        throw new FS.ErrnoError(6);
                    }

                    // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
                    // requeued TCP data it'll be an ArrayBufferView
                    var queuedLength = queued.data.byteLength || queued.data.length;
                    var queuedOffset = queued.data.byteOffset || 0;
                    var queuedBuffer = queued.data.buffer || queued.data;
                    var bytesRead = Math.min(length, queuedLength);
                    var res = {
                        buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
                        addr: queued.addr,
                        port: queued.port
                    };

                    // push back any unread data for TCP connections
                    if (sock.type === 1 && bytesRead < queuedLength) {
                        var bytesRemaining = queuedLength - bytesRead;
                        queued.data = new Uint8Array(
                            queuedBuffer,
                            queuedOffset + bytesRead,
                            bytesRemaining
                        );
                        sock.recv_queue.unshift(queued);
                    }

                    return res;
                }
            }
        };

        function getSocketFromFD(fd) {
            var socket = SOCKFS.getSocket(fd);
            if (!socket) throw new FS.ErrnoError(8);
            return socket;
        }

        function setErrNo(value) {
            HEAP32[___errno_location() >> 2] = value;
            return value;
        }
        var Sockets = {
            BUFFER_SIZE: 10240,
            MAX_BUFFER_SIZE: 10485760,
            nextFd: 1,
            fds: {},
            nextport: 1,
            maxport: 65535,
            peer: null,
            connections: {},
            portmap: {},
            localAddr: 4261412874,
            addrPool: [
                33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954,
                167772170, 184549386, 201326602, 218103818, 234881034
            ]
        };

        function inetPton4(str) {
            var b = str.split(".");
            for (var i = 0; i < 4; i++) {
                var tmp = Number(b[i]);
                if (isNaN(tmp)) return null;
                b[i] = tmp;
            }
            return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
        }

        /** @suppress {checkTypes} */
        function jstoi_q(str) {
            return parseInt(str);
        }
        function inetPton6(str) {
            var words;
            var w, offset, z, i;
            /* http://home.deds.nl/~aeron/regex/ */
            var valid6regx =
                /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
            var parts = [];
            if (!valid6regx.test(str)) {
                return null;
            }
            if (str === "::") {
                return [0, 0, 0, 0, 0, 0, 0, 0];
            }
            // Z placeholder to keep track of zeros when splitting the string on ":"
            if (str.startsWith("::")) {
                str = str.replace("::", "Z:"); // leading zeros case
            } else {
                str = str.replace("::", ":Z:");
            }

            if (str.indexOf(".") > 0) {
                // parse IPv4 embedded stress
                str = str.replace(new RegExp("[.]", "g"), ":");
                words = str.split(":");
                words[words.length - 4] =
                    jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
                words[words.length - 3] =
                    jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
                words = words.slice(0, words.length - 2);
            } else {
                words = str.split(":");
            }

            offset = 0;
            z = 0;
            for (w = 0; w < words.length; w++) {
                if (typeof words[w] == "string") {
                    if (words[w] === "Z") {
                        // compressed zeros - write appropriate number of zero words
                        for (z = 0; z < 8 - words.length + 1; z++) {
                            parts[w + z] = 0;
                        }
                        offset = z - 1;
                    } else {
                        // parse hex to field to 16-bit value and write it in network byte-order
                        parts[w + offset] = _htons(parseInt(words[w], 16));
                    }
                } else {
                    // parsed IPv4 words
                    parts[w + offset] = words[w];
                }
            }
            return [
                (parts[1] << 16) | parts[0],
                (parts[3] << 16) | parts[2],
                (parts[5] << 16) | parts[4],
                (parts[7] << 16) | parts[6]
            ];
        }

        /** @param {number=} addrlen */
        function writeSockaddr(sa, family, addr, port, addrlen) {
            switch (family) {
                case 2:
                    addr = inetPton4(addr);
                    zeroMemory(sa, 16);
                    if (addrlen) {
                        HEAP32[addrlen >> 2] = 16;
                    }
                    HEAP16[sa >> 1] = family;
                    HEAP32[(sa + 4) >> 2] = addr;
                    HEAP16[(sa + 2) >> 1] = _htons(port);
                    break;
                case 10:
                    addr = inetPton6(addr);
                    zeroMemory(sa, 28);
                    if (addrlen) {
                        HEAP32[addrlen >> 2] = 28;
                    }
                    HEAP32[sa >> 2] = family;
                    HEAP32[(sa + 8) >> 2] = addr[0];
                    HEAP32[(sa + 12) >> 2] = addr[1];
                    HEAP32[(sa + 16) >> 2] = addr[2];
                    HEAP32[(sa + 20) >> 2] = addr[3];
                    HEAP16[(sa + 2) >> 1] = _htons(port);
                    break;
                default:
                    return 5;
            }
            return 0;
        }

        var DNS = {
            address_map: { id: 1, addrs: {}, names: {} },
            lookup_name: function (name) {
                // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
                var res = inetPton4(name);
                if (res !== null) {
                    return name;
                }
                res = inetPton6(name);
                if (res !== null) {
                    return name;
                }

                // See if this name is already mapped.
                var addr;

                if (DNS.address_map.addrs[name]) {
                    addr = DNS.address_map.addrs[name];
                } else {
                    var id = DNS.address_map.id++;
                    assert(id < 65535, "exceeded max address mappings of 65535");

                    addr = "172.29." + (id & 0xff) + "." + (id & 0xff00);

                    DNS.address_map.names[addr] = name;
                    DNS.address_map.addrs[name] = addr;
                }

                return addr;
            },
            lookup_addr: function (addr) {
                if (DNS.address_map.names[addr]) {
                    return DNS.address_map.names[addr];
                }

                return null;
            }
        };

        function ___syscall_accept4(fd, addr, addrlen, flags) {
            try {
                var sock = getSocketFromFD(fd);
                var newsock = sock.sock_ops.accept(sock);
                if (addr) {
                    var errno = writeSockaddr(
                        addr,
                        newsock.family,
                        DNS.lookup_name(newsock.daddr),
                        newsock.dport,
                        addrlen
                    );
                    assert(!errno);
                }
                return newsock.stream.fd;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function inetNtop4(addr) {
            return (
                (addr & 0xff) +
                "." +
                ((addr >> 8) & 0xff) +
                "." +
                ((addr >> 16) & 0xff) +
                "." +
                ((addr >> 24) & 0xff)
            );
        }

        function inetNtop6(ints) {
            //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
            //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
            //  128-bits are split into eight 16-bit words
            //  stored in network byte order (big-endian)
            //  |                80 bits               | 16 |      32 bits        |
            //  +-----------------------------------------------------------------+
            //  |               10 bytes               |  2 |      4 bytes        |
            //  +--------------------------------------+--------------------------+
            //  +               5 words                |  1 |      2 words        |
            //  +--------------------------------------+--------------------------+
            //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
            //  +--------------------------------------+----+---------------------+
            //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
            //  +--------------------------------------+----+---------------------+
            var str = "";
            var word = 0;
            var longest = 0;
            var lastzero = 0;
            var zstart = 0;
            var len = 0;
            var i = 0;
            var parts = [
                ints[0] & 0xffff,
                ints[0] >> 16,
                ints[1] & 0xffff,
                ints[1] >> 16,
                ints[2] & 0xffff,
                ints[2] >> 16,
                ints[3] & 0xffff,
                ints[3] >> 16
            ];

            // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses

            var hasipv4 = true;
            var v4part = "";
            // check if the 10 high-order bytes are all zeros (first 5 words)
            for (i = 0; i < 5; i++) {
                if (parts[i] !== 0) {
                    hasipv4 = false;
                    break;
                }
            }

            if (hasipv4) {
                // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
                v4part = inetNtop4(parts[6] | (parts[7] << 16));
                // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
                if (parts[5] === -1) {
                    str = "::ffff:";
                    str += v4part;
                    return str;
                }
                // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
                if (parts[5] === 0) {
                    str = "::";
                    //special case IPv6 addresses
                    if (v4part === "0.0.0.0") v4part = ""; // any/unspecified address
                    if (v4part === "0.0.0.1") v4part = "1"; // loopback address
                    str += v4part;
                    return str;
                }
            }

            // Handle all other IPv6 addresses

            // first run to find the longest contiguous zero words
            for (word = 0; word < 8; word++) {
                if (parts[word] === 0) {
                    if (word - lastzero > 1) {
                        len = 0;
                    }
                    lastzero = word;
                    len++;
                }
                if (len > longest) {
                    longest = len;
                    zstart = word - longest + 1;
                }
            }

            for (word = 0; word < 8; word++) {
                if (longest > 1) {
                    // compress contiguous zeros - to produce "::"
                    if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
                        if (word === zstart) {
                            str += ":";
                            if (zstart === 0) str += ":"; //leading zeros case
                        }
                        continue;
                    }
                }
                // converts 16-bit words from big-endian to little-endian before converting to hex string
                str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
                str += word < 7 ? ":" : "";
            }
            return str;
        }

        function readSockaddr(sa, salen) {
            // family / port offsets are common to both sockaddr_in and sockaddr_in6
            var family = HEAP16[sa >> 1];
            var port = _ntohs(HEAPU16[(sa + 2) >> 1]);
            var addr;

            switch (family) {
                case 2:
                    if (salen !== 16) {
                        return { errno: 28 };
                    }
                    addr = HEAP32[(sa + 4) >> 2];
                    addr = inetNtop4(addr);
                    break;
                case 10:
                    if (salen !== 28) {
                        return { errno: 28 };
                    }
                    addr = [
                        HEAP32[(sa + 8) >> 2],
                        HEAP32[(sa + 12) >> 2],
                        HEAP32[(sa + 16) >> 2],
                        HEAP32[(sa + 20) >> 2]
                    ];
                    addr = inetNtop6(addr);
                    break;
                default:
                    return { errno: 5 };
            }

            return { family: family, addr: addr, port: port };
        }

        /** @param {boolean=} allowNull */
        function getSocketAddress(addrp, addrlen, allowNull) {
            if (allowNull && addrp === 0) return null;
            var info = readSockaddr(addrp, addrlen);
            if (info.errno) throw new FS.ErrnoError(info.errno);
            info.addr = DNS.lookup_addr(info.addr) || info.addr;
            return info;
        }

        function ___syscall_bind(fd, addr, addrlen) {
            try {
                var sock = getSocketFromFD(fd);
                var info = getSocketAddress(addr, addrlen);
                sock.sock_ops.bind(sock, info.addr, info.port);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_chdir(path) {
            try {
                path = SYSCALLS.getStr(path);
                FS.chdir(path);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_connect(fd, addr, addrlen) {
            try {
                var sock = getSocketFromFD(fd);
                var info = getSocketAddress(addr, addrlen);
                sock.sock_ops.connect(sock, info.addr, info.port);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_dup(fd) {
            try {
                var old = SYSCALLS.getStreamFromFD(fd);
                return FS.createStream(old, 0).fd;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_dup3(fd, suggestFD, flags) {
            try {
                var old = SYSCALLS.getStreamFromFD(fd);
                assert(!flags);
                if (old.fd === suggestFD) return -28;
                var suggest = FS.getStream(suggestFD);
                if (suggest) FS.close(suggest);
                return FS.createStream(old, suggestFD, suggestFD + 1).fd;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_faccessat(dirfd, path, amode, flags) {
            try {
                path = SYSCALLS.getStr(path);
                assert(flags === 0);
                path = SYSCALLS.calculateAt(dirfd, path);
                if (amode & ~7) {
                    // need a valid mode
                    return -28;
                }
                var lookup = FS.lookupPath(path, { follow: true });
                var node = lookup.node;
                if (!node) {
                    return -44;
                }
                var perms = "";
                if (amode & 4) perms += "r";
                if (amode & 2) perms += "w";
                if (amode & 1) perms += "x";
                if (
                    perms /* otherwise, they've just passed F_OK */ &&
                    FS.nodePermissions(node, perms)
                ) {
                    return -2;
                }
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_fcntl64(fd, cmd, varargs) {
            SYSCALLS.varargs = varargs;
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                switch (cmd) {
                    case 0: {
                        var arg = SYSCALLS.get();
                        if (arg < 0) {
                            return -28;
                        }
                        var newStream;
                        newStream = FS.createStream(stream, arg);
                        return newStream.fd;
                    }
                    case 1:
                    case 2:
                        return 0; // FD_CLOEXEC makes no sense for a single process.
                    case 3:
                        return stream.flags;
                    case 4: {
                        var arg = SYSCALLS.get();
                        stream.flags |= arg;
                        return 0;
                    }
                    case 5: /* case 5: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
                        var arg = SYSCALLS.get();
                        var offset = 0;
                        // We're always unlocked.
                        HEAP16[(arg + offset) >> 1] = 2;
                        return 0;
                    }
                    case 6:
                    case 7:
                        /* case 6: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
                        /* case 7: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */

                        return 0; // Pretend that the locking is successful.
                    case 16:
                    case 8:
                        return -28; // These are for sockets. We don't have them fully implemented yet.
                    case 9:
                        // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fcntl() returns that, and we set errno ourselves.
                        setErrNo(28);
                        return -1;
                    default: {
                        return -28;
                    }
                }
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_fstat64(fd, buf) {
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                return SYSCALLS.doStat(FS.stat, stream.path, buf);
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_getcwd(buf, size) {
            try {
                if (size === 0) return -28;
                var cwd = FS.cwd();
                var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
                if (size < cwdLengthInBytes) return -68;
                stringToUTF8(cwd, buf, size);
                return cwdLengthInBytes;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_getdents64(fd, dirp, count) {
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                if (!stream.getdents) {
                    stream.getdents = FS.readdir(stream.path);
                }

                var struct_size = 280;
                var pos = 0;
                var off = FS.llseek(stream, 0, 1);

                var idx = Math.floor(off / struct_size);

                while (idx < stream.getdents.length && pos + struct_size <= count) {
                    var id;
                    var type;
                    var name = stream.getdents[idx];
                    if (name === ".") {
                        id = stream.node.id;
                        type = 4; // DT_DIR
                    } else if (name === "..") {
                        var lookup = FS.lookupPath(stream.path, { parent: true });
                        id = lookup.node.id;
                        type = 4; // DT_DIR
                    } else {
                        var child = FS.lookupNode(stream.node, name);
                        id = child.id;
                        type = FS.isChrdev(child.mode)
                            ? 2 // DT_CHR, character device.
                            : FS.isDir(child.mode)
                              ? 4 // DT_DIR, directory.
                              : FS.isLink(child.mode)
                                ? 10 // DT_LNK, symbolic link.
                                : 8; // DT_REG, regular file.
                    }
                    assert(id);
                    (tempI64 = [
                        id >>> 0,
                        ((tempDouble = id),
                        +Math.abs(tempDouble) >= 1.0
                            ? tempDouble > 0.0
                                ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                      0) >>>
                                  0
                                : ~~+Math.ceil(
                                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0
                                  ) >>> 0
                            : 0)
                    ]),
                        (HEAP32[(dirp + pos) >> 2] = tempI64[0]),
                        (HEAP32[(dirp + pos + 4) >> 2] = tempI64[1]);
                    (tempI64 = [
                        ((idx + 1) * struct_size) >>> 0,
                        ((tempDouble = (idx + 1) * struct_size),
                        +Math.abs(tempDouble) >= 1.0
                            ? tempDouble > 0.0
                                ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                      0) >>>
                                  0
                                : ~~+Math.ceil(
                                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0
                                  ) >>> 0
                            : 0)
                    ]),
                        (HEAP32[(dirp + pos + 8) >> 2] = tempI64[0]),
                        (HEAP32[(dirp + pos + 12) >> 2] = tempI64[1]);
                    HEAP16[(dirp + pos + 16) >> 1] = 280;
                    HEAP8[(dirp + pos + 18) >> 0] = type;
                    stringToUTF8(name, dirp + pos + 19, 256);
                    pos += struct_size;
                    idx += 1;
                }
                FS.llseek(stream, idx * struct_size, 0);
                return pos;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_getpeername(fd, addr, addrlen) {
            try {
                var sock = getSocketFromFD(fd);
                if (!sock.daddr) {
                    return -53; // The socket is not connected.
                }
                var errno = writeSockaddr(
                    addr,
                    sock.family,
                    DNS.lookup_name(sock.daddr),
                    sock.dport,
                    addrlen
                );
                assert(!errno);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_getsockname(fd, addr, addrlen) {
            try {
                err("__syscall_getsockname " + fd);
                var sock = getSocketFromFD(fd);
                // TODO: sock.saddr should never be undefined, see TODO in websocket_sock_ops.getname
                var errno = writeSockaddr(
                    addr,
                    sock.family,
                    DNS.lookup_name(sock.saddr || "0.0.0.0"),
                    sock.sport,
                    addrlen
                );
                assert(!errno);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_getsockopt(fd, level, optname, optval, optlen) {
            try {
                var sock = getSocketFromFD(fd);
                // Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
                // so only supports SOL_SOCKET with SO_ERROR.
                if (level === 1) {
                    if (optname === 4) {
                        HEAP32[optval >> 2] = sock.error;
                        HEAP32[optlen >> 2] = 4;
                        sock.error = null; // Clear the error (The SO_ERROR option obtains and then clears this field).
                        return 0;
                    }
                }
                return -50; // The option is unknown at the level indicated.
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_ioctl(fd, op, varargs) {
            SYSCALLS.varargs = varargs;
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                switch (op) {
                    case 21509:
                    case 21505: {
                        if (!stream.tty) return -59;
                        return 0;
                    }
                    case 21510:
                    case 21511:
                    case 21512:
                    case 21506:
                    case 21507:
                    case 21508: {
                        if (!stream.tty) return -59;
                        return 0; // no-op, not actually adjusting terminal settings
                    }
                    case 21519: {
                        if (!stream.tty) return -59;
                        var argp = SYSCALLS.get();
                        HEAP32[argp >> 2] = 0;
                        return 0;
                    }
                    case 21520: {
                        if (!stream.tty) return -59;
                        return -28; // not supported
                    }
                    case 21531: {
                        var argp = SYSCALLS.get();
                        return FS.ioctl(stream, op, argp);
                    }
                    case 21523: {
                        // TODO: in theory we should write to the winsize struct that gets
                        // passed in, but for now musl doesn't read anything on it
                        if (!stream.tty) return -59;
                        return 0;
                    }
                    case 21524: {
                        // TODO: technically, this ioctl call should change the window size.
                        // but, since emscripten doesn't have any concept of a terminal window
                        // yet, we'll just silently throw it away as we do TIOCGWINSZ
                        if (!stream.tty) return -59;
                        return 0;
                    }
                    default:
                        return -28; // not supported
                }
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_listen(fd, backlog) {
            try {
                var sock = getSocketFromFD(fd);
                sock.sock_ops.listen(sock, backlog);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_lstat64(path, buf) {
            try {
                path = SYSCALLS.getStr(path);
                return SYSCALLS.doStat(FS.lstat, path, buf);
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_mkdirat(dirfd, path, mode) {
            try {
                path = SYSCALLS.getStr(path);
                path = SYSCALLS.calculateAt(dirfd, path);
                // remove a trailing slash, if one - /a/b/ has basename of '', but
                // we want to create b in the context of this function
                path = PATH.normalize(path);
                if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
                FS.mkdir(path, mode, 0);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_mknodat(dirfd, path, mode, dev) {
            try {
                path = SYSCALLS.getStr(path);
                path = SYSCALLS.calculateAt(dirfd, path);
                // we don't want this in the JS API as it uses mknod to create all nodes.
                switch (mode & 61440) {
                    case 32768:
                    case 8192:
                    case 24576:
                    case 4096:
                    case 49152:
                        break;
                    default:
                        return -28;
                }
                FS.mknod(path, mode, dev);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_newfstatat(dirfd, path, buf, flags) {
            try {
                path = SYSCALLS.getStr(path);
                var nofollow = flags & 256;
                var allowEmpty = flags & 4096;
                flags = flags & ~6400;
                assert(!flags, "unknown flags in __syscall_newfstatat: " + flags);
                path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
                return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_openat(dirfd, path, flags, varargs) {
            SYSCALLS.varargs = varargs;
            try {
                path = SYSCALLS.getStr(path);
                path = SYSCALLS.calculateAt(dirfd, path);
                var mode = varargs ? SYSCALLS.get() : 0;
                return FS.open(path, flags, mode).fd;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        var PIPEFS = {
            BUCKET_BUFFER_SIZE: 8192,
            mount: function (mount) {
                // Do not pollute the real root directory or its child nodes with pipes
                // Looks like it is OK to create another pseudo-root node not linked to the FS.root hierarchy this way
                return FS.createNode(null, "/", 16384 | 511 /* 0777 */, 0);
            },
            createPipe: function () {
                var pipe = {
                    buckets: [],
                    // refcnt 2 because pipe has a read end and a write end. We need to be
                    // able to read from the read end after write end is closed.
                    refcnt: 2
                };

                pipe.buckets.push({
                    buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                    offset: 0,
                    roffset: 0
                });

                var rName = PIPEFS.nextname();
                var wName = PIPEFS.nextname();
                var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
                var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);

                rNode.pipe = pipe;
                wNode.pipe = pipe;

                var readableStream = FS.createStream({
                    path: rName,
                    node: rNode,
                    flags: 0,
                    seekable: false,
                    stream_ops: PIPEFS.stream_ops
                });
                rNode.stream = readableStream;

                var writableStream = FS.createStream({
                    path: wName,
                    node: wNode,
                    flags: 1,
                    seekable: false,
                    stream_ops: PIPEFS.stream_ops
                });
                wNode.stream = writableStream;

                return {
                    readable_fd: readableStream.fd,
                    writable_fd: writableStream.fd
                };
            },
            stream_ops: {
                poll: function (stream) {
                    var pipe = stream.node.pipe;

                    if ((stream.flags & 2097155) === 1) {
                        return 256 | 4;
                    }
                    if (pipe.buckets.length > 0) {
                        for (var i = 0; i < pipe.buckets.length; i++) {
                            var bucket = pipe.buckets[i];
                            if (bucket.offset - bucket.roffset > 0) {
                                return 64 | 1;
                            }
                        }
                    }

                    return 0;
                },
                ioctl: function (stream, request, varargs) {
                    return 28;
                },
                fsync: function (stream) {
                    return 28;
                },
                read: function (stream, buffer, offset, length, position /* ignored */) {
                    var pipe = stream.node.pipe;
                    var currentLength = 0;

                    for (var i = 0; i < pipe.buckets.length; i++) {
                        var bucket = pipe.buckets[i];
                        currentLength += bucket.offset - bucket.roffset;
                    }

                    assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
                    var data = buffer.subarray(offset, offset + length);

                    if (length <= 0) {
                        return 0;
                    }
                    if (currentLength == 0) {
                        // Behave as if the read end is always non-blocking
                        throw new FS.ErrnoError(6);
                    }
                    var toRead = Math.min(currentLength, length);

                    var totalRead = toRead;
                    var toRemove = 0;

                    for (var i = 0; i < pipe.buckets.length; i++) {
                        var currBucket = pipe.buckets[i];
                        var bucketSize = currBucket.offset - currBucket.roffset;

                        if (toRead <= bucketSize) {
                            var tmpSlice = currBucket.buffer.subarray(
                                currBucket.roffset,
                                currBucket.offset
                            );
                            if (toRead < bucketSize) {
                                tmpSlice = tmpSlice.subarray(0, toRead);
                                currBucket.roffset += toRead;
                            } else {
                                toRemove++;
                            }
                            data.set(tmpSlice);
                            break;
                        } else {
                            var tmpSlice = currBucket.buffer.subarray(
                                currBucket.roffset,
                                currBucket.offset
                            );
                            data.set(tmpSlice);
                            data = data.subarray(tmpSlice.byteLength);
                            toRead -= tmpSlice.byteLength;
                            toRemove++;
                        }
                    }

                    if (toRemove && toRemove == pipe.buckets.length) {
                        // Do not generate excessive garbage in use cases such as
                        // write several bytes, read everything, write several bytes, read everything...
                        toRemove--;
                        pipe.buckets[toRemove].offset = 0;
                        pipe.buckets[toRemove].roffset = 0;
                    }

                    pipe.buckets.splice(0, toRemove);

                    return totalRead;
                },
                write: function (stream, buffer, offset, length, position /* ignored */) {
                    var pipe = stream.node.pipe;

                    assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
                    var data = buffer.subarray(offset, offset + length);

                    var dataLen = data.byteLength;
                    if (dataLen <= 0) {
                        return 0;
                    }

                    var currBucket = null;

                    if (pipe.buckets.length == 0) {
                        currBucket = {
                            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                            offset: 0,
                            roffset: 0
                        };
                        pipe.buckets.push(currBucket);
                    } else {
                        currBucket = pipe.buckets[pipe.buckets.length - 1];
                    }

                    assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);

                    var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
                    if (freeBytesInCurrBuffer >= dataLen) {
                        currBucket.buffer.set(data, currBucket.offset);
                        currBucket.offset += dataLen;
                        return dataLen;
                    } else if (freeBytesInCurrBuffer > 0) {
                        currBucket.buffer.set(
                            data.subarray(0, freeBytesInCurrBuffer),
                            currBucket.offset
                        );
                        currBucket.offset += freeBytesInCurrBuffer;
                        data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
                    }

                    var numBuckets = (data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE) | 0;
                    var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;

                    for (var i = 0; i < numBuckets; i++) {
                        var newBucket = {
                            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                            offset: PIPEFS.BUCKET_BUFFER_SIZE,
                            roffset: 0
                        };
                        pipe.buckets.push(newBucket);
                        newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
                        data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
                    }

                    if (remElements > 0) {
                        var newBucket = {
                            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
                            offset: data.byteLength,
                            roffset: 0
                        };
                        pipe.buckets.push(newBucket);
                        newBucket.buffer.set(data);
                    }

                    return dataLen;
                },
                close: function (stream) {
                    var pipe = stream.node.pipe;
                    pipe.refcnt--;
                    if (pipe.refcnt === 0) {
                        pipe.buckets = null;
                    }
                }
            },
            nextname: function () {
                if (!PIPEFS.nextname.current) {
                    PIPEFS.nextname.current = 0;
                }
                return "pipe[" + PIPEFS.nextname.current++ + "]";
            }
        };

        function ___syscall_pipe(fdPtr) {
            try {
                if (fdPtr == 0) {
                    throw new FS.ErrnoError(21);
                }

                var res = PIPEFS.createPipe();

                HEAP32[fdPtr >> 2] = res.readable_fd;
                HEAP32[(fdPtr + 4) >> 2] = res.writable_fd;

                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_poll(fds, nfds, timeout) {
            try {
                var nonzero = 0;
                for (var i = 0; i < nfds; i++) {
                    var pollfd = fds + 8 * i;
                    var fd = HEAP32[pollfd >> 2];
                    var events = HEAP16[(pollfd + 4) >> 1];
                    var mask = 32;
                    var stream = FS.getStream(fd);
                    if (stream) {
                        mask = SYSCALLS.DEFAULT_POLLMASK;
                        if (stream.stream_ops.poll) {
                            mask = stream.stream_ops.poll(stream);
                        }
                    }
                    mask &= events | 8 | 16;
                    if (mask) nonzero++;
                    HEAP16[(pollfd + 6) >> 1] = mask;
                }
                return nonzero;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
            try {
                path = SYSCALLS.getStr(path);
                path = SYSCALLS.calculateAt(dirfd, path);
                if (bufsize <= 0) return -28;
                var ret = FS.readlink(path);

                var len = Math.min(bufsize, lengthBytesUTF8(ret));
                var endChar = HEAP8[buf + len];
                stringToUTF8(ret, buf, bufsize + 1);
                // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
                // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
                HEAP8[buf + len] = endChar;
                return len;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
            try {
                var sock = getSocketFromFD(fd);
                var msg = sock.sock_ops.recvmsg(sock, len);
                if (!msg) return 0; // socket is closed
                if (addr) {
                    var errno = writeSockaddr(
                        addr,
                        sock.family,
                        DNS.lookup_name(msg.addr),
                        msg.port,
                        addrlen
                    );
                    assert(!errno);
                }
                HEAPU8.set(msg.buffer, buf);
                return msg.buffer.byteLength;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
            try {
                oldpath = SYSCALLS.getStr(oldpath);
                newpath = SYSCALLS.getStr(newpath);
                oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
                newpath = SYSCALLS.calculateAt(newdirfd, newpath);
                FS.rename(oldpath, newpath);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_rmdir(path) {
            try {
                path = SYSCALLS.getStr(path);
                FS.rmdir(path);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
            try {
                var sock = getSocketFromFD(fd);
                var dest = getSocketAddress(addr, addr_len, true);
                if (!dest) {
                    // send, no address provided
                    return FS.write(sock.stream, HEAP8, message, length);
                }
                // sendto an address
                return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_socket(domain, type, protocol) {
            try {
                var sock = SOCKFS.createSocket(domain, type, protocol);
                assert(sock.stream.fd < 64); // XXX ? select() assumes socket fd values are in 0..63
                return sock.stream.fd;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_stat64(path, buf) {
            try {
                path = SYSCALLS.getStr(path);
                return SYSCALLS.doStat(FS.stat, path, buf);
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_symlink(target, linkpath) {
            try {
                target = SYSCALLS.getStr(target);
                linkpath = SYSCALLS.getStr(linkpath);
                FS.symlink(target, linkpath);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function ___syscall_unlinkat(dirfd, path, flags) {
            try {
                path = SYSCALLS.getStr(path);
                path = SYSCALLS.calculateAt(dirfd, path);
                if (flags === 0) {
                    FS.unlink(path);
                } else if (flags === 512) {
                    FS.rmdir(path);
                } else {
                    abort("Invalid flags passed to unlinkat");
                }
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function readI53FromI64(ptr) {
            return HEAPU32[ptr >> 2] + HEAP32[(ptr + 4) >> 2] * 4294967296;
        }

        function ___syscall_utimensat(dirfd, path, times, flags) {
            try {
                path = SYSCALLS.getStr(path);
                assert(flags === 0);
                path = SYSCALLS.calculateAt(dirfd, path, true);
                if (!times) {
                    var atime = Date.now();
                    var mtime = atime;
                } else {
                    var seconds = readI53FromI64(times);
                    var nanoseconds = HEAP32[(times + 8) >> 2];
                    atime = seconds * 1000 + nanoseconds / (1000 * 1000);
                    times += 16;
                    seconds = readI53FromI64(times);
                    nanoseconds = HEAP32[(times + 8) >> 2];
                    mtime = seconds * 1000 + nanoseconds / (1000 * 1000);
                }
                FS.utime(path, atime, mtime);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        var nowIsMonotonic = true;
        function __emscripten_get_now_is_monotonic() {
            return nowIsMonotonic;
        }

        function __emscripten_throw_longjmp() {
            throw Infinity;
        }

        function __gmtime_js(time, tmPtr) {
            var date = new Date(readI53FromI64(time) * 1000);
            HEAP32[tmPtr >> 2] = date.getUTCSeconds();
            HEAP32[(tmPtr + 4) >> 2] = date.getUTCMinutes();
            HEAP32[(tmPtr + 8) >> 2] = date.getUTCHours();
            HEAP32[(tmPtr + 12) >> 2] = date.getUTCDate();
            HEAP32[(tmPtr + 16) >> 2] = date.getUTCMonth();
            HEAP32[(tmPtr + 20) >> 2] = date.getUTCFullYear() - 1900;
            HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();
            var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
            var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24)) | 0;
            HEAP32[(tmPtr + 28) >> 2] = yday;
        }

        function __isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }

        var __MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

        var __MONTH_DAYS_REGULAR_CUMULATIVE = [
            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
        ];
        function __yday_from_date(date) {
            var isLeapYear = __isLeapYear(date.getFullYear());
            var monthDaysCumulative = isLeapYear
                ? __MONTH_DAYS_LEAP_CUMULATIVE
                : __MONTH_DAYS_REGULAR_CUMULATIVE;
            var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; // -1 since it's days since Jan 1

            return yday;
        }
        function __localtime_js(time, tmPtr) {
            var date = new Date(readI53FromI64(time) * 1000);
            HEAP32[tmPtr >> 2] = date.getSeconds();
            HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();
            HEAP32[(tmPtr + 8) >> 2] = date.getHours();
            HEAP32[(tmPtr + 12) >> 2] = date.getDate();
            HEAP32[(tmPtr + 16) >> 2] = date.getMonth();
            HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;
            HEAP32[(tmPtr + 24) >> 2] = date.getDay();

            var yday = __yday_from_date(date) | 0;
            HEAP32[(tmPtr + 28) >> 2] = yday;
            HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);

            // Attention: DST is in December in South, and some regions don't have DST at all.
            var start = new Date(date.getFullYear(), 0, 1);
            var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
            var winterOffset = start.getTimezoneOffset();
            var dst =
                (summerOffset != winterOffset &&
                    date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
            HEAP32[(tmPtr + 32) >> 2] = dst;
        }

        function __mktime_js(tmPtr) {
            var date = new Date(
                HEAP32[(tmPtr + 20) >> 2] + 1900,
                HEAP32[(tmPtr + 16) >> 2],
                HEAP32[(tmPtr + 12) >> 2],
                HEAP32[(tmPtr + 8) >> 2],
                HEAP32[(tmPtr + 4) >> 2],
                HEAP32[tmPtr >> 2],
                0
            );

            // There's an ambiguous hour when the time goes back; the tm_isdst field is
            // used to disambiguate it.  Date() basically guesses, so we fix it up if it
            // guessed wrong, or fill in tm_isdst with the guess if it's -1.
            var dst = HEAP32[(tmPtr + 32) >> 2];
            var guessedOffset = date.getTimezoneOffset();
            var start = new Date(date.getFullYear(), 0, 1);
            var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
            var winterOffset = start.getTimezoneOffset();
            var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South
            if (dst < 0) {
                // Attention: some regions don't have DST at all.
                HEAP32[(tmPtr + 32) >> 2] = Number(
                    summerOffset != winterOffset && dstOffset == guessedOffset
                );
            } else if (dst > 0 != (dstOffset == guessedOffset)) {
                var nonDstOffset = Math.max(winterOffset, summerOffset);
                var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
                // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
                date.setTime(date.getTime() + (trueOffset - guessedOffset) * 60000);
            }

            HEAP32[(tmPtr + 24) >> 2] = date.getDay();
            var yday = __yday_from_date(date) | 0;
            HEAP32[(tmPtr + 28) >> 2] = yday;
            // To match expected behavior, update fields from date
            HEAP32[tmPtr >> 2] = date.getSeconds();
            HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();
            HEAP32[(tmPtr + 8) >> 2] = date.getHours();
            HEAP32[(tmPtr + 12) >> 2] = date.getDate();
            HEAP32[(tmPtr + 16) >> 2] = date.getMonth();
            HEAP32[(tmPtr + 20) >> 2] = date.getYear();

            return (date.getTime() / 1000) | 0;
        }

        function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                var res = FS.mmap(stream, len, off, prot, flags);
                var ptr = res.ptr;
                HEAP32[allocated >> 2] = res.allocated;
                HEAPU32[addr >> 2] = ptr;
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function __munmap_js(addr, len, prot, flags, fd, offset) {
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                if (prot & 2) {
                    SYSCALLS.doMsync(addr, stream, len, flags, offset);
                }
                FS.munmap(stream);
                // implicitly return 0
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return -e.errno;
            }
        }

        function __timegm_js(tmPtr) {
            var time = Date.UTC(
                HEAP32[(tmPtr + 20) >> 2] + 1900,
                HEAP32[(tmPtr + 16) >> 2],
                HEAP32[(tmPtr + 12) >> 2],
                HEAP32[(tmPtr + 8) >> 2],
                HEAP32[(tmPtr + 4) >> 2],
                HEAP32[tmPtr >> 2],
                0
            );
            var date = new Date(time);

            HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();
            var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
            var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24)) | 0;
            HEAP32[(tmPtr + 28) >> 2] = yday;

            return (date.getTime() / 1000) | 0;
        }

        function allocateUTF8(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = _malloc(size);
            if (ret) stringToUTF8Array(str, HEAP8, ret, size);
            return ret;
        }
        function __tzset_js(timezone, daylight, tzname) {
            // TODO: Use (malleable) environment variables instead of system settings.
            var currentYear = new Date().getFullYear();
            var winter = new Date(currentYear, 0, 1);
            var summer = new Date(currentYear, 6, 1);
            var winterOffset = winter.getTimezoneOffset();
            var summerOffset = summer.getTimezoneOffset();

            // Local standard timezone offset. Local standard time is not adjusted for daylight savings.
            // This code uses the fact that getTimezoneOffset returns a greater value during Standard Time versus Daylight Saving Time (DST).
            // Thus it determines the expected output during Standard Time, and it compares whether the output of the given date the same (Standard) or less (DST).
            var stdTimezoneOffset = Math.max(winterOffset, summerOffset);

            // timezone is specified as seconds west of UTC ("The external variable
            // `timezone` shall be set to the difference, in seconds, between
            // Coordinated Universal Time (UTC) and local standard time."), the same
            // as returned by stdTimezoneOffset.
            // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
            HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;

            HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);

            function extractZone(date) {
                var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
                return match ? match[1] : "GMT";
            }
            var winterName = extractZone(winter);
            var summerName = extractZone(summer);
            var winterNamePtr = allocateUTF8(winterName);
            var summerNamePtr = allocateUTF8(summerName);
            if (summerOffset < winterOffset) {
                // Northern hemisphere
                HEAPU32[tzname >> 2] = winterNamePtr;
                HEAPU32[(tzname + 4) >> 2] = summerNamePtr;
            } else {
                HEAPU32[tzname >> 2] = summerNamePtr;
                HEAPU32[(tzname + 4) >> 2] = winterNamePtr;
            }
        }

        function _abort() {
            abort("native code called abort()");
        }

        function _dlopen(handle) {
            abort(dlopenMissingError);
        }

        function _emscripten_set_main_loop_timing(mode, value) {
            Browser.mainLoop.timingMode = mode;
            Browser.mainLoop.timingValue = value;

            if (!Browser.mainLoop.func) {
                err(
                    "emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up."
                );
                return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
            }

            if (!Browser.mainLoop.running) {
                Browser.mainLoop.running = true;
            }
            if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
                Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
                    var timeUntilNextTick =
                        Math.max(
                            0,
                            Browser.mainLoop.tickStartTime + value - _emscripten_get_now()
                        ) | 0;
                    setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
                };
                Browser.mainLoop.method = "timeout";
            } else if (mode == 1 /*EM_TIMING_RAF*/) {
                Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
                    Browser.requestAnimationFrame(Browser.mainLoop.runner);
                };
                Browser.mainLoop.method = "rAF";
            } else if (mode == 2 /*EM_TIMING_SETIMMEDIATE*/) {
                if (typeof setImmediate == "undefined") {
                    // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
                    var setImmediates = [];
                    var emscriptenMainLoopMessageId = "setimmediate";
                    /** @param {Event} event */
                    var Browser_setImmediate_messageHandler = (event) => {
                        // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
                        // so check for both cases.
                        if (
                            event.data === emscriptenMainLoopMessageId ||
                            event.data.target === emscriptenMainLoopMessageId
                        ) {
                            event.stopPropagation();
                            setImmediates.shift()();
                        }
                    };
                    addEventListener("message", Browser_setImmediate_messageHandler, true);
                    setImmediate = /** @type{function(function(): ?, ...?): number} */ (
                        function Browser_emulated_setImmediate(func) {
                            setImmediates.push(func);
                            if (ENVIRONMENT_IS_WORKER) {
                                if (Module["setImmediates"] === undefined)
                                    Module["setImmediates"] = [];
                                Module["setImmediates"].push(func);
                                postMessage({ target: emscriptenMainLoopMessageId }); // In --proxy-to-worker, route the message via proxyClient.js
                            } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
                        }
                    );
                }
                Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
                    setImmediate(Browser.mainLoop.runner);
                };
                Browser.mainLoop.method = "immediate";
            }
            return 0;
        }

        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) {
            _emscripten_get_now = () => {
                var t = process.hrtime();
                return t[0] * 1e3 + t[1] / 1e6;
            };
        } else _emscripten_get_now = () => performance.now();
        /**
         * @param {number=} arg
         * @param {boolean=} noSetTiming
         */
        function setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) {
            assert(
                !Browser.mainLoop.func,
                "emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters."
            );

            Browser.mainLoop.func = browserIterationFunc;
            Browser.mainLoop.arg = arg;

            var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
            function checkIsRunning() {
                if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {
                    return false;
                }
                return true;
            }

            // We create the loop runner here but it is not actually running until
            // _emscripten_set_main_loop_timing is called (which might happen a
            // later time).  This member signifies that the current runner has not
            // yet been started so that we can call runtimeKeepalivePush when it
            // gets it timing set for the first time.
            Browser.mainLoop.running = false;
            Browser.mainLoop.runner = function Browser_mainLoop_runner() {
                if (ABORT) return;
                if (Browser.mainLoop.queue.length > 0) {
                    var start = Date.now();
                    var blocker = Browser.mainLoop.queue.shift();
                    blocker.func(blocker.arg);
                    if (Browser.mainLoop.remainingBlockers) {
                        var remaining = Browser.mainLoop.remainingBlockers;
                        var next = remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);
                        if (blocker.counted) {
                            Browser.mainLoop.remainingBlockers = next;
                        } else {
                            // not counted, but move the progress along a tiny bit
                            next = next + 0.5; // do not steal all the next one's progress
                            Browser.mainLoop.remainingBlockers = (8 * remaining + next) / 9;
                        }
                    }
                    out(
                        'main loop blocker "' +
                            blocker.name +
                            '" took ' +
                            (Date.now() - start) +
                            " ms"
                    ); //, left: ' + Browser.mainLoop.remainingBlockers);
                    Browser.mainLoop.updateStatus();

                    // catches pause/resume main loop from blocker execution
                    if (!checkIsRunning()) return;

                    setTimeout(Browser.mainLoop.runner, 0);
                    return;
                }

                // catch pauses from non-main loop sources
                if (!checkIsRunning()) return;

                // Implement very basic swap interval control
                Browser.mainLoop.currentFrameNumber = (Browser.mainLoop.currentFrameNumber + 1) | 0;
                if (
                    Browser.mainLoop.timingMode == 1 /*EM_TIMING_RAF*/ &&
                    Browser.mainLoop.timingValue > 1 &&
                    Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0
                ) {
                    // Not the scheduled time to render this frame - skip.
                    Browser.mainLoop.scheduler();
                    return;
                } else if (Browser.mainLoop.timingMode == 0 /*EM_TIMING_SETTIMEOUT*/) {
                    Browser.mainLoop.tickStartTime = _emscripten_get_now();
                }

                // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
                // VBO double-buffering and reduce GPU stalls.

                if (Browser.mainLoop.method === "timeout" && Module.ctx) {
                    warnOnce(
                        "Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!"
                    );
                    Browser.mainLoop.method = ""; // just warn once per call to set main loop
                }

                Browser.mainLoop.runIter(browserIterationFunc);

                checkStackCookie();

                // catch pauses from the main loop itself
                if (!checkIsRunning()) return;

                // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
                // to queue the newest produced audio samples.
                // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
                //       do not need to be hardcoded into this function, but can be more generic.
                if (typeof SDL == "object" && SDL.audio && SDL.audio.queueNewAudioData)
                    SDL.audio.queueNewAudioData();

                Browser.mainLoop.scheduler();
            };

            if (!noSetTiming) {
                if (fps && fps > 0)
                    _emscripten_set_main_loop_timing(0 /*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
                else _emscripten_set_main_loop_timing(1 /*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)

                Browser.mainLoop.scheduler();
            }

            if (simulateInfiniteLoop) {
                throw "unwind";
            }
        }

        function handleException(e) {
            // Certain exception types we do not treat as errors since they are used for
            // internal control flow.
            // 1. ExitStatus, which is thrown by exit()
            // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
            //    that wish to return to JS event loop.
            if (e instanceof ExitStatus || e == "unwind") {
                return EXITSTATUS;
            }
            checkStackCookie();
            if (e instanceof WebAssembly.RuntimeError) {
                if (_emscripten_stack_get_current() <= 0) {
                    err(
                        "Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to " +
                            1048576 +
                            ")"
                    );
                }
            }
            quit_(1, e);
        }
        function callUserCallback(func) {
            if (ABORT) {
                err(
                    "user callback triggered after runtime exited or application aborted.  Ignoring."
                );
                return;
            }
            try {
                func();
            } catch (e) {
                handleException(e);
            }
        }

        /** @param {number=} timeout */
        function safeSetTimeout(func, timeout) {
            return setTimeout(function () {
                callUserCallback(func);
            }, timeout);
        }

        var Browser = {
            mainLoop: {
                running: false,
                scheduler: null,
                method: "",
                currentlyRunningMainloop: 0,
                func: null,
                arg: 0,
                timingMode: 0,
                timingValue: 0,
                currentFrameNumber: 0,
                queue: [],
                pause: function () {
                    Browser.mainLoop.scheduler = null;
                    // Incrementing this signals the previous main loop that it's now become old, and it must return.
                    Browser.mainLoop.currentlyRunningMainloop++;
                },
                resume: function () {
                    Browser.mainLoop.currentlyRunningMainloop++;
                    var timingMode = Browser.mainLoop.timingMode;
                    var timingValue = Browser.mainLoop.timingValue;
                    var func = Browser.mainLoop.func;
                    Browser.mainLoop.func = null;
                    // do not set timing and call scheduler, we will do it on the next lines
                    setMainLoop(func, 0, false, Browser.mainLoop.arg, true);
                    _emscripten_set_main_loop_timing(timingMode, timingValue);
                    Browser.mainLoop.scheduler();
                },
                updateStatus: function () {
                    if (Module["setStatus"]) {
                        var message = Module["statusMessage"] || "Please wait...";
                        var remaining = Browser.mainLoop.remainingBlockers;
                        var expected = Browser.mainLoop.expectedBlockers;
                        if (remaining) {
                            if (remaining < expected) {
                                Module["setStatus"](
                                    message + " (" + (expected - remaining) + "/" + expected + ")"
                                );
                            } else {
                                Module["setStatus"](message);
                            }
                        } else {
                            Module["setStatus"]("");
                        }
                    }
                },
                runIter: function (func) {
                    if (ABORT) return;
                    if (Module["preMainLoop"]) {
                        var preRet = Module["preMainLoop"]();
                        if (preRet === false) {
                            return; // |return false| skips a frame
                        }
                    }
                    callUserCallback(func);
                    if (Module["postMainLoop"]) Module["postMainLoop"]();
                }
            },
            isFullscreen: false,
            pointerLock: false,
            moduleContextCreatedCallbacks: [],
            workers: [],
            init: function () {
                if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers

                if (Browser.initted) return;
                Browser.initted = true;

                try {
                    new Blob();
                    Browser.hasBlobConstructor = true;
                } catch (e) {
                    Browser.hasBlobConstructor = false;
                    err("warning: no blob constructor, cannot create blobs with mimetypes");
                }
                Browser.BlobBuilder =
                    typeof MozBlobBuilder != "undefined"
                        ? MozBlobBuilder
                        : typeof WebKitBlobBuilder != "undefined"
                          ? WebKitBlobBuilder
                          : !Browser.hasBlobConstructor
                            ? err("warning: no BlobBuilder")
                            : null;
                Browser.URLObject =
                    typeof window != "undefined"
                        ? window.URL
                            ? window.URL
                            : window.webkitURL
                        : undefined;
                if (!Module.noImageDecoding && typeof Browser.URLObject == "undefined") {
                    err(
                        "warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available."
                    );
                    Module.noImageDecoding = true;
                }

                // Support for plugins that can process preloaded files. You can add more of these to
                // your app by creating and appending to Module.preloadPlugins.
                //
                // Each plugin is asked if it can handle a file based on the file's name. If it can,
                // it is given the file's raw data. When it is done, it calls a callback with the file's
                // (possibly modified) data. For example, a plugin might decompress a file, or it
                // might create some side data structure for use later (like an Image element, etc.).

                var imagePlugin = {};
                imagePlugin["canHandle"] = function imagePlugin_canHandle(name) {
                    return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
                };
                imagePlugin["handle"] = function imagePlugin_handle(
                    byteArray,
                    name,
                    onload,
                    onerror
                ) {
                    var b = null;
                    if (Browser.hasBlobConstructor) {
                        try {
                            b = new Blob([byteArray], { type: Browser.getMimetype(name) });
                            if (b.size !== byteArray.length) {
                                // Safari bug #118630
                                // Safari's Blob can only take an ArrayBuffer
                                b = new Blob([new Uint8Array(byteArray).buffer], {
                                    type: Browser.getMimetype(name)
                                });
                            }
                        } catch (e) {
                            warnOnce(
                                "Blob constructor present but fails: " +
                                    e +
                                    "; falling back to blob builder"
                            );
                        }
                    }
                    if (!b) {
                        var bb = new Browser.BlobBuilder();
                        bb.append(new Uint8Array(byteArray).buffer); // we need to pass a buffer, and must copy the array to get the right data range
                        b = bb.getBlob();
                    }
                    var url = Browser.URLObject.createObjectURL(b);
                    assert(typeof url == "string", "createObjectURL must return a url as a string");
                    var img = new Image();
                    img.onload = () => {
                        assert(img.complete, "Image " + name + " could not be decoded");
                        var canvas = /** @type {!HTMLCanvasElement} */ (
                            document.createElement("canvas")
                        );
                        canvas.width = img.width;
                        canvas.height = img.height;
                        var ctx = canvas.getContext("2d");
                        ctx.drawImage(img, 0, 0);
                        preloadedImages[name] = canvas;
                        Browser.URLObject.revokeObjectURL(url);
                        if (onload) onload(byteArray);
                    };
                    img.onerror = (event) => {
                        out("Image " + url + " could not be decoded");
                        if (onerror) onerror();
                    };
                    img.src = url;
                };
                Module["preloadPlugins"].push(imagePlugin);

                var audioPlugin = {};
                audioPlugin["canHandle"] = function audioPlugin_canHandle(name) {
                    return (
                        !Module.noAudioDecoding &&
                        name.substr(-4) in { ".ogg": 1, ".wav": 1, ".mp3": 1 }
                    );
                };
                audioPlugin["handle"] = function audioPlugin_handle(
                    byteArray,
                    name,
                    onload,
                    onerror
                ) {
                    var done = false;
                    function finish(audio) {
                        if (done) return;
                        done = true;
                        preloadedAudios[name] = audio;
                        if (onload) onload(byteArray);
                    }
                    function fail() {
                        if (done) return;
                        done = true;
                        preloadedAudios[name] = new Audio(); // empty shim
                        if (onerror) onerror();
                    }
                    if (Browser.hasBlobConstructor) {
                        try {
                            var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
                        } catch (e) {
                            return fail();
                        }
                        var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
                        assert(
                            typeof url == "string",
                            "createObjectURL must return a url as a string"
                        );
                        var audio = new Audio();
                        audio.addEventListener("canplaythrough", () => finish(audio), false); // use addEventListener due to chromium bug 124926
                        audio.onerror = function audio_onerror(event) {
                            if (done) return;
                            err(
                                "warning: browser could not fully decode audio " +
                                    name +
                                    ", trying slower base64 approach"
                            );
                            function encode64(data) {
                                var BASE =
                                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                                var PAD = "=";
                                var ret = "";
                                var leftchar = 0;
                                var leftbits = 0;
                                for (var i = 0; i < data.length; i++) {
                                    leftchar = (leftchar << 8) | data[i];
                                    leftbits += 8;
                                    while (leftbits >= 6) {
                                        var curr = (leftchar >> (leftbits - 6)) & 0x3f;
                                        leftbits -= 6;
                                        ret += BASE[curr];
                                    }
                                }
                                if (leftbits == 2) {
                                    ret += BASE[(leftchar & 3) << 4];
                                    ret += PAD + PAD;
                                } else if (leftbits == 4) {
                                    ret += BASE[(leftchar & 0xf) << 2];
                                    ret += PAD;
                                }
                                return ret;
                            }
                            audio.src =
                                "data:audio/x-" +
                                name.substr(-3) +
                                ";base64," +
                                encode64(byteArray);
                            finish(audio); // we don't wait for confirmation this worked - but it's worth trying
                        };
                        audio.src = url;
                        // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
                        safeSetTimeout(function () {
                            finish(audio); // try to use it even though it is not necessarily ready to play
                        }, 10000);
                    } else {
                        return fail();
                    }
                };
                Module["preloadPlugins"].push(audioPlugin);

                // Canvas event setup

                function pointerLockChange() {
                    Browser.pointerLock =
                        document["pointerLockElement"] === Module["canvas"] ||
                        document["mozPointerLockElement"] === Module["canvas"] ||
                        document["webkitPointerLockElement"] === Module["canvas"] ||
                        document["msPointerLockElement"] === Module["canvas"];
                }
                var canvas = Module["canvas"];
                if (canvas) {
                    // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
                    // Module['forcedAspectRatio'] = 4 / 3;

                    canvas.requestPointerLock =
                        canvas["requestPointerLock"] ||
                        canvas["mozRequestPointerLock"] ||
                        canvas["webkitRequestPointerLock"] ||
                        canvas["msRequestPointerLock"] ||
                        (() => {});
                    canvas.exitPointerLock =
                        document["exitPointerLock"] ||
                        document["mozExitPointerLock"] ||
                        document["webkitExitPointerLock"] ||
                        document["msExitPointerLock"] ||
                        (() => {}); // no-op if function does not exist
                    canvas.exitPointerLock = canvas.exitPointerLock.bind(document);

                    document.addEventListener("pointerlockchange", pointerLockChange, false);
                    document.addEventListener("mozpointerlockchange", pointerLockChange, false);
                    document.addEventListener("webkitpointerlockchange", pointerLockChange, false);
                    document.addEventListener("mspointerlockchange", pointerLockChange, false);

                    if (Module["elementPointerLock"]) {
                        canvas.addEventListener(
                            "click",
                            (ev) => {
                                if (!Browser.pointerLock && Module["canvas"].requestPointerLock) {
                                    Module["canvas"].requestPointerLock();
                                    ev.preventDefault();
                                }
                            },
                            false
                        );
                    }
                }
            },
            handledByPreloadPlugin: function (byteArray, fullname, finish, onerror) {
                // Ensure plugins are ready.
                Browser.init();

                var handled = false;
                Module["preloadPlugins"].forEach(function (plugin) {
                    if (handled) return;
                    if (plugin["canHandle"](fullname)) {
                        plugin["handle"](byteArray, fullname, finish, onerror);
                        handled = true;
                    }
                });
                return handled;
            },
            createContext: function (
                /** @type {HTMLCanvasElement} */ canvas,
                useWebGL,
                setInModule,
                webGLContextAttributes
            ) {
                if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.

                var ctx;
                var contextHandle;
                if (useWebGL) {
                    // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
                    var contextAttributes = {
                        antialias: false,
                        alpha: false,
                        majorVersion: 1
                    };

                    if (webGLContextAttributes) {
                        for (var attribute in webGLContextAttributes) {
                            contextAttributes[attribute] = webGLContextAttributes[attribute];
                        }
                    }

                    // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
                    // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
                    // Browser.createContext() should not even be emitted.
                    if (typeof GL != "undefined") {
                        contextHandle = GL.createContext(canvas, contextAttributes);
                        if (contextHandle) {
                            ctx = GL.getContext(contextHandle).GLctx;
                        }
                    }
                } else {
                    ctx = canvas.getContext("2d");
                }

                if (!ctx) return null;

                if (setInModule) {
                    if (!useWebGL)
                        assert(
                            typeof GLctx == "undefined",
                            "cannot set in module if GLctx is used, but we are a non-GL context that would replace it"
                        );

                    Module.ctx = ctx;
                    if (useWebGL) GL.makeContextCurrent(contextHandle);
                    Module.useWebGL = useWebGL;
                    Browser.moduleContextCreatedCallbacks.forEach(function (callback) {
                        callback();
                    });
                    Browser.init();
                }
                return ctx;
            },
            destroyContext: function (canvas, useWebGL, setInModule) {},
            fullscreenHandlersInstalled: false,
            lockPointer: undefined,
            resizeCanvas: undefined,
            requestFullscreen: function (lockPointer, resizeCanvas) {
                Browser.lockPointer = lockPointer;
                Browser.resizeCanvas = resizeCanvas;
                if (typeof Browser.lockPointer == "undefined") Browser.lockPointer = true;
                if (typeof Browser.resizeCanvas == "undefined") Browser.resizeCanvas = false;

                var canvas = Module["canvas"];
                function fullscreenChange() {
                    Browser.isFullscreen = false;
                    var canvasContainer = canvas.parentNode;
                    if (
                        (document["fullscreenElement"] ||
                            document["mozFullScreenElement"] ||
                            document["msFullscreenElement"] ||
                            document["webkitFullscreenElement"] ||
                            document["webkitCurrentFullScreenElement"]) === canvasContainer
                    ) {
                        canvas.exitFullscreen = Browser.exitFullscreen;
                        if (Browser.lockPointer) canvas.requestPointerLock();
                        Browser.isFullscreen = true;
                        if (Browser.resizeCanvas) {
                            Browser.setFullscreenCanvasSize();
                        } else {
                            Browser.updateCanvasDimensions(canvas);
                        }
                    } else {
                        // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
                        canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
                        canvasContainer.parentNode.removeChild(canvasContainer);

                        if (Browser.resizeCanvas) {
                            Browser.setWindowedCanvasSize();
                        } else {
                            Browser.updateCanvasDimensions(canvas);
                        }
                    }
                    if (Module["onFullScreen"]) Module["onFullScreen"](Browser.isFullscreen);
                    if (Module["onFullscreen"]) Module["onFullscreen"](Browser.isFullscreen);
                }

                if (!Browser.fullscreenHandlersInstalled) {
                    Browser.fullscreenHandlersInstalled = true;
                    document.addEventListener("fullscreenchange", fullscreenChange, false);
                    document.addEventListener("mozfullscreenchange", fullscreenChange, false);
                    document.addEventListener("webkitfullscreenchange", fullscreenChange, false);
                    document.addEventListener("MSFullscreenChange", fullscreenChange, false);
                }

                // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
                var canvasContainer = document.createElement("div");
                canvas.parentNode.insertBefore(canvasContainer, canvas);
                canvasContainer.appendChild(canvas);

                // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
                canvasContainer.requestFullscreen =
                    canvasContainer["requestFullscreen"] ||
                    canvasContainer["mozRequestFullScreen"] ||
                    canvasContainer["msRequestFullscreen"] ||
                    (canvasContainer["webkitRequestFullscreen"]
                        ? () =>
                              canvasContainer["webkitRequestFullscreen"](
                                  Element["ALLOW_KEYBOARD_INPUT"]
                              )
                        : null) ||
                    (canvasContainer["webkitRequestFullScreen"]
                        ? () =>
                              canvasContainer["webkitRequestFullScreen"](
                                  Element["ALLOW_KEYBOARD_INPUT"]
                              )
                        : null);

                canvasContainer.requestFullscreen();
            },
            requestFullScreen: function () {
                abort(
                    "Module.requestFullScreen has been replaced by Module.requestFullscreen (without a capital S)"
                );
            },
            exitFullscreen: function () {
                // This is workaround for chrome. Trying to exit from fullscreen
                // not in fullscreen state will cause "TypeError: Document not active"
                // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
                if (!Browser.isFullscreen) {
                    return false;
                }

                var CFS =
                    document["exitFullscreen"] ||
                    document["cancelFullScreen"] ||
                    document["mozCancelFullScreen"] ||
                    document["msExitFullscreen"] ||
                    document["webkitCancelFullScreen"] ||
                    function () {};
                CFS.apply(document, []);
                return true;
            },
            nextRAF: 0,
            fakeRequestAnimationFrame: function (func) {
                // try to keep 60fps between calls to here
                var now = Date.now();
                if (Browser.nextRAF === 0) {
                    Browser.nextRAF = now + 1000 / 60;
                } else {
                    while (now + 2 >= Browser.nextRAF) {
                        // fudge a little, to avoid timer jitter causing us to do lots of delay:0
                        Browser.nextRAF += 1000 / 60;
                    }
                }
                var delay = Math.max(Browser.nextRAF - now, 0);
                setTimeout(func, delay);
            },
            requestAnimationFrame: function (func) {
                if (typeof requestAnimationFrame == "function") {
                    requestAnimationFrame(func);
                    return;
                }
                var RAF = Browser.fakeRequestAnimationFrame;
                RAF(func);
            },
            safeSetTimeout: function (func, timeout) {
                // Legacy function, this is used by the SDL2 port so we need to keep it
                // around at least until that is updated.
                // See https://github.com/libsdl-org/SDL/pull/6304
                return safeSetTimeout(func, timeout);
            },
            safeRequestAnimationFrame: function (func) {
                return Browser.requestAnimationFrame(function () {
                    callUserCallback(func);
                });
            },
            getMimetype: function (name) {
                return {
                    jpg: "image/jpeg",
                    jpeg: "image/jpeg",
                    png: "image/png",
                    bmp: "image/bmp",
                    ogg: "audio/ogg",
                    wav: "audio/wav",
                    mp3: "audio/mpeg"
                }[name.substr(name.lastIndexOf(".") + 1)];
            },
            getUserMedia: function (func) {
                if (!window.getUserMedia) {
                    window.getUserMedia = navigator["getUserMedia"] || navigator["mozGetUserMedia"];
                }
                window.getUserMedia(func);
            },
            getMovementX: function (event) {
                return event["movementX"] || event["mozMovementX"] || event["webkitMovementX"] || 0;
            },
            getMovementY: function (event) {
                return event["movementY"] || event["mozMovementY"] || event["webkitMovementY"] || 0;
            },
            getMouseWheelDelta: function (event) {
                var delta = 0;
                switch (event.type) {
                    case "DOMMouseScroll":
                        // 3 lines make up a step
                        delta = event.detail / 3;
                        break;
                    case "mousewheel":
                        // 120 units make up a step
                        delta = event.wheelDelta / 120;
                        break;
                    case "wheel":
                        delta = event.deltaY;
                        switch (event.deltaMode) {
                            case 0:
                                // DOM_DELTA_PIXEL: 100 pixels make up a step
                                delta /= 100;
                                break;
                            case 1:
                                // DOM_DELTA_LINE: 3 lines make up a step
                                delta /= 3;
                                break;
                            case 2:
                                // DOM_DELTA_PAGE: A page makes up 80 steps
                                delta *= 80;
                                break;
                            default:
                                throw "unrecognized mouse wheel delta mode: " + event.deltaMode;
                        }
                        break;
                    default:
                        throw "unrecognized mouse wheel event: " + event.type;
                }
                return delta;
            },
            mouseX: 0,
            mouseY: 0,
            mouseMovementX: 0,
            mouseMovementY: 0,
            touches: {},
            lastTouches: {},
            calculateMouseEvent: function (event) {
                // event should be mousemove, mousedown or mouseup
                if (Browser.pointerLock) {
                    // When the pointer is locked, calculate the coordinates
                    // based on the movement of the mouse.
                    // Workaround for Firefox bug 764498
                    if (event.type != "mousemove" && "mozMovementX" in event) {
                        Browser.mouseMovementX = Browser.mouseMovementY = 0;
                    } else {
                        Browser.mouseMovementX = Browser.getMovementX(event);
                        Browser.mouseMovementY = Browser.getMovementY(event);
                    }

                    // check if SDL is available
                    if (typeof SDL != "undefined") {
                        Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
                        Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
                    } else {
                        // just add the mouse delta to the current absolut mouse position
                        // FIXME: ideally this should be clamped against the canvas size and zero
                        Browser.mouseX += Browser.mouseMovementX;
                        Browser.mouseY += Browser.mouseMovementY;
                    }
                } else {
                    // Otherwise, calculate the movement based on the changes
                    // in the coordinates.
                    var rect = Module["canvas"].getBoundingClientRect();
                    var cw = Module["canvas"].width;
                    var ch = Module["canvas"].height;

                    // Neither .scrollX or .pageXOffset are defined in a spec, but
                    // we prefer .scrollX because it is currently in a spec draft.
                    // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
                    var scrollX =
                        typeof window.scrollX != "undefined" ? window.scrollX : window.pageXOffset;
                    var scrollY =
                        typeof window.scrollY != "undefined" ? window.scrollY : window.pageYOffset;
                    // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset
                    // and we have no viable fallback.
                    assert(
                        typeof scrollX != "undefined" && typeof scrollY != "undefined",
                        "Unable to retrieve scroll position, mouse positions likely broken."
                    );

                    if (
                        event.type === "touchstart" ||
                        event.type === "touchend" ||
                        event.type === "touchmove"
                    ) {
                        var touch = event.touch;
                        if (touch === undefined) {
                            return; // the "touch" property is only defined in SDL
                        }
                        var adjustedX = touch.pageX - (scrollX + rect.left);
                        var adjustedY = touch.pageY - (scrollY + rect.top);

                        adjustedX = adjustedX * (cw / rect.width);
                        adjustedY = adjustedY * (ch / rect.height);

                        var coords = { x: adjustedX, y: adjustedY };

                        if (event.type === "touchstart") {
                            Browser.lastTouches[touch.identifier] = coords;
                            Browser.touches[touch.identifier] = coords;
                        } else if (event.type === "touchend" || event.type === "touchmove") {
                            var last = Browser.touches[touch.identifier];
                            if (!last) last = coords;
                            Browser.lastTouches[touch.identifier] = last;
                            Browser.touches[touch.identifier] = coords;
                        }
                        return;
                    }

                    var x = event.pageX - (scrollX + rect.left);
                    var y = event.pageY - (scrollY + rect.top);

                    // the canvas might be CSS-scaled compared to its backbuffer;
                    // SDL-using content will want mouse coordinates in terms
                    // of backbuffer units.
                    x = x * (cw / rect.width);
                    y = y * (ch / rect.height);

                    Browser.mouseMovementX = x - Browser.mouseX;
                    Browser.mouseMovementY = y - Browser.mouseY;
                    Browser.mouseX = x;
                    Browser.mouseY = y;
                }
            },
            resizeListeners: [],
            updateResizeListeners: function () {
                var canvas = Module["canvas"];
                Browser.resizeListeners.forEach(function (listener) {
                    listener(canvas.width, canvas.height);
                });
            },
            setCanvasSize: function (width, height, noUpdates) {
                var canvas = Module["canvas"];
                Browser.updateCanvasDimensions(canvas, width, height);
                if (!noUpdates) Browser.updateResizeListeners();
            },
            windowedWidth: 0,
            windowedHeight: 0,
            setFullscreenCanvasSize: function () {
                // check if SDL is available
                if (typeof SDL != "undefined") {
                    var flags = HEAPU32[SDL.screen >> 2];
                    flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
                    HEAP32[SDL.screen >> 2] = flags;
                }
                Browser.updateCanvasDimensions(Module["canvas"]);
                Browser.updateResizeListeners();
            },
            setWindowedCanvasSize: function () {
                // check if SDL is available
                if (typeof SDL != "undefined") {
                    var flags = HEAPU32[SDL.screen >> 2];
                    flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
                    HEAP32[SDL.screen >> 2] = flags;
                }
                Browser.updateCanvasDimensions(Module["canvas"]);
                Browser.updateResizeListeners();
            },
            updateCanvasDimensions: function (canvas, wNative, hNative) {
                if (wNative && hNative) {
                    canvas.widthNative = wNative;
                    canvas.heightNative = hNative;
                } else {
                    wNative = canvas.widthNative;
                    hNative = canvas.heightNative;
                }
                var w = wNative;
                var h = hNative;
                if (Module["forcedAspectRatio"] && Module["forcedAspectRatio"] > 0) {
                    if (w / h < Module["forcedAspectRatio"]) {
                        w = Math.round(h * Module["forcedAspectRatio"]);
                    } else {
                        h = Math.round(w / Module["forcedAspectRatio"]);
                    }
                }
                if (
                    (document["fullscreenElement"] ||
                        document["mozFullScreenElement"] ||
                        document["msFullscreenElement"] ||
                        document["webkitFullscreenElement"] ||
                        document["webkitCurrentFullScreenElement"]) === canvas.parentNode &&
                    typeof screen != "undefined"
                ) {
                    var factor = Math.min(screen.width / w, screen.height / h);
                    w = Math.round(w * factor);
                    h = Math.round(h * factor);
                }
                if (Browser.resizeCanvas) {
                    if (canvas.width != w) canvas.width = w;
                    if (canvas.height != h) canvas.height = h;
                    if (typeof canvas.style != "undefined") {
                        canvas.style.removeProperty("width");
                        canvas.style.removeProperty("height");
                    }
                } else {
                    if (canvas.width != wNative) canvas.width = wNative;
                    if (canvas.height != hNative) canvas.height = hNative;
                    if (typeof canvas.style != "undefined") {
                        if (w != wNative || h != hNative) {
                            canvas.style.setProperty("width", w + "px", "important");
                            canvas.style.setProperty("height", h + "px", "important");
                        } else {
                            canvas.style.removeProperty("width");
                            canvas.style.removeProperty("height");
                        }
                    }
                }
            }
        };

        var EGL = {
            errorCode: 12288,
            defaultDisplayInitialized: false,
            currentContext: 0,
            currentReadSurface: 0,
            currentDrawSurface: 0,
            contextAttributes: { alpha: false, depth: false, stencil: false, antialias: false },
            stringCache: {},
            setErrorCode: function (code) {
                EGL.errorCode = code;
            },
            chooseConfig: function (display, attribList, config, config_size, numConfigs) {
                if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                    EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                    return 0;
                }

                if (attribList) {
                    // read attribList if it is non-null
                    for (;;) {
                        var param = HEAP32[attribList >> 2];
                        if (param == 0x3021 /*EGL_ALPHA_SIZE*/) {
                            var alphaSize = HEAP32[(attribList + 4) >> 2];
                            EGL.contextAttributes.alpha = alphaSize > 0;
                        } else if (param == 0x3025 /*EGL_DEPTH_SIZE*/) {
                            var depthSize = HEAP32[(attribList + 4) >> 2];
                            EGL.contextAttributes.depth = depthSize > 0;
                        } else if (param == 0x3026 /*EGL_STENCIL_SIZE*/) {
                            var stencilSize = HEAP32[(attribList + 4) >> 2];
                            EGL.contextAttributes.stencil = stencilSize > 0;
                        } else if (param == 0x3031 /*EGL_SAMPLES*/) {
                            var samples = HEAP32[(attribList + 4) >> 2];
                            EGL.contextAttributes.antialias = samples > 0;
                        } else if (param == 0x3032 /*EGL_SAMPLE_BUFFERS*/) {
                            var samples = HEAP32[(attribList + 4) >> 2];
                            EGL.contextAttributes.antialias = samples == 1;
                        } else if (param == 0x3100 /*EGL_CONTEXT_PRIORITY_LEVEL_IMG*/) {
                            var requestedPriority = HEAP32[(attribList + 4) >> 2];
                            EGL.contextAttributes.lowLatency =
                                requestedPriority != 0x3103 /*EGL_CONTEXT_PRIORITY_LOW_IMG*/;
                        } else if (param == 0x3038 /*EGL_NONE*/) {
                            break;
                        }
                        attribList += 8;
                    }
                }

                if ((!config || !config_size) && !numConfigs) {
                    EGL.setErrorCode(0x300c /* EGL_BAD_PARAMETER */);
                    return 0;
                }
                if (numConfigs) {
                    HEAP32[numConfigs >> 2] = 1; // Total number of supported configs: 1.
                }
                if (config && config_size > 0) {
                    HEAP32[config >> 2] = 62002;
                }

                EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
                return 1;
            }
        };
        function _eglBindAPI(api) {
            if (api == 0x30a0 /* EGL_OPENGL_ES_API */) {
                EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
                return 1;
            }
            // if (api == 0x30A1 /* EGL_OPENVG_API */ || api == 0x30A2 /* EGL_OPENGL_API */) {
            EGL.setErrorCode(0x300c /* EGL_BAD_PARAMETER */);
            return 0;
        }

        function _eglChooseConfig(display, attrib_list, configs, config_size, numConfigs) {
            return EGL.chooseConfig(display, attrib_list, configs, config_size, numConfigs);
        }

        function __webgl_enable_ANGLE_instanced_arrays(ctx) {
            // Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.
            var ext = ctx.getExtension("ANGLE_instanced_arrays");
            if (ext) {
                ctx["vertexAttribDivisor"] = function (index, divisor) {
                    ext["vertexAttribDivisorANGLE"](index, divisor);
                };
                ctx["drawArraysInstanced"] = function (mode, first, count, primcount) {
                    ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
                };
                ctx["drawElementsInstanced"] = function (mode, count, type, indices, primcount) {
                    ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
                };
                return 1;
            }
        }

        function __webgl_enable_OES_vertex_array_object(ctx) {
            // Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.
            var ext = ctx.getExtension("OES_vertex_array_object");
            if (ext) {
                ctx["createVertexArray"] = function () {
                    return ext["createVertexArrayOES"]();
                };
                ctx["deleteVertexArray"] = function (vao) {
                    ext["deleteVertexArrayOES"](vao);
                };
                ctx["bindVertexArray"] = function (vao) {
                    ext["bindVertexArrayOES"](vao);
                };
                ctx["isVertexArray"] = function (vao) {
                    return ext["isVertexArrayOES"](vao);
                };
                return 1;
            }
        }

        function __webgl_enable_WEBGL_draw_buffers(ctx) {
            // Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.
            var ext = ctx.getExtension("WEBGL_draw_buffers");
            if (ext) {
                ctx["drawBuffers"] = function (n, bufs) {
                    ext["drawBuffersWEBGL"](n, bufs);
                };
                return 1;
            }
        }

        function __webgl_enable_WEBGL_multi_draw(ctx) {
            // Closure is expected to be allowed to minify the '.multiDrawWebgl' property, so not accessing it quoted.
            return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
        }

        var GL = {
            counter: 1,
            buffers: [],
            programs: [],
            framebuffers: [],
            renderbuffers: [],
            textures: [],
            shaders: [],
            vaos: [],
            contexts: [],
            offscreenCanvases: {},
            queries: [],
            stringCache: {},
            unpackAlignment: 4,
            recordError: function recordError(errorCode) {
                if (!GL.lastError) {
                    GL.lastError = errorCode;
                }
            },
            getNewId: function (table) {
                var ret = GL.counter++;
                for (var i = table.length; i < ret; i++) {
                    table[i] = null;
                }
                return ret;
            },
            getSource: function (shader, count, string, length) {
                var source = "";
                for (var i = 0; i < count; ++i) {
                    var len = length ? HEAP32[(length + i * 4) >> 2] : -1;
                    source += UTF8ToString(
                        HEAP32[(string + i * 4) >> 2],
                        len < 0 ? undefined : len
                    );
                }
                return source;
            },
            createContext: function (
                /** @type {HTMLCanvasElement} */ canvas,
                webGLContextAttributes
            ) {
                // BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL context on a canvas,
                // calling .getContext() will always return that context independent of which 'webgl' or 'webgl2'
                // context version was passed. See https://bugs.webkit.org/show_bug.cgi?id=222758 and
                // https://github.com/emscripten-core/emscripten/issues/13295.
                // TODO: Once the bug is fixed and shipped in Safari, adjust the Safari version field in above check.
                if (!canvas.getContextSafariWebGL2Fixed) {
                    canvas.getContextSafariWebGL2Fixed = canvas.getContext;
                    /** @type {function(this:HTMLCanvasElement, string, (Object|null)=): (Object|null)} */
                    function fixedGetContext(ver, attrs) {
                        var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
                        return (ver == "webgl") == gl instanceof WebGLRenderingContext ? gl : null;
                    }
                    canvas.getContext = fixedGetContext;
                }

                var ctx = canvas.getContext("webgl", webGLContextAttributes);
                // https://caniuse.com/#feat=webgl

                if (!ctx) return 0;

                var handle = GL.registerContext(ctx, webGLContextAttributes);

                return handle;
            },
            registerContext: function (ctx, webGLContextAttributes) {
                // without pthreads a context is just an integer ID
                var handle = GL.getNewId(GL.contexts);

                var context = {
                    handle: handle,
                    attributes: webGLContextAttributes,
                    version: webGLContextAttributes.majorVersion,
                    GLctx: ctx
                };

                // Store the created context object so that we can access the context given a canvas without having to pass the parameters again.
                if (ctx.canvas) ctx.canvas.GLctxObject = context;
                GL.contexts[handle] = context;
                if (
                    typeof webGLContextAttributes.enableExtensionsByDefault == "undefined" ||
                    webGLContextAttributes.enableExtensionsByDefault
                ) {
                    GL.initExtensions(context);
                }

                return handle;
            },
            makeContextCurrent: function (contextHandle) {
                GL.currentContext = GL.contexts[contextHandle]; // Active Emscripten GL layer context object.
                Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx; // Active WebGL context object.
                return !(contextHandle && !GLctx);
            },
            getContext: function (contextHandle) {
                return GL.contexts[contextHandle];
            },
            deleteContext: function (contextHandle) {
                if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
                if (typeof JSEvents == "object")
                    JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas); // Release all JS event handlers on the DOM element that the GL context is associated with since the context is now deleted.
                if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas)
                    GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined; // Make sure the canvas object no longer refers to the context object so there are no GC surprises.
                GL.contexts[contextHandle] = null;
            },
            initExtensions: function (context) {
                // If this function is called without a specific context object, init the extensions of the currently active context.
                if (!context) context = GL.currentContext;

                if (context.initExtensionsDone) return;
                context.initExtensionsDone = true;

                var GLctx = context.GLctx;

                // Detect the presence of a few extensions manually, this GL interop layer itself will need to know if they exist.

                // Extensions that are only available in WebGL 1 (the calls will be no-ops if called on a WebGL 2 context active)
                __webgl_enable_ANGLE_instanced_arrays(GLctx);
                __webgl_enable_OES_vertex_array_object(GLctx);
                __webgl_enable_WEBGL_draw_buffers(GLctx);

                {
                    GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
                }

                __webgl_enable_WEBGL_multi_draw(GLctx);

                // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
                var exts = GLctx.getSupportedExtensions() || [];
                exts.forEach(function (ext) {
                    // WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders are not enabled by default.
                    if (!ext.includes("lose_context") && !ext.includes("debug")) {
                        // Call .getExtension() to enable that extension permanently.
                        GLctx.getExtension(ext);
                    }
                });
            }
        };

        function _eglCreateContext(display, config, hmm, contextAttribs) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }

            // EGL 1.4 spec says default EGL_CONTEXT_CLIENT_VERSION is GLES1, but this is not supported by Emscripten.
            // So user must pass EGL_CONTEXT_CLIENT_VERSION == 2 to initialize EGL.
            var glesContextVersion = 1;
            for (;;) {
                var param = HEAP32[contextAttribs >> 2];
                if (param == 0x3098 /*EGL_CONTEXT_CLIENT_VERSION*/) {
                    glesContextVersion = HEAP32[(contextAttribs + 4) >> 2];
                } else if (param == 0x3038 /*EGL_NONE*/) {
                    break;
                } else {
                    /* EGL1.4 specifies only EGL_CONTEXT_CLIENT_VERSION as supported attribute */
                    EGL.setErrorCode(0x3004 /*EGL_BAD_ATTRIBUTE*/);
                    return 0;
                }
                contextAttribs += 8;
            }
            if (glesContextVersion != 2) {
                EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
                return 0; /* EGL_NO_CONTEXT */
            }

            EGL.contextAttributes.majorVersion = glesContextVersion - 1; // WebGL 1 is GLES 2, WebGL2 is GLES3
            EGL.contextAttributes.minorVersion = 0;

            EGL.context = GL.createContext(Module["canvas"], EGL.contextAttributes);

            if (EGL.context != 0) {
                EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);

                // Run callbacks so that GL emulation works
                GL.makeContextCurrent(EGL.context);
                Module.useWebGL = true;
                Browser.moduleContextCreatedCallbacks.forEach(function (callback) {
                    callback();
                });

                // Note: This function only creates a context, but it shall not make it active.
                GL.makeContextCurrent(null);
                return 62004; // Magic ID for Emscripten EGLContext
            } else {
                EGL.setErrorCode(0x3009 /* EGL_BAD_MATCH */); // By the EGL 1.4 spec, an implementation that does not support GLES2 (WebGL in this case), this error code is set.
                return 0; /* EGL_NO_CONTEXT */
            }
        }

        function _eglCreateWindowSurface(display, config, win, attrib_list) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }
            if (config != 62002 /* Magic ID for the only EGLConfig supported by Emscripten */) {
                EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
                return 0;
            }
            // TODO: Examine attrib_list! Parameters that can be present there are:
            // - EGL_RENDER_BUFFER (must be EGL_BACK_BUFFER)
            // - EGL_VG_COLORSPACE (can't be set)
            // - EGL_VG_ALPHA_FORMAT (can't be set)
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 62006; /* Magic ID for Emscripten 'default surface' */
        }

        function _eglDestroyContext(display, context) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }
            if (context != 62004 /* Magic ID for Emscripten EGLContext */) {
                EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
                return 0;
            }

            GL.deleteContext(EGL.context);
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            if (EGL.currentContext == context) {
                EGL.currentContext = 0;
            }
            return 1 /* EGL_TRUE */;
        }

        function _eglDestroySurface(display, surface) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }
            if (surface != 62006 /* Magic ID for the only EGLSurface supported by Emscripten */) {
                EGL.setErrorCode(0x300d /* EGL_BAD_SURFACE */);
                return 1;
            }
            if (EGL.currentReadSurface == surface) {
                EGL.currentReadSurface = 0;
            }
            if (EGL.currentDrawSurface == surface) {
                EGL.currentDrawSurface = 0;
            }
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1; /* Magic ID for Emscripten 'default surface' */
        }

        function _eglGetConfigAttrib(display, config, attribute, value) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }
            if (config != 62002 /* Magic ID for the only EGLConfig supported by Emscripten */) {
                EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
                return 0;
            }
            if (!value) {
                EGL.setErrorCode(0x300c /* EGL_BAD_PARAMETER */);
                return 0;
            }
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            switch (attribute) {
                case 0x3020: // EGL_BUFFER_SIZE
                    HEAP32[value >> 2] = EGL.contextAttributes.alpha ? 32 : 24;
                    return 1;
                case 0x3021: // EGL_ALPHA_SIZE
                    HEAP32[value >> 2] = EGL.contextAttributes.alpha ? 8 : 0;
                    return 1;
                case 0x3022: // EGL_BLUE_SIZE
                    HEAP32[value >> 2] = 8;
                    return 1;
                case 0x3023: // EGL_GREEN_SIZE
                    HEAP32[value >> 2] = 8;
                    return 1;
                case 0x3024: // EGL_RED_SIZE
                    HEAP32[value >> 2] = 8;
                    return 1;
                case 0x3025: // EGL_DEPTH_SIZE
                    HEAP32[value >> 2] = EGL.contextAttributes.depth ? 24 : 0;
                    return 1;
                case 0x3026: // EGL_STENCIL_SIZE
                    HEAP32[value >> 2] = EGL.contextAttributes.stencil ? 8 : 0;
                    return 1;
                case 0x3027: // EGL_CONFIG_CAVEAT
                    // We can return here one of EGL_NONE (0x3038), EGL_SLOW_CONFIG (0x3050) or EGL_NON_CONFORMANT_CONFIG (0x3051).
                    HEAP32[value >> 2] = 0x3038;
                    return 1;
                case 0x3028: // EGL_CONFIG_ID
                    HEAP32[value >> 2] = 62002;
                    return 1;
                case 0x3029: // EGL_LEVEL
                    HEAP32[value >> 2] = 0;
                    return 1;
                case 0x302a: // EGL_MAX_PBUFFER_HEIGHT
                    HEAP32[value >> 2] = 4096;
                    return 1;
                case 0x302b: // EGL_MAX_PBUFFER_PIXELS
                    HEAP32[value >> 2] = 16777216;
                    return 1;
                case 0x302c: // EGL_MAX_PBUFFER_WIDTH
                    HEAP32[value >> 2] = 4096;
                    return 1;
                case 0x302d: // EGL_NATIVE_RENDERABLE
                    HEAP32[value >> 2] = 0;
                    return 1;
                case 0x302e: // EGL_NATIVE_VISUAL_ID
                    HEAP32[value >> 2] = 0;
                    return 1;
                case 0x302f: // EGL_NATIVE_VISUAL_TYPE
                    HEAP32[value >> 2] = 0x3038;
                    return 1;
                case 0x3031: // EGL_SAMPLES
                    HEAP32[value >> 2] = EGL.contextAttributes.antialias ? 4 : 0;
                    return 1;
                case 0x3032: // EGL_SAMPLE_BUFFERS
                    HEAP32[value >> 2] = EGL.contextAttributes.antialias ? 1 : 0;
                    return 1;
                case 0x3033: // EGL_SURFACE_TYPE
                    HEAP32[value >> 2] = 0x4;
                    return 1;
                case 0x3034: // EGL_TRANSPARENT_TYPE
                    // If this returns EGL_TRANSPARENT_RGB (0x3052), transparency is used through color-keying. No such thing applies to Emscripten canvas.
                    HEAP32[value >> 2] = 0x3038;
                    return 1;
                case 0x3035: // EGL_TRANSPARENT_BLUE_VALUE
                case 0x3036: // EGL_TRANSPARENT_GREEN_VALUE
                case 0x3037: // EGL_TRANSPARENT_RED_VALUE
                    // "If EGL_TRANSPARENT_TYPE is EGL_NONE, then the values for EGL_TRANSPARENT_RED_VALUE, EGL_TRANSPARENT_GREEN_VALUE, and EGL_TRANSPARENT_BLUE_VALUE are undefined."
                    HEAP32[value >> 2] = -1;
                    return 1;
                case 0x3039: // EGL_BIND_TO_TEXTURE_RGB
                case 0x303a: // EGL_BIND_TO_TEXTURE_RGBA
                    HEAP32[value >> 2] = 0;
                    return 1;
                case 0x303b: // EGL_MIN_SWAP_INTERVAL
                    HEAP32[value >> 2] = 0;
                    return 1;
                case 0x303c: // EGL_MAX_SWAP_INTERVAL
                    HEAP32[value >> 2] = 1;
                    return 1;
                case 0x303d: // EGL_LUMINANCE_SIZE
                case 0x303e: // EGL_ALPHA_MASK_SIZE
                    HEAP32[value >> 2] = 0;
                    return 1;
                case 0x303f: // EGL_COLOR_BUFFER_TYPE
                    // EGL has two types of buffers: EGL_RGB_BUFFER and EGL_LUMINANCE_BUFFER.
                    HEAP32[value >> 2] = 0x308e;
                    return 1;
                case 0x3040: // EGL_RENDERABLE_TYPE
                    // A bit combination of EGL_OPENGL_ES_BIT,EGL_OPENVG_BIT,EGL_OPENGL_ES2_BIT and EGL_OPENGL_BIT.
                    HEAP32[value >> 2] = 0x4;
                    return 1;
                case 0x3042: // EGL_CONFORMANT
                    // "EGL_CONFORMANT is a mask indicating if a client API context created with respect to the corresponding EGLConfig will pass the required conformance tests for that API."
                    HEAP32[value >> 2] = 0;
                    return 1;
                default:
                    EGL.setErrorCode(0x3004 /* EGL_BAD_ATTRIBUTE */);
                    return 0;
            }
        }

        function _eglGetDisplay(nativeDisplayType) {
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            // Note: As a 'conformant' implementation of EGL, we would prefer to init here only if the user
            //       calls this function with EGL_DEFAULT_DISPLAY. Other display IDs would be preferred to be unsupported
            //       and EGL_NO_DISPLAY returned. Uncomment the following code lines to do this.
            // Instead, an alternative route has been preferred, namely that the Emscripten EGL implementation
            // "emulates" X11, and eglGetDisplay is expected to accept/receive a pointer to an X11 Display object.
            // Therefore, be lax and allow anything to be passed in, and return the magic handle to our default EGLDisplay object.

            //    if (nativeDisplayType == 0 /* EGL_DEFAULT_DISPLAY */) {
            return 62000; // Magic ID for Emscripten 'default display'
            //    }
            //    else
            //      return 0; // EGL_NO_DISPLAY
        }

        function _eglGetError() {
            return EGL.errorCode;
        }

        function _eglInitialize(display, majorVersion, minorVersion) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }
            if (majorVersion) {
                HEAP32[majorVersion >> 2] = 1; // Advertise EGL Major version: '1'
            }
            if (minorVersion) {
                HEAP32[minorVersion >> 2] = 4; // Advertise EGL Minor version: '4'
            }
            EGL.defaultDisplayInitialized = true;
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1;
        }

        function _eglMakeCurrent(display, draw, read, context) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0 /* EGL_FALSE */;
            }
            //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
            if (context != 0 && context != 62004 /* Magic ID for Emscripten EGLContext */) {
                EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
                return 0;
            }
            if (
                (read != 0 && read != 62006) ||
                (draw != 0 && draw != 62006) /* Magic ID for Emscripten 'default surface' */
            ) {
                EGL.setErrorCode(0x300d /* EGL_BAD_SURFACE */);
                return 0;
            }

            GL.makeContextCurrent(context ? EGL.context : null);

            EGL.currentContext = context;
            EGL.currentDrawSurface = draw;
            EGL.currentReadSurface = read;
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1 /* EGL_TRUE */;
        }

        function _eglQueryString(display, name) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }
            //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            if (EGL.stringCache[name]) return EGL.stringCache[name];
            var ret;
            switch (name) {
                case 0x3053 /* EGL_VENDOR */:
                    ret = allocateUTF8("Emscripten");
                    break;
                case 0x3054 /* EGL_VERSION */:
                    ret = allocateUTF8("1.4 Emscripten EGL");
                    break;
                case 0x3055 /* EGL_EXTENSIONS */:
                    ret = allocateUTF8("");
                    break; // Currently not supporting any EGL extensions.
                case 0x308d /* EGL_CLIENT_APIS */:
                    ret = allocateUTF8("OpenGL_ES");
                    break;
                default:
                    EGL.setErrorCode(0x300c /* EGL_BAD_PARAMETER */);
                    return 0;
            }
            EGL.stringCache[name] = ret;
            return ret;
        }

        function _eglSwapBuffers() {
            if (!EGL.defaultDisplayInitialized) {
                EGL.setErrorCode(0x3001 /* EGL_NOT_INITIALIZED */);
            } else if (!Module.ctx) {
                EGL.setErrorCode(0x3002 /* EGL_BAD_ACCESS */);
            } else if (Module.ctx.isContextLost()) {
                EGL.setErrorCode(0x300e /* EGL_CONTEXT_LOST */);
            } else {
                // According to documentation this does an implicit flush.
                // Due to discussion at https://github.com/emscripten-core/emscripten/pull/1871
                // the flush was removed since this _may_ result in slowing code down.
                //_glFlush();
                EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
                return 1 /* EGL_TRUE */;
            }
            return 0 /* EGL_FALSE */;
        }

        function _eglSwapInterval(display, interval) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }
            if (interval == 0) _emscripten_set_main_loop_timing(0 /*EM_TIMING_SETTIMEOUT*/, 0);
            else _emscripten_set_main_loop_timing(1 /*EM_TIMING_RAF*/, interval);

            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1;
        }

        function _eglTerminate(display) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }
            EGL.currentContext = 0;
            EGL.currentReadSurface = 0;
            EGL.currentDrawSurface = 0;
            EGL.defaultDisplayInitialized = false;
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1;
        }

        function _eglWaitClient() {
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1;
        }
        var _eglWaitGL = _eglWaitClient;

        function _eglWaitNative(nativeEngineId) {
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1;
        }

        var readEmAsmArgsArray = [];
        function readEmAsmArgs(sigPtr, buf) {
            // Nobody should have mutated _readEmAsmArgsArray underneath us to be something else than an array.
            assert(Array.isArray(readEmAsmArgsArray));
            // The input buffer is allocated on the stack, so it must be stack-aligned.
            assert(buf % 16 == 0);
            readEmAsmArgsArray.length = 0;
            var ch;
            // Most arguments are i32s, so shift the buffer pointer so it is a plain
            // index into HEAP32.
            buf >>= 2;
            while ((ch = HEAPU8[sigPtr++])) {
                var chr = String.fromCharCode(ch);
                var validChars = ["d", "f", "i"];
                // In WASM_BIGINT mode we support passing i64 values as bigint.
                validChars.push("j");
                assert(
                    validChars.includes(chr),
                    "Invalid character " +
                        ch +
                        '("' +
                        chr +
                        '") in readEmAsmArgs! Use only [' +
                        validChars +
                        '], and do not specify "v" for void return argument.'
                );
                // Floats are always passed as doubles, and doubles and int64s take up 8
                // bytes (two 32-bit slots) in memory, align reads to these:
                buf += (ch != 105) /*i*/ & buf;
                readEmAsmArgsArray.push(
                    ch == 105 /*i*/ ? HEAP32[buf] : (ch == 106 /*j*/ ? HEAP64 : HEAPF64)[buf++ >> 1]
                );
                ++buf;
            }
            return readEmAsmArgsArray;
        }
        function runEmAsmFunction(code, sigPtr, argbuf) {
            var args = readEmAsmArgs(sigPtr, argbuf);
            if (!ASM_CONSTS.hasOwnProperty(code))
                abort("No EM_ASM constant found at address " + code);
            return ASM_CONSTS[code].apply(null, args);
        }
        function _emscripten_asm_const_int(code, sigPtr, argbuf) {
            return runEmAsmFunction(code, sigPtr, argbuf);
        }

        function runMainThreadEmAsm(code, sigPtr, argbuf, sync) {
            var args = readEmAsmArgs(sigPtr, argbuf);
            if (!ASM_CONSTS.hasOwnProperty(code))
                abort("No EM_ASM constant found at address " + code);
            return ASM_CONSTS[code].apply(null, args);
        }
        function _emscripten_asm_const_int_sync_on_main_thread(code, sigPtr, argbuf) {
            return runMainThreadEmAsm(code, sigPtr, argbuf, 1);
        }

        function _emscripten_cancel_main_loop() {
            Browser.mainLoop.pause();
            Browser.mainLoop.func = null;
        }

        function _emscripten_console_error(str) {
            assert(typeof str == "number");
            console.error(UTF8ToString(str));
        }

        function _emscripten_date_now() {
            return Date.now();
        }

        function withStackSave(f) {
            var stack = stackSave();
            var ret = f();
            stackRestore(stack);
            return ret;
        }
        var JSEvents = {
            inEventHandler: 0,
            removeAllEventListeners: function () {
                for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
                    JSEvents._removeHandler(i);
                }
                JSEvents.eventHandlers = [];
                JSEvents.deferredCalls = [];
            },
            registerRemoveEventListeners: function () {
                if (!JSEvents.removeEventListenersRegistered) {
                    __ATEXIT__.push(JSEvents.removeAllEventListeners);
                    JSEvents.removeEventListenersRegistered = true;
                }
            },
            deferredCalls: [],
            deferCall: function (targetFunction, precedence, argsList) {
                function arraysHaveEqualContent(arrA, arrB) {
                    if (arrA.length != arrB.length) return false;

                    for (var i in arrA) {
                        if (arrA[i] != arrB[i]) return false;
                    }
                    return true;
                }
                // Test if the given call was already queued, and if so, don't add it again.
                for (var i in JSEvents.deferredCalls) {
                    var call = JSEvents.deferredCalls[i];
                    if (
                        call.targetFunction == targetFunction &&
                        arraysHaveEqualContent(call.argsList, argsList)
                    ) {
                        return;
                    }
                }
                JSEvents.deferredCalls.push({
                    targetFunction: targetFunction,
                    precedence: precedence,
                    argsList: argsList
                });

                JSEvents.deferredCalls.sort(function (x, y) {
                    return x.precedence < y.precedence;
                });
            },
            removeDeferredCalls: function (targetFunction) {
                for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
                    if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
                        JSEvents.deferredCalls.splice(i, 1);
                        --i;
                    }
                }
            },
            canPerformEventHandlerRequests: function () {
                return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
            },
            runDeferredCalls: function () {
                if (!JSEvents.canPerformEventHandlerRequests()) {
                    return;
                }
                for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
                    var call = JSEvents.deferredCalls[i];
                    JSEvents.deferredCalls.splice(i, 1);
                    --i;
                    call.targetFunction.apply(null, call.argsList);
                }
            },
            eventHandlers: [],
            removeAllHandlersOnTarget: function (target, eventTypeString) {
                for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
                    if (
                        JSEvents.eventHandlers[i].target == target &&
                        (!eventTypeString ||
                            eventTypeString == JSEvents.eventHandlers[i].eventTypeString)
                    ) {
                        JSEvents._removeHandler(i--);
                    }
                }
            },
            _removeHandler: function (i) {
                var h = JSEvents.eventHandlers[i];
                h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
                JSEvents.eventHandlers.splice(i, 1);
            },
            registerOrRemoveHandler: function (eventHandler) {
                var jsEventHandler = function jsEventHandler(event) {
                    // Increment nesting count for the event handler.
                    ++JSEvents.inEventHandler;
                    JSEvents.currentEventHandler = eventHandler;
                    // Process any old deferred calls the user has placed.
                    JSEvents.runDeferredCalls();
                    // Process the actual event, calls back to user C code handler.
                    eventHandler.handlerFunc(event);
                    // Process any new deferred calls that were placed right now from this event handler.
                    JSEvents.runDeferredCalls();
                    // Out of event handler - restore nesting count.
                    --JSEvents.inEventHandler;
                };

                if (eventHandler.callbackfunc) {
                    eventHandler.eventListenerFunc = jsEventHandler;
                    eventHandler.target.addEventListener(
                        eventHandler.eventTypeString,
                        jsEventHandler,
                        eventHandler.useCapture
                    );
                    JSEvents.eventHandlers.push(eventHandler);
                    JSEvents.registerRemoveEventListeners();
                } else {
                    for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
                        if (
                            JSEvents.eventHandlers[i].target == eventHandler.target &&
                            JSEvents.eventHandlers[i].eventTypeString ==
                                eventHandler.eventTypeString
                        ) {
                            JSEvents._removeHandler(i--);
                        }
                    }
                }
            },
            getNodeNameForTarget: function (target) {
                if (!target) return "";
                if (target == window) return "#window";
                if (target == screen) return "#screen";
                return target && target.nodeName ? target.nodeName : "";
            },
            fullscreenEnabled: function () {
                return (
                    document.fullscreenEnabled ||
                    // Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
                    // TODO: If Safari at some point ships with unprefixed version, update the version check above.
                    document.webkitFullscreenEnabled
                );
            }
        };

        var currentFullscreenStrategy = {};

        function maybeCStringToJsString(cString) {
            // "cString > 2" checks if the input is a number, and isn't of the special
            // values we accept here, EMSCRIPTEN_EVENT_TARGET_* (which map to 0, 1, 2).
            // In other words, if cString > 2 then it's a pointer to a valid place in
            // memory, and points to a C string.
            return cString > 2 ? UTF8ToString(cString) : cString;
        }

        var specialHTMLTargets = [
            0,
            typeof document != "undefined" ? document : 0,
            typeof window != "undefined" ? window : 0
        ];
        function findEventTarget(target) {
            target = maybeCStringToJsString(target);
            var domElement =
                specialHTMLTargets[target] ||
                (typeof document != "undefined" ? document.querySelector(target) : undefined);
            return domElement;
        }
        function findCanvasEventTarget(target) {
            return findEventTarget(target);
        }
        function _emscripten_get_canvas_element_size(target, width, height) {
            var canvas = findCanvasEventTarget(target);
            if (!canvas) return -4;
            HEAP32[width >> 2] = canvas.width;
            HEAP32[height >> 2] = canvas.height;
        }

        function getCanvasElementSize(target) {
            return withStackSave(function () {
                var w = stackAlloc(8);
                var h = w + 4;

                var targetInt = stackAlloc(target.id.length + 1);
                stringToUTF8(target.id, targetInt, target.id.length + 1);
                var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
                var size = [HEAP32[w >> 2], HEAP32[h >> 2]];
                return size;
            });
        }

        function _emscripten_set_canvas_element_size(target, width, height) {
            var canvas = findCanvasEventTarget(target);
            if (!canvas) return -4;
            canvas.width = width;
            canvas.height = height;
            return 0;
        }

        function setCanvasElementSize(target, width, height) {
            if (!target.controlTransferredOffscreen) {
                target.width = width;
                target.height = height;
            } else {
                // This function is being called from high-level JavaScript code instead of asm.js/Wasm,
                // and it needs to synchronously proxy over to another thread, so marshal the string onto the heap to do the call.
                withStackSave(function () {
                    var targetInt = stackAlloc(target.id.length + 1);
                    stringToUTF8(target.id, targetInt, target.id.length + 1);
                    _emscripten_set_canvas_element_size(targetInt, width, height);
                });
            }
        }

        function registerRestoreOldStyle(canvas) {
            var canvasSize = getCanvasElementSize(canvas);
            var oldWidth = canvasSize[0];
            var oldHeight = canvasSize[1];
            var oldCssWidth = canvas.style.width;
            var oldCssHeight = canvas.style.height;
            var oldBackgroundColor = canvas.style.backgroundColor; // Chrome reads color from here.
            var oldDocumentBackgroundColor = document.body.style.backgroundColor; // IE11 reads color from here.
            // Firefox always has black background color.
            var oldPaddingLeft = canvas.style.paddingLeft; // Chrome, FF, Safari
            var oldPaddingRight = canvas.style.paddingRight;
            var oldPaddingTop = canvas.style.paddingTop;
            var oldPaddingBottom = canvas.style.paddingBottom;
            var oldMarginLeft = canvas.style.marginLeft; // IE11
            var oldMarginRight = canvas.style.marginRight;
            var oldMarginTop = canvas.style.marginTop;
            var oldMarginBottom = canvas.style.marginBottom;
            var oldDocumentBodyMargin = document.body.style.margin;
            var oldDocumentOverflow = document.documentElement.style.overflow; // Chrome, Firefox
            var oldDocumentScroll = document.body.scroll; // IE
            var oldImageRendering = canvas.style.imageRendering;

            function restoreOldStyle() {
                var fullscreenElement =
                    document.fullscreenElement || document.webkitFullscreenElement;
                if (!fullscreenElement) {
                    document.removeEventListener("fullscreenchange", restoreOldStyle);

                    // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
                    // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
                    document.removeEventListener("webkitfullscreenchange", restoreOldStyle);

                    setCanvasElementSize(canvas, oldWidth, oldHeight);

                    canvas.style.width = oldCssWidth;
                    canvas.style.height = oldCssHeight;
                    canvas.style.backgroundColor = oldBackgroundColor; // Chrome
                    // IE11 hack: assigning 'undefined' or an empty string to document.body.style.backgroundColor has no effect, so first assign back the default color
                    // before setting the undefined value. Setting undefined value is also important, or otherwise we would later treat that as something that the user
                    // had explicitly set so subsequent fullscreen transitions would not set background color properly.
                    if (!oldDocumentBackgroundColor) document.body.style.backgroundColor = "white";
                    document.body.style.backgroundColor = oldDocumentBackgroundColor; // IE11
                    canvas.style.paddingLeft = oldPaddingLeft; // Chrome, FF, Safari
                    canvas.style.paddingRight = oldPaddingRight;
                    canvas.style.paddingTop = oldPaddingTop;
                    canvas.style.paddingBottom = oldPaddingBottom;
                    canvas.style.marginLeft = oldMarginLeft; // IE11
                    canvas.style.marginRight = oldMarginRight;
                    canvas.style.marginTop = oldMarginTop;
                    canvas.style.marginBottom = oldMarginBottom;
                    document.body.style.margin = oldDocumentBodyMargin;
                    document.documentElement.style.overflow = oldDocumentOverflow; // Chrome, Firefox
                    document.body.scroll = oldDocumentScroll; // IE
                    canvas.style.imageRendering = oldImageRendering;
                    if (canvas.GLctxObject)
                        canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);

                    if (currentFullscreenStrategy.canvasResizedCallback) {
                        getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(
                            37,
                            0,
                            currentFullscreenStrategy.canvasResizedCallbackUserData
                        );
                    }
                }
            }
            document.addEventListener("fullscreenchange", restoreOldStyle);
            // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
            // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
            document.addEventListener("webkitfullscreenchange", restoreOldStyle);
            return restoreOldStyle;
        }

        function setLetterbox(element, topBottom, leftRight) {
            // Cannot use margin to specify letterboxes in FF or Chrome, since those ignore margins in fullscreen mode.
            element.style.paddingLeft = element.style.paddingRight = leftRight + "px";
            element.style.paddingTop = element.style.paddingBottom = topBottom + "px";
        }

        function getBoundingClientRect(e) {
            return specialHTMLTargets.indexOf(e) < 0
                ? e.getBoundingClientRect()
                : { left: 0, top: 0 };
        }
        function JSEvents_resizeCanvasForFullscreen(target, strategy) {
            var restoreOldStyle = registerRestoreOldStyle(target);
            var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
            var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
            var rect = getBoundingClientRect(target);
            var windowedCssWidth = rect.width;
            var windowedCssHeight = rect.height;
            var canvasSize = getCanvasElementSize(target);
            var windowedRttWidth = canvasSize[0];
            var windowedRttHeight = canvasSize[1];

            if (strategy.scaleMode == 3) {
                setLetterbox(
                    target,
                    (cssHeight - windowedCssHeight) / 2,
                    (cssWidth - windowedCssWidth) / 2
                );
                cssWidth = windowedCssWidth;
                cssHeight = windowedCssHeight;
            } else if (strategy.scaleMode == 2) {
                if (cssWidth * windowedRttHeight < windowedRttWidth * cssHeight) {
                    var desiredCssHeight = (windowedRttHeight * cssWidth) / windowedRttWidth;
                    setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
                    cssHeight = desiredCssHeight;
                } else {
                    var desiredCssWidth = (windowedRttWidth * cssHeight) / windowedRttHeight;
                    setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
                    cssWidth = desiredCssWidth;
                }
            }

            // If we are adding padding, must choose a background color or otherwise Chrome will give the
            // padding a default white color. Do it only if user has not customized their own background color.
            if (!target.style.backgroundColor) target.style.backgroundColor = "black";
            // IE11 does the same, but requires the color to be set in the document body.
            if (!document.body.style.backgroundColor) document.body.style.backgroundColor = "black"; // IE11
            // Firefox always shows black letterboxes independent of style color.

            target.style.width = cssWidth + "px";
            target.style.height = cssHeight + "px";

            if (strategy.filteringMode == 1) {
                target.style.imageRendering = "optimizeSpeed";
                target.style.imageRendering = "-moz-crisp-edges";
                target.style.imageRendering = "-o-crisp-edges";
                target.style.imageRendering = "-webkit-optimize-contrast";
                target.style.imageRendering = "optimize-contrast";
                target.style.imageRendering = "crisp-edges";
                target.style.imageRendering = "pixelated";
            }

            var dpiScale = strategy.canvasResolutionScaleMode == 2 ? devicePixelRatio : 1;
            if (strategy.canvasResolutionScaleMode != 0) {
                var newWidth = (cssWidth * dpiScale) | 0;
                var newHeight = (cssHeight * dpiScale) | 0;
                setCanvasElementSize(target, newWidth, newHeight);
                if (target.GLctxObject)
                    target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
            }
            return restoreOldStyle;
        }

        function JSEvents_requestFullscreen(target, strategy) {
            // EMSCRIPTEN_FULLSCREEN_SCALE_DEFAULT + EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE is a mode where no extra logic is performed to the DOM elements.
            if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
                JSEvents_resizeCanvasForFullscreen(target, strategy);
            }

            if (target.requestFullscreen) {
                target.requestFullscreen();
            } else if (target.webkitRequestFullscreen) {
                target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            } else {
                return JSEvents.fullscreenEnabled() ? -3 : -1;
            }

            currentFullscreenStrategy = strategy;

            if (strategy.canvasResizedCallback) {
                getWasmTableEntry(strategy.canvasResizedCallback)(
                    37,
                    0,
                    strategy.canvasResizedCallbackUserData
                );
            }

            return 0;
        }

        function _emscripten_exit_fullscreen() {
            if (!JSEvents.fullscreenEnabled()) return -1;
            // Make sure no queued up calls will fire after this.
            JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);

            var d = specialHTMLTargets[1];
            if (d.exitFullscreen) {
                d.fullscreenElement && d.exitFullscreen();
            } else if (d.webkitExitFullscreen) {
                d.webkitFullscreenElement && d.webkitExitFullscreen();
            } else {
                return -1;
            }

            return 0;
        }

        function requestPointerLock(target) {
            if (target.requestPointerLock) {
                target.requestPointerLock();
            } else {
                // document.body is known to accept pointer lock, so use that to differentiate if the user passed a bad element,
                // or if the whole browser just doesn't support the feature.
                if (document.body.requestPointerLock) {
                    return -3;
                }
                return -1;
            }
            return 0;
        }
        function _emscripten_exit_pointerlock() {
            // Make sure no queued up calls will fire after this.
            JSEvents.removeDeferredCalls(requestPointerLock);

            if (document.exitPointerLock) {
                document.exitPointerLock();
            } else {
                return -1;
            }
            return 0;
        }

        function _emscripten_get_device_pixel_ratio() {
            return (typeof devicePixelRatio == "number" && devicePixelRatio) || 1.0;
        }

        function _emscripten_get_element_css_size(target, width, height) {
            target = findEventTarget(target);
            if (!target) return -4;

            var rect = getBoundingClientRect(target);
            HEAPF64[width >> 3] = rect.width;
            HEAPF64[height >> 3] = rect.height;

            return 0;
        }

        function fillGamepadEventData(eventStruct, e) {
            HEAPF64[eventStruct >> 3] = e.timestamp;
            for (var i = 0; i < e.axes.length; ++i) {
                HEAPF64[(eventStruct + i * 8 + 16) >> 3] = e.axes[i];
            }
            for (var i = 0; i < e.buttons.length; ++i) {
                if (typeof e.buttons[i] == "object") {
                    HEAPF64[(eventStruct + i * 8 + 528) >> 3] = e.buttons[i].value;
                } else {
                    HEAPF64[(eventStruct + i * 8 + 528) >> 3] = e.buttons[i];
                }
            }
            for (var i = 0; i < e.buttons.length; ++i) {
                if (typeof e.buttons[i] == "object") {
                    HEAP32[(eventStruct + i * 4 + 1040) >> 2] = e.buttons[i].pressed;
                } else {
                    // Assigning a boolean to HEAP32, that's ok, but Closure would like to warn about it:
                    /** @suppress {checkTypes} */
                    HEAP32[(eventStruct + i * 4 + 1040) >> 2] = e.buttons[i] == 1;
                }
            }
            HEAP32[(eventStruct + 1296) >> 2] = e.connected;
            HEAP32[(eventStruct + 1300) >> 2] = e.index;
            HEAP32[(eventStruct + 8) >> 2] = e.axes.length;
            HEAP32[(eventStruct + 12) >> 2] = e.buttons.length;
            stringToUTF8(e.id, eventStruct + 1304, 64);
            stringToUTF8(e.mapping, eventStruct + 1368, 64);
        }
        function _emscripten_get_gamepad_status(index, gamepadState) {
            if (!JSEvents.lastGamepadState)
                throw "emscripten_get_gamepad_status() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!";

            // INVALID_PARAM is returned on a Gamepad index that never was there.
            if (index < 0 || index >= JSEvents.lastGamepadState.length) return -5;

            // NO_DATA is returned on a Gamepad index that was removed.
            // For previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
            // This is because gamepads must keep their original position in the array.
            // For example, removing the first of two gamepads produces [null/undefined/false, gamepad].
            if (!JSEvents.lastGamepadState[index]) return -7;

            fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
            return 0;
        }

        function getHeapMax() {
            // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
            // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
            // for any code that deals with heap sizes, which would require special
            // casing all heap size related code to treat 0 specially.
            return 2147483648;
        }
        function _emscripten_get_heap_max() {
            return getHeapMax();
        }

        function _emscripten_get_num_gamepads() {
            if (!JSEvents.lastGamepadState)
                throw "emscripten_get_num_gamepads() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!";
            // N.B. Do not call emscripten_get_num_gamepads() unless having first called emscripten_sample_gamepad_data(), and that has returned EMSCRIPTEN_RESULT_SUCCESS.
            // Otherwise the following line will throw an exception.
            return JSEvents.lastGamepadState.length;
        }

        function _emscripten_get_screen_size(width, height) {
            HEAP32[width >> 2] = screen.width;
            HEAP32[height >> 2] = screen.height;
        }

        function _emscripten_glActiveTexture(x0) {
            GLctx["activeTexture"](x0);
        }

        function _emscripten_glAttachShader(program, shader) {
            GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
        }

        function _emscripten_glBeginQueryEXT(target, id) {
            GLctx.disjointTimerQueryExt["beginQueryEXT"](target, GL.queries[id]);
        }

        function _emscripten_glBindAttribLocation(program, index, name) {
            GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
        }

        function _emscripten_glBindBuffer(target, buffer) {
            GLctx.bindBuffer(target, GL.buffers[buffer]);
        }

        function _emscripten_glBindFramebuffer(target, framebuffer) {
            GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
        }

        function _emscripten_glBindRenderbuffer(target, renderbuffer) {
            GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
        }

        function _emscripten_glBindTexture(target, texture) {
            GLctx.bindTexture(target, GL.textures[texture]);
        }

        function _emscripten_glBindVertexArrayOES(vao) {
            GLctx["bindVertexArray"](GL.vaos[vao]);
        }

        function _emscripten_glBlendColor(x0, x1, x2, x3) {
            GLctx["blendColor"](x0, x1, x2, x3);
        }

        function _emscripten_glBlendEquation(x0) {
            GLctx["blendEquation"](x0);
        }

        function _emscripten_glBlendEquationSeparate(x0, x1) {
            GLctx["blendEquationSeparate"](x0, x1);
        }

        function _emscripten_glBlendFunc(x0, x1) {
            GLctx["blendFunc"](x0, x1);
        }

        function _emscripten_glBlendFuncSeparate(x0, x1, x2, x3) {
            GLctx["blendFuncSeparate"](x0, x1, x2, x3);
        }

        function _emscripten_glBufferData(target, size, data, usage) {
            // N.b. here first form specifies a heap subarray, second form an integer size, so the ?: code here is polymorphic. It is advised to avoid
            // randomly mixing both uses in calling code, to avoid any potential JS engine JIT issues.
            GLctx.bufferData(target, data ? HEAPU8.subarray(data, data + size) : size, usage);
        }

        function _emscripten_glBufferSubData(target, offset, size, data) {
            GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data + size));
        }

        function _emscripten_glCheckFramebufferStatus(x0) {
            return GLctx["checkFramebufferStatus"](x0);
        }

        function _emscripten_glClear(x0) {
            GLctx["clear"](x0);
        }

        function _emscripten_glClearColor(x0, x1, x2, x3) {
            GLctx["clearColor"](x0, x1, x2, x3);
        }

        function _emscripten_glClearDepthf(x0) {
            GLctx["clearDepth"](x0);
        }

        function _emscripten_glClearStencil(x0) {
            GLctx["clearStencil"](x0);
        }

        function _emscripten_glColorMask(red, green, blue, alpha) {
            GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
        }

        function _emscripten_glCompileShader(shader) {
            GLctx.compileShader(GL.shaders[shader]);
        }

        function _emscripten_glCompressedTexImage2D(
            target,
            level,
            internalFormat,
            width,
            height,
            border,
            imageSize,
            data
        ) {
            GLctx["compressedTexImage2D"](
                target,
                level,
                internalFormat,
                width,
                height,
                border,
                data ? HEAPU8.subarray(data, data + imageSize) : null
            );
        }

        function _emscripten_glCompressedTexSubImage2D(
            target,
            level,
            xoffset,
            yoffset,
            width,
            height,
            format,
            imageSize,
            data
        ) {
            GLctx["compressedTexSubImage2D"](
                target,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                data ? HEAPU8.subarray(data, data + imageSize) : null
            );
        }

        function _emscripten_glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx["copyTexImage2D"](x0, x1, x2, x3, x4, x5, x6, x7);
        }

        function _emscripten_glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx["copyTexSubImage2D"](x0, x1, x2, x3, x4, x5, x6, x7);
        }

        function _emscripten_glCreateProgram() {
            var id = GL.getNewId(GL.programs);
            var program = GLctx.createProgram();
            // Store additional information needed for each shader program:
            program.name = id;
            // Lazy cache results of glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
            program.maxUniformLength =
                program.maxAttributeLength =
                program.maxUniformBlockNameLength =
                    0;
            program.uniformIdCounter = 1;
            GL.programs[id] = program;
            return id;
        }

        function _emscripten_glCreateShader(shaderType) {
            var id = GL.getNewId(GL.shaders);
            GL.shaders[id] = GLctx.createShader(shaderType);

            return id;
        }

        function _emscripten_glCullFace(x0) {
            GLctx["cullFace"](x0);
        }

        function _emscripten_glDeleteBuffers(n, buffers) {
            for (var i = 0; i < n; i++) {
                var id = HEAP32[(buffers + i * 4) >> 2];
                var buffer = GL.buffers[id];

                // From spec: "glDeleteBuffers silently ignores 0's and names that do not
                // correspond to existing buffer objects."
                if (!buffer) continue;

                GLctx.deleteBuffer(buffer);
                buffer.name = 0;
                GL.buffers[id] = null;
            }
        }

        function _emscripten_glDeleteFramebuffers(n, framebuffers) {
            for (var i = 0; i < n; ++i) {
                var id = HEAP32[(framebuffers + i * 4) >> 2];
                var framebuffer = GL.framebuffers[id];
                if (!framebuffer) continue; // GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
                GLctx.deleteFramebuffer(framebuffer);
                framebuffer.name = 0;
                GL.framebuffers[id] = null;
            }
        }

        function _emscripten_glDeleteProgram(id) {
            if (!id) return;
            var program = GL.programs[id];
            if (!program) {
                // glDeleteProgram actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            GLctx.deleteProgram(program);
            program.name = 0;
            GL.programs[id] = null;
        }

        function _emscripten_glDeleteQueriesEXT(n, ids) {
            for (var i = 0; i < n; i++) {
                var id = HEAP32[(ids + i * 4) >> 2];
                var query = GL.queries[id];
                if (!query) continue; // GL spec: "unused names in ids are ignored, as is the name zero."
                GLctx.disjointTimerQueryExt["deleteQueryEXT"](query);
                GL.queries[id] = null;
            }
        }

        function _emscripten_glDeleteRenderbuffers(n, renderbuffers) {
            for (var i = 0; i < n; i++) {
                var id = HEAP32[(renderbuffers + i * 4) >> 2];
                var renderbuffer = GL.renderbuffers[id];
                if (!renderbuffer) continue; // GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
                GLctx.deleteRenderbuffer(renderbuffer);
                renderbuffer.name = 0;
                GL.renderbuffers[id] = null;
            }
        }

        function _emscripten_glDeleteShader(id) {
            if (!id) return;
            var shader = GL.shaders[id];
            if (!shader) {
                // glDeleteShader actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            GLctx.deleteShader(shader);
            GL.shaders[id] = null;
        }

        function _emscripten_glDeleteTextures(n, textures) {
            for (var i = 0; i < n; i++) {
                var id = HEAP32[(textures + i * 4) >> 2];
                var texture = GL.textures[id];
                if (!texture) continue; // GL spec: "glDeleteTextures silently ignores 0s and names that do not correspond to existing textures".
                GLctx.deleteTexture(texture);
                texture.name = 0;
                GL.textures[id] = null;
            }
        }

        function _emscripten_glDeleteVertexArraysOES(n, vaos) {
            for (var i = 0; i < n; i++) {
                var id = HEAP32[(vaos + i * 4) >> 2];
                GLctx["deleteVertexArray"](GL.vaos[id]);
                GL.vaos[id] = null;
            }
        }

        function _emscripten_glDepthFunc(x0) {
            GLctx["depthFunc"](x0);
        }

        function _emscripten_glDepthMask(flag) {
            GLctx.depthMask(!!flag);
        }

        function _emscripten_glDepthRangef(x0, x1) {
            GLctx["depthRange"](x0, x1);
        }

        function _emscripten_glDetachShader(program, shader) {
            GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
        }

        function _emscripten_glDisable(x0) {
            GLctx["disable"](x0);
        }

        function _emscripten_glDisableVertexAttribArray(index) {
            GLctx.disableVertexAttribArray(index);
        }

        function _emscripten_glDrawArrays(mode, first, count) {
            GLctx.drawArrays(mode, first, count);
        }

        function _emscripten_glDrawArraysInstancedANGLE(mode, first, count, primcount) {
            GLctx["drawArraysInstanced"](mode, first, count, primcount);
        }

        var tempFixedLengthArray = [];

        function _emscripten_glDrawBuffersWEBGL(n, bufs) {
            var bufArray = tempFixedLengthArray[n];
            for (var i = 0; i < n; i++) {
                bufArray[i] = HEAP32[(bufs + i * 4) >> 2];
            }

            GLctx["drawBuffers"](bufArray);
        }

        function _emscripten_glDrawElements(mode, count, type, indices) {
            GLctx.drawElements(mode, count, type, indices);
        }

        function _emscripten_glDrawElementsInstancedANGLE(mode, count, type, indices, primcount) {
            GLctx["drawElementsInstanced"](mode, count, type, indices, primcount);
        }

        function _emscripten_glEnable(x0) {
            GLctx["enable"](x0);
        }

        function _emscripten_glEnableVertexAttribArray(index) {
            GLctx.enableVertexAttribArray(index);
        }

        function _emscripten_glEndQueryEXT(target) {
            GLctx.disjointTimerQueryExt["endQueryEXT"](target);
        }

        function _emscripten_glFinish() {
            GLctx["finish"]();
        }

        function _emscripten_glFlush() {
            GLctx["flush"]();
        }

        function _emscripten_glFramebufferRenderbuffer(
            target,
            attachment,
            renderbuffertarget,
            renderbuffer
        ) {
            GLctx.framebufferRenderbuffer(
                target,
                attachment,
                renderbuffertarget,
                GL.renderbuffers[renderbuffer]
            );
        }

        function _emscripten_glFramebufferTexture2D(target, attachment, textarget, texture, level) {
            GLctx.framebufferTexture2D(target, attachment, textarget, GL.textures[texture], level);
        }

        function _emscripten_glFrontFace(x0) {
            GLctx["frontFace"](x0);
        }

        function __glGenObject(n, buffers, createFunction, objectTable) {
            for (var i = 0; i < n; i++) {
                var buffer = GLctx[createFunction]();
                var id = buffer && GL.getNewId(objectTable);
                if (buffer) {
                    buffer.name = id;
                    objectTable[id] = buffer;
                } else {
                    GL.recordError(0x502 /* GL_INVALID_OPERATION */);
                }
                HEAP32[(buffers + i * 4) >> 2] = id;
            }
        }

        function _emscripten_glGenBuffers(n, buffers) {
            __glGenObject(n, buffers, "createBuffer", GL.buffers);
        }

        function _emscripten_glGenFramebuffers(n, ids) {
            __glGenObject(n, ids, "createFramebuffer", GL.framebuffers);
        }

        function _emscripten_glGenQueriesEXT(n, ids) {
            for (var i = 0; i < n; i++) {
                var query = GLctx.disjointTimerQueryExt["createQueryEXT"]();
                if (!query) {
                    GL.recordError(0x502 /* GL_INVALID_OPERATION */);
                    while (i < n) HEAP32[(ids + i++ * 4) >> 2] = 0;
                    return;
                }
                var id = GL.getNewId(GL.queries);
                query.name = id;
                GL.queries[id] = query;
                HEAP32[(ids + i * 4) >> 2] = id;
            }
        }

        function _emscripten_glGenRenderbuffers(n, renderbuffers) {
            __glGenObject(n, renderbuffers, "createRenderbuffer", GL.renderbuffers);
        }

        function _emscripten_glGenTextures(n, textures) {
            __glGenObject(n, textures, "createTexture", GL.textures);
        }

        function _emscripten_glGenVertexArraysOES(n, arrays) {
            __glGenObject(n, arrays, "createVertexArray", GL.vaos);
        }

        function _emscripten_glGenerateMipmap(x0) {
            GLctx["generateMipmap"](x0);
        }

        function __glGetActiveAttribOrUniform(
            funcName,
            program,
            index,
            bufSize,
            length,
            size,
            type,
            name
        ) {
            program = GL.programs[program];
            var info = GLctx[funcName](program, index);
            if (info) {
                // If an error occurs, nothing will be written to length, size and type and name.
                var numBytesWrittenExclNull = name && stringToUTF8(info.name, name, bufSize);
                if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
                if (size) HEAP32[size >> 2] = info.size;
                if (type) HEAP32[type >> 2] = info.type;
            }
        }

        function _emscripten_glGetActiveAttrib(program, index, bufSize, length, size, type, name) {
            __glGetActiveAttribOrUniform(
                "getActiveAttrib",
                program,
                index,
                bufSize,
                length,
                size,
                type,
                name
            );
        }

        function _emscripten_glGetActiveUniform(program, index, bufSize, length, size, type, name) {
            __glGetActiveAttribOrUniform(
                "getActiveUniform",
                program,
                index,
                bufSize,
                length,
                size,
                type,
                name
            );
        }

        function _emscripten_glGetAttachedShaders(program, maxCount, count, shaders) {
            var result = GLctx.getAttachedShaders(GL.programs[program]);
            var len = result.length;
            if (len > maxCount) {
                len = maxCount;
            }
            HEAP32[count >> 2] = len;
            for (var i = 0; i < len; ++i) {
                var id = GL.shaders.indexOf(result[i]);
                HEAP32[(shaders + i * 4) >> 2] = id;
            }
        }

        function _emscripten_glGetAttribLocation(program, name) {
            return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));
        }

        function readI53FromU64(ptr) {
            return HEAPU32[ptr >> 2] + HEAPU32[(ptr + 4) >> 2] * 4294967296;
        }
        function writeI53ToI64(ptr, num) {
            HEAPU32[ptr >> 2] = num;
            HEAPU32[(ptr + 4) >> 2] = (num - HEAPU32[ptr >> 2]) / 4294967296;
            var deserialized = num >= 0 ? readI53FromU64(ptr) : readI53FromI64(ptr);
            if (deserialized != num)
                warnOnce(
                    "writeI53ToI64() out of range: serialized JS Number " +
                        num +
                        " to Wasm heap as bytes lo=" +
                        ptrToString(HEAPU32[ptr >> 2]) +
                        ", hi=" +
                        ptrToString(HEAPU32[(ptr + 4) >> 2]) +
                        ", which deserializes back to " +
                        deserialized +
                        " instead!"
                );
        }

        function emscriptenWebGLGet(name_, p, type) {
            // Guard against user passing a null pointer.
            // Note that GLES2 spec does not say anything about how passing a null pointer should be treated.
            // Testing on desktop core GL 3, the application crashes on glGetIntegerv to a null pointer, but
            // better to report an error instead of doing anything random.
            if (!p) {
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            var ret = undefined;
            switch (
                name_ // Handle a few trivial GLES values
            ) {
                case 0x8dfa: // GL_SHADER_COMPILER
                    ret = 1;
                    break;
                case 0x8df8: // GL_SHADER_BINARY_FORMATS
                    if (type != 0 && type != 1) {
                        GL.recordError(0x500); // GL_INVALID_ENUM
                    }
                    return; // Do not write anything to the out pointer, since no binary formats are supported.
                case 0x8df9: // GL_NUM_SHADER_BINARY_FORMATS
                    ret = 0;
                    break;
                case 0x86a2: // GL_NUM_COMPRESSED_TEXTURE_FORMATS
                    // WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be queried for length),
                    // so implement it ourselves to allow C++ GLES2 code get the length.
                    var formats = GLctx.getParameter(0x86a3 /*GL_COMPRESSED_TEXTURE_FORMATS*/);
                    ret = formats ? formats.length : 0;
                    break;
            }

            if (ret === undefined) {
                var result = GLctx.getParameter(name_);
                switch (typeof result) {
                    case "number":
                        ret = result;
                        break;
                    case "boolean":
                        ret = result ? 1 : 0;
                        break;
                    case "string":
                        GL.recordError(0x500); // GL_INVALID_ENUM
                        return;
                    case "object":
                        if (result === null) {
                            // null is a valid result for some (e.g., which buffer is bound - perhaps nothing is bound), but otherwise
                            // can mean an invalid name_, which we need to report as an error
                            switch (name_) {
                                case 0x8894: // ARRAY_BUFFER_BINDING
                                case 0x8b8d: // CURRENT_PROGRAM
                                case 0x8895: // ELEMENT_ARRAY_BUFFER_BINDING
                                case 0x8ca6: // FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
                                case 0x8ca7: // RENDERBUFFER_BINDING
                                case 0x8069: // TEXTURE_BINDING_2D
                                case 0x85b5: // WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
                                case 0x8514: {
                                    // TEXTURE_BINDING_CUBE_MAP
                                    ret = 0;
                                    break;
                                }
                                default: {
                                    GL.recordError(0x500); // GL_INVALID_ENUM
                                    return;
                                }
                            }
                        } else if (
                            result instanceof Float32Array ||
                            result instanceof Uint32Array ||
                            result instanceof Int32Array ||
                            result instanceof Array
                        ) {
                            for (var i = 0; i < result.length; ++i) {
                                switch (type) {
                                    case 0:
                                        HEAP32[(p + i * 4) >> 2] = result[i];
                                        break;
                                    case 2:
                                        HEAPF32[(p + i * 4) >> 2] = result[i];
                                        break;
                                    case 4:
                                        HEAP8[(p + i) >> 0] = result[i] ? 1 : 0;
                                        break;
                                }
                            }
                            return;
                        } else {
                            try {
                                ret = result.name | 0;
                            } catch (e) {
                                GL.recordError(0x500); // GL_INVALID_ENUM
                                err(
                                    "GL_INVALID_ENUM in glGet" +
                                        type +
                                        "v: Unknown object returned from WebGL getParameter(" +
                                        name_ +
                                        ")! (error: " +
                                        e +
                                        ")"
                                );
                                return;
                            }
                        }
                        break;
                    default:
                        GL.recordError(0x500); // GL_INVALID_ENUM
                        err(
                            "GL_INVALID_ENUM in glGet" +
                                type +
                                "v: Native code calling glGet" +
                                type +
                                "v(" +
                                name_ +
                                ") and it returns " +
                                result +
                                " of type " +
                                typeof result +
                                "!"
                        );
                        return;
                }
            }

            switch (type) {
                case 1:
                    writeI53ToI64(p, ret);
                    break;
                case 0:
                    HEAP32[p >> 2] = ret;
                    break;
                case 2:
                    HEAPF32[p >> 2] = ret;
                    break;
                case 4:
                    HEAP8[p >> 0] = ret ? 1 : 0;
                    break;
            }
        }

        function _emscripten_glGetBooleanv(name_, p) {
            emscriptenWebGLGet(name_, p, 4);
        }

        function _emscripten_glGetBufferParameteriv(target, value, data) {
            if (!data) {
                // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
                // if data == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[data >> 2] = GLctx.getBufferParameter(target, value);
        }

        function _emscripten_glGetError() {
            var error = GLctx.getError() || GL.lastError;
            GL.lastError = 0 /*GL_NO_ERROR*/;
            return error;
        }

        function _emscripten_glGetFloatv(name_, p) {
            emscriptenWebGLGet(name_, p, 2);
        }

        function _emscripten_glGetFramebufferAttachmentParameteriv(
            target,
            attachment,
            pname,
            params
        ) {
            var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
            if (result instanceof WebGLRenderbuffer || result instanceof WebGLTexture) {
                result = result.name | 0;
            }
            HEAP32[params >> 2] = result;
        }

        function _emscripten_glGetIntegerv(name_, p) {
            emscriptenWebGLGet(name_, p, 0);
        }

        function _emscripten_glGetProgramInfoLog(program, maxLength, length, infoLog) {
            var log = GLctx.getProgramInfoLog(GL.programs[program]);
            if (log === null) log = "(unknown error)";
            var numBytesWrittenExclNull =
                maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
        }

        function _emscripten_glGetProgramiv(program, pname, p) {
            if (!p) {
                // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }

            if (program >= GL.counter) {
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }

            program = GL.programs[program];

            if (pname == 0x8b84) {
                // GL_INFO_LOG_LENGTH
                var log = GLctx.getProgramInfoLog(program);
                if (log === null) log = "(unknown error)";
                HEAP32[p >> 2] = log.length + 1;
            } else if (pname == 0x8b87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {
                if (!program.maxUniformLength) {
                    for (
                        var i = 0;
                        i < GLctx.getProgramParameter(program, 0x8b86 /*GL_ACTIVE_UNIFORMS*/);
                        ++i
                    ) {
                        program.maxUniformLength = Math.max(
                            program.maxUniformLength,
                            GLctx.getActiveUniform(program, i).name.length + 1
                        );
                    }
                }
                HEAP32[p >> 2] = program.maxUniformLength;
            } else if (pname == 0x8b8a /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {
                if (!program.maxAttributeLength) {
                    for (
                        var i = 0;
                        i < GLctx.getProgramParameter(program, 0x8b89 /*GL_ACTIVE_ATTRIBUTES*/);
                        ++i
                    ) {
                        program.maxAttributeLength = Math.max(
                            program.maxAttributeLength,
                            GLctx.getActiveAttrib(program, i).name.length + 1
                        );
                    }
                }
                HEAP32[p >> 2] = program.maxAttributeLength;
            } else if (pname == 0x8a35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {
                if (!program.maxUniformBlockNameLength) {
                    for (
                        var i = 0;
                        i < GLctx.getProgramParameter(program, 0x8a36 /*GL_ACTIVE_UNIFORM_BLOCKS*/);
                        ++i
                    ) {
                        program.maxUniformBlockNameLength = Math.max(
                            program.maxUniformBlockNameLength,
                            GLctx.getActiveUniformBlockName(program, i).length + 1
                        );
                    }
                }
                HEAP32[p >> 2] = program.maxUniformBlockNameLength;
            } else {
                HEAP32[p >> 2] = GLctx.getProgramParameter(program, pname);
            }
        }

        function _emscripten_glGetQueryObjecti64vEXT(id, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            var query = GL.queries[id];
            var param;
            {
                param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            }
            var ret;
            if (typeof param == "boolean") {
                ret = param ? 1 : 0;
            } else {
                ret = param;
            }
            writeI53ToI64(params, ret);
        }

        function _emscripten_glGetQueryObjectivEXT(id, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            var query = GL.queries[id];
            var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            var ret;
            if (typeof param == "boolean") {
                ret = param ? 1 : 0;
            } else {
                ret = param;
            }
            HEAP32[params >> 2] = ret;
        }

        function _emscripten_glGetQueryObjectui64vEXT(id, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            var query = GL.queries[id];
            var param;
            {
                param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            }
            var ret;
            if (typeof param == "boolean") {
                ret = param ? 1 : 0;
            } else {
                ret = param;
            }
            writeI53ToI64(params, ret);
        }

        function _emscripten_glGetQueryObjectuivEXT(id, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            var query = GL.queries[id];
            var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            var ret;
            if (typeof param == "boolean") {
                ret = param ? 1 : 0;
            } else {
                ret = param;
            }
            HEAP32[params >> 2] = ret;
        }

        function _emscripten_glGetQueryivEXT(target, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[params >> 2] = GLctx.disjointTimerQueryExt["getQueryEXT"](target, pname);
        }

        function _emscripten_glGetRenderbufferParameteriv(target, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if params == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[params >> 2] = GLctx.getRenderbufferParameter(target, pname);
        }

        function _emscripten_glGetShaderInfoLog(shader, maxLength, length, infoLog) {
            var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
            if (log === null) log = "(unknown error)";
            var numBytesWrittenExclNull =
                maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
        }

        function _emscripten_glGetShaderPrecisionFormat(
            shaderType,
            precisionType,
            range,
            precision
        ) {
            var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
            HEAP32[range >> 2] = result.rangeMin;
            HEAP32[(range + 4) >> 2] = result.rangeMax;
            HEAP32[precision >> 2] = result.precision;
        }

        function _emscripten_glGetShaderSource(shader, bufSize, length, source) {
            var result = GLctx.getShaderSource(GL.shaders[shader]);
            if (!result) return; // If an error occurs, nothing will be written to length or source.
            var numBytesWrittenExclNull =
                bufSize > 0 && source ? stringToUTF8(result, source, bufSize) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
        }

        function _emscripten_glGetShaderiv(shader, pname, p) {
            if (!p) {
                // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            if (pname == 0x8b84) {
                // GL_INFO_LOG_LENGTH
                var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
                if (log === null) log = "(unknown error)";
                // The GLES2 specification says that if the shader has an empty info log,
                // a value of 0 is returned. Otherwise the log has a null char appended.
                // (An empty string is falsey, so we can just check that instead of
                // looking at log.length.)
                var logLength = log ? log.length + 1 : 0;
                HEAP32[p >> 2] = logLength;
            } else if (pname == 0x8b88) {
                // GL_SHADER_SOURCE_LENGTH
                var source = GLctx.getShaderSource(GL.shaders[shader]);
                // source may be a null, or the empty string, both of which are falsey
                // values that we report a 0 length for.
                var sourceLength = source ? source.length + 1 : 0;
                HEAP32[p >> 2] = sourceLength;
            } else {
                HEAP32[p >> 2] = GLctx.getShaderParameter(GL.shaders[shader], pname);
            }
        }

        function stringToNewUTF8(jsString) {
            var length = lengthBytesUTF8(jsString) + 1;
            var cString = _malloc(length);
            stringToUTF8(jsString, cString, length);
            return cString;
        }

        function _emscripten_glGetString(name_) {
            var ret = GL.stringCache[name_];
            if (!ret) {
                switch (name_) {
                    case 0x1f03 /* GL_EXTENSIONS */:
                        var exts = GLctx.getSupportedExtensions() || []; // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
                        exts = exts.concat(
                            exts.map(function (e) {
                                return "GL_" + e;
                            })
                        );
                        ret = stringToNewUTF8(exts.join(" "));
                        break;
                    case 0x1f00 /* GL_VENDOR */:
                    case 0x1f01 /* GL_RENDERER */:
                    case 0x9245 /* UNMASKED_VENDOR_WEBGL */:
                    case 0x9246 /* UNMASKED_RENDERER_WEBGL */:
                        var s = GLctx.getParameter(name_);
                        if (!s) {
                            GL.recordError(0x500 /*GL_INVALID_ENUM*/);
                        }
                        ret = s && stringToNewUTF8(s);
                        break;

                    case 0x1f02 /* GL_VERSION */:
                        var glVersion = GLctx.getParameter(0x1f02 /*GL_VERSION*/);
                        // return GLES version string corresponding to the version of the WebGL context
                        {
                            glVersion = "OpenGL ES 2.0 (" + glVersion + ")";
                        }
                        ret = stringToNewUTF8(glVersion);
                        break;
                    case 0x8b8c /* GL_SHADING_LANGUAGE_VERSION */:
                        var glslVersion = GLctx.getParameter(
                            0x8b8c /*GL_SHADING_LANGUAGE_VERSION*/
                        );
                        // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
                        var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
                        var ver_num = glslVersion.match(ver_re);
                        if (ver_num !== null) {
                            if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + "0"; // ensure minor version has 2 digits
                            glslVersion =
                                "OpenGL ES GLSL ES " + ver_num[1] + " (" + glslVersion + ")";
                        }
                        ret = stringToNewUTF8(glslVersion);
                        break;
                    default:
                        GL.recordError(0x500 /*GL_INVALID_ENUM*/);
                    // fall through
                }
                GL.stringCache[name_] = ret;
            }
            return ret;
        }

        function _emscripten_glGetTexParameterfv(target, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAPF32[params >> 2] = GLctx.getTexParameter(target, pname);
        }

        function _emscripten_glGetTexParameteriv(target, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[params >> 2] = GLctx.getTexParameter(target, pname);
        }

        /** @noinline */
        function webglGetLeftBracePos(name) {
            return name.slice(-1) == "]" && name.lastIndexOf("[");
        }

        function webglPrepareUniformLocationsBeforeFirstUse(program) {
            var uniformLocsById = program.uniformLocsById, // Maps GLuint -> WebGLUniformLocation
                uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, // Maps name -> [uniform array length, GLuint]
                i,
                j;

            // On the first time invocation of glGetUniformLocation on this shader program:
            // initialize cache data structures and discover which uniforms are arrays.
            if (!uniformLocsById) {
                // maps GLint integer locations to WebGLUniformLocations
                program.uniformLocsById = uniformLocsById = {};
                // maps integer locations back to uniform name strings, so that we can lazily fetch uniform array locations
                program.uniformArrayNamesById = {};

                for (
                    i = 0;
                    i < GLctx.getProgramParameter(program, 0x8b86 /*GL_ACTIVE_UNIFORMS*/);
                    ++i
                ) {
                    var u = GLctx.getActiveUniform(program, i);
                    var nm = u.name;
                    var sz = u.size;
                    var lb = webglGetLeftBracePos(nm);
                    var arrayName = lb > 0 ? nm.slice(0, lb) : nm;

                    // Assign a new location.
                    var id = program.uniformIdCounter;
                    program.uniformIdCounter += sz;
                    // Eagerly get the location of the uniformArray[0] base element.
                    // The remaining indices >0 will be left for lazy evaluation to
                    // improve performance. Those may never be needed to fetch, if the
                    // application fills arrays always in full starting from the first
                    // element of the array.
                    uniformSizeAndIdsByName[arrayName] = [sz, id];

                    // Store placeholder integers in place that highlight that these
                    // >0 index locations are array indices pending population.
                    for (j = 0; j < sz; ++j) {
                        uniformLocsById[id] = j;
                        program.uniformArrayNamesById[id++] = arrayName;
                    }
                }
            }
        }

        function _emscripten_glGetUniformLocation(program, name) {
            name = UTF8ToString(name);

            if ((program = GL.programs[program])) {
                webglPrepareUniformLocationsBeforeFirstUse(program);
                var uniformLocsById = program.uniformLocsById; // Maps GLuint -> WebGLUniformLocation
                var arrayIndex = 0;
                var uniformBaseName = name;

                // Invariant: when populating integer IDs for uniform locations, we must maintain the precondition that
                // arrays reside in contiguous addresses, i.e. for a 'vec4 colors[10];', colors[4] must be at location colors[0]+4.
                // However, user might call glGetUniformLocation(program, "colors") for an array, so we cannot discover based on the user
                // input arguments whether the uniform we are dealing with is an array. The only way to discover which uniforms are arrays
                // is to enumerate over all the active uniforms in the program.
                var leftBrace = webglGetLeftBracePos(name);

                // If user passed an array accessor "[index]", parse the array index off the accessor.
                if (leftBrace > 0) {
                    arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0; // "index]", coerce parseInt(']') with >>>0 to treat "foo[]" as "foo[0]" and foo[-1] as unsigned out-of-bounds.
                    uniformBaseName = name.slice(0, leftBrace);
                }

                // Have we cached the location of this uniform before?
                var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName]; // A pair [array length, GLint of the uniform location]

                // If an uniform with this name exists, and if its index is within the array limits (if it's even an array),
                // query the WebGLlocation, or return an existing cached location.
                if (sizeAndId && arrayIndex < sizeAndId[0]) {
                    arrayIndex += sizeAndId[1]; // Add the base location of the uniform to the array index offset.
                    if (
                        (uniformLocsById[arrayIndex] =
                            uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name))
                    ) {
                        return arrayIndex;
                    }
                }
            } else {
                // N.b. we are currently unable to distinguish between GL program IDs that never existed vs GL program IDs that have been deleted,
                // so report GL_INVALID_VALUE in both cases.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
            }
            return -1;
        }

        function webglGetUniformLocation(location) {
            var p = GLctx.currentProgram;

            if (p) {
                var webglLoc = p.uniformLocsById[location];
                // p.uniformLocsById[location] stores either an integer, or a WebGLUniformLocation.

                // If an integer, we have not yet bound the location, so do it now. The integer value specifies the array index
                // we should bind to.
                if (typeof webglLoc == "number") {
                    p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(
                        p,
                        p.uniformArrayNamesById[location] +
                            (webglLoc > 0 ? "[" + webglLoc + "]" : "")
                    );
                }
                // Else an already cached WebGLUniformLocation, return it.
                return webglLoc;
            } else {
                GL.recordError(0x502 /*GL_INVALID_OPERATION*/);
            }
        }

        /** @suppress{checkTypes} */
        function emscriptenWebGLGetUniform(program, location, params, type) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if params == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            program = GL.programs[program];
            webglPrepareUniformLocationsBeforeFirstUse(program);
            var data = GLctx.getUniform(program, webglGetUniformLocation(location));
            if (typeof data == "number" || typeof data == "boolean") {
                switch (type) {
                    case 0:
                        HEAP32[params >> 2] = data;
                        break;
                    case 2:
                        HEAPF32[params >> 2] = data;
                        break;
                }
            } else {
                for (var i = 0; i < data.length; i++) {
                    switch (type) {
                        case 0:
                            HEAP32[(params + i * 4) >> 2] = data[i];
                            break;
                        case 2:
                            HEAPF32[(params + i * 4) >> 2] = data[i];
                            break;
                    }
                }
            }
        }

        function _emscripten_glGetUniformfv(program, location, params) {
            emscriptenWebGLGetUniform(program, location, params, 2);
        }

        function _emscripten_glGetUniformiv(program, location, params) {
            emscriptenWebGLGetUniform(program, location, params, 0);
        }

        function _emscripten_glGetVertexAttribPointerv(index, pname, pointer) {
            if (!pointer) {
                // GLES2 specification does not specify how to behave if pointer is a null pointer. Since calling this function does not make sense
                // if pointer == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[pointer >> 2] = GLctx.getVertexAttribOffset(index, pname);
        }

        /** @suppress{checkTypes} */
        function emscriptenWebGLGetVertexAttrib(index, pname, params, type) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if params == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            var data = GLctx.getVertexAttrib(index, pname);
            if (pname == 0x889f /*VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*/) {
                HEAP32[params >> 2] = data && data["name"];
            } else if (typeof data == "number" || typeof data == "boolean") {
                switch (type) {
                    case 0:
                        HEAP32[params >> 2] = data;
                        break;
                    case 2:
                        HEAPF32[params >> 2] = data;
                        break;
                    case 5:
                        HEAP32[params >> 2] = Math.fround(data);
                        break;
                }
            } else {
                for (var i = 0; i < data.length; i++) {
                    switch (type) {
                        case 0:
                            HEAP32[(params + i * 4) >> 2] = data[i];
                            break;
                        case 2:
                            HEAPF32[(params + i * 4) >> 2] = data[i];
                            break;
                        case 5:
                            HEAP32[(params + i * 4) >> 2] = Math.fround(data[i]);
                            break;
                    }
                }
            }
        }

        function _emscripten_glGetVertexAttribfv(index, pname, params) {
            // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
            // otherwise the results are undefined. (GLES3 spec 6.1.12)
            emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
        }

        function _emscripten_glGetVertexAttribiv(index, pname, params) {
            // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
            // otherwise the results are undefined. (GLES3 spec 6.1.12)
            emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
        }

        function _emscripten_glHint(x0, x1) {
            GLctx["hint"](x0, x1);
        }

        function _emscripten_glIsBuffer(buffer) {
            var b = GL.buffers[buffer];
            if (!b) return 0;
            return GLctx.isBuffer(b);
        }

        function _emscripten_glIsEnabled(x0) {
            return GLctx["isEnabled"](x0);
        }

        function _emscripten_glIsFramebuffer(framebuffer) {
            var fb = GL.framebuffers[framebuffer];
            if (!fb) return 0;
            return GLctx.isFramebuffer(fb);
        }

        function _emscripten_glIsProgram(program) {
            program = GL.programs[program];
            if (!program) return 0;
            return GLctx.isProgram(program);
        }

        function _emscripten_glIsQueryEXT(id) {
            var query = GL.queries[id];
            if (!query) return 0;
            return GLctx.disjointTimerQueryExt["isQueryEXT"](query);
        }

        function _emscripten_glIsRenderbuffer(renderbuffer) {
            var rb = GL.renderbuffers[renderbuffer];
            if (!rb) return 0;
            return GLctx.isRenderbuffer(rb);
        }

        function _emscripten_glIsShader(shader) {
            var s = GL.shaders[shader];
            if (!s) return 0;
            return GLctx.isShader(s);
        }

        function _emscripten_glIsTexture(id) {
            var texture = GL.textures[id];
            if (!texture) return 0;
            return GLctx.isTexture(texture);
        }

        function _emscripten_glIsVertexArrayOES(array) {
            var vao = GL.vaos[array];
            if (!vao) return 0;
            return GLctx["isVertexArray"](vao);
        }

        function _emscripten_glLineWidth(x0) {
            GLctx["lineWidth"](x0);
        }

        function _emscripten_glLinkProgram(program) {
            program = GL.programs[program];
            GLctx.linkProgram(program);
            // Invalidate earlier computed uniform->ID mappings, those have now become stale
            program.uniformLocsById = 0; // Mark as null-like so that glGetUniformLocation() knows to populate this again.
            program.uniformSizeAndIdsByName = {};
        }

        function _emscripten_glPixelStorei(pname, param) {
            if (pname == 0xcf5 /* GL_UNPACK_ALIGNMENT */) {
                GL.unpackAlignment = param;
            }
            GLctx.pixelStorei(pname, param);
        }

        function _emscripten_glPolygonOffset(x0, x1) {
            GLctx["polygonOffset"](x0, x1);
        }

        function _emscripten_glQueryCounterEXT(id, target) {
            GLctx.disjointTimerQueryExt["queryCounterEXT"](GL.queries[id], target);
        }

        function computeUnpackAlignedImageSize(width, height, sizePerPixel, alignment) {
            function roundedToNextMultipleOf(x, y) {
                return (x + y - 1) & -y;
            }
            var plainRowSize = width * sizePerPixel;
            var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
            return height * alignedRowSize;
        }

        function __colorChannelsInGlTextureFormat(format) {
            // Micro-optimizations for size: map format to size by subtracting smallest enum value (0x1902) from all values first.
            // Also omit the most common size value (1) from the list, which is assumed by formats not on the list.
            var colorChannels = {
                // 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
                // 0x1906 /* GL_ALPHA */ - 0x1902: 1,
                5: 3,
                6: 4,
                // 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
                8: 2,
                29502: 3,
                29504: 4
            };
            return colorChannels[format - 0x1902] || 1;
        }

        function heapObjectForWebGLType(type) {
            // Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
            // smaller values for the heap, for shorter generated code size.
            // Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
            // (since most types are HEAPU16)
            type -= 0x1400;

            if (type == 1) return HEAPU8;

            if (type == 4) return HEAP32;

            if (type == 6) return HEAPF32;

            if (type == 5 || type == 28922) return HEAPU32;

            return HEAPU16;
        }

        function heapAccessShiftForWebGLHeap(heap) {
            return 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
        }

        function emscriptenWebGLGetTexPixelData(
            type,
            format,
            width,
            height,
            pixels,
            internalFormat
        ) {
            var heap = heapObjectForWebGLType(type);
            var shift = heapAccessShiftForWebGLHeap(heap);
            var byteSize = 1 << shift;
            var sizePerPixel = __colorChannelsInGlTextureFormat(format) * byteSize;
            var bytes = computeUnpackAlignedImageSize(
                width,
                height,
                sizePerPixel,
                GL.unpackAlignment
            );
            return heap.subarray(pixels >> shift, (pixels + bytes) >> shift);
        }

        function _emscripten_glReadPixels(x, y, width, height, format, type, pixels) {
            var pixelData = emscriptenWebGLGetTexPixelData(
                type,
                format,
                width,
                height,
                pixels,
                format
            );
            if (!pixelData) {
                GL.recordError(0x500 /*GL_INVALID_ENUM*/);
                return;
            }
            GLctx.readPixels(x, y, width, height, format, type, pixelData);
        }

        function _emscripten_glReleaseShaderCompiler() {
            // NOP (as allowed by GLES 2.0 spec)
        }

        function _emscripten_glRenderbufferStorage(x0, x1, x2, x3) {
            GLctx["renderbufferStorage"](x0, x1, x2, x3);
        }

        function _emscripten_glSampleCoverage(value, invert) {
            GLctx.sampleCoverage(value, !!invert);
        }

        function _emscripten_glScissor(x0, x1, x2, x3) {
            GLctx["scissor"](x0, x1, x2, x3);
        }

        function _emscripten_glShaderBinary() {
            GL.recordError(0x500 /*GL_INVALID_ENUM*/);
        }

        function _emscripten_glShaderSource(shader, count, string, length) {
            var source = GL.getSource(shader, count, string, length);

            GLctx.shaderSource(GL.shaders[shader], source);
        }

        function _emscripten_glStencilFunc(x0, x1, x2) {
            GLctx["stencilFunc"](x0, x1, x2);
        }

        function _emscripten_glStencilFuncSeparate(x0, x1, x2, x3) {
            GLctx["stencilFuncSeparate"](x0, x1, x2, x3);
        }

        function _emscripten_glStencilMask(x0) {
            GLctx["stencilMask"](x0);
        }

        function _emscripten_glStencilMaskSeparate(x0, x1) {
            GLctx["stencilMaskSeparate"](x0, x1);
        }

        function _emscripten_glStencilOp(x0, x1, x2) {
            GLctx["stencilOp"](x0, x1, x2);
        }

        function _emscripten_glStencilOpSeparate(x0, x1, x2, x3) {
            GLctx["stencilOpSeparate"](x0, x1, x2, x3);
        }

        function _emscripten_glTexImage2D(
            target,
            level,
            internalFormat,
            width,
            height,
            border,
            format,
            type,
            pixels
        ) {
            GLctx.texImage2D(
                target,
                level,
                internalFormat,
                width,
                height,
                border,
                format,
                type,
                pixels
                    ? emscriptenWebGLGetTexPixelData(
                          type,
                          format,
                          width,
                          height,
                          pixels,
                          internalFormat
                      )
                    : null
            );
        }

        function _emscripten_glTexParameterf(x0, x1, x2) {
            GLctx["texParameterf"](x0, x1, x2);
        }

        function _emscripten_glTexParameterfv(target, pname, params) {
            var param = HEAPF32[params >> 2];
            GLctx.texParameterf(target, pname, param);
        }

        function _emscripten_glTexParameteri(x0, x1, x2) {
            GLctx["texParameteri"](x0, x1, x2);
        }

        function _emscripten_glTexParameteriv(target, pname, params) {
            var param = HEAP32[params >> 2];
            GLctx.texParameteri(target, pname, param);
        }

        function _emscripten_glTexSubImage2D(
            target,
            level,
            xoffset,
            yoffset,
            width,
            height,
            format,
            type,
            pixels
        ) {
            var pixelData = null;
            if (pixels)
                pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
            GLctx.texSubImage2D(
                target,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                type,
                pixelData
            );
        }

        function _emscripten_glUniform1f(location, v0) {
            GLctx.uniform1f(webglGetUniformLocation(location), v0);
        }

        var miniTempWebGLFloatBuffers = [];

        function _emscripten_glUniform1fv(location, count, value) {
            if (count <= 288) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[count - 1];
                for (var i = 0; i < count; ++i) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 4) >> 2);
            }
            GLctx.uniform1fv(webglGetUniformLocation(location), view);
        }

        function _emscripten_glUniform1i(location, v0) {
            GLctx.uniform1i(webglGetUniformLocation(location), v0);
        }

        var __miniTempWebGLIntBuffers = [];

        function _emscripten_glUniform1iv(location, count, value) {
            if (count <= 288) {
                // avoid allocation when uploading few enough uniforms
                var view = __miniTempWebGLIntBuffers[count - 1];
                for (var i = 0; i < count; ++i) {
                    view[i] = HEAP32[(value + 4 * i) >> 2];
                }
            } else {
                var view = HEAP32.subarray(value >> 2, (value + count * 4) >> 2);
            }
            GLctx.uniform1iv(webglGetUniformLocation(location), view);
        }

        function _emscripten_glUniform2f(location, v0, v1) {
            GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
        }

        function _emscripten_glUniform2fv(location, count, value) {
            if (count <= 144) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[2 * count - 1];
                for (var i = 0; i < 2 * count; i += 2) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAPF32[(value + (4 * i + 4)) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 8) >> 2);
            }
            GLctx.uniform2fv(webglGetUniformLocation(location), view);
        }

        function _emscripten_glUniform2i(location, v0, v1) {
            GLctx.uniform2i(webglGetUniformLocation(location), v0, v1);
        }

        function _emscripten_glUniform2iv(location, count, value) {
            if (count <= 144) {
                // avoid allocation when uploading few enough uniforms
                var view = __miniTempWebGLIntBuffers[2 * count - 1];
                for (var i = 0; i < 2 * count; i += 2) {
                    view[i] = HEAP32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAP32[(value + (4 * i + 4)) >> 2];
                }
            } else {
                var view = HEAP32.subarray(value >> 2, (value + count * 8) >> 2);
            }
            GLctx.uniform2iv(webglGetUniformLocation(location), view);
        }

        function _emscripten_glUniform3f(location, v0, v1, v2) {
            GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
        }

        function _emscripten_glUniform3fv(location, count, value) {
            if (count <= 96) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[3 * count - 1];
                for (var i = 0; i < 3 * count; i += 3) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAPF32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAPF32[(value + (4 * i + 8)) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 12) >> 2);
            }
            GLctx.uniform3fv(webglGetUniformLocation(location), view);
        }

        function _emscripten_glUniform3i(location, v0, v1, v2) {
            GLctx.uniform3i(webglGetUniformLocation(location), v0, v1, v2);
        }

        function _emscripten_glUniform3iv(location, count, value) {
            if (count <= 96) {
                // avoid allocation when uploading few enough uniforms
                var view = __miniTempWebGLIntBuffers[3 * count - 1];
                for (var i = 0; i < 3 * count; i += 3) {
                    view[i] = HEAP32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAP32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAP32[(value + (4 * i + 8)) >> 2];
                }
            } else {
                var view = HEAP32.subarray(value >> 2, (value + count * 12) >> 2);
            }
            GLctx.uniform3iv(webglGetUniformLocation(location), view);
        }

        function _emscripten_glUniform4f(location, v0, v1, v2, v3) {
            GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
        }

        function _emscripten_glUniform4fv(location, count, value) {
            if (count <= 72) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[4 * count - 1];
                // hoist the heap out of the loop for size and for pthreads+growth.
                var heap = HEAPF32;
                value >>= 2;
                for (var i = 0; i < 4 * count; i += 4) {
                    var dst = value + i;
                    view[i] = heap[dst];
                    view[i + 1] = heap[dst + 1];
                    view[i + 2] = heap[dst + 2];
                    view[i + 3] = heap[dst + 3];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 16) >> 2);
            }
            GLctx.uniform4fv(webglGetUniformLocation(location), view);
        }

        function _emscripten_glUniform4i(location, v0, v1, v2, v3) {
            GLctx.uniform4i(webglGetUniformLocation(location), v0, v1, v2, v3);
        }

        function _emscripten_glUniform4iv(location, count, value) {
            if (count <= 72) {
                // avoid allocation when uploading few enough uniforms
                var view = __miniTempWebGLIntBuffers[4 * count - 1];
                for (var i = 0; i < 4 * count; i += 4) {
                    view[i] = HEAP32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAP32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAP32[(value + (4 * i + 8)) >> 2];
                    view[i + 3] = HEAP32[(value + (4 * i + 12)) >> 2];
                }
            } else {
                var view = HEAP32.subarray(value >> 2, (value + count * 16) >> 2);
            }
            GLctx.uniform4iv(webglGetUniformLocation(location), view);
        }

        function _emscripten_glUniformMatrix2fv(location, count, transpose, value) {
            if (count <= 72) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[4 * count - 1];
                for (var i = 0; i < 4 * count; i += 4) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAPF32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAPF32[(value + (4 * i + 8)) >> 2];
                    view[i + 3] = HEAPF32[(value + (4 * i + 12)) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 16) >> 2);
            }
            GLctx.uniformMatrix2fv(webglGetUniformLocation(location), !!transpose, view);
        }

        function _emscripten_glUniformMatrix3fv(location, count, transpose, value) {
            if (count <= 32) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[9 * count - 1];
                for (var i = 0; i < 9 * count; i += 9) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAPF32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAPF32[(value + (4 * i + 8)) >> 2];
                    view[i + 3] = HEAPF32[(value + (4 * i + 12)) >> 2];
                    view[i + 4] = HEAPF32[(value + (4 * i + 16)) >> 2];
                    view[i + 5] = HEAPF32[(value + (4 * i + 20)) >> 2];
                    view[i + 6] = HEAPF32[(value + (4 * i + 24)) >> 2];
                    view[i + 7] = HEAPF32[(value + (4 * i + 28)) >> 2];
                    view[i + 8] = HEAPF32[(value + (4 * i + 32)) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 36) >> 2);
            }
            GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, view);
        }

        function _emscripten_glUniformMatrix4fv(location, count, transpose, value) {
            if (count <= 18) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[16 * count - 1];
                // hoist the heap out of the loop for size and for pthreads+growth.
                var heap = HEAPF32;
                value >>= 2;
                for (var i = 0; i < 16 * count; i += 16) {
                    var dst = value + i;
                    view[i] = heap[dst];
                    view[i + 1] = heap[dst + 1];
                    view[i + 2] = heap[dst + 2];
                    view[i + 3] = heap[dst + 3];
                    view[i + 4] = heap[dst + 4];
                    view[i + 5] = heap[dst + 5];
                    view[i + 6] = heap[dst + 6];
                    view[i + 7] = heap[dst + 7];
                    view[i + 8] = heap[dst + 8];
                    view[i + 9] = heap[dst + 9];
                    view[i + 10] = heap[dst + 10];
                    view[i + 11] = heap[dst + 11];
                    view[i + 12] = heap[dst + 12];
                    view[i + 13] = heap[dst + 13];
                    view[i + 14] = heap[dst + 14];
                    view[i + 15] = heap[dst + 15];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 64) >> 2);
            }
            GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
        }

        function _emscripten_glUseProgram(program) {
            program = GL.programs[program];
            GLctx.useProgram(program);
            // Record the currently active program so that we can access the uniform
            // mapping table of that program.
            GLctx.currentProgram = program;
        }

        function _emscripten_glValidateProgram(program) {
            GLctx.validateProgram(GL.programs[program]);
        }

        function _emscripten_glVertexAttrib1f(x0, x1) {
            GLctx["vertexAttrib1f"](x0, x1);
        }

        function _emscripten_glVertexAttrib1fv(index, v) {
            GLctx.vertexAttrib1f(index, HEAPF32[v >> 2]);
        }

        function _emscripten_glVertexAttrib2f(x0, x1, x2) {
            GLctx["vertexAttrib2f"](x0, x1, x2);
        }

        function _emscripten_glVertexAttrib2fv(index, v) {
            GLctx.vertexAttrib2f(index, HEAPF32[v >> 2], HEAPF32[(v + 4) >> 2]);
        }

        function _emscripten_glVertexAttrib3f(x0, x1, x2, x3) {
            GLctx["vertexAttrib3f"](x0, x1, x2, x3);
        }

        function _emscripten_glVertexAttrib3fv(index, v) {
            GLctx.vertexAttrib3f(
                index,
                HEAPF32[v >> 2],
                HEAPF32[(v + 4) >> 2],
                HEAPF32[(v + 8) >> 2]
            );
        }

        function _emscripten_glVertexAttrib4f(x0, x1, x2, x3, x4) {
            GLctx["vertexAttrib4f"](x0, x1, x2, x3, x4);
        }

        function _emscripten_glVertexAttrib4fv(index, v) {
            GLctx.vertexAttrib4f(
                index,
                HEAPF32[v >> 2],
                HEAPF32[(v + 4) >> 2],
                HEAPF32[(v + 8) >> 2],
                HEAPF32[(v + 12) >> 2]
            );
        }

        function _emscripten_glVertexAttribDivisorANGLE(index, divisor) {
            GLctx["vertexAttribDivisor"](index, divisor);
        }

        function _emscripten_glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
            GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
        }

        function _emscripten_glViewport(x0, x1, x2, x3) {
            GLctx["viewport"](x0, x1, x2, x3);
        }

        function _emscripten_has_asyncify() {
            return 0;
        }

        function _emscripten_memcpy_big(dest, src, num) {
            HEAPU8.copyWithin(dest, src, src + num);
        }

        function doRequestFullscreen(target, strategy) {
            if (!JSEvents.fullscreenEnabled()) return -1;
            target = findEventTarget(target);
            if (!target) return -4;

            if (!target.requestFullscreen && !target.webkitRequestFullscreen) {
                return -3;
            }

            var canPerformRequests = JSEvents.canPerformEventHandlerRequests();

            // Queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
            if (!canPerformRequests) {
                if (strategy.deferUntilInEventHandler) {
                    JSEvents.deferCall(
                        JSEvents_requestFullscreen,
                        1 /* priority over pointer lock */,
                        [target, strategy]
                    );
                    return 1;
                }
                return -2;
            }

            return JSEvents_requestFullscreen(target, strategy);
        }

        function _emscripten_request_fullscreen_strategy(
            target,
            deferUntilInEventHandler,
            fullscreenStrategy
        ) {
            var strategy = {
                scaleMode: HEAP32[fullscreenStrategy >> 2],
                canvasResolutionScaleMode: HEAP32[(fullscreenStrategy + 4) >> 2],
                filteringMode: HEAP32[(fullscreenStrategy + 8) >> 2],
                deferUntilInEventHandler: deferUntilInEventHandler,
                canvasResizedCallback: HEAP32[(fullscreenStrategy + 12) >> 2],
                canvasResizedCallbackUserData: HEAP32[(fullscreenStrategy + 16) >> 2]
            };

            return doRequestFullscreen(target, strategy);
        }

        function _emscripten_request_pointerlock(target, deferUntilInEventHandler) {
            target = findEventTarget(target);
            if (!target) return -4;
            if (!target.requestPointerLock) {
                return -1;
            }

            var canPerformRequests = JSEvents.canPerformEventHandlerRequests();

            // Queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
            if (!canPerformRequests) {
                if (deferUntilInEventHandler) {
                    JSEvents.deferCall(requestPointerLock, 2 /* priority below fullscreen */, [
                        target
                    ]);
                    return 1;
                }
                return -2;
            }

            return requestPointerLock(target);
        }

        function emscripten_realloc_buffer(size) {
            var b = wasmMemory.buffer;
            try {
                // round size grow request up to wasm page size (fixed 64KB per spec)
                wasmMemory.grow((size - b.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size
                updateMemoryViews();
                return 1 /*success*/;
            } catch (e) {
                err(
                    "emscripten_realloc_buffer: Attempted to grow heap from " +
                        b.byteLength +
                        " bytes to " +
                        size +
                        " bytes, but got error: " +
                        e
                );
            }
            // implicit 0 return to save code size (caller will cast "undefined" into 0
            // anyhow)
        }
        function _emscripten_resize_heap(requestedSize) {
            var oldSize = HEAPU8.length;
            requestedSize = requestedSize >>> 0;
            // With multithreaded builds, races can happen (another thread might increase the size
            // in between), so return a failure, and let the caller retry.
            assert(requestedSize > oldSize);

            // Memory resize rules:
            // 1.  Always increase heap size to at least the requested size, rounded up
            //     to next page multiple.
            // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
            //     geometrically: increase the heap size according to
            //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
            //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
            // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
            //     linearly: increase the heap size by at least
            //     MEMORY_GROWTH_LINEAR_STEP bytes.
            // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
            //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
            // 4.  If we were unable to allocate as much memory, it may be due to
            //     over-eager decision to excessively reserve due to (3) above.
            //     Hence if an allocation fails, cut down on the amount of excess
            //     growth, in an attempt to succeed to perform a smaller allocation.

            // A limit is set for how much we can grow. We should not exceed that
            // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
            var maxHeapSize = getHeapMax();
            if (requestedSize > maxHeapSize) {
                err(
                    "Cannot enlarge memory, asked to go up to " +
                        requestedSize +
                        " bytes, but the limit is " +
                        maxHeapSize +
                        " bytes!"
                );
                return false;
            }

            let alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);

            // Loop through potential heap size increases. If we attempt a too eager
            // reservation that fails, cut down on the attempted size and reserve a
            // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
                var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
                // but limit overreserving (default to capping at +96MB overgrowth at most)
                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);

                var newSize = Math.min(
                    maxHeapSize,
                    alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)
                );

                var replacement = emscripten_realloc_buffer(newSize);
                if (replacement) {
                    return true;
                }
            }
            err(
                "Failed to grow the heap from " +
                    oldSize +
                    " bytes to " +
                    newSize +
                    " bytes, not enough memory!"
            );
            return false;
        }

        function _emscripten_sample_gamepad_data() {
            return (JSEvents.lastGamepadState = navigator.getGamepads
                ? navigator.getGamepads()
                : navigator.webkitGetGamepads
                  ? navigator.webkitGetGamepads()
                  : null)
                ? 0
                : -1;
        }

        function registerBeforeUnloadEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString
        ) {
            var beforeUnloadEventHandlerFunc = function (e = event) {
                // Note: This is always called on the main browser thread, since it needs synchronously return a value!
                var confirmationMessage = getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData);

                if (confirmationMessage) {
                    confirmationMessage = UTF8ToString(confirmationMessage);
                }
                if (confirmationMessage) {
                    e.preventDefault();
                    e.returnValue = confirmationMessage;
                    return confirmationMessage;
                }
            };

            var eventHandler = {
                target: findEventTarget(target),
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: beforeUnloadEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }
        function _emscripten_set_beforeunload_callback_on_thread(
            userData,
            callbackfunc,
            targetThread
        ) {
            if (typeof onbeforeunload == "undefined") return -1;
            // beforeunload callback can only be registered on the main browser thread, because the page will go away immediately after returning from the handler,
            // and there is no time to start proxying it anywhere.
            if (targetThread !== 1) return -5;
            registerBeforeUnloadEventCallback(2, userData, true, callbackfunc, 28, "beforeunload");
            return 0;
        }

        function registerFocusEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.focusEvent) JSEvents.focusEvent = _malloc(256);

            var focusEventHandlerFunc = function (e = event) {
                var nodeName = JSEvents.getNodeNameForTarget(e.target);
                var id = e.target.id ? e.target.id : "";

                var focusEvent = JSEvents.focusEvent;
                stringToUTF8(nodeName, focusEvent + 0, 128);
                stringToUTF8(id, focusEvent + 128, 128);

                if (getWasmTableEntry(callbackfunc)(eventTypeId, focusEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: findEventTarget(target),
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: focusEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }
        function _emscripten_set_blur_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerFocusEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                12,
                "blur",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_element_css_size(target, width, height) {
            target = findEventTarget(target);
            if (!target) return -4;

            target.style.width = width + "px";
            target.style.height = height + "px";

            return 0;
        }

        function _emscripten_set_focus_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerFocusEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                13,
                "focus",
                targetThread
            );
            return 0;
        }

        function fillFullscreenChangeEventData(eventStruct) {
            var fullscreenElement =
                document.fullscreenElement ||
                document.mozFullScreenElement ||
                document.webkitFullscreenElement ||
                document.msFullscreenElement;
            var isFullscreen = !!fullscreenElement;
            // Assigning a boolean to HEAP32 with expected type coercion.
            /** @suppress{checkTypes} */
            HEAP32[eventStruct >> 2] = isFullscreen;
            HEAP32[(eventStruct + 4) >> 2] = JSEvents.fullscreenEnabled();
            // If transitioning to fullscreen, report info about the element that is now fullscreen.
            // If transitioning to windowed mode, report info about the element that just was fullscreen.
            var reportedElement = isFullscreen
                ? fullscreenElement
                : JSEvents.previousFullscreenElement;
            var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
            var id = reportedElement && reportedElement.id ? reportedElement.id : "";
            stringToUTF8(nodeName, eventStruct + 8, 128);
            stringToUTF8(id, eventStruct + 136, 128);
            HEAP32[(eventStruct + 264) >> 2] = reportedElement ? reportedElement.clientWidth : 0;
            HEAP32[(eventStruct + 268) >> 2] = reportedElement ? reportedElement.clientHeight : 0;
            HEAP32[(eventStruct + 272) >> 2] = screen.width;
            HEAP32[(eventStruct + 276) >> 2] = screen.height;
            if (isFullscreen) {
                JSEvents.previousFullscreenElement = fullscreenElement;
            }
        }

        function registerFullscreenChangeEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.fullscreenChangeEvent) JSEvents.fullscreenChangeEvent = _malloc(280);

            var fullscreenChangeEventhandlerFunc = function (e = event) {
                var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;

                fillFullscreenChangeEventData(fullscreenChangeEvent);

                if (getWasmTableEntry(callbackfunc)(eventTypeId, fullscreenChangeEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: target,
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: fullscreenChangeEventhandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }

        function _emscripten_set_fullscreenchange_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            if (!JSEvents.fullscreenEnabled()) return -1;
            target = findEventTarget(target);
            if (!target) return -4;
            registerFullscreenChangeEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                19,
                "fullscreenchange",
                targetThread
            );

            // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
            // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
            registerFullscreenChangeEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                19,
                "webkitfullscreenchange",
                targetThread
            );

            return 0;
        }

        function registerGamepadEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.gamepadEvent) JSEvents.gamepadEvent = _malloc(1432);

            var gamepadEventHandlerFunc = function (e = event) {
                var gamepadEvent = JSEvents.gamepadEvent;
                fillGamepadEventData(gamepadEvent, e["gamepad"]);

                if (getWasmTableEntry(callbackfunc)(eventTypeId, gamepadEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: findEventTarget(target),
                allowsDeferredCalls: true,
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: gamepadEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }
        function _emscripten_set_gamepadconnected_callback_on_thread(
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            if (!navigator.getGamepads && !navigator.webkitGetGamepads) return -1;
            registerGamepadEventCallback(
                2,
                userData,
                useCapture,
                callbackfunc,
                26,
                "gamepadconnected",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_gamepaddisconnected_callback_on_thread(
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            if (!navigator.getGamepads && !navigator.webkitGetGamepads) return -1;
            registerGamepadEventCallback(
                2,
                userData,
                useCapture,
                callbackfunc,
                27,
                "gamepaddisconnected",
                targetThread
            );
            return 0;
        }

        function registerKeyEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.keyEvent) JSEvents.keyEvent = _malloc(176);

            var keyEventHandlerFunc = function (e) {
                assert(e);

                var keyEventData = JSEvents.keyEvent;
                HEAPF64[keyEventData >> 3] = e.timeStamp;

                var idx = keyEventData >> 2;

                HEAP32[idx + 2] = e.location;
                HEAP32[idx + 3] = e.ctrlKey;
                HEAP32[idx + 4] = e.shiftKey;
                HEAP32[idx + 5] = e.altKey;
                HEAP32[idx + 6] = e.metaKey;
                HEAP32[idx + 7] = e.repeat;
                HEAP32[idx + 8] = e.charCode;
                HEAP32[idx + 9] = e.keyCode;
                HEAP32[idx + 10] = e.which;
                stringToUTF8(e.key || "", keyEventData + 44, 32);
                stringToUTF8(e.code || "", keyEventData + 76, 32);
                stringToUTF8(e.char || "", keyEventData + 108, 32);
                stringToUTF8(e.locale || "", keyEventData + 140, 32);

                if (getWasmTableEntry(callbackfunc)(eventTypeId, keyEventData, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: findEventTarget(target),
                allowsDeferredCalls: true,
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: keyEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }
        function _emscripten_set_keydown_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerKeyEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                2,
                "keydown",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_keypress_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerKeyEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                1,
                "keypress",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_keyup_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerKeyEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                3,
                "keyup",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_main_loop_arg(func, arg, fps, simulateInfiniteLoop) {
            var browserIterationFunc = () => getWasmTableEntry(func)(arg);
            setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop, arg);
        }

        function fillMouseEventData(eventStruct, e, target) {
            assert(eventStruct % 4 == 0);
            HEAPF64[eventStruct >> 3] = e.timeStamp;
            var idx = eventStruct >> 2;
            HEAP32[idx + 2] = e.screenX;
            HEAP32[idx + 3] = e.screenY;
            HEAP32[idx + 4] = e.clientX;
            HEAP32[idx + 5] = e.clientY;
            HEAP32[idx + 6] = e.ctrlKey;
            HEAP32[idx + 7] = e.shiftKey;
            HEAP32[idx + 8] = e.altKey;
            HEAP32[idx + 9] = e.metaKey;
            HEAP16[idx * 2 + 20] = e.button;
            HEAP16[idx * 2 + 21] = e.buttons;

            HEAP32[idx + 11] = e["movementX"];

            HEAP32[idx + 12] = e["movementY"];

            var rect = getBoundingClientRect(target);
            HEAP32[idx + 13] = e.clientX - rect.left;
            HEAP32[idx + 14] = e.clientY - rect.top;
        }

        function registerMouseEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.mouseEvent) JSEvents.mouseEvent = _malloc(72);
            target = findEventTarget(target);

            var mouseEventHandlerFunc = function (e = event) {
                // TODO: Make this access thread safe, or this could update live while app is reading it.
                fillMouseEventData(JSEvents.mouseEvent, e, target);

                if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.mouseEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: target,
                allowsDeferredCalls:
                    eventTypeString != "mousemove" &&
                    eventTypeString != "mouseenter" &&
                    eventTypeString != "mouseleave", // Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: mouseEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }
        function _emscripten_set_mousedown_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerMouseEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                5,
                "mousedown",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_mouseenter_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerMouseEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                33,
                "mouseenter",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_mouseleave_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerMouseEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                34,
                "mouseleave",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_mousemove_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerMouseEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                8,
                "mousemove",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_mouseup_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerMouseEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                6,
                "mouseup",
                targetThread
            );
            return 0;
        }

        function fillPointerlockChangeEventData(eventStruct) {
            var pointerLockElement =
                document.pointerLockElement ||
                document.mozPointerLockElement ||
                document.webkitPointerLockElement ||
                document.msPointerLockElement;
            var isPointerlocked = !!pointerLockElement;
            // Assigning a boolean to HEAP32 with expected type coercion.
            /** @suppress{checkTypes} */
            HEAP32[eventStruct >> 2] = isPointerlocked;
            var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
            var id = pointerLockElement && pointerLockElement.id ? pointerLockElement.id : "";
            stringToUTF8(nodeName, eventStruct + 4, 128);
            stringToUTF8(id, eventStruct + 132, 128);
        }

        function registerPointerlockChangeEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.pointerlockChangeEvent) JSEvents.pointerlockChangeEvent = _malloc(260);

            var pointerlockChangeEventHandlerFunc = function (e = event) {
                var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
                fillPointerlockChangeEventData(pointerlockChangeEvent);

                if (getWasmTableEntry(callbackfunc)(eventTypeId, pointerlockChangeEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: target,
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: pointerlockChangeEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }

        /** @suppress {missingProperties} */
        function _emscripten_set_pointerlockchange_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            // TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
            if (
                !document ||
                !document.body ||
                (!document.body.requestPointerLock &&
                    !document.body.mozRequestPointerLock &&
                    !document.body.webkitRequestPointerLock &&
                    !document.body.msRequestPointerLock)
            ) {
                return -1;
            }

            target = findEventTarget(target);
            if (!target) return -4;
            registerPointerlockChangeEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                20,
                "pointerlockchange",
                targetThread
            );
            registerPointerlockChangeEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                20,
                "mozpointerlockchange",
                targetThread
            );
            registerPointerlockChangeEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                20,
                "webkitpointerlockchange",
                targetThread
            );
            registerPointerlockChangeEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                20,
                "mspointerlockchange",
                targetThread
            );
            return 0;
        }

        function registerUiEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.uiEvent) JSEvents.uiEvent = _malloc(36);

            target = findEventTarget(target);

            var uiEventHandlerFunc = function (e = event) {
                if (e.target != target) {
                    // Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
                    // was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log
                    // message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
                    // causing a new scroll, etc..
                    return;
                }
                var b = document.body; // Take document.body to a variable, Closure compiler does not outline access to it on its own.
                if (!b) {
                    // During a page unload 'body' can be null, with "Cannot read property 'clientWidth' of null" being thrown
                    return;
                }
                var uiEvent = JSEvents.uiEvent;
                HEAP32[uiEvent >> 2] = e.detail;
                HEAP32[(uiEvent + 4) >> 2] = b.clientWidth;
                HEAP32[(uiEvent + 8) >> 2] = b.clientHeight;
                HEAP32[(uiEvent + 12) >> 2] = innerWidth;
                HEAP32[(uiEvent + 16) >> 2] = innerHeight;
                HEAP32[(uiEvent + 20) >> 2] = outerWidth;
                HEAP32[(uiEvent + 24) >> 2] = outerHeight;
                HEAP32[(uiEvent + 28) >> 2] = pageXOffset;
                HEAP32[(uiEvent + 32) >> 2] = pageYOffset;
                if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: target,
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: uiEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }
        function _emscripten_set_resize_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerUiEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                10,
                "resize",
                targetThread
            );
            return 0;
        }

        function registerTouchEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.touchEvent) JSEvents.touchEvent = _malloc(1696);

            target = findEventTarget(target);

            var touchEventHandlerFunc = function (e) {
                assert(e);
                var t,
                    touches = {},
                    et = e.touches;
                // To ease marshalling different kinds of touches that browser reports (all touches are listed in e.touches,
                // only changed touches in e.changedTouches, and touches on target at a.targetTouches), mark a boolean in
                // each Touch object so that we can later loop only once over all touches we see to marshall over to Wasm.

                for (var i = 0; i < et.length; ++i) {
                    t = et[i];
                    // Browser might recycle the generated Touch objects between each frame (Firefox on Android), so reset any
                    // changed/target states we may have set from previous frame.
                    t.isChanged = t.onTarget = 0;
                    touches[t.identifier] = t;
                }
                // Mark which touches are part of the changedTouches list.
                for (var i = 0; i < e.changedTouches.length; ++i) {
                    t = e.changedTouches[i];
                    t.isChanged = 1;
                    touches[t.identifier] = t;
                }
                // Mark which touches are part of the targetTouches list.
                for (var i = 0; i < e.targetTouches.length; ++i) {
                    touches[e.targetTouches[i].identifier].onTarget = 1;
                }

                var touchEvent = JSEvents.touchEvent;
                HEAPF64[touchEvent >> 3] = e.timeStamp;
                var idx = touchEvent >> 2; // Pre-shift the ptr to index to HEAP32 to save code size
                HEAP32[idx + 3] = e.ctrlKey;
                HEAP32[idx + 4] = e.shiftKey;
                HEAP32[idx + 5] = e.altKey;
                HEAP32[idx + 6] = e.metaKey;
                idx += 7; // Advance to the start of the touch array.
                var targetRect = getBoundingClientRect(target);
                var numTouches = 0;
                for (var i in touches) {
                    t = touches[i];
                    HEAP32[idx + 0] = t.identifier;
                    HEAP32[idx + 1] = t.screenX;
                    HEAP32[idx + 2] = t.screenY;
                    HEAP32[idx + 3] = t.clientX;
                    HEAP32[idx + 4] = t.clientY;
                    HEAP32[idx + 5] = t.pageX;
                    HEAP32[idx + 6] = t.pageY;
                    HEAP32[idx + 7] = t.isChanged;
                    HEAP32[idx + 8] = t.onTarget;
                    HEAP32[idx + 9] = t.clientX - targetRect.left;
                    HEAP32[idx + 10] = t.clientY - targetRect.top;

                    idx += 13;

                    if (++numTouches > 31) {
                        break;
                    }
                }
                HEAP32[(touchEvent + 8) >> 2] = numTouches;

                if (getWasmTableEntry(callbackfunc)(eventTypeId, touchEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: target,
                allowsDeferredCalls:
                    eventTypeString == "touchstart" || eventTypeString == "touchend",
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: touchEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }
        function _emscripten_set_touchcancel_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerTouchEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                25,
                "touchcancel",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_touchend_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerTouchEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                23,
                "touchend",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_touchmove_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerTouchEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                24,
                "touchmove",
                targetThread
            );
            return 0;
        }

        function _emscripten_set_touchstart_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            registerTouchEventCallback(
                target,
                userData,
                useCapture,
                callbackfunc,
                22,
                "touchstart",
                targetThread
            );
            return 0;
        }

        function fillVisibilityChangeEventData(eventStruct) {
            var visibilityStates = ["hidden", "visible", "prerender", "unloaded"];
            var visibilityState = visibilityStates.indexOf(document.visibilityState);

            // Assigning a boolean to HEAP32 with expected type coercion.
            /** @suppress{checkTypes} */
            HEAP32[eventStruct >> 2] = document.hidden;
            HEAP32[(eventStruct + 4) >> 2] = visibilityState;
        }

        function registerVisibilityChangeEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.visibilityChangeEvent) JSEvents.visibilityChangeEvent = _malloc(8);

            var visibilityChangeEventHandlerFunc = function (e = event) {
                var visibilityChangeEvent = JSEvents.visibilityChangeEvent;

                fillVisibilityChangeEventData(visibilityChangeEvent);

                if (getWasmTableEntry(callbackfunc)(eventTypeId, visibilityChangeEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: target,
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: visibilityChangeEventHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }

        function _emscripten_set_visibilitychange_callback_on_thread(
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            if (!specialHTMLTargets[1]) {
                return -4;
            }
            registerVisibilityChangeEventCallback(
                specialHTMLTargets[1],
                userData,
                useCapture,
                callbackfunc,
                21,
                "visibilitychange",
                targetThread
            );
            return 0;
        }

        function registerWheelEventCallback(
            target,
            userData,
            useCapture,
            callbackfunc,
            eventTypeId,
            eventTypeString,
            targetThread
        ) {
            if (!JSEvents.wheelEvent) JSEvents.wheelEvent = _malloc(104);

            // The DOM Level 3 events spec event 'wheel'
            var wheelHandlerFunc = function (e = event) {
                var wheelEvent = JSEvents.wheelEvent;
                fillMouseEventData(wheelEvent, e, target);
                HEAPF64[(wheelEvent + 72) >> 3] = e["deltaX"];
                HEAPF64[(wheelEvent + 80) >> 3] = e["deltaY"];
                HEAPF64[(wheelEvent + 88) >> 3] = e["deltaZ"];
                HEAP32[(wheelEvent + 96) >> 2] = e["deltaMode"];
                if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData))
                    e.preventDefault();
            };

            var eventHandler = {
                target: target,
                allowsDeferredCalls: true,
                eventTypeString: eventTypeString,
                callbackfunc: callbackfunc,
                handlerFunc: wheelHandlerFunc,
                useCapture: useCapture
            };
            JSEvents.registerOrRemoveHandler(eventHandler);
        }

        function _emscripten_set_wheel_callback_on_thread(
            target,
            userData,
            useCapture,
            callbackfunc,
            targetThread
        ) {
            target = findEventTarget(target);
            if (typeof target.onwheel != "undefined") {
                registerWheelEventCallback(
                    target,
                    userData,
                    useCapture,
                    callbackfunc,
                    9,
                    "wheel",
                    targetThread
                );
                return 0;
            } else {
                return -1;
            }
        }

        function _emscripten_set_window_title(title) {
            setWindowTitle(UTF8ToString(title));
        }

        function _emscripten_sleep() {
            throw "Please compile your program with async support in order to use asynchronous operations like emscripten_sleep";
        }

        var ENV = {};

        function getExecutableName() {
            return thisProgram || "./this.program";
        }
        function getEnvStrings() {
            if (!getEnvStrings.strings) {
                // Default values.
                // Browser language detection #8751
                var lang =
                    (
                        (typeof navigator == "object" &&
                            navigator.languages &&
                            navigator.languages[0]) ||
                        "C"
                    ).replace("-", "_") + ".UTF-8";
                var env = {
                    USER: "web_user",
                    LOGNAME: "web_user",
                    PATH: "/",
                    PWD: "/",
                    HOME: "/home/web_user",
                    LANG: lang,
                    _: getExecutableName()
                };
                // Apply the user-provided values, if any.
                for (var x in ENV) {
                    // x is a key in ENV; if ENV[x] is undefined, that means it was
                    // explicitly set to be so. We allow user code to do that to
                    // force variables with default values to remain unset.
                    if (ENV[x] === undefined) delete env[x];
                    else env[x] = ENV[x];
                }
                var strings = [];
                for (var x in env) {
                    strings.push(x + "=" + env[x]);
                }
                getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
        }

        /** @param {boolean=} dontAddNull */
        function writeAsciiToMemory(str, buffer, dontAddNull) {
            for (var i = 0; i < str.length; ++i) {
                assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));
                HEAP8[buffer++ >> 0] = str.charCodeAt(i);
            }
            // Null-terminate the pointer to the HEAP.
            if (!dontAddNull) HEAP8[buffer >> 0] = 0;
        }

        function _environ_get(__environ, environ_buf) {
            var bufSize = 0;
            getEnvStrings().forEach(function (string, i) {
                var ptr = environ_buf + bufSize;
                HEAPU32[(__environ + i * 4) >> 2] = ptr;
                writeAsciiToMemory(string, ptr);
                bufSize += string.length + 1;
            });
            return 0;
        }

        function _environ_sizes_get(penviron_count, penviron_buf_size) {
            var strings = getEnvStrings();
            HEAPU32[penviron_count >> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function (string) {
                bufSize += string.length + 1;
            });
            HEAPU32[penviron_buf_size >> 2] = bufSize;
            return 0;
        }

        function _proc_exit(code) {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
                if (Module["onExit"]) Module["onExit"](code);
                ABORT = true;
            }
            quit_(code, new ExitStatus(code));
        }
        /** @param {boolean|number=} implicit */
        function exitJS(status, implicit) {
            EXITSTATUS = status;

            checkUnflushedContent();

            // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
            if (keepRuntimeAlive() && !implicit) {
                var msg =
                    "program exited (with status: " +
                    status +
                    "), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)";
                readyPromiseReject(msg);
                err(msg);
            }

            _proc_exit(status);
        }
        var _exit = exitJS;

        function _fd_close(fd) {
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                FS.close(stream);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return e.errno;
            }
        }

        function _fd_fdstat_get(fd, pbuf) {
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                // All character devices are terminals (other things a Linux system would
                // assume is a character device, like the mouse, we have special APIs for).
                var type = stream.tty
                    ? 2
                    : FS.isDir(stream.mode)
                      ? 3
                      : FS.isLink(stream.mode)
                        ? 7
                        : 4;
                HEAP8[pbuf >> 0] = type;
                // TODO HEAP16[(((pbuf)+(2))>>1)] = ?;
                // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)] = tempI64[0],HEAP32[(((pbuf)+(12))>>2)] = tempI64[1]);
                // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)] = tempI64[0],HEAP32[(((pbuf)+(20))>>2)] = tempI64[1]);
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return e.errno;
            }
        }

        /** @param {number=} offset */
        function doReadv(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAPU32[iov >> 2];
                var len = HEAPU32[(iov + 4) >> 2];
                iov += 8;
                var curr = FS.read(stream, HEAP8, ptr, len, offset);
                if (curr < 0) return -1;
                ret += curr;
                if (curr < len) break; // nothing more to read
                if (typeof offset !== "undefined") {
                    offset += curr;
                }
            }
            return ret;
        }

        function _fd_read(fd, iov, iovcnt, pnum) {
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                var num = doReadv(stream, iov, iovcnt);
                HEAPU32[pnum >> 2] = num;
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return e.errno;
            }
        }

        var MAX_INT53 = 9007199254740992;

        var MIN_INT53 = -9007199254740992;
        function bigintToI53Checked(num) {
            return num < MIN_INT53 || num > MAX_INT53 ? NaN : Number(num);
        }

        function _fd_seek(fd, /** @type {!BigInt} */ offset, whence, newOffset) {
            try {
                offset = bigintToI53Checked(offset);
                if (isNaN(offset)) return 61;
                var stream = SYSCALLS.getStreamFromFD(fd);
                FS.llseek(stream, offset, whence);
                (tempI64 = [
                    stream.position >>> 0,
                    ((tempDouble = stream.position),
                    +Math.abs(tempDouble) >= 1.0
                        ? tempDouble > 0.0
                            ? (Math.min(+Math.floor(tempDouble / 4294967296.0), 4294967295.0) |
                                  0) >>>
                              0
                            : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>>
                              0
                        : 0)
                ]),
                    (HEAP32[newOffset >> 2] = tempI64[0]),
                    (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
                if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return e.errno;
            }
        }

        /** @param {number=} offset */
        function doWritev(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAPU32[iov >> 2];
                var len = HEAPU32[(iov + 4) >> 2];
                iov += 8;
                var curr = FS.write(stream, HEAP8, ptr, len, offset);
                if (curr < 0) return -1;
                ret += curr;
                if (typeof offset !== "undefined") {
                    offset += curr;
                }
            }
            return ret;
        }

        function _fd_write(fd, iov, iovcnt, pnum) {
            try {
                var stream = SYSCALLS.getStreamFromFD(fd);
                var num = doWritev(stream, iov, iovcnt);
                HEAPU32[pnum >> 2] = num;
                return 0;
            } catch (e) {
                if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
                return e.errno;
            }
        }

        function _getaddrinfo(node, service, hint, out) {
            // Note getaddrinfo currently only returns a single addrinfo with ai_next defaulting to NULL. When NULL
            // hints are specified or ai_family set to AF_UNSPEC or ai_socktype or ai_protocol set to 0 then we
            // really should provide a linked list of suitable addrinfo values.
            var addrs = [];
            var canon = null;
            var addr = 0;
            var port = 0;
            var flags = 0;
            var family = 0;
            var type = 0;
            var proto = 0;
            var ai, last;

            function allocaddrinfo(family, type, proto, canon, addr, port) {
                var sa, salen, ai;
                var errno;

                salen = family === 10 ? 28 : 16;
                addr = family === 10 ? inetNtop6(addr) : inetNtop4(addr);
                sa = _malloc(salen);
                errno = writeSockaddr(sa, family, addr, port);
                assert(!errno);

                ai = _malloc(32);
                HEAP32[(ai + 4) >> 2] = family;
                HEAP32[(ai + 8) >> 2] = type;
                HEAP32[(ai + 12) >> 2] = proto;
                HEAP32[(ai + 24) >> 2] = canon;
                HEAPU32[(ai + 20) >> 2] = sa;
                if (family === 10) {
                    HEAP32[(ai + 16) >> 2] = 28;
                } else {
                    HEAP32[(ai + 16) >> 2] = 16;
                }
                HEAP32[(ai + 28) >> 2] = 0;

                return ai;
            }

            if (hint) {
                flags = HEAP32[hint >> 2];
                family = HEAP32[(hint + 4) >> 2];
                type = HEAP32[(hint + 8) >> 2];
                proto = HEAP32[(hint + 12) >> 2];
            }
            if (type && !proto) {
                proto = type === 2 ? 17 : 6;
            }
            if (!type && proto) {
                type = proto === 17 ? 2 : 1;
            }

            // If type or proto are set to zero in hints we should really be returning multiple addrinfo values, but for
            // now default to a TCP STREAM socket so we can at least return a sensible addrinfo given NULL hints.
            if (proto === 0) {
                proto = 6;
            }
            if (type === 0) {
                type = 1;
            }

            if (!node && !service) {
                return -2;
            }
            if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
                return -1;
            }
            if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
                return -1;
            }
            if (flags & 32) {
                // TODO
                return -2;
            }
            if (type !== 0 && type !== 1 && type !== 2) {
                return -7;
            }
            if (family !== 0 && family !== 2 && family !== 10) {
                return -6;
            }

            if (service) {
                service = UTF8ToString(service);
                port = parseInt(service, 10);

                if (isNaN(port)) {
                    if (flags & 1024) {
                        return -2;
                    }
                    // TODO support resolving well-known service names from:
                    // http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
                    return -8;
                }
            }

            if (!node) {
                if (family === 0) {
                    family = 2;
                }
                if ((flags & 1) === 0) {
                    if (family === 2) {
                        addr = _htonl(2130706433);
                    } else {
                        addr = [0, 0, 0, 1];
                    }
                }
                ai = allocaddrinfo(family, type, proto, null, addr, port);
                HEAPU32[out >> 2] = ai;
                return 0;
            }

            //
            // try as a numeric address
            //
            node = UTF8ToString(node);
            addr = inetPton4(node);
            if (addr !== null) {
                // incoming node is a valid ipv4 address
                if (family === 0 || family === 2) {
                    family = 2;
                } else if (family === 10 && flags & 8) {
                    addr = [0, 0, _htonl(0xffff), addr];
                    family = 10;
                } else {
                    return -2;
                }
            } else {
                addr = inetPton6(node);
                if (addr !== null) {
                    // incoming node is a valid ipv6 address
                    if (family === 0 || family === 10) {
                        family = 10;
                    } else {
                        return -2;
                    }
                }
            }
            if (addr != null) {
                ai = allocaddrinfo(family, type, proto, node, addr, port);
                HEAPU32[out >> 2] = ai;
                return 0;
            }
            if (flags & 4) {
                return -2;
            }

            //
            // try as a hostname
            //
            // resolve the hostname to a temporary fake address
            node = DNS.lookup_name(node);
            addr = inetPton4(node);
            if (family === 0) {
                family = 2;
            } else if (family === 10) {
                addr = [0, 0, _htonl(0xffff), addr];
            }
            ai = allocaddrinfo(family, type, proto, null, addr, port);
            HEAPU32[out >> 2] = ai;
            return 0;
        }

        function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
            var info = readSockaddr(sa, salen);
            if (info.errno) {
                return -6;
            }
            var port = info.port;
            var addr = info.addr;

            var overflowed = false;

            if (node && nodelen) {
                var lookup;
                if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {
                    if (flags & 8) {
                        return -2;
                    }
                } else {
                    addr = lookup;
                }
                var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);

                if (numBytesWrittenExclNull + 1 >= nodelen) {
                    overflowed = true;
                }
            }

            if (serv && servlen) {
                port = "" + port;
                var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);

                if (numBytesWrittenExclNull + 1 >= servlen) {
                    overflowed = true;
                }
            }

            if (overflowed) {
                // Note: even when we overflow, getnameinfo() is specced to write out the truncated results.
                return -12;
            }

            return 0;
        }

        function _glActiveTexture(x0) {
            GLctx["activeTexture"](x0);
        }

        function _glAttachShader(program, shader) {
            GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
        }

        function _glBindAttribLocation(program, index, name) {
            GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
        }

        function _glBindBuffer(target, buffer) {
            GLctx.bindBuffer(target, GL.buffers[buffer]);
        }

        function _glBindFramebuffer(target, framebuffer) {
            GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
        }

        function _glBindRenderbuffer(target, renderbuffer) {
            GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
        }

        function _glBindTexture(target, texture) {
            GLctx.bindTexture(target, GL.textures[texture]);
        }

        function _glBlendColor(x0, x1, x2, x3) {
            GLctx["blendColor"](x0, x1, x2, x3);
        }

        function _glBlendEquation(x0) {
            GLctx["blendEquation"](x0);
        }

        function _glBlendEquationSeparate(x0, x1) {
            GLctx["blendEquationSeparate"](x0, x1);
        }

        function _glBlendFunc(x0, x1) {
            GLctx["blendFunc"](x0, x1);
        }

        function _glBlendFuncSeparate(x0, x1, x2, x3) {
            GLctx["blendFuncSeparate"](x0, x1, x2, x3);
        }

        function _glBufferData(target, size, data, usage) {
            // N.b. here first form specifies a heap subarray, second form an integer size, so the ?: code here is polymorphic. It is advised to avoid
            // randomly mixing both uses in calling code, to avoid any potential JS engine JIT issues.
            GLctx.bufferData(target, data ? HEAPU8.subarray(data, data + size) : size, usage);
        }

        function _glBufferSubData(target, offset, size, data) {
            GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data + size));
        }

        function _glCheckFramebufferStatus(x0) {
            return GLctx["checkFramebufferStatus"](x0);
        }

        function _glClear(x0) {
            GLctx["clear"](x0);
        }

        function _glClearColor(x0, x1, x2, x3) {
            GLctx["clearColor"](x0, x1, x2, x3);
        }

        function _glClearDepthf(x0) {
            GLctx["clearDepth"](x0);
        }

        function _glClearStencil(x0) {
            GLctx["clearStencil"](x0);
        }

        function _glColorMask(red, green, blue, alpha) {
            GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
        }

        function _glCompileShader(shader) {
            GLctx.compileShader(GL.shaders[shader]);
        }

        function _glCompressedTexImage2D(
            target,
            level,
            internalFormat,
            width,
            height,
            border,
            imageSize,
            data
        ) {
            GLctx["compressedTexImage2D"](
                target,
                level,
                internalFormat,
                width,
                height,
                border,
                data ? HEAPU8.subarray(data, data + imageSize) : null
            );
        }

        function _glCompressedTexSubImage2D(
            target,
            level,
            xoffset,
            yoffset,
            width,
            height,
            format,
            imageSize,
            data
        ) {
            GLctx["compressedTexSubImage2D"](
                target,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                data ? HEAPU8.subarray(data, data + imageSize) : null
            );
        }

        function _glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx["copyTexImage2D"](x0, x1, x2, x3, x4, x5, x6, x7);
        }

        function _glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx["copyTexSubImage2D"](x0, x1, x2, x3, x4, x5, x6, x7);
        }

        function _glCreateProgram() {
            var id = GL.getNewId(GL.programs);
            var program = GLctx.createProgram();
            // Store additional information needed for each shader program:
            program.name = id;
            // Lazy cache results of glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
            program.maxUniformLength =
                program.maxAttributeLength =
                program.maxUniformBlockNameLength =
                    0;
            program.uniformIdCounter = 1;
            GL.programs[id] = program;
            return id;
        }

        function _glCreateShader(shaderType) {
            var id = GL.getNewId(GL.shaders);
            GL.shaders[id] = GLctx.createShader(shaderType);

            return id;
        }

        function _glCullFace(x0) {
            GLctx["cullFace"](x0);
        }

        function _glDeleteBuffers(n, buffers) {
            for (var i = 0; i < n; i++) {
                var id = HEAP32[(buffers + i * 4) >> 2];
                var buffer = GL.buffers[id];

                // From spec: "glDeleteBuffers silently ignores 0's and names that do not
                // correspond to existing buffer objects."
                if (!buffer) continue;

                GLctx.deleteBuffer(buffer);
                buffer.name = 0;
                GL.buffers[id] = null;
            }
        }

        function _glDeleteFramebuffers(n, framebuffers) {
            for (var i = 0; i < n; ++i) {
                var id = HEAP32[(framebuffers + i * 4) >> 2];
                var framebuffer = GL.framebuffers[id];
                if (!framebuffer) continue; // GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
                GLctx.deleteFramebuffer(framebuffer);
                framebuffer.name = 0;
                GL.framebuffers[id] = null;
            }
        }

        function _glDeleteProgram(id) {
            if (!id) return;
            var program = GL.programs[id];
            if (!program) {
                // glDeleteProgram actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            GLctx.deleteProgram(program);
            program.name = 0;
            GL.programs[id] = null;
        }

        function _glDeleteRenderbuffers(n, renderbuffers) {
            for (var i = 0; i < n; i++) {
                var id = HEAP32[(renderbuffers + i * 4) >> 2];
                var renderbuffer = GL.renderbuffers[id];
                if (!renderbuffer) continue; // GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
                GLctx.deleteRenderbuffer(renderbuffer);
                renderbuffer.name = 0;
                GL.renderbuffers[id] = null;
            }
        }

        function _glDeleteShader(id) {
            if (!id) return;
            var shader = GL.shaders[id];
            if (!shader) {
                // glDeleteShader actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            GLctx.deleteShader(shader);
            GL.shaders[id] = null;
        }

        function _glDeleteTextures(n, textures) {
            for (var i = 0; i < n; i++) {
                var id = HEAP32[(textures + i * 4) >> 2];
                var texture = GL.textures[id];
                if (!texture) continue; // GL spec: "glDeleteTextures silently ignores 0s and names that do not correspond to existing textures".
                GLctx.deleteTexture(texture);
                texture.name = 0;
                GL.textures[id] = null;
            }
        }

        function _glDepthFunc(x0) {
            GLctx["depthFunc"](x0);
        }

        function _glDepthMask(flag) {
            GLctx.depthMask(!!flag);
        }

        function _glDepthRangef(x0, x1) {
            GLctx["depthRange"](x0, x1);
        }

        function _glDetachShader(program, shader) {
            GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
        }

        function _glDisable(x0) {
            GLctx["disable"](x0);
        }

        function _glDisableVertexAttribArray(index) {
            GLctx.disableVertexAttribArray(index);
        }

        function _glDrawArrays(mode, first, count) {
            GLctx.drawArrays(mode, first, count);
        }

        function _glDrawElements(mode, count, type, indices) {
            GLctx.drawElements(mode, count, type, indices);
        }

        function _glEnable(x0) {
            GLctx["enable"](x0);
        }

        function _glEnableVertexAttribArray(index) {
            GLctx.enableVertexAttribArray(index);
        }

        function _glFinish() {
            GLctx["finish"]();
        }

        function _glFlush() {
            GLctx["flush"]();
        }

        function _glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
            GLctx.framebufferRenderbuffer(
                target,
                attachment,
                renderbuffertarget,
                GL.renderbuffers[renderbuffer]
            );
        }

        function _glFramebufferTexture2D(target, attachment, textarget, texture, level) {
            GLctx.framebufferTexture2D(target, attachment, textarget, GL.textures[texture], level);
        }

        function _glFrontFace(x0) {
            GLctx["frontFace"](x0);
        }

        function _glGenBuffers(n, buffers) {
            __glGenObject(n, buffers, "createBuffer", GL.buffers);
        }

        function _glGenFramebuffers(n, ids) {
            __glGenObject(n, ids, "createFramebuffer", GL.framebuffers);
        }

        function _glGenRenderbuffers(n, renderbuffers) {
            __glGenObject(n, renderbuffers, "createRenderbuffer", GL.renderbuffers);
        }

        function _glGenTextures(n, textures) {
            __glGenObject(n, textures, "createTexture", GL.textures);
        }

        function _glGenerateMipmap(x0) {
            GLctx["generateMipmap"](x0);
        }

        function _glGetActiveAttrib(program, index, bufSize, length, size, type, name) {
            __glGetActiveAttribOrUniform(
                "getActiveAttrib",
                program,
                index,
                bufSize,
                length,
                size,
                type,
                name
            );
        }

        function _glGetActiveUniform(program, index, bufSize, length, size, type, name) {
            __glGetActiveAttribOrUniform(
                "getActiveUniform",
                program,
                index,
                bufSize,
                length,
                size,
                type,
                name
            );
        }

        function _glGetAttachedShaders(program, maxCount, count, shaders) {
            var result = GLctx.getAttachedShaders(GL.programs[program]);
            var len = result.length;
            if (len > maxCount) {
                len = maxCount;
            }
            HEAP32[count >> 2] = len;
            for (var i = 0; i < len; ++i) {
                var id = GL.shaders.indexOf(result[i]);
                HEAP32[(shaders + i * 4) >> 2] = id;
            }
        }

        function _glGetAttribLocation(program, name) {
            return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));
        }

        function _glGetBooleanv(name_, p) {
            emscriptenWebGLGet(name_, p, 4);
        }

        function _glGetBufferParameteriv(target, value, data) {
            if (!data) {
                // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
                // if data == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[data >> 2] = GLctx.getBufferParameter(target, value);
        }

        function _glGetError() {
            var error = GLctx.getError() || GL.lastError;
            GL.lastError = 0 /*GL_NO_ERROR*/;
            return error;
        }

        function _glGetFloatv(name_, p) {
            emscriptenWebGLGet(name_, p, 2);
        }

        function _glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
            var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
            if (result instanceof WebGLRenderbuffer || result instanceof WebGLTexture) {
                result = result.name | 0;
            }
            HEAP32[params >> 2] = result;
        }

        function _glGetIntegerv(name_, p) {
            emscriptenWebGLGet(name_, p, 0);
        }

        function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
            var log = GLctx.getProgramInfoLog(GL.programs[program]);
            if (log === null) log = "(unknown error)";
            var numBytesWrittenExclNull =
                maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
        }

        function _glGetProgramiv(program, pname, p) {
            if (!p) {
                // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }

            if (program >= GL.counter) {
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }

            program = GL.programs[program];

            if (pname == 0x8b84) {
                // GL_INFO_LOG_LENGTH
                var log = GLctx.getProgramInfoLog(program);
                if (log === null) log = "(unknown error)";
                HEAP32[p >> 2] = log.length + 1;
            } else if (pname == 0x8b87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {
                if (!program.maxUniformLength) {
                    for (
                        var i = 0;
                        i < GLctx.getProgramParameter(program, 0x8b86 /*GL_ACTIVE_UNIFORMS*/);
                        ++i
                    ) {
                        program.maxUniformLength = Math.max(
                            program.maxUniformLength,
                            GLctx.getActiveUniform(program, i).name.length + 1
                        );
                    }
                }
                HEAP32[p >> 2] = program.maxUniformLength;
            } else if (pname == 0x8b8a /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {
                if (!program.maxAttributeLength) {
                    for (
                        var i = 0;
                        i < GLctx.getProgramParameter(program, 0x8b89 /*GL_ACTIVE_ATTRIBUTES*/);
                        ++i
                    ) {
                        program.maxAttributeLength = Math.max(
                            program.maxAttributeLength,
                            GLctx.getActiveAttrib(program, i).name.length + 1
                        );
                    }
                }
                HEAP32[p >> 2] = program.maxAttributeLength;
            } else if (pname == 0x8a35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {
                if (!program.maxUniformBlockNameLength) {
                    for (
                        var i = 0;
                        i < GLctx.getProgramParameter(program, 0x8a36 /*GL_ACTIVE_UNIFORM_BLOCKS*/);
                        ++i
                    ) {
                        program.maxUniformBlockNameLength = Math.max(
                            program.maxUniformBlockNameLength,
                            GLctx.getActiveUniformBlockName(program, i).length + 1
                        );
                    }
                }
                HEAP32[p >> 2] = program.maxUniformBlockNameLength;
            } else {
                HEAP32[p >> 2] = GLctx.getProgramParameter(program, pname);
            }
        }

        function _glGetRenderbufferParameteriv(target, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if params == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[params >> 2] = GLctx.getRenderbufferParameter(target, pname);
        }

        function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
            var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
            if (log === null) log = "(unknown error)";
            var numBytesWrittenExclNull =
                maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
        }

        function _glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
            var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
            HEAP32[range >> 2] = result.rangeMin;
            HEAP32[(range + 4) >> 2] = result.rangeMax;
            HEAP32[precision >> 2] = result.precision;
        }

        function _glGetShaderSource(shader, bufSize, length, source) {
            var result = GLctx.getShaderSource(GL.shaders[shader]);
            if (!result) return; // If an error occurs, nothing will be written to length or source.
            var numBytesWrittenExclNull =
                bufSize > 0 && source ? stringToUTF8(result, source, bufSize) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
        }

        function _glGetShaderiv(shader, pname, p) {
            if (!p) {
                // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            if (pname == 0x8b84) {
                // GL_INFO_LOG_LENGTH
                var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
                if (log === null) log = "(unknown error)";
                // The GLES2 specification says that if the shader has an empty info log,
                // a value of 0 is returned. Otherwise the log has a null char appended.
                // (An empty string is falsey, so we can just check that instead of
                // looking at log.length.)
                var logLength = log ? log.length + 1 : 0;
                HEAP32[p >> 2] = logLength;
            } else if (pname == 0x8b88) {
                // GL_SHADER_SOURCE_LENGTH
                var source = GLctx.getShaderSource(GL.shaders[shader]);
                // source may be a null, or the empty string, both of which are falsey
                // values that we report a 0 length for.
                var sourceLength = source ? source.length + 1 : 0;
                HEAP32[p >> 2] = sourceLength;
            } else {
                HEAP32[p >> 2] = GLctx.getShaderParameter(GL.shaders[shader], pname);
            }
        }

        function _glGetString(name_) {
            var ret = GL.stringCache[name_];
            if (!ret) {
                switch (name_) {
                    case 0x1f03 /* GL_EXTENSIONS */:
                        var exts = GLctx.getSupportedExtensions() || []; // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
                        exts = exts.concat(
                            exts.map(function (e) {
                                return "GL_" + e;
                            })
                        );
                        ret = stringToNewUTF8(exts.join(" "));
                        break;
                    case 0x1f00 /* GL_VENDOR */:
                    case 0x1f01 /* GL_RENDERER */:
                    case 0x9245 /* UNMASKED_VENDOR_WEBGL */:
                    case 0x9246 /* UNMASKED_RENDERER_WEBGL */:
                        var s = GLctx.getParameter(name_);
                        if (!s) {
                            GL.recordError(0x500 /*GL_INVALID_ENUM*/);
                        }
                        ret = s && stringToNewUTF8(s);
                        break;

                    case 0x1f02 /* GL_VERSION */:
                        var glVersion = GLctx.getParameter(0x1f02 /*GL_VERSION*/);
                        // return GLES version string corresponding to the version of the WebGL context
                        {
                            glVersion = "OpenGL ES 2.0 (" + glVersion + ")";
                        }
                        ret = stringToNewUTF8(glVersion);
                        break;
                    case 0x8b8c /* GL_SHADING_LANGUAGE_VERSION */:
                        var glslVersion = GLctx.getParameter(
                            0x8b8c /*GL_SHADING_LANGUAGE_VERSION*/
                        );
                        // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
                        var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
                        var ver_num = glslVersion.match(ver_re);
                        if (ver_num !== null) {
                            if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + "0"; // ensure minor version has 2 digits
                            glslVersion =
                                "OpenGL ES GLSL ES " + ver_num[1] + " (" + glslVersion + ")";
                        }
                        ret = stringToNewUTF8(glslVersion);
                        break;
                    default:
                        GL.recordError(0x500 /*GL_INVALID_ENUM*/);
                    // fall through
                }
                GL.stringCache[name_] = ret;
            }
            return ret;
        }

        function _glGetTexParameteriv(target, pname, params) {
            if (!params) {
                // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
                // if p == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[params >> 2] = GLctx.getTexParameter(target, pname);
        }

        function _glGetUniformLocation(program, name) {
            name = UTF8ToString(name);

            if ((program = GL.programs[program])) {
                webglPrepareUniformLocationsBeforeFirstUse(program);
                var uniformLocsById = program.uniformLocsById; // Maps GLuint -> WebGLUniformLocation
                var arrayIndex = 0;
                var uniformBaseName = name;

                // Invariant: when populating integer IDs for uniform locations, we must maintain the precondition that
                // arrays reside in contiguous addresses, i.e. for a 'vec4 colors[10];', colors[4] must be at location colors[0]+4.
                // However, user might call glGetUniformLocation(program, "colors") for an array, so we cannot discover based on the user
                // input arguments whether the uniform we are dealing with is an array. The only way to discover which uniforms are arrays
                // is to enumerate over all the active uniforms in the program.
                var leftBrace = webglGetLeftBracePos(name);

                // If user passed an array accessor "[index]", parse the array index off the accessor.
                if (leftBrace > 0) {
                    arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0; // "index]", coerce parseInt(']') with >>>0 to treat "foo[]" as "foo[0]" and foo[-1] as unsigned out-of-bounds.
                    uniformBaseName = name.slice(0, leftBrace);
                }

                // Have we cached the location of this uniform before?
                var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName]; // A pair [array length, GLint of the uniform location]

                // If an uniform with this name exists, and if its index is within the array limits (if it's even an array),
                // query the WebGLlocation, or return an existing cached location.
                if (sizeAndId && arrayIndex < sizeAndId[0]) {
                    arrayIndex += sizeAndId[1]; // Add the base location of the uniform to the array index offset.
                    if (
                        (uniformLocsById[arrayIndex] =
                            uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name))
                    ) {
                        return arrayIndex;
                    }
                }
            } else {
                // N.b. we are currently unable to distinguish between GL program IDs that never existed vs GL program IDs that have been deleted,
                // so report GL_INVALID_VALUE in both cases.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
            }
            return -1;
        }

        function _glGetUniformfv(program, location, params) {
            emscriptenWebGLGetUniform(program, location, params, 2);
        }

        function _glGetUniformiv(program, location, params) {
            emscriptenWebGLGetUniform(program, location, params, 0);
        }

        function _glGetVertexAttribPointerv(index, pname, pointer) {
            if (!pointer) {
                // GLES2 specification does not specify how to behave if pointer is a null pointer. Since calling this function does not make sense
                // if pointer == null, issue a GL error to notify user about it.
                GL.recordError(0x501 /* GL_INVALID_VALUE */);
                return;
            }
            HEAP32[pointer >> 2] = GLctx.getVertexAttribOffset(index, pname);
        }

        function _glGetVertexAttribfv(index, pname, params) {
            // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
            // otherwise the results are undefined. (GLES3 spec 6.1.12)
            emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
        }

        function _glGetVertexAttribiv(index, pname, params) {
            // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
            // otherwise the results are undefined. (GLES3 spec 6.1.12)
            emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
        }

        function _glHint(x0, x1) {
            GLctx["hint"](x0, x1);
        }

        function _glIsBuffer(buffer) {
            var b = GL.buffers[buffer];
            if (!b) return 0;
            return GLctx.isBuffer(b);
        }

        function _glIsEnabled(x0) {
            return GLctx["isEnabled"](x0);
        }

        function _glIsFramebuffer(framebuffer) {
            var fb = GL.framebuffers[framebuffer];
            if (!fb) return 0;
            return GLctx.isFramebuffer(fb);
        }

        function _glIsProgram(program) {
            program = GL.programs[program];
            if (!program) return 0;
            return GLctx.isProgram(program);
        }

        function _glIsRenderbuffer(renderbuffer) {
            var rb = GL.renderbuffers[renderbuffer];
            if (!rb) return 0;
            return GLctx.isRenderbuffer(rb);
        }

        function _glIsShader(shader) {
            var s = GL.shaders[shader];
            if (!s) return 0;
            return GLctx.isShader(s);
        }

        function _glIsTexture(id) {
            var texture = GL.textures[id];
            if (!texture) return 0;
            return GLctx.isTexture(texture);
        }

        function _glLineWidth(x0) {
            GLctx["lineWidth"](x0);
        }

        function _glLinkProgram(program) {
            program = GL.programs[program];
            GLctx.linkProgram(program);
            // Invalidate earlier computed uniform->ID mappings, those have now become stale
            program.uniformLocsById = 0; // Mark as null-like so that glGetUniformLocation() knows to populate this again.
            program.uniformSizeAndIdsByName = {};
        }

        function _glPixelStorei(pname, param) {
            if (pname == 0xcf5 /* GL_UNPACK_ALIGNMENT */) {
                GL.unpackAlignment = param;
            }
            GLctx.pixelStorei(pname, param);
        }

        function _glPolygonOffset(x0, x1) {
            GLctx["polygonOffset"](x0, x1);
        }

        function _glReadPixels(x, y, width, height, format, type, pixels) {
            var pixelData = emscriptenWebGLGetTexPixelData(
                type,
                format,
                width,
                height,
                pixels,
                format
            );
            if (!pixelData) {
                GL.recordError(0x500 /*GL_INVALID_ENUM*/);
                return;
            }
            GLctx.readPixels(x, y, width, height, format, type, pixelData);
        }

        function _glRenderbufferStorage(x0, x1, x2, x3) {
            GLctx["renderbufferStorage"](x0, x1, x2, x3);
        }

        function _glSampleCoverage(value, invert) {
            GLctx.sampleCoverage(value, !!invert);
        }

        function _glScissor(x0, x1, x2, x3) {
            GLctx["scissor"](x0, x1, x2, x3);
        }

        function _glShaderSource(shader, count, string, length) {
            var source = GL.getSource(shader, count, string, length);

            GLctx.shaderSource(GL.shaders[shader], source);
        }

        function _glStencilFunc(x0, x1, x2) {
            GLctx["stencilFunc"](x0, x1, x2);
        }

        function _glStencilFuncSeparate(x0, x1, x2, x3) {
            GLctx["stencilFuncSeparate"](x0, x1, x2, x3);
        }

        function _glStencilMask(x0) {
            GLctx["stencilMask"](x0);
        }

        function _glStencilMaskSeparate(x0, x1) {
            GLctx["stencilMaskSeparate"](x0, x1);
        }

        function _glStencilOp(x0, x1, x2) {
            GLctx["stencilOp"](x0, x1, x2);
        }

        function _glStencilOpSeparate(x0, x1, x2, x3) {
            GLctx["stencilOpSeparate"](x0, x1, x2, x3);
        }

        function _glTexImage2D(
            target,
            level,
            internalFormat,
            width,
            height,
            border,
            format,
            type,
            pixels
        ) {
            GLctx.texImage2D(
                target,
                level,
                internalFormat,
                width,
                height,
                border,
                format,
                type,
                pixels
                    ? emscriptenWebGLGetTexPixelData(
                          type,
                          format,
                          width,
                          height,
                          pixels,
                          internalFormat
                      )
                    : null
            );
        }

        function _glTexParameterf(x0, x1, x2) {
            GLctx["texParameterf"](x0, x1, x2);
        }

        function _glTexParameteri(x0, x1, x2) {
            GLctx["texParameteri"](x0, x1, x2);
        }

        function _glTexSubImage2D(
            target,
            level,
            xoffset,
            yoffset,
            width,
            height,
            format,
            type,
            pixels
        ) {
            var pixelData = null;
            if (pixels)
                pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
            GLctx.texSubImage2D(
                target,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                type,
                pixelData
            );
        }

        function _glUniform1f(location, v0) {
            GLctx.uniform1f(webglGetUniformLocation(location), v0);
        }

        function _glUniform1fv(location, count, value) {
            if (count <= 288) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[count - 1];
                for (var i = 0; i < count; ++i) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 4) >> 2);
            }
            GLctx.uniform1fv(webglGetUniformLocation(location), view);
        }

        function _glUniform1i(location, v0) {
            GLctx.uniform1i(webglGetUniformLocation(location), v0);
        }

        function _glUniform1iv(location, count, value) {
            if (count <= 288) {
                // avoid allocation when uploading few enough uniforms
                var view = __miniTempWebGLIntBuffers[count - 1];
                for (var i = 0; i < count; ++i) {
                    view[i] = HEAP32[(value + 4 * i) >> 2];
                }
            } else {
                var view = HEAP32.subarray(value >> 2, (value + count * 4) >> 2);
            }
            GLctx.uniform1iv(webglGetUniformLocation(location), view);
        }

        function _glUniform2f(location, v0, v1) {
            GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
        }

        function _glUniform2fv(location, count, value) {
            if (count <= 144) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[2 * count - 1];
                for (var i = 0; i < 2 * count; i += 2) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAPF32[(value + (4 * i + 4)) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 8) >> 2);
            }
            GLctx.uniform2fv(webglGetUniformLocation(location), view);
        }

        function _glUniform2i(location, v0, v1) {
            GLctx.uniform2i(webglGetUniformLocation(location), v0, v1);
        }

        function _glUniform2iv(location, count, value) {
            if (count <= 144) {
                // avoid allocation when uploading few enough uniforms
                var view = __miniTempWebGLIntBuffers[2 * count - 1];
                for (var i = 0; i < 2 * count; i += 2) {
                    view[i] = HEAP32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAP32[(value + (4 * i + 4)) >> 2];
                }
            } else {
                var view = HEAP32.subarray(value >> 2, (value + count * 8) >> 2);
            }
            GLctx.uniform2iv(webglGetUniformLocation(location), view);
        }

        function _glUniform3f(location, v0, v1, v2) {
            GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
        }

        function _glUniform3fv(location, count, value) {
            if (count <= 96) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[3 * count - 1];
                for (var i = 0; i < 3 * count; i += 3) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAPF32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAPF32[(value + (4 * i + 8)) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 12) >> 2);
            }
            GLctx.uniform3fv(webglGetUniformLocation(location), view);
        }

        function _glUniform3i(location, v0, v1, v2) {
            GLctx.uniform3i(webglGetUniformLocation(location), v0, v1, v2);
        }

        function _glUniform3iv(location, count, value) {
            if (count <= 96) {
                // avoid allocation when uploading few enough uniforms
                var view = __miniTempWebGLIntBuffers[3 * count - 1];
                for (var i = 0; i < 3 * count; i += 3) {
                    view[i] = HEAP32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAP32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAP32[(value + (4 * i + 8)) >> 2];
                }
            } else {
                var view = HEAP32.subarray(value >> 2, (value + count * 12) >> 2);
            }
            GLctx.uniform3iv(webglGetUniformLocation(location), view);
        }

        function _glUniform4f(location, v0, v1, v2, v3) {
            GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
        }

        function _glUniform4fv(location, count, value) {
            if (count <= 72) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[4 * count - 1];
                // hoist the heap out of the loop for size and for pthreads+growth.
                var heap = HEAPF32;
                value >>= 2;
                for (var i = 0; i < 4 * count; i += 4) {
                    var dst = value + i;
                    view[i] = heap[dst];
                    view[i + 1] = heap[dst + 1];
                    view[i + 2] = heap[dst + 2];
                    view[i + 3] = heap[dst + 3];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 16) >> 2);
            }
            GLctx.uniform4fv(webglGetUniformLocation(location), view);
        }

        function _glUniform4i(location, v0, v1, v2, v3) {
            GLctx.uniform4i(webglGetUniformLocation(location), v0, v1, v2, v3);
        }

        function _glUniform4iv(location, count, value) {
            if (count <= 72) {
                // avoid allocation when uploading few enough uniforms
                var view = __miniTempWebGLIntBuffers[4 * count - 1];
                for (var i = 0; i < 4 * count; i += 4) {
                    view[i] = HEAP32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAP32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAP32[(value + (4 * i + 8)) >> 2];
                    view[i + 3] = HEAP32[(value + (4 * i + 12)) >> 2];
                }
            } else {
                var view = HEAP32.subarray(value >> 2, (value + count * 16) >> 2);
            }
            GLctx.uniform4iv(webglGetUniformLocation(location), view);
        }

        function _glUniformMatrix2fv(location, count, transpose, value) {
            if (count <= 72) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[4 * count - 1];
                for (var i = 0; i < 4 * count; i += 4) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAPF32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAPF32[(value + (4 * i + 8)) >> 2];
                    view[i + 3] = HEAPF32[(value + (4 * i + 12)) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 16) >> 2);
            }
            GLctx.uniformMatrix2fv(webglGetUniformLocation(location), !!transpose, view);
        }

        function _glUniformMatrix3fv(location, count, transpose, value) {
            if (count <= 32) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[9 * count - 1];
                for (var i = 0; i < 9 * count; i += 9) {
                    view[i] = HEAPF32[(value + 4 * i) >> 2];
                    view[i + 1] = HEAPF32[(value + (4 * i + 4)) >> 2];
                    view[i + 2] = HEAPF32[(value + (4 * i + 8)) >> 2];
                    view[i + 3] = HEAPF32[(value + (4 * i + 12)) >> 2];
                    view[i + 4] = HEAPF32[(value + (4 * i + 16)) >> 2];
                    view[i + 5] = HEAPF32[(value + (4 * i + 20)) >> 2];
                    view[i + 6] = HEAPF32[(value + (4 * i + 24)) >> 2];
                    view[i + 7] = HEAPF32[(value + (4 * i + 28)) >> 2];
                    view[i + 8] = HEAPF32[(value + (4 * i + 32)) >> 2];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 36) >> 2);
            }
            GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, view);
        }

        function _glUniformMatrix4fv(location, count, transpose, value) {
            if (count <= 18) {
                // avoid allocation when uploading few enough uniforms
                var view = miniTempWebGLFloatBuffers[16 * count - 1];
                // hoist the heap out of the loop for size and for pthreads+growth.
                var heap = HEAPF32;
                value >>= 2;
                for (var i = 0; i < 16 * count; i += 16) {
                    var dst = value + i;
                    view[i] = heap[dst];
                    view[i + 1] = heap[dst + 1];
                    view[i + 2] = heap[dst + 2];
                    view[i + 3] = heap[dst + 3];
                    view[i + 4] = heap[dst + 4];
                    view[i + 5] = heap[dst + 5];
                    view[i + 6] = heap[dst + 6];
                    view[i + 7] = heap[dst + 7];
                    view[i + 8] = heap[dst + 8];
                    view[i + 9] = heap[dst + 9];
                    view[i + 10] = heap[dst + 10];
                    view[i + 11] = heap[dst + 11];
                    view[i + 12] = heap[dst + 12];
                    view[i + 13] = heap[dst + 13];
                    view[i + 14] = heap[dst + 14];
                    view[i + 15] = heap[dst + 15];
                }
            } else {
                var view = HEAPF32.subarray(value >> 2, (value + count * 64) >> 2);
            }
            GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
        }

        function _glUseProgram(program) {
            program = GL.programs[program];
            GLctx.useProgram(program);
            // Record the currently active program so that we can access the uniform
            // mapping table of that program.
            GLctx.currentProgram = program;
        }

        function _glValidateProgram(program) {
            GLctx.validateProgram(GL.programs[program]);
        }

        function _glVertexAttrib1f(x0, x1) {
            GLctx["vertexAttrib1f"](x0, x1);
        }

        function _glVertexAttrib1fv(index, v) {
            GLctx.vertexAttrib1f(index, HEAPF32[v >> 2]);
        }

        function _glVertexAttrib2f(x0, x1, x2) {
            GLctx["vertexAttrib2f"](x0, x1, x2);
        }

        function _glVertexAttrib2fv(index, v) {
            GLctx.vertexAttrib2f(index, HEAPF32[v >> 2], HEAPF32[(v + 4) >> 2]);
        }

        function _glVertexAttrib3f(x0, x1, x2, x3) {
            GLctx["vertexAttrib3f"](x0, x1, x2, x3);
        }

        function _glVertexAttrib3fv(index, v) {
            GLctx.vertexAttrib3f(
                index,
                HEAPF32[v >> 2],
                HEAPF32[(v + 4) >> 2],
                HEAPF32[(v + 8) >> 2]
            );
        }

        function _glVertexAttrib4f(x0, x1, x2, x3, x4) {
            GLctx["vertexAttrib4f"](x0, x1, x2, x3, x4);
        }

        function _glVertexAttrib4fv(index, v) {
            GLctx.vertexAttrib4f(
                index,
                HEAPF32[v >> 2],
                HEAPF32[(v + 4) >> 2],
                HEAPF32[(v + 8) >> 2],
                HEAPF32[(v + 12) >> 2]
            );
        }

        function _glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
            GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
        }

        function _glViewport(x0, x1, x2, x3) {
            GLctx["viewport"](x0, x1, x2, x3);
        }

        function __arraySum(array, index) {
            var sum = 0;
            for (var i = 0; i <= index; sum += array[i++]) {
                // no-op
            }
            return sum;
        }

        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) {
            var newDate = new Date(date.getTime());
            while (days > 0) {
                var leap = __isLeapYear(newDate.getFullYear());
                var currentMonth = newDate.getMonth();
                var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[
                    currentMonth
                ];

                if (days > daysInCurrentMonth - newDate.getDate()) {
                    // we spill over to next month
                    days -= daysInCurrentMonth - newDate.getDate() + 1;
                    newDate.setDate(1);
                    if (currentMonth < 11) {
                        newDate.setMonth(currentMonth + 1);
                    } else {
                        newDate.setMonth(0);
                        newDate.setFullYear(newDate.getFullYear() + 1);
                    }
                } else {
                    // we stay in current month
                    newDate.setDate(newDate.getDate() + days);
                    return newDate;
                }
            }

            return newDate;
        }

        function writeArrayToMemory(array, buffer) {
            assert(
                array.length >= 0,
                "writeArrayToMemory array must have a length (should be an array or typed array)"
            );
            HEAP8.set(array, buffer);
        }
        function _strftime(s, maxsize, format, tm) {
            // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
            // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html

            var tm_zone = HEAP32[(tm + 40) >> 2];

            var date = {
                tm_sec: HEAP32[tm >> 2],
                tm_min: HEAP32[(tm + 4) >> 2],
                tm_hour: HEAP32[(tm + 8) >> 2],
                tm_mday: HEAP32[(tm + 12) >> 2],
                tm_mon: HEAP32[(tm + 16) >> 2],
                tm_year: HEAP32[(tm + 20) >> 2],
                tm_wday: HEAP32[(tm + 24) >> 2],
                tm_yday: HEAP32[(tm + 28) >> 2],
                tm_isdst: HEAP32[(tm + 32) >> 2],
                tm_gmtoff: HEAP32[(tm + 36) >> 2],
                tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
            };

            var pattern = UTF8ToString(format);

            // expand format
            var EXPANSION_RULES_1 = {
                "%c": "%a %b %d %H:%M:%S %Y", // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013
                "%D": "%m/%d/%y", // Equivalent to %m / %d / %y
                "%F": "%Y-%m-%d", // Equivalent to %Y - %m - %d
                "%h": "%b", // Equivalent to %b
                "%r": "%I:%M:%S %p", // Replaced by the time in a.m. and p.m. notation
                "%R": "%H:%M", // Replaced by the time in 24-hour notation
                "%T": "%H:%M:%S", // Replaced by the time
                "%x": "%m/%d/%y", // Replaced by the locale's appropriate date representation
                "%X": "%H:%M:%S", // Replaced by the locale's appropriate time representation
                // Modified Conversion Specifiers
                "%Ec": "%c", // Replaced by the locale's alternative appropriate date and time representation.
                "%EC": "%C", // Replaced by the name of the base year (period) in the locale's alternative representation.
                "%Ex": "%m/%d/%y", // Replaced by the locale's alternative date representation.
                "%EX": "%H:%M:%S", // Replaced by the locale's alternative time representation.
                "%Ey": "%y", // Replaced by the offset from %EC (year only) in the locale's alternative representation.
                "%EY": "%Y", // Replaced by the full alternative year representation.
                "%Od": "%d", // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.
                "%Oe": "%e", // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.
                "%OH": "%H", // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
                "%OI": "%I", // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
                "%Om": "%m", // Replaced by the month using the locale's alternative numeric symbols.
                "%OM": "%M", // Replaced by the minutes using the locale's alternative numeric symbols.
                "%OS": "%S", // Replaced by the seconds using the locale's alternative numeric symbols.
                "%Ou": "%u", // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
                "%OU": "%U", // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.
                "%OV": "%V", // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.
                "%Ow": "%w", // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
                "%OW": "%W", // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.
                "%Oy": "%y" // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.
            };
            for (var rule in EXPANSION_RULES_1) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }

            var WEEKDAYS = [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday"
            ];
            var MONTHS = [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December"
            ];

            function leadingSomething(value, digits, character) {
                var str = typeof value == "number" ? value.toString() : value || "";
                while (str.length < digits) {
                    str = character[0] + str;
                }
                return str;
            }

            function leadingNulls(value, digits) {
                return leadingSomething(value, digits, "0");
            }

            function compareByDay(date1, date2) {
                function sgn(value) {
                    return value < 0 ? -1 : value > 0 ? 1 : 0;
                }

                var compare;
                if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                    if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                        compare = sgn(date1.getDate() - date2.getDate());
                    }
                }
                return compare;
            }

            function getFirstWeekStartDate(janFourth) {
                switch (janFourth.getDay()) {
                    case 0: // Sunday
                        return new Date(janFourth.getFullYear() - 1, 11, 29);
                    case 1: // Monday
                        return janFourth;
                    case 2: // Tuesday
                        return new Date(janFourth.getFullYear(), 0, 3);
                    case 3: // Wednesday
                        return new Date(janFourth.getFullYear(), 0, 2);
                    case 4: // Thursday
                        return new Date(janFourth.getFullYear(), 0, 1);
                    case 5: // Friday
                        return new Date(janFourth.getFullYear() - 1, 11, 31);
                    case 6: // Saturday
                        return new Date(janFourth.getFullYear() - 1, 11, 30);
                }
            }

            function getWeekBasedYear(date) {
                var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);

                var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
                var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);

                var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
                var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);

                if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                    // this date is after the start of the first week of this year
                    if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                        return thisDate.getFullYear() + 1;
                    }
                    return thisDate.getFullYear();
                }
                return thisDate.getFullYear() - 1;
            }

            var EXPANSION_RULES_2 = {
                "%a": function (date) {
                    return WEEKDAYS[date.tm_wday].substring(0, 3);
                },
                "%A": function (date) {
                    return WEEKDAYS[date.tm_wday];
                },
                "%b": function (date) {
                    return MONTHS[date.tm_mon].substring(0, 3);
                },
                "%B": function (date) {
                    return MONTHS[date.tm_mon];
                },
                "%C": function (date) {
                    var year = date.tm_year + 1900;
                    return leadingNulls((year / 100) | 0, 2);
                },
                "%d": function (date) {
                    return leadingNulls(date.tm_mday, 2);
                },
                "%e": function (date) {
                    return leadingSomething(date.tm_mday, 2, " ");
                },
                "%g": function (date) {
                    // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.
                    // In this system, weeks begin on a Monday and week 1 of the year is the week that includes
                    // January 4th, which is also the week that includes the first Thursday of the year, and
                    // is also the first week that contains at least four days in the year.
                    // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of
                    // the last week of the preceding year; thus, for Saturday 2nd January 1999,
                    // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,
                    // or 31st is a Monday, it and any following days are part of week 1 of the following year.
                    // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.

                    return getWeekBasedYear(date).toString().substring(2);
                },
                "%G": function (date) {
                    return getWeekBasedYear(date);
                },
                "%H": function (date) {
                    return leadingNulls(date.tm_hour, 2);
                },
                "%I": function (date) {
                    var twelveHour = date.tm_hour;
                    if (twelveHour == 0) twelveHour = 12;
                    else if (twelveHour > 12) twelveHour -= 12;
                    return leadingNulls(twelveHour, 2);
                },
                "%j": function (date) {
                    // Day of the year (001-366)
                    return leadingNulls(
                        date.tm_mday +
                            __arraySum(
                                __isLeapYear(date.tm_year + 1900)
                                    ? __MONTH_DAYS_LEAP
                                    : __MONTH_DAYS_REGULAR,
                                date.tm_mon - 1
                            ),
                        3
                    );
                },
                "%m": function (date) {
                    return leadingNulls(date.tm_mon + 1, 2);
                },
                "%M": function (date) {
                    return leadingNulls(date.tm_min, 2);
                },
                "%n": function () {
                    return "\n";
                },
                "%p": function (date) {
                    if (date.tm_hour >= 0 && date.tm_hour < 12) {
                        return "AM";
                    }
                    return "PM";
                },
                "%S": function (date) {
                    return leadingNulls(date.tm_sec, 2);
                },
                "%t": function () {
                    return "\t";
                },
                "%u": function (date) {
                    return date.tm_wday || 7;
                },
                "%U": function (date) {
                    var days = date.tm_yday + 7 - date.tm_wday;
                    return leadingNulls(Math.floor(days / 7), 2);
                },
                "%V": function (date) {
                    // Replaced by the week number of the year (Monday as the first day of the week)
                    // as a decimal number [01,53]. If the week containing 1 January has four
                    // or more days in the new year, then it is considered week 1.
                    // Otherwise, it is the last week of the previous year, and the next week is week 1.
                    // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]
                    var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7);
                    // If 1 Jan is just 1-3 days past Monday, the previous week
                    // is also in this year.
                    if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {
                        val++;
                    }
                    if (!val) {
                        val = 52;
                        // If 31 December of prev year a Thursday, or Friday of a
                        // leap year, then the prev year has 53 weeks.
                        var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;
                        if (dec31 == 4 || (dec31 == 5 && __isLeapYear((date.tm_year % 400) - 1))) {
                            val++;
                        }
                    } else if (val == 53) {
                        // If 1 January is not a Thursday, and not a Wednesday of a
                        // leap year, then this year has only 52 weeks.
                        var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;
                        if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year))) val = 1;
                    }
                    return leadingNulls(val, 2);
                },
                "%w": function (date) {
                    return date.tm_wday;
                },
                "%W": function (date) {
                    var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);
                    return leadingNulls(Math.floor(days / 7), 2);
                },
                "%y": function (date) {
                    // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
                    return (date.tm_year + 1900).toString().substring(2);
                },
                "%Y": function (date) {
                    // Replaced by the year as a decimal number (for example, 1997). [ tm_year]
                    return date.tm_year + 1900;
                },
                "%z": function (date) {
                    // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).
                    // For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
                    var off = date.tm_gmtoff;
                    var ahead = off >= 0;
                    off = Math.abs(off) / 60;
                    // convert from minutes into hhmm format (which means 60 minutes = 100 units)
                    off = (off / 60) * 100 + (off % 60);
                    return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
                },
                "%Z": function (date) {
                    return date.tm_zone;
                },
                "%%": function () {
                    return "%";
                }
            };

            // Replace %% with a pair of NULLs (which cannot occur in a C string), then
            // re-inject them after processing.
            pattern = pattern.replace(/%%/g, "\0\0");
            for (var rule in EXPANSION_RULES_2) {
                if (pattern.includes(rule)) {
                    pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
                }
            }
            pattern = pattern.replace(/\0\0/g, "%");

            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
                return 0;
            }

            writeArrayToMemory(bytes, s);
            return bytes.length - 1;
        }

        function _system(command) {
            if (ENVIRONMENT_IS_NODE) {
                if (!command) return 1; // shell is available

                var cmdstr = UTF8ToString(command);
                if (!cmdstr.length) return 0; // this is what glibc seems to do (shell works test?)

                var cp = require("child_process");
                var ret = cp.spawnSync(cmdstr, [], { shell: true, stdio: "inherit" });

                var _W_EXITCODE = (ret, sig) => (ret << 8) | sig;

                // this really only can happen if process is killed by signal
                if (ret.status === null) {
                    // sadly node doesn't expose such function
                    var signalToNumber = (sig) => {
                        // implement only the most common ones, and fallback to SIGINT
                        switch (sig) {
                            case "SIGHUP":
                                return 1;
                            case "SIGINT":
                                return 2;
                            case "SIGQUIT":
                                return 3;
                            case "SIGFPE":
                                return 8;
                            case "SIGKILL":
                                return 9;
                            case "SIGALRM":
                                return 14;
                            case "SIGTERM":
                                return 15;
                        }
                        return 2; // SIGINT
                    };
                    return _W_EXITCODE(0, signalToNumber(ret.signal));
                }

                return _W_EXITCODE(ret.status, 0);
            }
            // int system(const char *command);
            // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
            // Can't call external programs.
            if (!command) return 0; // no shell available
            setErrNo(52);
            return -1;
        }

        function allocateUTF8OnStack(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8Array(str, HEAP8, ret, size);
            return ret;
        }

        function getCFunc(ident) {
            var func = Module["_" + ident]; // closure exported function
            assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
            return func;
        }

        /**
         * @param {string|null=} returnType
         * @param {Array=} argTypes
         * @param {Arguments|Array=} args
         * @param {Object=} opts
         */
        function ccall(ident, returnType, argTypes, args, opts) {
            // For fast lookup of conversion functions
            var toC = {
                string: (str) => {
                    var ret = 0;
                    if (str !== null && str !== undefined && str !== 0) {
                        // null string
                        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
                        var len = (str.length << 2) + 1;
                        ret = stackAlloc(len);
                        stringToUTF8(str, ret, len);
                    }
                    return ret;
                },
                array: (arr) => {
                    var ret = stackAlloc(arr.length);
                    writeArrayToMemory(arr, ret);
                    return ret;
                }
            };

            function convertReturnValue(ret) {
                if (returnType === "string") {
                    return UTF8ToString(ret);
                }
                if (returnType === "boolean") return Boolean(ret);
                return ret;
            }

            var func = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            assert(returnType !== "array", 'Return type should not be "array".');
            if (args) {
                for (var i = 0; i < args.length; i++) {
                    var converter = toC[argTypes[i]];
                    if (converter) {
                        if (stack === 0) stack = stackSave();
                        cArgs[i] = converter(args[i]);
                    } else {
                        cArgs[i] = args[i];
                    }
                }
            }
            var ret = func.apply(null, cArgs);
            function onDone(ret) {
                if (stack !== 0) stackRestore(stack);
                return convertReturnValue(ret);
            }

            ret = onDone(ret);
            return ret;
        }

        /**
         * @param {string=} returnType
         * @param {Array=} argTypes
         * @param {Object=} opts
         */
        function cwrap(ident, returnType, argTypes, opts) {
            return function () {
                return ccall(ident, returnType, argTypes, arguments, opts);
            };
        }

        function uleb128Encode(n, target) {
            assert(n < 16384);
            if (n < 128) {
                target.push(n);
            } else {
                target.push(n % 128 | 128, n >> 7);
            }
        }

        function sigToWasmTypes(sig) {
            var typeNames = {
                i: "i32",
                // i64 values will be split into two i32s.
                j: "i32",
                f: "f32",
                d: "f64",
                p: "i32"
            };
            var type = {
                parameters: [],
                results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
            };
            for (var i = 1; i < sig.length; ++i) {
                assert(sig[i] in typeNames, "invalid signature char: " + sig[i]);
                type.parameters.push(typeNames[sig[i]]);
                if (sig[i] === "j") {
                    type.parameters.push("i32");
                }
            }
            return type;
        }

        function generateFuncType(sig, target) {
            var sigRet = sig.slice(0, 1);
            var sigParam = sig.slice(1);
            var typeCodes = {
                i: 0x7f, // i32
                p: 0x7f, // i32
                j: 0x7e, // i64
                f: 0x7d, // f32
                d: 0x7c // f64
            };

            // Parameters, length + signatures
            target.push(0x60 /* form: func */);
            uleb128Encode(sigParam.length, target);
            for (var i = 0; i < sigParam.length; ++i) {
                assert(sigParam[i] in typeCodes, "invalid signature char: " + sigParam[i]);
                target.push(typeCodes[sigParam[i]]);
            }

            // Return values, length + signatures
            // With no multi-return in MVP, either 0 (void) or 1 (anything else)
            if (sigRet == "v") {
                target.push(0x00);
            } else {
                target.push(0x01, typeCodes[sigRet]);
            }
        }
        function convertJsFunctionToWasm(func, sig) {
            // If the type reflection proposal is available, use the new
            // "WebAssembly.Function" constructor.
            // Otherwise, construct a minimal wasm module importing the JS function and
            // re-exporting it.
            if (typeof WebAssembly.Function == "function") {
                return new WebAssembly.Function(sigToWasmTypes(sig), func);
            }

            // The module is static, with the exception of the type section, which is
            // generated based on the signature passed in.
            var typeSectionBody = [
                0x01 // count: 1
            ];
            generateFuncType(sig, typeSectionBody);

            // Rest of the module is static
            var bytes = [
                0x00,
                0x61,
                0x73,
                0x6d, // magic ("\0asm")
                0x01,
                0x00,
                0x00,
                0x00, // version: 1
                0x01 // Type section code
            ];
            // Write the overall length of the type section followed by the body
            uleb128Encode(typeSectionBody.length, bytes);
            bytes.push.apply(bytes, typeSectionBody);

            // The rest of the module is static
            bytes.push(
                0x02,
                0x07, // import section
                // (import "e" "f" (func 0 (type 0)))
                0x01,
                0x01,
                0x65,
                0x01,
                0x66,
                0x00,
                0x00,
                0x07,
                0x05, // export section
                // (export "f" (func 0 (type 0)))
                0x01,
                0x01,
                0x66,
                0x00,
                0x00
            );

            // We can compile this wasm module synchronously because it is very small.
            // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
            var module = new WebAssembly.Module(new Uint8Array(bytes));
            var instance = new WebAssembly.Instance(module, { e: { f: func } });
            var wrappedFunc = instance.exports["f"];
            return wrappedFunc;
        }

        function updateTableMap(offset, count) {
            if (functionsInTableMap) {
                for (var i = offset; i < offset + count; i++) {
                    var item = getWasmTableEntry(i);
                    // Ignore null values.
                    if (item) {
                        functionsInTableMap.set(item, i);
                    }
                }
            }
        }

        var functionsInTableMap = undefined;
        function getFunctionAddress(func) {
            // First, create the map if this is the first use.
            if (!functionsInTableMap) {
                functionsInTableMap = new WeakMap();
                updateTableMap(0, wasmTable.length);
            }
            return functionsInTableMap.get(func) || 0;
        }

        var freeTableIndexes = [];
        function getEmptyTableSlot() {
            // Reuse a free index if there is one, otherwise grow.
            if (freeTableIndexes.length) {
                return freeTableIndexes.pop();
            }
            // Grow the table
            try {
                wasmTable.grow(1);
            } catch (err) {
                if (!(err instanceof RangeError)) {
                    throw err;
                }
                throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return wasmTable.length - 1;
        }

        function setWasmTableEntry(idx, func) {
            wasmTable.set(idx, func);
            // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped
            // functions so we need to call it here to retrieve the potential wrapper correctly
            // instead of just storing 'func' directly into wasmTableMirror
            wasmTableMirror[idx] = wasmTable.get(idx);
        }
        /** @param {string=} sig */
        function addFunction(func, sig) {
            assert(typeof func != "undefined");
            // Check if the function is already in the table, to ensure each function
            // gets a unique index.
            var rtn = getFunctionAddress(func);
            if (rtn) {
                return rtn;
            }

            // It's not in the table, add it now.

            var ret = getEmptyTableSlot();

            // Set the new value.
            try {
                // Attempting to call this with JS function will cause of table.set() to fail
                setWasmTableEntry(ret, func);
            } catch (err) {
                if (!(err instanceof TypeError)) {
                    throw err;
                }
                assert(
                    typeof sig != "undefined",
                    "Missing signature argument to addFunction: " + func
                );
                var wrapped = convertJsFunctionToWasm(func, sig);
                setWasmTableEntry(ret, wrapped);
            }

            functionsInTableMap.set(func, ret);

            return ret;
        }

        var FSNode = /** @constructor */ function (parent, name, mode, rdev) {
            if (!parent) {
                parent = this; // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
        };
        var readMode = 292 /*292*/ | 73; /*73*/
        var writeMode = 146; /*146*/
        Object.defineProperties(FSNode.prototype, {
            read: {
                get: /** @this{FSNode} */ function () {
                    return (this.mode & readMode) === readMode;
                },
                set: /** @this{FSNode} */ function (val) {
                    val ? (this.mode |= readMode) : (this.mode &= ~readMode);
                }
            },
            write: {
                get: /** @this{FSNode} */ function () {
                    return (this.mode & writeMode) === writeMode;
                },
                set: /** @this{FSNode} */ function (val) {
                    val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
                }
            },
            isFolder: {
                get: /** @this{FSNode} */ function () {
                    return FS.isDir(this.mode);
                }
            },
            isDevice: {
                get: /** @this{FSNode} */ function () {
                    return FS.isChrdev(this.mode);
                }
            }
        });
        FS.FSNode = FSNode;
        FS.staticInit();
        ERRNO_CODES = {
            EPERM: 63,
            ENOENT: 44,
            ESRCH: 71,
            EINTR: 27,
            EIO: 29,
            ENXIO: 60,
            E2BIG: 1,
            ENOEXEC: 45,
            EBADF: 8,
            ECHILD: 12,
            EAGAIN: 6,
            EWOULDBLOCK: 6,
            ENOMEM: 48,
            EACCES: 2,
            EFAULT: 21,
            ENOTBLK: 105,
            EBUSY: 10,
            EEXIST: 20,
            EXDEV: 75,
            ENODEV: 43,
            ENOTDIR: 54,
            EISDIR: 31,
            EINVAL: 28,
            ENFILE: 41,
            EMFILE: 33,
            ENOTTY: 59,
            ETXTBSY: 74,
            EFBIG: 22,
            ENOSPC: 51,
            ESPIPE: 70,
            EROFS: 69,
            EMLINK: 34,
            EPIPE: 64,
            EDOM: 18,
            ERANGE: 68,
            ENOMSG: 49,
            EIDRM: 24,
            ECHRNG: 106,
            EL2NSYNC: 156,
            EL3HLT: 107,
            EL3RST: 108,
            ELNRNG: 109,
            EUNATCH: 110,
            ENOCSI: 111,
            EL2HLT: 112,
            EDEADLK: 16,
            ENOLCK: 46,
            EBADE: 113,
            EBADR: 114,
            EXFULL: 115,
            ENOANO: 104,
            EBADRQC: 103,
            EBADSLT: 102,
            EDEADLOCK: 16,
            EBFONT: 101,
            ENOSTR: 100,
            ENODATA: 116,
            ETIME: 117,
            ENOSR: 118,
            ENONET: 119,
            ENOPKG: 120,
            EREMOTE: 121,
            ENOLINK: 47,
            EADV: 122,
            ESRMNT: 123,
            ECOMM: 124,
            EPROTO: 65,
            EMULTIHOP: 36,
            EDOTDOT: 125,
            EBADMSG: 9,
            ENOTUNIQ: 126,
            EBADFD: 127,
            EREMCHG: 128,
            ELIBACC: 129,
            ELIBBAD: 130,
            ELIBSCN: 131,
            ELIBMAX: 132,
            ELIBEXEC: 133,
            ENOSYS: 52,
            ENOTEMPTY: 55,
            ENAMETOOLONG: 37,
            ELOOP: 32,
            EOPNOTSUPP: 138,
            EPFNOSUPPORT: 139,
            ECONNRESET: 15,
            ENOBUFS: 42,
            EAFNOSUPPORT: 5,
            EPROTOTYPE: 67,
            ENOTSOCK: 57,
            ENOPROTOOPT: 50,
            ESHUTDOWN: 140,
            ECONNREFUSED: 14,
            EADDRINUSE: 3,
            ECONNABORTED: 13,
            ENETUNREACH: 40,
            ENETDOWN: 38,
            ETIMEDOUT: 73,
            EHOSTDOWN: 142,
            EHOSTUNREACH: 23,
            EINPROGRESS: 26,
            EALREADY: 7,
            EDESTADDRREQ: 17,
            EMSGSIZE: 35,
            EPROTONOSUPPORT: 66,
            ESOCKTNOSUPPORT: 137,
            EADDRNOTAVAIL: 4,
            ENETRESET: 39,
            EISCONN: 30,
            ENOTCONN: 53,
            ETOOMANYREFS: 141,
            EUSERS: 136,
            EDQUOT: 19,
            ESTALE: 72,
            ENOTSUP: 138,
            ENOMEDIUM: 148,
            EILSEQ: 25,
            EOVERFLOW: 61,
            ECANCELED: 11,
            ENOTRECOVERABLE: 56,
            EOWNERDEAD: 62,
            ESTRPIPE: 135
        };

        // exports
        Module["requestFullscreen"] = function Module_requestFullscreen(lockPointer, resizeCanvas) {
            Browser.requestFullscreen(lockPointer, resizeCanvas);
        };
        Module["requestFullScreen"] = function Module_requestFullScreen() {
            Browser.requestFullScreen();
        };
        Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) {
            Browser.requestAnimationFrame(func);
        };
        Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) {
            Browser.setCanvasSize(width, height, noUpdates);
        };
        Module["pauseMainLoop"] = function Module_pauseMainLoop() {
            Browser.mainLoop.pause();
        };
        Module["resumeMainLoop"] = function Module_resumeMainLoop() {
            Browser.mainLoop.resume();
        };
        Module["getUserMedia"] = function Module_getUserMedia() {
            Browser.getUserMedia();
        };
        Module["createContext"] = function Module_createContext(
            canvas,
            useWebGL,
            setInModule,
            webGLContextAttributes
        ) {
            return Browser.createContext(canvas, useWebGL, setInModule, webGLContextAttributes);
        };
        var preloadedImages = {};
        var preloadedAudios = {};
        var GLctx;
        for (var i = 0; i < 32; ++i) tempFixedLengthArray.push(new Array(i));
        var miniTempWebGLFloatBuffersStorage = new Float32Array(288);
        for (/**@suppress{duplicate}*/ var i = 0; i < 288; ++i) {
            miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i + 1);
        }
        var __miniTempWebGLIntBuffersStorage = new Int32Array(288);
        for (/**@suppress{duplicate}*/ var i = 0; i < 288; ++i) {
            __miniTempWebGLIntBuffers[i] = __miniTempWebGLIntBuffersStorage.subarray(0, i + 1);
        }
        function checkIncomingModuleAPI() {
            ignoredModuleProp("fetchSettings");
        }
        var wasmImports = {
            __assert_fail: ___assert_fail,
            __call_sighandler: ___call_sighandler,
            __dlsym: ___dlsym,
            __syscall__newselect: ___syscall__newselect,
            __syscall_accept4: ___syscall_accept4,
            __syscall_bind: ___syscall_bind,
            __syscall_chdir: ___syscall_chdir,
            __syscall_connect: ___syscall_connect,
            __syscall_dup: ___syscall_dup,
            __syscall_dup3: ___syscall_dup3,
            __syscall_faccessat: ___syscall_faccessat,
            __syscall_fcntl64: ___syscall_fcntl64,
            __syscall_fstat64: ___syscall_fstat64,
            __syscall_getcwd: ___syscall_getcwd,
            __syscall_getdents64: ___syscall_getdents64,
            __syscall_getpeername: ___syscall_getpeername,
            __syscall_getsockname: ___syscall_getsockname,
            __syscall_getsockopt: ___syscall_getsockopt,
            __syscall_ioctl: ___syscall_ioctl,
            __syscall_listen: ___syscall_listen,
            __syscall_lstat64: ___syscall_lstat64,
            __syscall_mkdirat: ___syscall_mkdirat,
            __syscall_mknodat: ___syscall_mknodat,
            __syscall_newfstatat: ___syscall_newfstatat,
            __syscall_openat: ___syscall_openat,
            __syscall_pipe: ___syscall_pipe,
            __syscall_poll: ___syscall_poll,
            __syscall_readlinkat: ___syscall_readlinkat,
            __syscall_recvfrom: ___syscall_recvfrom,
            __syscall_renameat: ___syscall_renameat,
            __syscall_rmdir: ___syscall_rmdir,
            __syscall_sendto: ___syscall_sendto,
            __syscall_socket: ___syscall_socket,
            __syscall_stat64: ___syscall_stat64,
            __syscall_symlink: ___syscall_symlink,
            __syscall_unlinkat: ___syscall_unlinkat,
            __syscall_utimensat: ___syscall_utimensat,
            _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
            _emscripten_throw_longjmp: __emscripten_throw_longjmp,
            _gmtime_js: __gmtime_js,
            _localtime_js: __localtime_js,
            _mktime_js: __mktime_js,
            _mmap_js: __mmap_js,
            _munmap_js: __munmap_js,
            _timegm_js: __timegm_js,
            _tzset_js: __tzset_js,
            abort: _abort,
            dlopen: _dlopen,
            dm_fetch_cancel: dm_fetch_cancel,
            dm_fetch_data: dm_fetch_data,
            dm_fetch_init: dm_fetch_init,
            eglBindAPI: _eglBindAPI,
            eglChooseConfig: _eglChooseConfig,
            eglCreateContext: _eglCreateContext,
            eglCreateWindowSurface: _eglCreateWindowSurface,
            eglDestroyContext: _eglDestroyContext,
            eglDestroySurface: _eglDestroySurface,
            eglGetConfigAttrib: _eglGetConfigAttrib,
            eglGetDisplay: _eglGetDisplay,
            eglGetError: _eglGetError,
            eglInitialize: _eglInitialize,
            eglMakeCurrent: _eglMakeCurrent,
            eglQueryString: _eglQueryString,
            eglSwapBuffers: _eglSwapBuffers,
            eglSwapInterval: _eglSwapInterval,
            eglTerminate: _eglTerminate,
            eglWaitGL: _eglWaitGL,
            eglWaitNative: _eglWaitNative,
            emscripten_asm_const_int: _emscripten_asm_const_int,
            emscripten_asm_const_int_sync_on_main_thread:
                _emscripten_asm_const_int_sync_on_main_thread,
            emscripten_cancel_main_loop: _emscripten_cancel_main_loop,
            emscripten_console_error: _emscripten_console_error,
            emscripten_date_now: _emscripten_date_now,
            emscripten_exit_fullscreen: _emscripten_exit_fullscreen,
            emscripten_exit_pointerlock: _emscripten_exit_pointerlock,
            emscripten_get_device_pixel_ratio: _emscripten_get_device_pixel_ratio,
            emscripten_get_element_css_size: _emscripten_get_element_css_size,
            emscripten_get_gamepad_status: _emscripten_get_gamepad_status,
            emscripten_get_heap_max: _emscripten_get_heap_max,
            emscripten_get_now: _emscripten_get_now,
            emscripten_get_num_gamepads: _emscripten_get_num_gamepads,
            emscripten_get_screen_size: _emscripten_get_screen_size,
            emscripten_glActiveTexture: _emscripten_glActiveTexture,
            emscripten_glAttachShader: _emscripten_glAttachShader,
            emscripten_glBeginQueryEXT: _emscripten_glBeginQueryEXT,
            emscripten_glBindAttribLocation: _emscripten_glBindAttribLocation,
            emscripten_glBindBuffer: _emscripten_glBindBuffer,
            emscripten_glBindFramebuffer: _emscripten_glBindFramebuffer,
            emscripten_glBindRenderbuffer: _emscripten_glBindRenderbuffer,
            emscripten_glBindTexture: _emscripten_glBindTexture,
            emscripten_glBindVertexArrayOES: _emscripten_glBindVertexArrayOES,
            emscripten_glBlendColor: _emscripten_glBlendColor,
            emscripten_glBlendEquation: _emscripten_glBlendEquation,
            emscripten_glBlendEquationSeparate: _emscripten_glBlendEquationSeparate,
            emscripten_glBlendFunc: _emscripten_glBlendFunc,
            emscripten_glBlendFuncSeparate: _emscripten_glBlendFuncSeparate,
            emscripten_glBufferData: _emscripten_glBufferData,
            emscripten_glBufferSubData: _emscripten_glBufferSubData,
            emscripten_glCheckFramebufferStatus: _emscripten_glCheckFramebufferStatus,
            emscripten_glClear: _emscripten_glClear,
            emscripten_glClearColor: _emscripten_glClearColor,
            emscripten_glClearDepthf: _emscripten_glClearDepthf,
            emscripten_glClearStencil: _emscripten_glClearStencil,
            emscripten_glColorMask: _emscripten_glColorMask,
            emscripten_glCompileShader: _emscripten_glCompileShader,
            emscripten_glCompressedTexImage2D: _emscripten_glCompressedTexImage2D,
            emscripten_glCompressedTexSubImage2D: _emscripten_glCompressedTexSubImage2D,
            emscripten_glCopyTexImage2D: _emscripten_glCopyTexImage2D,
            emscripten_glCopyTexSubImage2D: _emscripten_glCopyTexSubImage2D,
            emscripten_glCreateProgram: _emscripten_glCreateProgram,
            emscripten_glCreateShader: _emscripten_glCreateShader,
            emscripten_glCullFace: _emscripten_glCullFace,
            emscripten_glDeleteBuffers: _emscripten_glDeleteBuffers,
            emscripten_glDeleteFramebuffers: _emscripten_glDeleteFramebuffers,
            emscripten_glDeleteProgram: _emscripten_glDeleteProgram,
            emscripten_glDeleteQueriesEXT: _emscripten_glDeleteQueriesEXT,
            emscripten_glDeleteRenderbuffers: _emscripten_glDeleteRenderbuffers,
            emscripten_glDeleteShader: _emscripten_glDeleteShader,
            emscripten_glDeleteTextures: _emscripten_glDeleteTextures,
            emscripten_glDeleteVertexArraysOES: _emscripten_glDeleteVertexArraysOES,
            emscripten_glDepthFunc: _emscripten_glDepthFunc,
            emscripten_glDepthMask: _emscripten_glDepthMask,
            emscripten_glDepthRangef: _emscripten_glDepthRangef,
            emscripten_glDetachShader: _emscripten_glDetachShader,
            emscripten_glDisable: _emscripten_glDisable,
            emscripten_glDisableVertexAttribArray: _emscripten_glDisableVertexAttribArray,
            emscripten_glDrawArrays: _emscripten_glDrawArrays,
            emscripten_glDrawArraysInstancedANGLE: _emscripten_glDrawArraysInstancedANGLE,
            emscripten_glDrawBuffersWEBGL: _emscripten_glDrawBuffersWEBGL,
            emscripten_glDrawElements: _emscripten_glDrawElements,
            emscripten_glDrawElementsInstancedANGLE: _emscripten_glDrawElementsInstancedANGLE,
            emscripten_glEnable: _emscripten_glEnable,
            emscripten_glEnableVertexAttribArray: _emscripten_glEnableVertexAttribArray,
            emscripten_glEndQueryEXT: _emscripten_glEndQueryEXT,
            emscripten_glFinish: _emscripten_glFinish,
            emscripten_glFlush: _emscripten_glFlush,
            emscripten_glFramebufferRenderbuffer: _emscripten_glFramebufferRenderbuffer,
            emscripten_glFramebufferTexture2D: _emscripten_glFramebufferTexture2D,
            emscripten_glFrontFace: _emscripten_glFrontFace,
            emscripten_glGenBuffers: _emscripten_glGenBuffers,
            emscripten_glGenFramebuffers: _emscripten_glGenFramebuffers,
            emscripten_glGenQueriesEXT: _emscripten_glGenQueriesEXT,
            emscripten_glGenRenderbuffers: _emscripten_glGenRenderbuffers,
            emscripten_glGenTextures: _emscripten_glGenTextures,
            emscripten_glGenVertexArraysOES: _emscripten_glGenVertexArraysOES,
            emscripten_glGenerateMipmap: _emscripten_glGenerateMipmap,
            emscripten_glGetActiveAttrib: _emscripten_glGetActiveAttrib,
            emscripten_glGetActiveUniform: _emscripten_glGetActiveUniform,
            emscripten_glGetAttachedShaders: _emscripten_glGetAttachedShaders,
            emscripten_glGetAttribLocation: _emscripten_glGetAttribLocation,
            emscripten_glGetBooleanv: _emscripten_glGetBooleanv,
            emscripten_glGetBufferParameteriv: _emscripten_glGetBufferParameteriv,
            emscripten_glGetError: _emscripten_glGetError,
            emscripten_glGetFloatv: _emscripten_glGetFloatv,
            emscripten_glGetFramebufferAttachmentParameteriv:
                _emscripten_glGetFramebufferAttachmentParameteriv,
            emscripten_glGetIntegerv: _emscripten_glGetIntegerv,
            emscripten_glGetProgramInfoLog: _emscripten_glGetProgramInfoLog,
            emscripten_glGetProgramiv: _emscripten_glGetProgramiv,
            emscripten_glGetQueryObjecti64vEXT: _emscripten_glGetQueryObjecti64vEXT,
            emscripten_glGetQueryObjectivEXT: _emscripten_glGetQueryObjectivEXT,
            emscripten_glGetQueryObjectui64vEXT: _emscripten_glGetQueryObjectui64vEXT,
            emscripten_glGetQueryObjectuivEXT: _emscripten_glGetQueryObjectuivEXT,
            emscripten_glGetQueryivEXT: _emscripten_glGetQueryivEXT,
            emscripten_glGetRenderbufferParameteriv: _emscripten_glGetRenderbufferParameteriv,
            emscripten_glGetShaderInfoLog: _emscripten_glGetShaderInfoLog,
            emscripten_glGetShaderPrecisionFormat: _emscripten_glGetShaderPrecisionFormat,
            emscripten_glGetShaderSource: _emscripten_glGetShaderSource,
            emscripten_glGetShaderiv: _emscripten_glGetShaderiv,
            emscripten_glGetString: _emscripten_glGetString,
            emscripten_glGetTexParameterfv: _emscripten_glGetTexParameterfv,
            emscripten_glGetTexParameteriv: _emscripten_glGetTexParameteriv,
            emscripten_glGetUniformLocation: _emscripten_glGetUniformLocation,
            emscripten_glGetUniformfv: _emscripten_glGetUniformfv,
            emscripten_glGetUniformiv: _emscripten_glGetUniformiv,
            emscripten_glGetVertexAttribPointerv: _emscripten_glGetVertexAttribPointerv,
            emscripten_glGetVertexAttribfv: _emscripten_glGetVertexAttribfv,
            emscripten_glGetVertexAttribiv: _emscripten_glGetVertexAttribiv,
            emscripten_glHint: _emscripten_glHint,
            emscripten_glIsBuffer: _emscripten_glIsBuffer,
            emscripten_glIsEnabled: _emscripten_glIsEnabled,
            emscripten_glIsFramebuffer: _emscripten_glIsFramebuffer,
            emscripten_glIsProgram: _emscripten_glIsProgram,
            emscripten_glIsQueryEXT: _emscripten_glIsQueryEXT,
            emscripten_glIsRenderbuffer: _emscripten_glIsRenderbuffer,
            emscripten_glIsShader: _emscripten_glIsShader,
            emscripten_glIsTexture: _emscripten_glIsTexture,
            emscripten_glIsVertexArrayOES: _emscripten_glIsVertexArrayOES,
            emscripten_glLineWidth: _emscripten_glLineWidth,
            emscripten_glLinkProgram: _emscripten_glLinkProgram,
            emscripten_glPixelStorei: _emscripten_glPixelStorei,
            emscripten_glPolygonOffset: _emscripten_glPolygonOffset,
            emscripten_glQueryCounterEXT: _emscripten_glQueryCounterEXT,
            emscripten_glReadPixels: _emscripten_glReadPixels,
            emscripten_glReleaseShaderCompiler: _emscripten_glReleaseShaderCompiler,
            emscripten_glRenderbufferStorage: _emscripten_glRenderbufferStorage,
            emscripten_glSampleCoverage: _emscripten_glSampleCoverage,
            emscripten_glScissor: _emscripten_glScissor,
            emscripten_glShaderBinary: _emscripten_glShaderBinary,
            emscripten_glShaderSource: _emscripten_glShaderSource,
            emscripten_glStencilFunc: _emscripten_glStencilFunc,
            emscripten_glStencilFuncSeparate: _emscripten_glStencilFuncSeparate,
            emscripten_glStencilMask: _emscripten_glStencilMask,
            emscripten_glStencilMaskSeparate: _emscripten_glStencilMaskSeparate,
            emscripten_glStencilOp: _emscripten_glStencilOp,
            emscripten_glStencilOpSeparate: _emscripten_glStencilOpSeparate,
            emscripten_glTexImage2D: _emscripten_glTexImage2D,
            emscripten_glTexParameterf: _emscripten_glTexParameterf,
            emscripten_glTexParameterfv: _emscripten_glTexParameterfv,
            emscripten_glTexParameteri: _emscripten_glTexParameteri,
            emscripten_glTexParameteriv: _emscripten_glTexParameteriv,
            emscripten_glTexSubImage2D: _emscripten_glTexSubImage2D,
            emscripten_glUniform1f: _emscripten_glUniform1f,
            emscripten_glUniform1fv: _emscripten_glUniform1fv,
            emscripten_glUniform1i: _emscripten_glUniform1i,
            emscripten_glUniform1iv: _emscripten_glUniform1iv,
            emscripten_glUniform2f: _emscripten_glUniform2f,
            emscripten_glUniform2fv: _emscripten_glUniform2fv,
            emscripten_glUniform2i: _emscripten_glUniform2i,
            emscripten_glUniform2iv: _emscripten_glUniform2iv,
            emscripten_glUniform3f: _emscripten_glUniform3f,
            emscripten_glUniform3fv: _emscripten_glUniform3fv,
            emscripten_glUniform3i: _emscripten_glUniform3i,
            emscripten_glUniform3iv: _emscripten_glUniform3iv,
            emscripten_glUniform4f: _emscripten_glUniform4f,
            emscripten_glUniform4fv: _emscripten_glUniform4fv,
            emscripten_glUniform4i: _emscripten_glUniform4i,
            emscripten_glUniform4iv: _emscripten_glUniform4iv,
            emscripten_glUniformMatrix2fv: _emscripten_glUniformMatrix2fv,
            emscripten_glUniformMatrix3fv: _emscripten_glUniformMatrix3fv,
            emscripten_glUniformMatrix4fv: _emscripten_glUniformMatrix4fv,
            emscripten_glUseProgram: _emscripten_glUseProgram,
            emscripten_glValidateProgram: _emscripten_glValidateProgram,
            emscripten_glVertexAttrib1f: _emscripten_glVertexAttrib1f,
            emscripten_glVertexAttrib1fv: _emscripten_glVertexAttrib1fv,
            emscripten_glVertexAttrib2f: _emscripten_glVertexAttrib2f,
            emscripten_glVertexAttrib2fv: _emscripten_glVertexAttrib2fv,
            emscripten_glVertexAttrib3f: _emscripten_glVertexAttrib3f,
            emscripten_glVertexAttrib3fv: _emscripten_glVertexAttrib3fv,
            emscripten_glVertexAttrib4f: _emscripten_glVertexAttrib4f,
            emscripten_glVertexAttrib4fv: _emscripten_glVertexAttrib4fv,
            emscripten_glVertexAttribDivisorANGLE: _emscripten_glVertexAttribDivisorANGLE,
            emscripten_glVertexAttribPointer: _emscripten_glVertexAttribPointer,
            emscripten_glViewport: _emscripten_glViewport,
            emscripten_has_asyncify: _emscripten_has_asyncify,
            emscripten_memcpy_big: _emscripten_memcpy_big,
            emscripten_request_fullscreen_strategy: _emscripten_request_fullscreen_strategy,
            emscripten_request_pointerlock: _emscripten_request_pointerlock,
            emscripten_resize_heap: _emscripten_resize_heap,
            emscripten_sample_gamepad_data: _emscripten_sample_gamepad_data,
            emscripten_set_beforeunload_callback_on_thread:
                _emscripten_set_beforeunload_callback_on_thread,
            emscripten_set_blur_callback_on_thread: _emscripten_set_blur_callback_on_thread,
            emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size,
            emscripten_set_element_css_size: _emscripten_set_element_css_size,
            emscripten_set_focus_callback_on_thread: _emscripten_set_focus_callback_on_thread,
            emscripten_set_fullscreenchange_callback_on_thread:
                _emscripten_set_fullscreenchange_callback_on_thread,
            emscripten_set_gamepadconnected_callback_on_thread:
                _emscripten_set_gamepadconnected_callback_on_thread,
            emscripten_set_gamepaddisconnected_callback_on_thread:
                _emscripten_set_gamepaddisconnected_callback_on_thread,
            emscripten_set_keydown_callback_on_thread: _emscripten_set_keydown_callback_on_thread,
            emscripten_set_keypress_callback_on_thread: _emscripten_set_keypress_callback_on_thread,
            emscripten_set_keyup_callback_on_thread: _emscripten_set_keyup_callback_on_thread,
            emscripten_set_main_loop_arg: _emscripten_set_main_loop_arg,
            emscripten_set_mousedown_callback_on_thread:
                _emscripten_set_mousedown_callback_on_thread,
            emscripten_set_mouseenter_callback_on_thread:
                _emscripten_set_mouseenter_callback_on_thread,
            emscripten_set_mouseleave_callback_on_thread:
                _emscripten_set_mouseleave_callback_on_thread,
            emscripten_set_mousemove_callback_on_thread:
                _emscripten_set_mousemove_callback_on_thread,
            emscripten_set_mouseup_callback_on_thread: _emscripten_set_mouseup_callback_on_thread,
            emscripten_set_pointerlockchange_callback_on_thread:
                _emscripten_set_pointerlockchange_callback_on_thread,
            emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread,
            emscripten_set_touchcancel_callback_on_thread:
                _emscripten_set_touchcancel_callback_on_thread,
            emscripten_set_touchend_callback_on_thread: _emscripten_set_touchend_callback_on_thread,
            emscripten_set_touchmove_callback_on_thread:
                _emscripten_set_touchmove_callback_on_thread,
            emscripten_set_touchstart_callback_on_thread:
                _emscripten_set_touchstart_callback_on_thread,
            emscripten_set_visibilitychange_callback_on_thread:
                _emscripten_set_visibilitychange_callback_on_thread,
            emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread,
            emscripten_set_window_title: _emscripten_set_window_title,
            emscripten_sleep: _emscripten_sleep,
            environ_get: _environ_get,
            environ_sizes_get: _environ_sizes_get,
            exit: _exit,
            fd_close: _fd_close,
            fd_fdstat_get: _fd_fdstat_get,
            fd_read: _fd_read,
            fd_seek: _fd_seek,
            fd_write: _fd_write,
            fs_fetch_setup: fs_fetch_setup,
            getaddrinfo: _getaddrinfo,
            getnameinfo: _getnameinfo,
            glActiveTexture: _glActiveTexture,
            glAttachShader: _glAttachShader,
            glBindAttribLocation: _glBindAttribLocation,
            glBindBuffer: _glBindBuffer,
            glBindFramebuffer: _glBindFramebuffer,
            glBindRenderbuffer: _glBindRenderbuffer,
            glBindTexture: _glBindTexture,
            glBlendColor: _glBlendColor,
            glBlendEquation: _glBlendEquation,
            glBlendEquationSeparate: _glBlendEquationSeparate,
            glBlendFunc: _glBlendFunc,
            glBlendFuncSeparate: _glBlendFuncSeparate,
            glBufferData: _glBufferData,
            glBufferSubData: _glBufferSubData,
            glCheckFramebufferStatus: _glCheckFramebufferStatus,
            glClear: _glClear,
            glClearColor: _glClearColor,
            glClearDepthf: _glClearDepthf,
            glClearStencil: _glClearStencil,
            glColorMask: _glColorMask,
            glCompileShader: _glCompileShader,
            glCompressedTexImage2D: _glCompressedTexImage2D,
            glCompressedTexSubImage2D: _glCompressedTexSubImage2D,
            glCopyTexImage2D: _glCopyTexImage2D,
            glCopyTexSubImage2D: _glCopyTexSubImage2D,
            glCreateProgram: _glCreateProgram,
            glCreateShader: _glCreateShader,
            glCullFace: _glCullFace,
            glDeleteBuffers: _glDeleteBuffers,
            glDeleteFramebuffers: _glDeleteFramebuffers,
            glDeleteProgram: _glDeleteProgram,
            glDeleteRenderbuffers: _glDeleteRenderbuffers,
            glDeleteShader: _glDeleteShader,
            glDeleteTextures: _glDeleteTextures,
            glDepthFunc: _glDepthFunc,
            glDepthMask: _glDepthMask,
            glDepthRangef: _glDepthRangef,
            glDetachShader: _glDetachShader,
            glDisable: _glDisable,
            glDisableVertexAttribArray: _glDisableVertexAttribArray,
            glDrawArrays: _glDrawArrays,
            glDrawElements: _glDrawElements,
            glEnable: _glEnable,
            glEnableVertexAttribArray: _glEnableVertexAttribArray,
            glFinish: _glFinish,
            glFlush: _glFlush,
            glFramebufferRenderbuffer: _glFramebufferRenderbuffer,
            glFramebufferTexture2D: _glFramebufferTexture2D,
            glFrontFace: _glFrontFace,
            glGenBuffers: _glGenBuffers,
            glGenFramebuffers: _glGenFramebuffers,
            glGenRenderbuffers: _glGenRenderbuffers,
            glGenTextures: _glGenTextures,
            glGenerateMipmap: _glGenerateMipmap,
            glGetActiveAttrib: _glGetActiveAttrib,
            glGetActiveUniform: _glGetActiveUniform,
            glGetAttachedShaders: _glGetAttachedShaders,
            glGetAttribLocation: _glGetAttribLocation,
            glGetBooleanv: _glGetBooleanv,
            glGetBufferParameteriv: _glGetBufferParameteriv,
            glGetError: _glGetError,
            glGetFloatv: _glGetFloatv,
            glGetFramebufferAttachmentParameteriv: _glGetFramebufferAttachmentParameteriv,
            glGetIntegerv: _glGetIntegerv,
            glGetProgramInfoLog: _glGetProgramInfoLog,
            glGetProgramiv: _glGetProgramiv,
            glGetRenderbufferParameteriv: _glGetRenderbufferParameteriv,
            glGetShaderInfoLog: _glGetShaderInfoLog,
            glGetShaderPrecisionFormat: _glGetShaderPrecisionFormat,
            glGetShaderSource: _glGetShaderSource,
            glGetShaderiv: _glGetShaderiv,
            glGetString: _glGetString,
            glGetTexParameteriv: _glGetTexParameteriv,
            glGetUniformLocation: _glGetUniformLocation,
            glGetUniformfv: _glGetUniformfv,
            glGetUniformiv: _glGetUniformiv,
            glGetVertexAttribPointerv: _glGetVertexAttribPointerv,
            glGetVertexAttribfv: _glGetVertexAttribfv,
            glGetVertexAttribiv: _glGetVertexAttribiv,
            glHint: _glHint,
            glIsBuffer: _glIsBuffer,
            glIsEnabled: _glIsEnabled,
            glIsFramebuffer: _glIsFramebuffer,
            glIsProgram: _glIsProgram,
            glIsRenderbuffer: _glIsRenderbuffer,
            glIsShader: _glIsShader,
            glIsTexture: _glIsTexture,
            glLineWidth: _glLineWidth,
            glLinkProgram: _glLinkProgram,
            glPixelStorei: _glPixelStorei,
            glPolygonOffset: _glPolygonOffset,
            glReadPixels: _glReadPixels,
            glRenderbufferStorage: _glRenderbufferStorage,
            glSampleCoverage: _glSampleCoverage,
            glScissor: _glScissor,
            glShaderSource: _glShaderSource,
            glStencilFunc: _glStencilFunc,
            glStencilFuncSeparate: _glStencilFuncSeparate,
            glStencilMask: _glStencilMask,
            glStencilMaskSeparate: _glStencilMaskSeparate,
            glStencilOp: _glStencilOp,
            glStencilOpSeparate: _glStencilOpSeparate,
            glTexImage2D: _glTexImage2D,
            glTexParameterf: _glTexParameterf,
            glTexParameteri: _glTexParameteri,
            glTexSubImage2D: _glTexSubImage2D,
            glUniform1f: _glUniform1f,
            glUniform1fv: _glUniform1fv,
            glUniform1i: _glUniform1i,
            glUniform1iv: _glUniform1iv,
            glUniform2f: _glUniform2f,
            glUniform2fv: _glUniform2fv,
            glUniform2i: _glUniform2i,
            glUniform2iv: _glUniform2iv,
            glUniform3f: _glUniform3f,
            glUniform3fv: _glUniform3fv,
            glUniform3i: _glUniform3i,
            glUniform3iv: _glUniform3iv,
            glUniform4f: _glUniform4f,
            glUniform4fv: _glUniform4fv,
            glUniform4i: _glUniform4i,
            glUniform4iv: _glUniform4iv,
            glUniformMatrix2fv: _glUniformMatrix2fv,
            glUniformMatrix3fv: _glUniformMatrix3fv,
            glUniformMatrix4fv: _glUniformMatrix4fv,
            glUseProgram: _glUseProgram,
            glValidateProgram: _glValidateProgram,
            glVertexAttrib1f: _glVertexAttrib1f,
            glVertexAttrib1fv: _glVertexAttrib1fv,
            glVertexAttrib2f: _glVertexAttrib2f,
            glVertexAttrib2fv: _glVertexAttrib2fv,
            glVertexAttrib3f: _glVertexAttrib3f,
            glVertexAttrib3fv: _glVertexAttrib3fv,
            glVertexAttrib4f: _glVertexAttrib4f,
            glVertexAttrib4fv: _glVertexAttrib4fv,
            glVertexAttribPointer: _glVertexAttribPointer,
            glViewport: _glViewport,
            invoke_ii: invoke_ii,
            invoke_iii: invoke_iii,
            invoke_iiii: invoke_iiii,
            invoke_iiiii: invoke_iiiii,
            invoke_iiiiii: invoke_iiiiii,
            invoke_vi: invoke_vi,
            invoke_vii: invoke_vii,
            invoke_viii: invoke_viii,
            invoke_viiii: invoke_viiii,
            invoke_viiiiiiiii: invoke_viiiiiiiii,
            proc_exit: _proc_exit,
            strftime: _strftime,
            system: _system,
            wcdec_copy_audio: wcdec_copy_audio,
            wcdec_copy_frame: wcdec_copy_frame,
            wcdec_del: wcdec_del,
            wcdec_flush: wcdec_flush,
            wcdec_init: wcdec_init,
            wcdec_push_audio: wcdec_push_audio,
            wcdec_push_frame: wcdec_push_frame,
            wcenc_del: wcenc_del,
            wcenc_encode_audio: wcenc_encode_audio,
            wcenc_encode_frame: wcenc_encode_frame,
            wcenc_flush: wcenc_flush,
            wcenc_get_config: wcenc_get_config,
            wcenc_get_frame: wcenc_get_frame,
            wcenc_init: wcenc_init,
            webgrab_next_audio: webgrab_next_audio,
            webgrab_next_video: webgrab_next_video,
            webgrab_start_usermedia: webgrab_start_usermedia,
            wgrab_copy_audio: wgrab_copy_audio,
            wgrab_copy_frame: wgrab_copy_frame,
            wgrab_del: wgrab_del
        };
        var asm = createWasm();
        /** @type {function(...*):?} */
        var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
        /** @type {function(...*):?} */
        var _gf_log_tool_level_on = (Module["_gf_log_tool_level_on"] =
            createExportWrapper("gf_log_tool_level_on"));
        /** @type {function(...*):?} */
        var _gf_log_lt = (Module["_gf_log_lt"] = createExportWrapper("gf_log_lt"));
        /** @type {function(...*):?} */
        var _gf_log = (Module["_gf_log"] = createExportWrapper("gf_log"));
        /** @type {function(...*):?} */
        var _gpac_em_sig_handler = (Module["_gpac_em_sig_handler"] =
            createExportWrapper("gpac_em_sig_handler"));
        /** @type {function(...*):?} */
        var _gf_fs_abort = (Module["_gf_fs_abort"] = createExportWrapper("gf_fs_abort"));
        /** @type {function(...*):?} */
        var _gf_fs_set_ui_callback = (Module["_gf_fs_set_ui_callback"] =
            createExportWrapper("gf_fs_set_ui_callback"));
        /** @type {function(...*):?} */
        var _gf_fs_enable_reporting = (Module["_gf_fs_enable_reporting"] =
            createExportWrapper("gf_fs_enable_reporting"));
        /** @type {function(...*):?} */
        var _gf_log_use_file = (Module["_gf_log_use_file"] =
            createExportWrapper("gf_log_use_file"));
        /** @type {function(...*):?} */
        var _gf_malloc = (Module["_gf_malloc"] = createExportWrapper("gf_malloc"));
        /** @type {function(...*):?} */
        var _gf_log_set_callback = (Module["_gf_log_set_callback"] =
            createExportWrapper("gf_log_set_callback"));
        /** @type {function(...*):?} */
        var _gf_sys_clock_high_res = (Module["_gf_sys_clock_high_res"] =
            createExportWrapper("gf_sys_clock_high_res"));
        /** @type {function(...*):?} */
        var _gf_sys_get_rti = (Module["_gf_sys_get_rti"] = createExportWrapper("gf_sys_get_rti"));
        /** @type {function(...*):?} */
        var _gf_net_get_utc = (Module["_gf_net_get_utc"] = createExportWrapper("gf_net_get_utc"));
        /** @type {function(...*):?} */
        var _gf_fs_lock_filters = (Module["_gf_fs_lock_filters"] =
            createExportWrapper("gf_fs_lock_filters"));
        /** @type {function(...*):?} */
        var _gf_fs_get_filters_count = (Module["_gf_fs_get_filters_count"] =
            createExportWrapper("gf_fs_get_filters_count"));
        /** @type {function(...*):?} */
        var _gf_fs_get_filter_stats = (Module["_gf_fs_get_filter_stats"] =
            createExportWrapper("gf_fs_get_filter_stats"));
        /** @type {function(...*):?} */
        var _gf_stream_type_name = (Module["_gf_stream_type_name"] =
            createExportWrapper("gf_stream_type_name"));
        /** @type {function(...*):?} */
        var _gf_codecid_name = (Module["_gf_codecid_name"] =
            createExportWrapper("gf_codecid_name"));
        /** @type {function(...*):?} */
        var _fflush = (Module["_fflush"] = createExportWrapper("fflush"));
        /** @type {function(...*):?} */
        var _gpac_has_threads = (Module["_gpac_has_threads"] =
            createExportWrapper("gpac_has_threads"));
        /** @type {function(...*):?} */
        var _main = (Module["_main"] = createExportWrapper("__main_argc_argv"));
        /** @type {function(...*):?} */
        var _gf_sys_init = (Module["_gf_sys_init"] = createExportWrapper("gf_sys_init"));
        /** @type {function(...*):?} */
        var _gf_log_set_tool_level = (Module["_gf_log_set_tool_level"] =
            createExportWrapper("gf_log_set_tool_level"));
        /** @type {function(...*):?} */
        var _gf_opts_get_key_count = (Module["_gf_opts_get_key_count"] =
            createExportWrapper("gf_opts_get_key_count"));
        /** @type {function(...*):?} */
        var _gf_opts_get_key = (Module["_gf_opts_get_key"] =
            createExportWrapper("gf_opts_get_key"));
        /** @type {function(...*):?} */
        var _gf_opts_set_key = (Module["_gf_opts_set_key"] =
            createExportWrapper("gf_opts_set_key"));
        /** @type {function(...*):?} */
        var _gf_sys_set_args = (Module["_gf_sys_set_args"] =
            createExportWrapper("gf_sys_set_args"));
        /** @type {function(...*):?} */
        var _gf_error_to_string = (Module["_gf_error_to_string"] =
            createExportWrapper("gf_error_to_string"));
        /** @type {function(...*):?} */
        var _gf_sys_mark_arg_used = (Module["_gf_sys_mark_arg_used"] =
            createExportWrapper("gf_sys_mark_arg_used"));
        /** @type {function(...*):?} */
        var _gf_fs_new_defaults = (Module["_gf_fs_new_defaults"] =
            createExportWrapper("gf_fs_new_defaults"));
        /** @type {function(...*):?} */
        var _gf_set_progress_callback = (Module["_gf_set_progress_callback"] = createExportWrapper(
            "gf_set_progress_callback"
        ));
        /** @type {function(...*):?} */
        var _gf_fs_load_filter = (Module["_gf_fs_load_filter"] =
            createExportWrapper("gf_fs_load_filter"));
        /** @type {function(...*):?} */
        var _gf_fs_run = (Module["_gf_fs_run"] = createExportWrapper("gf_fs_run"));
        /** @type {function(...*):?} */
        var _gf_fs_del = (Module["_gf_fs_del"] = createExportWrapper("gf_fs_del"));
        /** @type {function(...*):?} */
        var _gf_gpac_version = (Module["_gf_gpac_version"] =
            createExportWrapper("gf_gpac_version"));
        /** @type {function(...*):?} */
        var _gf_sys_features = (Module["_gf_sys_features"] =
            createExportWrapper("gf_sys_features"));
        /** @type {function(...*):?} */
        var _gf_sys_format_help = (Module["_gf_sys_format_help"] =
            createExportWrapper("gf_sys_format_help"));
        /** @type {function(...*):?} */
        var _gf_fopen = (Module["_gf_fopen"] = createExportWrapper("gf_fopen"));
        /** @type {function(...*):?} */
        var _gf_enum_directory = (Module["_gf_enum_directory"] =
            createExportWrapper("gf_enum_directory"));
        /** @type {function(...*):?} */
        var _gf_fs_filter_exists = (Module["_gf_fs_filter_exists"] =
            createExportWrapper("gf_fs_filter_exists"));
        /** @type {function(...*):?} */
        var _gf_sys_is_gpac_arg = (Module["_gf_sys_is_gpac_arg"] =
            createExportWrapper("gf_sys_is_gpac_arg"));
        /** @type {function(...*):?} */
        var _gf_fclose = (Module["_gf_fclose"] = createExportWrapper("gf_fclose"));
        /** @type {function(...*):?} */
        var _gf_gpac_copyright = (Module["_gf_gpac_copyright"] =
            createExportWrapper("gf_gpac_copyright"));
        /** @type {function(...*):?} */
        var _gf_sys_get_argc = (Module["_gf_sys_get_argc"] =
            createExportWrapper("gf_sys_get_argc"));
        /** @type {function(...*):?} */
        var _gf_sys_is_arg_used = (Module["_gf_sys_is_arg_used"] =
            createExportWrapper("gf_sys_is_arg_used"));
        /** @type {function(...*):?} */
        var _gf_sys_get_arg = (Module["_gf_sys_get_arg"] = createExportWrapper("gf_sys_get_arg"));
        /** @type {function(...*):?} */
        var _gf_list_count = (Module["_gf_list_count"] = createExportWrapper("gf_list_count"));
        /** @type {function(...*):?} */
        var _gf_list_pop_back = (Module["_gf_list_pop_back"] =
            createExportWrapper("gf_list_pop_back"));
        /** @type {function(...*):?} */
        var _gf_free = (Module["_gf_free"] = createExportWrapper("gf_free"));
        /** @type {function(...*):?} */
        var _gf_list_del = (Module["_gf_list_del"] = createExportWrapper("gf_list_del"));
        /** @type {function(...*):?} */
        var _gf_sys_close = (Module["_gf_sys_close"] = createExportWrapper("gf_sys_close"));
        /** @type {function(...*):?} */
        var _gf_fs_set_separators = (Module["_gf_fs_set_separators"] =
            createExportWrapper("gf_fs_set_separators"));
        /** @type {function(...*):?} */
        var _gf_fs_register_test_filters = (Module["_gf_fs_register_test_filters"] =
            createExportWrapper("gf_fs_register_test_filters"));
        /** @type {function(...*):?} */
        var _gf_fs_get_max_resolution_chain_length = (Module[
            "_gf_fs_get_max_resolution_chain_length"
        ] = createExportWrapper("gf_fs_get_max_resolution_chain_length"));
        /** @type {function(...*):?} */
        var _gf_fs_print_all_connections = (Module["_gf_fs_print_all_connections"] =
            createExportWrapper("gf_fs_print_all_connections"));
        /** @type {function(...*):?} */
        var _gf_fs_load_script = (Module["_gf_fs_load_script"] =
            createExportWrapper("gf_fs_load_script"));
        /** @type {function(...*):?} */
        var _gf_list_new = (Module["_gf_list_new"] = createExportWrapper("gf_list_new"));
        /** @type {function(...*):?} */
        var _gf_fs_load_source = (Module["_gf_fs_load_source"] =
            createExportWrapper("gf_fs_load_source"));
        /** @type {function(...*):?} */
        var _gf_fs_load_destination = (Module["_gf_fs_load_destination"] =
            createExportWrapper("gf_fs_load_destination"));
        /** @type {function(...*):?} */
        var _gf_list_add = (Module["_gf_list_add"] = createExportWrapper("gf_list_add"));
        /** @type {function(...*):?} */
        var _gf_dynstrcat = (Module["_gf_dynstrcat"] = createExportWrapper("gf_dynstrcat"));
        /** @type {function(...*):?} */
        var _gf_filter_tag_subsession = (Module["_gf_filter_tag_subsession"] = createExportWrapper(
            "gf_filter_tag_subsession"
        ));
        /** @type {function(...*):?} */
        var _gf_list_pop_front = (Module["_gf_list_pop_front"] =
            createExportWrapper("gf_list_pop_front"));
        /** @type {function(...*):?} */
        var _gf_list_get = (Module["_gf_list_get"] = createExportWrapper("gf_list_get"));
        /** @type {function(...*):?} */
        var _gf_filter_set_source = (Module["_gf_filter_set_source"] =
            createExportWrapper("gf_filter_set_source"));
        /** @type {function(...*):?} */
        var _gf_filter_is_source = (Module["_gf_filter_is_source"] =
            createExportWrapper("gf_filter_is_source"));
        /** @type {function(...*):?} */
        var _gf_filter_is_sink = (Module["_gf_filter_is_sink"] =
            createExportWrapper("gf_filter_is_sink"));
        /** @type {function(...*):?} */
        var _gf_gpac_copyright_cite = (Module["_gf_gpac_copyright_cite"] =
            createExportWrapper("gf_gpac_copyright_cite"));
        /** @type {function(...*):?} */
        var _gf_opts_get_bool = (Module["_gf_opts_get_bool"] =
            createExportWrapper("gf_opts_get_bool"));
        /** @type {function(...*):?} */
        var _gf_fs_post_user_task_main = (Module["_gf_fs_post_user_task_main"] =
            createExportWrapper("gf_fs_post_user_task_main"));
        /** @type {function(...*):?} */
        var _gf_fs_post_user_task = (Module["_gf_fs_post_user_task"] =
            createExportWrapper("gf_fs_post_user_task"));
        /** @type {function(...*):?} */
        var _gf_fs_get_last_connect_error = (Module["_gf_fs_get_last_connect_error"] =
            createExportWrapper("gf_fs_get_last_connect_error"));
        /** @type {function(...*):?} */
        var _gf_fs_get_last_process_error = (Module["_gf_fs_get_last_process_error"] =
            createExportWrapper("gf_fs_get_last_process_error"));
        /** @type {function(...*):?} */
        var _gf_fs_print_non_connected_ex = (Module["_gf_fs_print_non_connected_ex"] =
            createExportWrapper("gf_fs_print_non_connected_ex"));
        /** @type {function(...*):?} */
        var _gf_fs_print_stats = (Module["_gf_fs_print_stats"] =
            createExportWrapper("gf_fs_print_stats"));
        /** @type {function(...*):?} */
        var _gf_fs_print_connections = (Module["_gf_fs_print_connections"] =
            createExportWrapper("gf_fs_print_connections"));
        /** @type {function(...*):?} */
        var _gf_fileio_get_udta = (Module["_gf_fileio_get_udta"] =
            createExportWrapper("gf_fileio_get_udta"));
        /** @type {function(...*):?} */
        var _gf_fileio_del = (Module["_gf_fileio_del"] = createExportWrapper("gf_fileio_del"));
        /** @type {function(...*):?} */
        var _gf_log_reset_file = (Module["_gf_log_reset_file"] =
            createExportWrapper("gf_log_reset_file"));
        /** @type {function(...*):?} */
        var _gf_fs_stop = (Module["_gf_fs_stop"] = createExportWrapper("gf_fs_stop"));
        /** @type {function(...*):?} */
        var _gf_url_colon_suffix = (Module["_gf_url_colon_suffix"] =
            createExportWrapper("gf_url_colon_suffix"));
        /** @type {function(...*):?} */
        var _gf_strdup = (Module["_gf_strdup"] = createExportWrapper("gf_strdup"));
        /** @type {function(...*):?} */
        var _gf_fileio_new = (Module["_gf_fileio_new"] = createExportWrapper("gf_fileio_new"));
        /** @type {function(...*):?} */
        var _gf_fileio_url = (Module["_gf_fileio_url"] = createExportWrapper("gf_fileio_url"));
        /** @type {function(...*):?} */
        var _gf_fs_new_filter = (Module["_gf_fs_new_filter"] =
            createExportWrapper("gf_fs_new_filter"));
        /** @type {function(...*):?} */
        var _gf_filter_push_caps = (Module["_gf_filter_push_caps"] =
            createExportWrapper("gf_filter_push_caps"));
        /** @type {function(...*):?} */
        var _gf_filter_set_configure_ckb = (Module["_gf_filter_set_configure_ckb"] =
            createExportWrapper("gf_filter_set_configure_ckb"));
        /** @type {function(...*):?} */
        var _gf_filter_set_process_ckb = (Module["_gf_filter_set_process_ckb"] =
            createExportWrapper("gf_filter_set_process_ckb"));
        /** @type {function(...*):?} */
        var _gf_filter_set_process_event_ckb = (Module["_gf_filter_set_process_event_ckb"] =
            createExportWrapper("gf_filter_set_process_event_ckb"));
        /** @type {function(...*):?} */
        var _gf_filter_set_reconfigure_output_ckb = (Module[
            "_gf_filter_set_reconfigure_output_ckb"
        ] = createExportWrapper("gf_filter_set_reconfigure_output_ckb"));
        /** @type {function(...*):?} */
        var _gf_filter_set_probe_data_cbk = (Module["_gf_filter_set_probe_data_cbk"] =
            createExportWrapper("gf_filter_set_probe_data_cbk"));
        /** @type {function(...*):?} */
        var _gf_prompt_has_input = (Module["_gf_prompt_has_input"] =
            createExportWrapper("gf_prompt_has_input"));
        /** @type {function(...*):?} */
        var _gf_prompt_get_char = (Module["_gf_prompt_get_char"] =
            createExportWrapper("gf_prompt_get_char"));
        /** @type {function(...*):?} */
        var _gf_fs_send_update = (Module["_gf_fs_send_update"] =
            createExportWrapper("gf_fs_send_update"));
        /** @type {function(...*):?} */
        var _gf_filter_remove = (Module["_gf_filter_remove"] =
            createExportWrapper("gf_filter_remove"));
        /** @type {function(...*):?} */
        var _gf_filter_reconnect_output = (Module["_gf_filter_reconnect_output"] =
            createExportWrapper("gf_filter_reconnect_output"));
        /** @type {function(...*):?} */
        var _gf_sleep = (Module["_gf_sleep"] = createExportWrapper("gf_sleep"));
        /** @type {function(...*):?} */
        var _gf_fs_is_last_task = (Module["_gf_fs_is_last_task"] =
            createExportWrapper("gf_fs_is_last_task"));
        /** @type {function(...*):?} */
        var _gf_getch = (Module["_gf_getch"] = createExportWrapper("gf_getch"));
        /** @type {function(...*):?} */
        var _gf_fs_print_debug_info = (Module["_gf_fs_print_debug_info"] =
            createExportWrapper("gf_fs_print_debug_info"));
        /** @type {function(...*):?} */
        var _gf_file_exists = (Module["_gf_file_exists"] = createExportWrapper("gf_file_exists"));
        /** @type {function(...*):?} */
        var _gf_fsize = (Module["_gf_fsize"] = createExportWrapper("gf_fsize"));
        /** @type {function(...*):?} */
        var _gf_fileio_set_stats = (Module["_gf_fileio_set_stats"] =
            createExportWrapper("gf_fileio_set_stats"));
        /** @type {function(...*):?} */
        var _gf_url_concatenate = (Module["_gf_url_concatenate"] =
            createExportWrapper("gf_url_concatenate"));
        /** @type {function(...*):?} */
        var _gf_list_del_item = (Module["_gf_list_del_item"] =
            createExportWrapper("gf_list_del_item"));
        /** @type {function(...*):?} */
        var _gf_fseek = (Module["_gf_fseek"] = createExportWrapper("gf_fseek"));
        /** @type {function(...*):?} */
        var _gf_fread = (Module["_gf_fread"] = createExportWrapper("gf_fread"));
        /** @type {function(...*):?} */
        var _gf_fwrite = (Module["_gf_fwrite"] = createExportWrapper("gf_fwrite"));
        /** @type {function(...*):?} */
        var _gf_ftell = (Module["_gf_ftell"] = createExportWrapper("gf_ftell"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_send_event = (Module["_gf_filter_pid_send_event"] = createExportWrapper(
            "gf_filter_pid_send_event"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_framing_mode = (Module["_gf_filter_pid_set_framing_mode"] =
            createExportWrapper("gf_filter_pid_set_framing_mode"));
        /** @type {function(...*):?} */
        var _gf_filter_get_ipid_count = (Module["_gf_filter_get_ipid_count"] = createExportWrapper(
            "gf_filter_get_ipid_count"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_get_ipid = (Module["_gf_filter_get_ipid"] =
            createExportWrapper("gf_filter_get_ipid"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_name = (Module["_gf_filter_pid_get_name"] =
            createExportWrapper("gf_filter_pid_get_name"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_packet = (Module["_gf_filter_pid_get_packet"] = createExportWrapper(
            "gf_filter_pid_get_packet"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_cts = (Module["_gf_filter_pck_get_cts"] =
            createExportWrapper("gf_filter_pck_get_cts"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_drop_packet = (Module["_gf_filter_pid_drop_packet"] =
            createExportWrapper("gf_filter_pid_drop_packet"));
        /** @type {function(...*):?} */
        var _gf_realloc = (Module["_gf_realloc"] = createExportWrapper("gf_realloc"));
        /** @type {function(...*):?} */
        var _gf_gmtime = (Module["_gf_gmtime"] = createExportWrapper("gf_gmtime"));
        /** @type {function(...*):?} */
        var _gf_sys_print_arg = (Module["_gf_sys_print_arg"] =
            createExportWrapper("gf_sys_print_arg"));
        /** @type {function(...*):?} */
        var _gf_sc_user_event = (Module["_gf_sc_user_event"] =
            createExportWrapper("gf_sc_user_event"));
        /** @type {function(...*):?} */
        var _gf_set_progress = (Module["_gf_set_progress"] =
            createExportWrapper("gf_set_progress"));
        /** @type {function(...*):?} */
        var _gf_sc_get_option = (Module["_gf_sc_get_option"] =
            createExportWrapper("gf_sc_get_option"));
        /** @type {function(...*):?} */
        var _gf_sc_set_option = (Module["_gf_sc_set_option"] =
            createExportWrapper("gf_sc_set_option"));
        /** @type {function(...*):?} */
        var _gf_sc_get_fps = (Module["_gf_sc_get_fps"] = createExportWrapper("gf_sc_get_fps"));
        /** @type {function(...*):?} */
        var _gf_sc_get_time_in_ms = (Module["_gf_sc_get_time_in_ms"] =
            createExportWrapper("gf_sc_get_time_in_ms"));
        /** @type {function(...*):?} */
        var _gf_sc_switch_quality = (Module["_gf_sc_switch_quality"] =
            createExportWrapper("gf_sc_switch_quality"));
        /** @type {function(...*):?} */
        var _gf_sc_toggle_addons = (Module["_gf_sc_toggle_addons"] =
            createExportWrapper("gf_sc_toggle_addons"));
        /** @type {function(...*):?} */
        var _gf_sc_set_speed = (Module["_gf_sc_set_speed"] =
            createExportWrapper("gf_sc_set_speed"));
        /** @type {function(...*):?} */
        var _gf_sc_set_size = (Module["_gf_sc_set_size"] = createExportWrapper("gf_sc_set_size"));
        /** @type {function(...*):?} */
        var _gf_sc_scene_update = (Module["_gf_sc_scene_update"] =
            createExportWrapper("gf_sc_scene_update"));
        /** @type {function(...*):?} */
        var _gf_sc_navigate_to = (Module["_gf_sc_navigate_to"] =
            createExportWrapper("gf_sc_navigate_to"));
        /** @type {function(...*):?} */
        var _gf_sc_is_supported_url = (Module["_gf_sc_is_supported_url"] =
            createExportWrapper("gf_sc_is_supported_url"));
        /** @type {function(...*):?} */
        var _gf_read_line_input = (Module["_gf_read_line_input"] =
            createExportWrapper("gf_read_line_input"));
        /** @type {function(...*):?} */
        var _gf_filter_get_udta = (Module["_gf_filter_get_udta"] =
            createExportWrapper("gf_filter_get_udta"));
        /** @type {function(...*):?} */
        var _gf_sc_connect_from_time = (Module["_gf_sc_connect_from_time"] =
            createExportWrapper("gf_sc_connect_from_time"));
        /** @type {function(...*):?} */
        var _gf_opts_discard_changes = (Module["_gf_opts_discard_changes"] =
            createExportWrapper("gf_opts_discard_changes"));
        /** @type {function(...*):?} */
        var _gf_sys_clock = (Module["_gf_sys_clock"] = createExportWrapper("gf_sys_clock"));
        /** @type {function(...*):?} */
        var _gf_sc_disconnect = (Module["_gf_sc_disconnect"] =
            createExportWrapper("gf_sc_disconnect"));
        /** @type {function(...*):?} */
        var _gf_sc_play_from_time = (Module["_gf_sc_play_from_time"] =
            createExportWrapper("gf_sc_play_from_time"));
        /** @type {function(...*):?} */
        var _gf_sc_get_url = (Module["_gf_sc_get_url"] = createExportWrapper("gf_sc_get_url"));
        /** @type {function(...*):?} */
        var _gf_sc_select_service = (Module["_gf_sc_select_service"] =
            createExportWrapper("gf_sc_select_service"));
        /** @type {function(...*):?} */
        var _gf_sc_dump_scene = (Module["_gf_sc_dump_scene"] =
            createExportWrapper("gf_sc_dump_scene"));
        /** @type {function(...*):?} */
        var _gf_log_get_tools_levels = (Module["_gf_log_get_tools_levels"] =
            createExportWrapper("gf_log_get_tools_levels"));
        /** @type {function(...*):?} */
        var _gf_log_modify_tools_levels = (Module["_gf_log_modify_tools_levels"] =
            createExportWrapper("gf_log_modify_tools_levels"));
        /** @type {function(...*):?} */
        var _gf_sc_get_offscreen_buffer = (Module["_gf_sc_get_offscreen_buffer"] =
            createExportWrapper("gf_sc_get_offscreen_buffer"));
        /** @type {function(...*):?} */
        var _gf_sc_get_screen_buffer = (Module["_gf_sc_get_screen_buffer"] =
            createExportWrapper("gf_sc_get_screen_buffer"));
        /** @type {function(...*):?} */
        var _gf_img_png_enc = (Module["_gf_img_png_enc"] = createExportWrapper("gf_img_png_enc"));
        /** @type {function(...*):?} */
        var _gf_sc_release_screen_buffer = (Module["_gf_sc_release_screen_buffer"] =
            createExportWrapper("gf_sc_release_screen_buffer"));
        /** @type {function(...*):?} */
        var _gf_sc_get_main_pid = (Module["_gf_sc_get_main_pid"] =
            createExportWrapper("gf_sc_get_main_pid"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_info_str = (Module["_gf_filter_pid_get_info_str"] =
            createExportWrapper("gf_filter_pid_get_info_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_property = (Module["_gf_filter_pid_get_property"] =
            createExportWrapper("gf_filter_pid_get_property"));
        /** @type {function(...*):?} */
        var _gf_file_basename = (Module["_gf_file_basename"] =
            createExportWrapper("gf_file_basename"));
        /** @type {function(...*):?} */
        var _gf_sys_localized = (Module["_gf_sys_localized"] =
            createExportWrapper("gf_sys_localized"));
        /** @type {function(...*):?} */
        var _gf_modules_load_by_name = (Module["_gf_modules_load_by_name"] =
            createExportWrapper("gf_modules_load_by_name"));
        /** @type {function(...*):?} */
        var _gf_modules_close_interface = (Module["_gf_modules_close_interface"] =
            createExportWrapper("gf_modules_close_interface"));
        /** @type {function(...*):?} */
        var _gf_modules_count = (Module["_gf_modules_count"] =
            createExportWrapper("gf_modules_count"));
        /** @type {function(...*):?} */
        var _gf_modules_get_file_name = (Module["_gf_modules_get_file_name"] = createExportWrapper(
            "gf_modules_get_file_name"
        ));
        /** @type {function(...*):?} */
        var _gf_opts_get_key_name = (Module["_gf_opts_get_key_name"] =
            createExportWrapper("gf_opts_get_key_name"));
        /** @type {function(...*):?} */
        var _gf_sys_print_core_help = (Module["_gf_sys_print_core_help"] =
            createExportWrapper("gf_sys_print_core_help"));
        /** @type {function(...*):?} */
        var _gf_opts_get_filename = (Module["_gf_opts_get_filename"] =
            createExportWrapper("gf_opts_get_filename"));
        /** @type {function(...*):?} */
        var _gf_cfg_force_new = (Module["_gf_cfg_force_new"] =
            createExportWrapper("gf_cfg_force_new"));
        /** @type {function(...*):?} */
        var _gf_cfg_get_key = (Module["_gf_cfg_get_key"] = createExportWrapper("gf_cfg_get_key"));
        /** @type {function(...*):?} */
        var _gf_cfg_del = (Module["_gf_cfg_del"] = createExportWrapper("gf_cfg_del"));
        /** @type {function(...*):?} */
        var _gf_cfg_del_section = (Module["_gf_cfg_del_section"] =
            createExportWrapper("gf_cfg_del_section"));
        /** @type {function(...*):?} */
        var _gf_cfg_set_key = (Module["_gf_cfg_set_key"] = createExportWrapper("gf_cfg_set_key"));
        /** @type {function(...*):?} */
        var _gf_fs_new = (Module["_gf_fs_new"] = createExportWrapper("gf_fs_new"));
        /** @type {function(...*):?} */
        var _gf_fs_filters_registers_count = (Module["_gf_fs_filters_registers_count"] =
            createExportWrapper("gf_fs_filters_registers_count"));
        /** @type {function(...*):?} */
        var _gf_fs_get_filter_register = (Module["_gf_fs_get_filter_register"] =
            createExportWrapper("gf_fs_get_filter_register"));
        /** @type {function(...*):?} */
        var _gf_sys_word_match = (Module["_gf_sys_word_match"] =
            createExportWrapper("gf_sys_word_match"));
        /** @type {function(...*):?} */
        var _gf_sys_get_options = (Module["_gf_sys_get_options"] =
            createExportWrapper("gf_sys_get_options"));
        /** @type {function(...*):?} */
        var _gf_props_get_description = (Module["_gf_props_get_description"] = createExportWrapper(
            "gf_props_get_description"
        ));
        /** @type {function(...*):?} */
        var _gf_fs_enum_unmapped_options = (Module["_gf_fs_enum_unmapped_options"] =
            createExportWrapper("gf_fs_enum_unmapped_options"));
        /** @type {function(...*):?} */
        var _gf_cfg_new = (Module["_gf_cfg_new"] = createExportWrapper("gf_cfg_new"));
        /** @type {function(...*):?} */
        var _gf_cfg_get_key_count = (Module["_gf_cfg_get_key_count"] =
            createExportWrapper("gf_cfg_get_key_count"));
        /** @type {function(...*):?} */
        var _gf_cfg_get_key_name = (Module["_gf_cfg_get_key_name"] =
            createExportWrapper("gf_cfg_get_key_name"));
        /** @type {function(...*):?} */
        var _gf_filter_get_register = (Module["_gf_filter_get_register"] =
            createExportWrapper("gf_filter_get_register"));
        /** @type {function(...*):?} */
        var _gf_file_ext_start = (Module["_gf_file_ext_start"] =
            createExportWrapper("gf_file_ext_start"));
        /** @type {function(...*):?} */
        var _gf_log_set_tools_levels = (Module["_gf_log_set_tools_levels"] =
            createExportWrapper("gf_log_set_tools_levels"));
        /** @type {function(...*):?} */
        var _gf_opts_default_shared_directory = (Module["_gf_opts_default_shared_directory"] =
            createExportWrapper("gf_opts_default_shared_directory"));
        /** @type {function(...*):?} */
        var _my_str_lwr = (Module["_my_str_lwr"] = createExportWrapper("my_str_lwr"));
        /** @type {function(...*):?} */
        var _gf_filter_get_description = (Module["_gf_filter_get_description"] =
            createExportWrapper("gf_filter_get_description"));
        /** @type {function(...*):?} */
        var _gf_filter_get_help = (Module["_gf_filter_get_help"] =
            createExportWrapper("gf_filter_get_help"));
        /** @type {function(...*):?} */
        var _gf_fgets = (Module["_gf_fgets"] = createExportWrapper("gf_fgets"));
        /** @type {function(...*):?} */
        var _gf_filter_get_version = (Module["_gf_filter_get_version"] =
            createExportWrapper("gf_filter_get_version"));
        /** @type {function(...*):?} */
        var _gf_filter_get_author = (Module["_gf_filter_get_author"] =
            createExportWrapper("gf_filter_get_author"));
        /** @type {function(...*):?} */
        var _gf_filter_get_args = (Module["_gf_filter_get_args"] =
            createExportWrapper("gf_filter_get_args"));
        /** @type {function(...*):?} */
        var _gf_filter_get_caps = (Module["_gf_filter_get_caps"] =
            createExportWrapper("gf_filter_get_caps"));
        /** @type {function(...*):?} */
        var _gf_filter_get_name = (Module["_gf_filter_get_name"] =
            createExportWrapper("gf_filter_get_name"));
        /** @type {function(...*):?} */
        var _gf_props_get_type_name = (Module["_gf_props_get_type_name"] =
            createExportWrapper("gf_props_get_type_name"));
        /** @type {function(...*):?} */
        var _gf_props_get_type_desc = (Module["_gf_props_get_type_desc"] =
            createExportWrapper("gf_props_get_type_desc"));
        /** @type {function(...*):?} */
        var _gf_4cc_to_str = (Module["_gf_4cc_to_str"] = createExportWrapper("gf_4cc_to_str"));
        /** @type {function(...*):?} */
        var _gf_strnistr = (Module["_gf_strnistr"] = createExportWrapper("gf_strnistr"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_all_names = (Module["_gf_pixel_fmt_all_names"] =
            createExportWrapper("gf_pixel_fmt_all_names"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_all_shortnames = (Module["_gf_pixel_fmt_all_shortnames"] =
            createExportWrapper("gf_pixel_fmt_all_shortnames"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_all_names = (Module["_gf_audio_fmt_all_names"] =
            createExportWrapper("gf_audio_fmt_all_names"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_all_shortnames = (Module["_gf_audio_fmt_all_shortnames"] =
            createExportWrapper("gf_audio_fmt_all_shortnames"));
        /** @type {function(...*):?} */
        var _gf_props_type_is_enum = (Module["_gf_props_type_is_enum"] =
            createExportWrapper("gf_props_type_is_enum"));
        /** @type {function(...*):?} */
        var _gf_props_enum_all_names = (Module["_gf_props_enum_all_names"] =
            createExportWrapper("gf_props_enum_all_names"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_enum = (Module["_gf_pixel_fmt_enum"] =
            createExportWrapper("gf_pixel_fmt_enum"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_to_qt_type = (Module["_gf_pixel_fmt_to_qt_type"] =
            createExportWrapper("gf_pixel_fmt_to_qt_type"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_enum = (Module["_gf_audio_fmt_enum"] =
            createExportWrapper("gf_audio_fmt_enum"));
        /** @type {function(...*):?} */
        var _gf_stream_types_enum = (Module["_gf_stream_types_enum"] =
            createExportWrapper("gf_stream_types_enum"));
        /** @type {function(...*):?} */
        var _gf_codecid_enum = (Module["_gf_codecid_enum"] =
            createExportWrapper("gf_codecid_enum"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_cicp_enum = (Module["_gf_audio_fmt_cicp_enum"] =
            createExportWrapper("gf_audio_fmt_cicp_enum"));
        /** @type {function(...*):?} */
        var _gf_cicp_color_primaries_name = (Module["_gf_cicp_color_primaries_name"] =
            createExportWrapper("gf_cicp_color_primaries_name"));
        /** @type {function(...*):?} */
        var _gf_cicp_color_transfer_name = (Module["_gf_cicp_color_transfer_name"] =
            createExportWrapper("gf_cicp_color_transfer_name"));
        /** @type {function(...*):?} */
        var _gf_cicp_color_matrix_name = (Module["_gf_cicp_color_matrix_name"] =
            createExportWrapper("gf_cicp_color_matrix_name"));
        /** @type {function(...*):?} */
        var _gf_color_enum = (Module["_gf_color_enum"] = createExportWrapper("gf_color_enum"));
        /** @type {function(...*):?} */
        var _gf_list_find = (Module["_gf_list_find"] = createExportWrapper("gf_list_find"));
        /** @type {function(...*):?} */
        var _gf_codecid_type = (Module["_gf_codecid_type"] =
            createExportWrapper("gf_codecid_type"));
        /** @type {function(...*):?} */
        var _gf_codecid_alt = (Module["_gf_codecid_alt"] = createExportWrapper("gf_codecid_alt"));
        /** @type {function(...*):?} */
        var _gf_fs_check_filter_register_cap = (Module["_gf_fs_check_filter_register_cap"] =
            createExportWrapper("gf_fs_check_filter_register_cap"));
        /** @type {function(...*):?} */
        var _gf_codecid_mime = (Module["_gf_codecid_mime"] =
            createExportWrapper("gf_codecid_mime"));
        /** @type {function(...*):?} */
        var _gf_codecid_4cc_type = (Module["_gf_codecid_4cc_type"] =
            createExportWrapper("gf_codecid_4cc_type"));
        /** @type {function(...*):?} */
        var _gf_list_rem = (Module["_gf_list_rem"] = createExportWrapper("gf_list_rem"));
        /** @type {function(...*):?} */
        var _gf_list_enum = (Module["_gf_list_enum"] = createExportWrapper("gf_list_enum"));
        /** @type {function(...*):?} */
        var _gf_cfg_discard_changes = (Module["_gf_cfg_discard_changes"] =
            createExportWrapper("gf_cfg_discard_changes"));
        /** @type {function(...*):?} */
        var _gf_crc_32 = (Module["_gf_crc_32"] = createExportWrapper("gf_crc_32"));
        /** @type {function(...*):?} */
        var _gf_props_4cc_get_name = (Module["_gf_props_4cc_get_name"] =
            createExportWrapper("gf_props_4cc_get_name"));
        /** @type {function(...*):?} */
        var _gf_props_dump_val = (Module["_gf_props_dump_val"] =
            createExportWrapper("gf_props_dump_val"));
        /** @type {function(...*):?} */
        var _memcpy = createExportWrapper("memcpy");
        /** @type {function(...*):?} */
        var _gf_parse_frac = (Module["_gf_parse_frac"] = createExportWrapper("gf_parse_frac"));
        /** @type {function(...*):?} */
        var _gf_file_load_data = (Module["_gf_file_load_data"] =
            createExportWrapper("gf_file_load_data"));
        /** @type {function(...*):?} */
        var _gf_itags_get_type = (Module["_gf_itags_get_type"] =
            createExportWrapper("gf_itags_get_type"));
        /** @type {function(...*):?} */
        var _gf_itags_get_name = (Module["_gf_itags_get_name"] =
            createExportWrapper("gf_itags_get_name"));
        /** @type {function(...*):?} */
        var _gf_itags_get_itag = (Module["_gf_itags_get_itag"] =
            createExportWrapper("gf_itags_get_itag"));
        /** @type {function(...*):?} */
        var _gf_itags_get_alt_name = (Module["_gf_itags_get_alt_name"] =
            createExportWrapper("gf_itags_get_alt_name"));
        /** @type {function(...*):?} */
        var _gf_parse_lfrac = (Module["_gf_parse_lfrac"] = createExportWrapper("gf_parse_lfrac"));
        /** @type {function(...*):?} */
        var _gf_isom_probe_file = (Module["_gf_isom_probe_file"] =
            createExportWrapper("gf_isom_probe_file"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_count = (Module["_gf_isom_get_track_count"] =
            createExportWrapper("gf_isom_get_track_count"));
        /** @type {function(...*):?} */
        var _gf_isom_set_pl_indication = (Module["_gf_isom_set_pl_indication"] =
            createExportWrapper("gf_isom_set_pl_indication"));
        /** @type {function(...*):?} */
        var _gf_isom_get_media_type = (Module["_gf_isom_get_media_type"] =
            createExportWrapper("gf_isom_get_media_type"));
        /** @type {function(...*):?} */
        var _gf_isom_get_media_subtype = (Module["_gf_isom_get_media_subtype"] =
            createExportWrapper("gf_isom_get_media_subtype"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_track_from_root_od = (Module["_gf_isom_remove_track_from_root_od"] =
            createExportWrapper("gf_isom_remove_track_from_root_od"));
        /** @type {function(...*):?} */
        var _gf_isom_get_esd = (Module["_gf_isom_get_esd"] =
            createExportWrapper("gf_isom_get_esd"));
        /** @type {function(...*):?} */
        var _gf_isom_get_pl_indication = (Module["_gf_isom_get_pl_indication"] =
            createExportWrapper("gf_isom_get_pl_indication"));
        /** @type {function(...*):?} */
        var _gf_m4v_get_config = (Module["_gf_m4v_get_config"] =
            createExportWrapper("gf_m4v_get_config"));
        /** @type {function(...*):?} */
        var _gf_m4a_get_config = (Module["_gf_m4a_get_config"] =
            createExportWrapper("gf_m4a_get_config"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_del = (Module["_gf_odf_desc_del"] =
            createExportWrapper("gf_odf_desc_del"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_track = (Module["_gf_isom_remove_track"] =
            createExportWrapper("gf_isom_remove_track"));
        /** @type {function(...*):?} */
        var _gf_isom_open = (Module["_gf_isom_open"] = createExportWrapper("gf_isom_open"));
        /** @type {function(...*):?} */
        var _gf_isom_open_segment = (Module["_gf_isom_open_segment"] =
            createExportWrapper("gf_isom_open_segment"));
        /** @type {function(...*):?} */
        var _gf_isom_delete = (Module["_gf_isom_delete"] = createExportWrapper("gf_isom_delete"));
        /** @type {function(...*):?} */
        var _gf_isom_last_error = (Module["_gf_isom_last_error"] =
            createExportWrapper("gf_isom_last_error"));
        /** @type {function(...*):?} */
        var _gf_isom_open_progressive = (Module["_gf_isom_open_progressive"] = createExportWrapper(
            "gf_isom_open_progressive"
        ));
        /** @type {function(...*):?} */
        var _gf_media_import = (Module["_gf_media_import"] =
            createExportWrapper("gf_media_import"));
        /** @type {function(...*):?} */
        var _gf_file_delete = (Module["_gf_file_delete"] = createExportWrapper("gf_file_delete"));
        /** @type {function(...*):?} */
        var _gf_isom_freeze_order = (Module["_gf_isom_freeze_order"] =
            createExportWrapper("gf_isom_freeze_order"));
        /** @type {function(...*):?} */
        var _gf_isom_keep_utc_times = (Module["_gf_isom_keep_utc_times"] =
            createExportWrapper("gf_isom_keep_utc_times"));
        /** @type {function(...*):?} */
        var _gf_strlcpy = (Module["_gf_strlcpy"] = createExportWrapper("gf_strlcpy"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_id = (Module["_gf_isom_get_track_id"] =
            createExportWrapper("gf_isom_get_track_id"));
        /** @type {function(...*):?} */
        var _gf_media_export = (Module["_gf_media_export"] =
            createExportWrapper("gf_media_export"));
        /** @type {function(...*):?} */
        var _gf_isom_reset_switch_parameters = (Module["_gf_isom_reset_switch_parameters"] =
            createExportWrapper("gf_isom_reset_switch_parameters"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_root_od = (Module["_gf_isom_remove_root_od"] =
            createExportWrapper("gf_isom_remove_root_od"));
        /** @type {function(...*):?} */
        var _gf_isom_get_timescale = (Module["_gf_isom_get_timescale"] =
            createExportWrapper("gf_isom_get_timescale"));
        /** @type {function(...*):?} */
        var _gf_isom_set_timescale = (Module["_gf_isom_set_timescale"] =
            createExportWrapper("gf_isom_set_timescale"));
        /** @type {function(...*):?} */
        var _gf_isom_is_inplace_rewrite = (Module["_gf_isom_is_inplace_rewrite"] =
            createExportWrapper("gf_isom_is_inplace_rewrite"));
        /** @type {function(...*):?} */
        var _gf_media_make_isma = (Module["_gf_media_make_isma"] =
            createExportWrapper("gf_media_make_isma"));
        /** @type {function(...*):?} */
        var _gf_media_make_3gpp = (Module["_gf_media_make_3gpp"] =
            createExportWrapper("gf_media_make_3gpp"));
        /** @type {function(...*):?} */
        var _gf_media_make_psp = (Module["_gf_media_make_psp"] =
            createExportWrapper("gf_media_make_psp"));
        /** @type {function(...*):?} */
        var _gf_media_check_qt_prores = (Module["_gf_media_check_qt_prores"] = createExportWrapper(
            "gf_media_check_qt_prores"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_set_copyright = (Module["_gf_isom_set_copyright"] =
            createExportWrapper("gf_isom_set_copyright"));
        /** @type {function(...*):?} */
        var _gf_media_import_chapters = (Module["_gf_media_import_chapters"] = createExportWrapper(
            "gf_media_import_chapters"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_set_brand_info = (Module["_gf_isom_set_brand_info"] =
            createExportWrapper("gf_isom_set_brand_info"));
        /** @type {function(...*):?} */
        var _gf_isom_modify_alternate_brand = (Module["_gf_isom_modify_alternate_brand"] =
            createExportWrapper("gf_isom_modify_alternate_brand"));
        /** @type {function(...*):?} */
        var _gf_isom_apply_box_patch = (Module["_gf_isom_apply_box_patch"] =
            createExportWrapper("gf_isom_apply_box_patch"));
        /** @type {function(...*):?} */
        var _gf_crypt_fragment = (Module["_gf_crypt_fragment"] =
            createExportWrapper("gf_crypt_fragment"));
        /** @type {function(...*):?} */
        var _gf_crypt_file = (Module["_gf_crypt_file"] = createExportWrapper("gf_crypt_file"));
        /** @type {function(...*):?} */
        var _gf_decrypt_fragment = (Module["_gf_decrypt_fragment"] =
            createExportWrapper("gf_decrypt_fragment"));
        /** @type {function(...*):?} */
        var _gf_decrypt_file = (Module["_gf_decrypt_file"] =
            createExportWrapper("gf_decrypt_file"));
        /** @type {function(...*):?} */
        var _gf_isom_get_filename = (Module["_gf_isom_get_filename"] =
            createExportWrapper("gf_isom_get_filename"));
        /** @type {function(...*):?} */
        var _gf_file_move = (Module["_gf_file_move"] = createExportWrapper("gf_file_move"));
        /** @type {function(...*):?} */
        var _gf_media_fragment_file = (Module["_gf_media_fragment_file"] =
            createExportWrapper("gf_media_fragment_file"));
        /** @type {function(...*):?} */
        var _gf_isom_force_64bit_chunk_offset = (Module["_gf_isom_force_64bit_chunk_offset"] =
            createExportWrapper("gf_isom_force_64bit_chunk_offset"));
        /** @type {function(...*):?} */
        var _gf_isom_enable_compression = (Module["_gf_isom_enable_compression"] =
            createExportWrapper("gf_isom_enable_compression"));
        /** @type {function(...*):?} */
        var _gf_isom_disable_inplace_rewrite = (Module["_gf_isom_disable_inplace_rewrite"] =
            createExportWrapper("gf_isom_disable_inplace_rewrite"));
        /** @type {function(...*):?} */
        var _gf_isom_set_inplace_padding = (Module["_gf_isom_set_inplace_padding"] =
            createExportWrapper("gf_isom_set_inplace_padding"));
        /** @type {function(...*):?} */
        var _gf_isom_set_final_name = (Module["_gf_isom_set_final_name"] =
            createExportWrapper("gf_isom_set_final_name"));
        /** @type {function(...*):?} */
        var _gf_isom_set_storage_mode = (Module["_gf_isom_set_storage_mode"] = createExportWrapper(
            "gf_isom_set_storage_mode"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_make_interleave = (Module["_gf_isom_make_interleave"] =
            createExportWrapper("gf_isom_make_interleave"));
        /** @type {function(...*):?} */
        var _gf_sys_is_quiet = (Module["_gf_sys_is_quiet"] =
            createExportWrapper("gf_sys_is_quiet"));
        /** @type {function(...*):?} */
        var _gf_isom_close = (Module["_gf_isom_close"] = createExportWrapper("gf_isom_close"));
        /** @type {function(...*):?} */
        var _gf_bs_from_file = (Module["_gf_bs_from_file"] =
            createExportWrapper("gf_bs_from_file"));
        /** @type {function(...*):?} */
        var _gf_bs_available = (Module["_gf_bs_available"] =
            createExportWrapper("gf_bs_available"));
        /** @type {function(...*):?} */
        var _gf_bs_read_u32 = (Module["_gf_bs_read_u32"] = createExportWrapper("gf_bs_read_u32"));
        /** @type {function(...*):?} */
        var _gf_bs_read_u64 = (Module["_gf_bs_read_u64"] = createExportWrapper("gf_bs_read_u64"));
        /** @type {function(...*):?} */
        var _gf_bs_skip_bytes = (Module["_gf_bs_skip_bytes"] =
            createExportWrapper("gf_bs_skip_bytes"));
        /** @type {function(...*):?} */
        var _gf_bs_del = (Module["_gf_bs_del"] = createExportWrapper("gf_bs_del"));
        /** @type {function(...*):?} */
        var _gf_bs_get_size = (Module["_gf_bs_get_size"] = createExportWrapper("gf_bs_get_size"));
        /** @type {function(...*):?} */
        var _gf_bs_write_u32 = (Module["_gf_bs_write_u32"] =
            createExportWrapper("gf_bs_write_u32"));
        /** @type {function(...*):?} */
        var _gf_bs_read_data = (Module["_gf_bs_read_data"] =
            createExportWrapper("gf_bs_read_data"));
        /** @type {function(...*):?} */
        var _gf_bs_write_data = (Module["_gf_bs_write_data"] =
            createExportWrapper("gf_bs_write_data"));
        /** @type {function(...*):?} */
        var _gf_gz_compress_payload = (Module["_gf_gz_compress_payload"] =
            createExportWrapper("gf_gz_compress_payload"));
        /** @type {function(...*):?} */
        var _gf_bs_get_position = (Module["_gf_bs_get_position"] =
            createExportWrapper("gf_bs_get_position"));
        /** @type {function(...*):?} */
        var _gf_isom_get_duration = (Module["_gf_isom_get_duration"] =
            createExportWrapper("gf_isom_get_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_count = (Module["_gf_isom_get_sample_count"] = createExportWrapper(
            "gf_isom_get_sample_count"
        ));
        /** @type {function(...*):?} */
        var _gf_fs_print_non_connected = (Module["_gf_fs_print_non_connected"] =
            createExportWrapper("gf_fs_print_non_connected"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_new = (Module["_gf_xml_dom_new"] = createExportWrapper("gf_xml_dom_new"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_parse = (Module["_gf_xml_dom_parse"] =
            createExportWrapper("gf_xml_dom_parse"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_del = (Module["_gf_xml_dom_del"] = createExportWrapper("gf_xml_dom_del"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_get_root_idx = (Module["_gf_xml_dom_get_root_idx"] =
            createExportWrapper("gf_xml_dom_get_root_idx"));
        /** @type {function(...*):?} */
        var _gf_xml_parse_bit_sequence = (Module["_gf_xml_parse_bit_sequence"] =
            createExportWrapper("gf_xml_parse_bit_sequence"));
        /** @type {function(...*):?} */
        var _gf_media_get_file_hash = (Module["_gf_media_get_file_hash"] =
            createExportWrapper("gf_media_get_file_hash"));
        /** @type {function(...*):?} */
        var _gf_isom_is_video_handler_type = (Module["_gf_isom_is_video_handler_type"] =
            createExportWrapper("gf_isom_is_video_handler_type"));
        /** @type {function(...*):?} */
        var _gf_mpd_new = (Module["_gf_mpd_new"] = createExportWrapper("gf_mpd_new"));
        /** @type {function(...*):?} */
        var _gf_m3u8_to_mpd = (Module["_gf_m3u8_to_mpd"] = createExportWrapper("gf_m3u8_to_mpd"));
        /** @type {function(...*):?} */
        var _gf_mpd_smooth_to_mpd = (Module["_gf_mpd_smooth_to_mpd"] =
            createExportWrapper("gf_mpd_smooth_to_mpd"));
        /** @type {function(...*):?} */
        var _gf_mpd_write_file = (Module["_gf_mpd_write_file"] =
            createExportWrapper("gf_mpd_write_file"));
        /** @type {function(...*):?} */
        var _gf_mpd_del = (Module["_gf_mpd_del"] = createExportWrapper("gf_mpd_del"));
        /** @type {function(...*):?} */
        var _gf_url_get_resource_name = (Module["_gf_url_get_resource_name"] = createExportWrapper(
            "gf_url_get_resource_name"
        ));
        /** @type {function(...*):?} */
        var _gf_rand = (Module["_gf_rand"] = createExportWrapper("gf_rand"));
        /** @type {function(...*):?} */
        var _gf_get_default_cache_directory = (Module["_gf_get_default_cache_directory"] =
            createExportWrapper("gf_get_default_cache_directory"));
        /** @type {function(...*):?} */
        var _gf_dasher_new = (Module["_gf_dasher_new"] = createExportWrapper("gf_dasher_new"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_info = (Module["_gf_dasher_set_info"] =
            createExportWrapper("gf_dasher_set_info"));
        /** @type {function(...*):?} */
        var _gf_dasher_del = (Module["_gf_dasher_del"] = createExportWrapper("gf_dasher_del"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_start_date = (Module["_gf_dasher_set_start_date"] = createExportWrapper(
            "gf_dasher_set_start_date"
        ));
        /** @type {function(...*):?} */
        var _gf_dasher_set_location = (Module["_gf_dasher_set_location"] =
            createExportWrapper("gf_dasher_set_location"));
        /** @type {function(...*):?} */
        var _gf_dasher_add_base_url = (Module["_gf_dasher_add_base_url"] =
            createExportWrapper("gf_dasher_add_base_url"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_url_template = (Module["_gf_dasher_enable_url_template"] =
            createExportWrapper("gf_dasher_enable_url_template"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_segment_timeline = (Module["_gf_dasher_enable_segment_timeline"] =
            createExportWrapper("gf_dasher_enable_segment_timeline"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_single_segment = (Module["_gf_dasher_enable_single_segment"] =
            createExportWrapper("gf_dasher_enable_single_segment"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_single_file = (Module["_gf_dasher_enable_single_file"] =
            createExportWrapper("gf_dasher_enable_single_file"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_switch_mode = (Module["_gf_dasher_set_switch_mode"] =
            createExportWrapper("gf_dasher_set_switch_mode"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_durations = (Module["_gf_dasher_set_durations"] =
            createExportWrapper("gf_dasher_set_durations"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_rap_splitting = (Module["_gf_dasher_enable_rap_splitting"] =
            createExportWrapper("gf_dasher_enable_rap_splitting"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_segment_marker = (Module["_gf_dasher_set_segment_marker"] =
            createExportWrapper("gf_dasher_set_segment_marker"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_sidx = (Module["_gf_dasher_enable_sidx"] =
            createExportWrapper("gf_dasher_enable_sidx"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_dynamic_mode = (Module["_gf_dasher_set_dynamic_mode"] =
            createExportWrapper("gf_dasher_set_dynamic_mode"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_min_buffer = (Module["_gf_dasher_set_min_buffer"] = createExportWrapper(
            "gf_dasher_set_min_buffer"
        ));
        /** @type {function(...*):?} */
        var _gf_dasher_set_ast_offset = (Module["_gf_dasher_set_ast_offset"] = createExportWrapper(
            "gf_dasher_set_ast_offset"
        ));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_memory_fragmenting = (Module["_gf_dasher_enable_memory_fragmenting"] =
            createExportWrapper("gf_dasher_enable_memory_fragmenting"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_initial_isobmf = (Module["_gf_dasher_set_initial_isobmf"] =
            createExportWrapper("gf_dasher_set_initial_isobmf"));
        /** @type {function(...*):?} */
        var _gf_dasher_configure_isobmf_default = (Module["_gf_dasher_configure_isobmf_default"] =
            createExportWrapper("gf_dasher_configure_isobmf_default"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_utc_ref = (Module["_gf_dasher_enable_utc_ref"] = createExportWrapper(
            "gf_dasher_enable_utc_ref"
        ));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_real_time = (Module["_gf_dasher_enable_real_time"] =
            createExportWrapper("gf_dasher_enable_real_time"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_content_protection_location_mode = (Module[
            "_gf_dasher_set_content_protection_location_mode"
        ] = createExportWrapper("gf_dasher_set_content_protection_location_mode"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_profile_extension = (Module["_gf_dasher_set_profile_extension"] =
            createExportWrapper("gf_dasher_set_profile_extension"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_cached_inputs = (Module["_gf_dasher_enable_cached_inputs"] =
            createExportWrapper("gf_dasher_enable_cached_inputs"));
        /** @type {function(...*):?} */
        var _gf_dasher_enable_loop_inputs = (Module["_gf_dasher_enable_loop_inputs"] =
            createExportWrapper("gf_dasher_enable_loop_inputs"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_split_mode = (Module["_gf_dasher_set_split_mode"] = createExportWrapper(
            "gf_dasher_set_split_mode"
        ));
        /** @type {function(...*):?} */
        var _gf_dasher_set_last_segment_merge = (Module["_gf_dasher_set_last_segment_merge"] =
            createExportWrapper("gf_dasher_set_last_segment_merge"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_hls_clock = (Module["_gf_dasher_set_hls_clock"] =
            createExportWrapper("gf_dasher_set_hls_clock"));
        /** @type {function(...*):?} */
        var _gf_dasher_set_cues = (Module["_gf_dasher_set_cues"] =
            createExportWrapper("gf_dasher_set_cues"));
        /** @type {function(...*):?} */
        var _gf_dasher_print_session_info = (Module["_gf_dasher_print_session_info"] =
            createExportWrapper("gf_dasher_print_session_info"));
        /** @type {function(...*):?} */
        var _gf_dasher_keep_source_utc = (Module["_gf_dasher_keep_source_utc"] =
            createExportWrapper("gf_dasher_keep_source_utc"));
        /** @type {function(...*):?} */
        var _gf_dasher_add_input = (Module["_gf_dasher_add_input"] =
            createExportWrapper("gf_dasher_add_input"));
        /** @type {function(...*):?} */
        var _gf_dasher_process = (Module["_gf_dasher_process"] =
            createExportWrapper("gf_dasher_process"));
        /** @type {function(...*):?} */
        var _gf_dasher_next_update_time = (Module["_gf_dasher_next_update_time"] =
            createExportWrapper("gf_dasher_next_update_time"));
        /** @type {function(...*):?} */
        var _gf_sys_is_test_mode = (Module["_gf_sys_is_test_mode"] =
            createExportWrapper("gf_sys_is_test_mode"));
        /** @type {function(...*):?} */
        var _gf_isom_get_root_od = (Module["_gf_isom_get_root_od"] =
            createExportWrapper("gf_isom_get_root_od"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_write = (Module["_gf_odf_desc_write"] =
            createExportWrapper("gf_odf_desc_write"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_by_id = (Module["_gf_isom_get_track_by_id"] =
            createExportWrapper("gf_isom_get_track_by_id"));
        /** @type {function(...*):?} */
        var _gf_isom_set_meta_type = (Module["_gf_isom_set_meta_type"] =
            createExportWrapper("gf_isom_set_meta_type"));
        /** @type {function(...*):?} */
        var _gf_isom_get_meta_item_by_id = (Module["_gf_isom_get_meta_item_by_id"] =
            createExportWrapper("gf_isom_get_meta_item_by_id"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_meta_item = (Module["_gf_isom_remove_meta_item"] = createExportWrapper(
            "gf_isom_remove_meta_item"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_add_meta_item = (Module["_gf_isom_add_meta_item"] =
            createExportWrapper("gf_isom_add_meta_item"));
        /** @type {function(...*):?} */
        var _gf_isom_meta_add_item_ref = (Module["_gf_isom_meta_add_item_ref"] =
            createExportWrapper("gf_isom_meta_add_item_ref"));
        /** @type {function(...*):?} */
        var _gf_isom_get_meta_type = (Module["_gf_isom_get_meta_type"] =
            createExportWrapper("gf_isom_get_meta_type"));
        /** @type {function(...*):?} */
        var _gf_isom_meta_get_next_item_id = (Module["_gf_isom_meta_get_next_item_id"] =
            createExportWrapper("gf_isom_meta_get_next_item_id"));
        /** @type {function(...*):?} */
        var _gf_isom_iff_create_image_overlay_item = (Module[
            "_gf_isom_iff_create_image_overlay_item"
        ] = createExportWrapper("gf_isom_iff_create_image_overlay_item"));
        /** @type {function(...*):?} */
        var _gf_isom_iff_create_image_grid_item = (Module["_gf_isom_iff_create_image_grid_item"] =
            createExportWrapper("gf_isom_iff_create_image_grid_item"));
        /** @type {function(...*):?} */
        var _gf_isom_iff_create_image_identity_item = (Module[
            "_gf_isom_iff_create_image_identity_item"
        ] = createExportWrapper("gf_isom_iff_create_image_identity_item"));
        /** @type {function(...*):?} */
        var _gf_isom_set_meta_primary_item = (Module["_gf_isom_set_meta_primary_item"] =
            createExportWrapper("gf_isom_set_meta_primary_item"));
        /** @type {function(...*):?} */
        var _gf_isom_set_meta_xml = (Module["_gf_isom_set_meta_xml"] =
            createExportWrapper("gf_isom_set_meta_xml"));
        /** @type {function(...*):?} */
        var _gf_isom_get_meta_item_count = (Module["_gf_isom_get_meta_item_count"] =
            createExportWrapper("gf_isom_get_meta_item_count"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_meta_xml = (Module["_gf_isom_remove_meta_xml"] =
            createExportWrapper("gf_isom_remove_meta_xml"));
        /** @type {function(...*):?} */
        var _gf_isom_extract_meta_item = (Module["_gf_isom_extract_meta_item"] =
            createExportWrapper("gf_isom_extract_meta_item"));
        /** @type {function(...*):?} */
        var _gf_isom_has_meta_xml = (Module["_gf_isom_has_meta_xml"] =
            createExportWrapper("gf_isom_has_meta_xml"));
        /** @type {function(...*):?} */
        var _gf_isom_extract_meta_xml = (Module["_gf_isom_extract_meta_xml"] = createExportWrapper(
            "gf_isom_extract_meta_xml"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_disable_brand_rewrite = (Module["_gf_isom_disable_brand_rewrite"] =
            createExportWrapper("gf_isom_disable_brand_rewrite"));
        /** @type {function(...*):?} */
        var _gf_isom_iff_create_image_item_from_track = (Module[
            "_gf_isom_iff_create_image_item_from_track"
        ] = createExportWrapper("gf_isom_iff_create_image_item_from_track"));
        /** @type {function(...*):?} */
        var _gf_isom_meta_add_item_group = (Module["_gf_isom_meta_add_item_group"] =
            createExportWrapper("gf_isom_meta_add_item_group"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_switch_parameter = (Module["_gf_isom_set_track_switch_parameter"] =
            createExportWrapper("gf_isom_set_track_switch_parameter"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_switch_group_count = (Module[
            "_gf_isom_get_track_switch_group_count"
        ] = createExportWrapper("gf_isom_get_track_switch_group_count"));
        /** @type {function(...*):?} */
        var _gf_isom_reset_track_switch_parameter = (Module[
            "_gf_isom_reset_track_switch_parameter"
        ] = createExportWrapper("gf_isom_reset_track_switch_parameter"));
        /** @type {function(...*):?} */
        var _gf_isom_set_ipod_compatible = (Module["_gf_isom_set_ipod_compatible"] =
            createExportWrapper("gf_isom_set_ipod_compatible"));
        /** @type {function(...*):?} */
        var _gf_isom_get_reference_count = (Module["_gf_isom_get_reference_count"] =
            createExportWrapper("gf_isom_get_reference_count"));
        /** @type {function(...*):?} */
        var _gf_isom_get_reference = (Module["_gf_isom_get_reference"] =
            createExportWrapper("gf_isom_get_reference"));
        /** @type {function(...*):?} */
        var _gf_isom_set_media_type = (Module["_gf_isom_set_media_type"] =
            createExportWrapper("gf_isom_set_media_type"));
        /** @type {function(...*):?} */
        var _gf_isom_set_media_creation_time = (Module["_gf_isom_set_media_creation_time"] =
            createExportWrapper("gf_isom_set_media_creation_time"));
        /** @type {function(...*):?} */
        var _gf_isom_is_media_encrypted = (Module["_gf_isom_is_media_encrypted"] =
            createExportWrapper("gf_isom_is_media_encrypted"));
        /** @type {function(...*):?} */
        var _gf_isom_is_ismacryp_media = (Module["_gf_isom_is_ismacryp_media"] =
            createExportWrapper("gf_isom_is_ismacryp_media"));
        /** @type {function(...*):?} */
        var _gf_isom_change_ismacryp_protection = (Module["_gf_isom_change_ismacryp_protection"] =
            createExportWrapper("gf_isom_change_ismacryp_protection"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_track_kind = (Module["_gf_isom_remove_track_kind"] =
            createExportWrapper("gf_isom_remove_track_kind"));
        /** @type {function(...*):?} */
        var _gf_isom_add_track_kind = (Module["_gf_isom_add_track_kind"] =
            createExportWrapper("gf_isom_add_track_kind"));
        /** @type {function(...*):?} */
        var _gf_isom_set_media_language = (Module["_gf_isom_set_media_language"] =
            createExportWrapper("gf_isom_set_media_language"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_edits = (Module["_gf_isom_remove_edits"] =
            createExportWrapper("gf_isom_remove_edits"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_duration = (Module["_gf_isom_get_track_duration"] =
            createExportWrapper("gf_isom_get_track_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_get_edits_count = (Module["_gf_isom_get_edits_count"] =
            createExportWrapper("gf_isom_get_edits_count"));
        /** @type {function(...*):?} */
        var _gf_isom_append_edit = (Module["_gf_isom_append_edit"] =
            createExportWrapper("gf_isom_append_edit"));
        /** @type {function(...*):?} */
        var _gf_isom_get_media_timescale = (Module["_gf_isom_get_media_timescale"] =
            createExportWrapper("gf_isom_get_media_timescale"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_id = (Module["_gf_isom_set_track_id"] =
            createExportWrapper("gf_isom_set_track_id"));
        /** @type {function(...*):?} */
        var _gf_isom_set_clean_aperture = (Module["_gf_isom_set_clean_aperture"] =
            createExportWrapper("gf_isom_set_clean_aperture"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_matrix = (Module["_gf_isom_set_track_matrix"] = createExportWrapper(
            "gf_isom_set_track_matrix"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_set_handler_name = (Module["_gf_isom_set_handler_name"] = createExportWrapper(
            "gf_isom_set_handler_name"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_is_track_enabled = (Module["_gf_isom_is_track_enabled"] = createExportWrapper(
            "gf_isom_is_track_enabled"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_enabled = (Module["_gf_isom_set_track_enabled"] =
            createExportWrapper("gf_isom_set_track_enabled"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_reference = (Module["_gf_isom_set_track_reference"] =
            createExportWrapper("gf_isom_set_track_reference"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_track_reference = (Module["_gf_isom_remove_track_reference"] =
            createExportWrapper("gf_isom_remove_track_reference"));
        /** @type {function(...*):?} */
        var _gf_media_remove_non_rap = (Module["_gf_media_remove_non_rap"] =
            createExportWrapper("gf_media_remove_non_rap"));
        /** @type {function(...*):?} */
        var _gf_isom_set_creation_time = (Module["_gf_isom_set_creation_time"] =
            createExportWrapper("gf_isom_set_creation_time"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_creation_time = (Module["_gf_isom_set_track_creation_time"] =
            createExportWrapper("gf_isom_set_track_creation_time"));
        /** @type {function(...*):?} */
        var _gf_media_change_par = (Module["_gf_media_change_par"] =
            createExportWrapper("gf_media_change_par"));
        /** @type {function(...*):?} */
        var _gf_itags_find_by_name = (Module["_gf_itags_find_by_name"] =
            createExportWrapper("gf_itags_find_by_name"));
        /** @type {function(...*):?} */
        var _gf_media_isom_apply_qt_key = (Module["_gf_media_isom_apply_qt_key"] =
            createExportWrapper("gf_media_isom_apply_qt_key"));
        /** @type {function(...*):?} */
        var _gf_isom_apple_set_tag = (Module["_gf_isom_apple_set_tag"] =
            createExportWrapper("gf_isom_apple_set_tag"));
        /** @type {function(...*):?} */
        var _gf_isom_set_qt_key = (Module["_gf_isom_set_qt_key"] =
            createExportWrapper("gf_isom_set_qt_key"));
        /** @type {function(...*):?} */
        var _gf_isom_wma_set_tag = (Module["_gf_isom_wma_set_tag"] =
            createExportWrapper("gf_isom_wma_set_tag"));
        /** @type {function(...*):?} */
        var _gf_lang_get_count = (Module["_gf_lang_get_count"] =
            createExportWrapper("gf_lang_get_count"));
        /** @type {function(...*):?} */
        var _gf_lang_get_2cc = (Module["_gf_lang_get_2cc"] =
            createExportWrapper("gf_lang_get_2cc"));
        /** @type {function(...*):?} */
        var _gf_lang_get_name = (Module["_gf_lang_get_name"] =
            createExportWrapper("gf_lang_get_name"));
        /** @type {function(...*):?} */
        var _gf_lang_get_3cc = (Module["_gf_lang_get_3cc"] =
            createExportWrapper("gf_lang_get_3cc"));
        /** @type {function(...*):?} */
        var _gf_isom_apple_get_tag = (Module["_gf_isom_apple_get_tag"] =
            createExportWrapper("gf_isom_apple_get_tag"));
        /** @type {function(...*):?} */
        var _gf_sg_new = (Module["_gf_sg_new"] = createExportWrapper("gf_sg_new"));
        /** @type {function(...*):?} */
        var _gf_sm_new = (Module["_gf_sm_new"] = createExportWrapper("gf_sm_new"));
        /** @type {function(...*):?} */
        var _gf_sm_del = (Module["_gf_sm_del"] = createExportWrapper("gf_sm_del"));
        /** @type {function(...*):?} */
        var _gf_sg_del = (Module["_gf_sg_del"] = createExportWrapper("gf_sg_del"));
        /** @type {function(...*):?} */
        var _gf_isom_disable_odf_conversion = (Module["_gf_isom_disable_odf_conversion"] =
            createExportWrapper("gf_isom_disable_odf_conversion"));
        /** @type {function(...*):?} */
        var _gf_sm_load_init = (Module["_gf_sm_load_init"] =
            createExportWrapper("gf_sm_load_init"));
        /** @type {function(...*):?} */
        var _gf_sm_load_run = (Module["_gf_sm_load_run"] = createExportWrapper("gf_sm_load_run"));
        /** @type {function(...*):?} */
        var _gf_sm_load_done = (Module["_gf_sm_load_done"] =
            createExportWrapper("gf_sm_load_done"));
        /** @type {function(...*):?} */
        var _gf_sm_dump = (Module["_gf_sm_dump"] = createExportWrapper("gf_sm_dump"));
        /** @type {function(...*):?} */
        var _gf_sm_stats_new = (Module["_gf_sm_stats_new"] =
            createExportWrapper("gf_sm_stats_new"));
        /** @type {function(...*):?} */
        var _gf_sm_stats_for_scene = (Module["_gf_sm_stats_for_scene"] =
            createExportWrapper("gf_sm_stats_for_scene"));
        /** @type {function(...*):?} */
        var _gf_sm_stats_get = (Module["_gf_sm_stats_get"] =
            createExportWrapper("gf_sm_stats_get"));
        /** @type {function(...*):?} */
        var _gf_list_insert = (Module["_gf_list_insert"] = createExportWrapper("gf_list_insert"));
        /** @type {function(...*):?} */
        var _gf_sm_stats_for_command = (Module["_gf_sm_stats_for_command"] =
            createExportWrapper("gf_sm_stats_for_command"));
        /** @type {function(...*):?} */
        var _gf_sg_command_apply = (Module["_gf_sg_command_apply"] =
            createExportWrapper("gf_sg_command_apply"));
        /** @type {function(...*):?} */
        var _gf_sm_stats_for_graph = (Module["_gf_sm_stats_for_graph"] =
            createExportWrapper("gf_sm_stats_for_graph"));
        /** @type {function(...*):?} */
        var _gf_sm_stats_reset = (Module["_gf_sm_stats_reset"] =
            createExportWrapper("gf_sm_stats_reset"));
        /** @type {function(...*):?} */
        var _gf_sm_stats_del = (Module["_gf_sm_stats_del"] =
            createExportWrapper("gf_sm_stats_del"));
        /** @type {function(...*):?} */
        var _gf_node_x3d_type_by_class_name = (Module["_gf_node_x3d_type_by_class_name"] =
            createExportWrapper("gf_node_x3d_type_by_class_name"));
        /** @type {function(...*):?} */
        var _gf_node_mpeg4_type_by_class_name = (Module["_gf_node_mpeg4_type_by_class_name"] =
            createExportWrapper("gf_node_mpeg4_type_by_class_name"));
        /** @type {function(...*):?} */
        var _gf_node_new = (Module["_gf_node_new"] = createExportWrapper("gf_node_new"));
        /** @type {function(...*):?} */
        var _gf_node_register = (Module["_gf_node_register"] =
            createExportWrapper("gf_node_register"));
        /** @type {function(...*):?} */
        var _gf_node_get_class_name = (Module["_gf_node_get_class_name"] =
            createExportWrapper("gf_node_get_class_name"));
        /** @type {function(...*):?} */
        var _gf_node_unregister = (Module["_gf_node_unregister"] =
            createExportWrapper("gf_node_unregister"));
        /** @type {function(...*):?} */
        var _gf_node_get_field_count = (Module["_gf_node_get_field_count"] =
            createExportWrapper("gf_node_get_field_count"));
        /** @type {function(...*):?} */
        var _gf_node_get_field_by_name = (Module["_gf_node_get_field_by_name"] =
            createExportWrapper("gf_node_get_field_by_name"));
        /** @type {function(...*):?} */
        var _gf_node_in_table_by_tag = (Module["_gf_node_in_table_by_tag"] =
            createExportWrapper("gf_node_in_table_by_tag"));
        /** @type {function(...*):?} */
        var _gf_bifs_get_child_table = (Module["_gf_bifs_get_child_table"] =
            createExportWrapper("gf_bifs_get_child_table"));
        /** @type {function(...*):?} */
        var _gf_node_get_num_fields_in_mode = (Module["_gf_node_get_num_fields_in_mode"] =
            createExportWrapper("gf_node_get_num_fields_in_mode"));
        /** @type {function(...*):?} */
        var _gf_sg_script_get_field_index = (Module["_gf_sg_script_get_field_index"] =
            createExportWrapper("gf_sg_script_get_field_index"));
        /** @type {function(...*):?} */
        var _gf_node_get_tag = (Module["_gf_node_get_tag"] =
            createExportWrapper("gf_node_get_tag"));
        /** @type {function(...*):?} */
        var _gf_node_get_field = (Module["_gf_node_get_field"] =
            createExportWrapper("gf_node_get_field"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_get_event_type_name = (Module["_gf_sg_vrml_get_event_type_name"] =
            createExportWrapper("gf_sg_vrml_get_event_type_name"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_get_field_type_name = (Module["_gf_sg_vrml_get_field_type_name"] =
            createExportWrapper("gf_sg_vrml_get_field_type_name"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_is_sf_field = (Module["_gf_sg_vrml_is_sf_field"] =
            createExportWrapper("gf_sg_vrml_is_sf_field"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_get_sf_type = (Module["_gf_sg_vrml_get_sf_type"] =
            createExportWrapper("gf_sg_vrml_get_sf_type"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_mf_get_item = (Module["_gf_sg_vrml_mf_get_item"] =
            createExportWrapper("gf_sg_vrml_mf_get_item"));
        /** @type {function(...*):?} */
        var _gf_bifs_get_aq_info = (Module["_gf_bifs_get_aq_info"] =
            createExportWrapper("gf_bifs_get_aq_info"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_field_pointer_new = (Module["_gf_sg_vrml_field_pointer_new"] =
            createExportWrapper("gf_sg_vrml_field_pointer_new"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_field_pointer_del = (Module["_gf_sg_vrml_field_pointer_del"] =
            createExportWrapper("gf_sg_vrml_field_pointer_del"));
        /** @type {function(...*):?} */
        var _gf_isom_get_num_supported_boxes = (Module["_gf_isom_get_num_supported_boxes"] =
            createExportWrapper("gf_isom_get_num_supported_boxes"));
        /** @type {function(...*):?} */
        var _gf_isom_dump_supported_box = (Module["_gf_isom_dump_supported_box"] =
            createExportWrapper("gf_isom_dump_supported_box"));
        /** @type {function(...*):?} */
        var _gf_isom_get_supported_box_type = (Module["_gf_isom_get_supported_box_type"] =
            createExportWrapper("gf_isom_get_supported_box_type"));
        /** @type {function(...*):?} */
        var _gf_isom_box_new = (Module["_gf_isom_box_new"] =
            createExportWrapper("gf_isom_box_new"));
        /** @type {function(...*):?} */
        var _gf_isom_clone_box = (Module["_gf_isom_clone_box"] =
            createExportWrapper("gf_isom_clone_box"));
        /** @type {function(...*):?} */
        var _gf_isom_box_del = (Module["_gf_isom_box_del"] =
            createExportWrapper("gf_isom_box_del"));
        /** @type {function(...*):?} */
        var _gf_isom_is_fragmented = (Module["_gf_isom_is_fragmented"] =
            createExportWrapper("gf_isom_is_fragmented"));
        /** @type {function(...*):?} */
        var _gf_isom_get_cts_to_dts_shift = (Module["_gf_isom_get_cts_to_dts_shift"] =
            createExportWrapper("gf_isom_get_cts_to_dts_shift"));
        /** @type {function(...*):?} */
        var _gf_isom_has_time_offset = (Module["_gf_isom_has_time_offset"] =
            createExportWrapper("gf_isom_has_time_offset"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_info = (Module["_gf_isom_get_sample_info"] =
            createExportWrapper("gf_isom_get_sample_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_flags = (Module["_gf_isom_get_sample_flags"] = createExportWrapper(
            "gf_isom_get_sample_flags"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_rap_roll_info = (Module["_gf_isom_get_sample_rap_roll_info"] =
            createExportWrapper("gf_isom_get_sample_rap_roll_info"));
        /** @type {function(...*):?} */
        var _gf_isom_sample_del = (Module["_gf_isom_sample_del"] =
            createExportWrapper("gf_isom_sample_del"));
        /** @type {function(...*):?} */
        var _gf_isom_sample_is_fragment_start = (Module["_gf_isom_sample_is_fragment_start"] =
            createExportWrapper("gf_isom_sample_is_fragment_start"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_get_line = (Module["_gf_xml_dom_get_line"] =
            createExportWrapper("gf_xml_dom_get_line"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_get_error = (Module["_gf_xml_dom_get_error"] =
            createExportWrapper("gf_xml_dom_get_error"));
        /** @type {function(...*):?} */
        var _gf_av1_init_state = (Module["_gf_av1_init_state"] =
            createExportWrapper("gf_av1_init_state"));
        /** @type {function(...*):?} */
        var _gf_isom_av1_config_get = (Module["_gf_isom_av1_config_get"] =
            createExportWrapper("gf_isom_av1_config_get"));
        /** @type {function(...*):?} */
        var _gf_bs_new = (Module["_gf_bs_new"] = createExportWrapper("gf_bs_new"));
        /** @type {function(...*):?} */
        var _gf_av1_parse_obu = (Module["_gf_av1_parse_obu"] =
            createExportWrapper("gf_av1_parse_obu"));
        /** @type {function(...*):?} */
        var _gf_odf_av1_cfg_del = (Module["_gf_odf_av1_cfg_del"] =
            createExportWrapper("gf_odf_av1_cfg_del"));
        /** @type {function(...*):?} */
        var _gf_av1_reset_state = (Module["_gf_av1_reset_state"] =
            createExportWrapper("gf_av1_reset_state"));
        /** @type {function(...*):?} */
        var _gf_inspect_dump_obu = (Module["_gf_inspect_dump_obu"] =
            createExportWrapper("gf_inspect_dump_obu"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample = (Module["_gf_isom_get_sample"] =
            createExportWrapper("gf_isom_get_sample"));
        /** @type {function(...*):?} */
        var _gf_inspect_dump_prores = (Module["_gf_inspect_dump_prores"] =
            createExportWrapper("gf_inspect_dump_prores"));
        /** @type {function(...*):?} */
        var _gf_isom_opus_config_get_desc = (Module["_gf_isom_opus_config_get_desc"] =
            createExportWrapper("gf_isom_opus_config_get_desc"));
        /** @type {function(...*):?} */
        var _gf_inspect_dump_opus = (Module["_gf_inspect_dump_opus"] =
            createExportWrapper("gf_inspect_dump_opus"));
        /** @type {function(...*):?} */
        var _gf_isom_get_nalu_extract_mode = (Module["_gf_isom_get_nalu_extract_mode"] =
            createExportWrapper("gf_isom_get_nalu_extract_mode"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_description_count = (Module[
            "_gf_isom_get_sample_description_count"
        ] = createExportWrapper("gf_isom_get_sample_description_count"));
        /** @type {function(...*):?} */
        var _gf_isom_avc_config_get = (Module["_gf_isom_avc_config_get"] =
            createExportWrapper("gf_isom_avc_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_svc_config_get = (Module["_gf_isom_svc_config_get"] =
            createExportWrapper("gf_isom_svc_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_mvc_config_get = (Module["_gf_isom_mvc_config_get"] =
            createExportWrapper("gf_isom_mvc_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_hevc_config_get = (Module["_gf_isom_hevc_config_get"] =
            createExportWrapper("gf_isom_hevc_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_lhvc_config_get = (Module["_gf_isom_lhvc_config_get"] =
            createExportWrapper("gf_isom_lhvc_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_vvc_config_get = (Module["_gf_isom_vvc_config_get"] =
            createExportWrapper("gf_isom_vvc_config_get"));
        /** @type {function(...*):?} */
        var _gf_inspect_dump_nalu = (Module["_gf_inspect_dump_nalu"] =
            createExportWrapper("gf_inspect_dump_nalu"));
        /** @type {function(...*):?} */
        var _gf_odf_avc_cfg_del = (Module["_gf_odf_avc_cfg_del"] =
            createExportWrapper("gf_odf_avc_cfg_del"));
        /** @type {function(...*):?} */
        var _gf_odf_hevc_cfg_del = (Module["_gf_odf_hevc_cfg_del"] =
            createExportWrapper("gf_odf_hevc_cfg_del"));
        /** @type {function(...*):?} */
        var _gf_odf_vvc_cfg_del = (Module["_gf_odf_vvc_cfg_del"] =
            createExportWrapper("gf_odf_vvc_cfg_del"));
        /** @type {function(...*):?} */
        var _gf_isom_get_reference_ID = (Module["_gf_isom_get_reference_ID"] = createExportWrapper(
            "gf_isom_get_reference_ID"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_set_nalu_extract_mode = (Module["_gf_isom_set_nalu_extract_mode"] =
            createExportWrapper("gf_isom_set_nalu_extract_mode"));
        /** @type {function(...*):?} */
        var _gf_isom_is_adobe_protection_media = (Module["_gf_isom_is_adobe_protection_media"] =
            createExportWrapper("gf_isom_is_adobe_protection_media"));
        /** @type {function(...*):?} */
        var _gf_isom_is_cenc_media = (Module["_gf_isom_is_cenc_media"] =
            createExportWrapper("gf_isom_is_cenc_media"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_cenc_info = (Module["_gf_isom_get_sample_cenc_info"] =
            createExportWrapper("gf_isom_get_sample_cenc_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_edit_list_type = (Module["_gf_isom_get_edit_list_type"] =
            createExportWrapper("gf_isom_get_edit_list_type"));
        /** @type {function(...*):?} */
        var _gf_isom_get_chunk_count = (Module["_gf_isom_get_chunk_count"] =
            createExportWrapper("gf_isom_get_chunk_count"));
        /** @type {function(...*):?} */
        var _gf_isom_get_media_duration = (Module["_gf_isom_get_media_duration"] =
            createExportWrapper("gf_isom_get_media_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_get_constant_sample_size = (Module["_gf_isom_get_constant_sample_size"] =
            createExportWrapper("gf_isom_get_constant_sample_size"));
        /** @type {function(...*):?} */
        var _gf_isom_enable_raw_pack = (Module["_gf_isom_enable_raw_pack"] =
            createExportWrapper("gf_isom_enable_raw_pack"));
        /** @type {function(...*):?} */
        var _gf_isom_get_chunk_info = (Module["_gf_isom_get_chunk_info"] =
            createExportWrapper("gf_isom_get_chunk_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_size = (Module["_gf_isom_get_sample_size"] =
            createExportWrapper("gf_isom_get_sample_size"));
        /** @type {function(...*):?} */
        var _gf_isom_get_first_mdat_start = (Module["_gf_isom_get_first_mdat_start"] =
            createExportWrapper("gf_isom_get_first_mdat_start"));
        /** @type {function(...*):?} */
        var _gf_isom_get_unused_box_bytes = (Module["_gf_isom_get_unused_box_bytes"] =
            createExportWrapper("gf_isom_get_unused_box_bytes"));
        /** @type {function(...*):?} */
        var _gf_isom_dump_ismacryp_protection = (Module["_gf_isom_dump_ismacryp_protection"] =
            createExportWrapper("gf_isom_dump_ismacryp_protection"));
        /** @type {function(...*):?} */
        var _gf_isom_dump_ismacryp_sample = (Module["_gf_isom_dump_ismacryp_sample"] =
            createExportWrapper("gf_isom_dump_ismacryp_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_text_dump = (Module["_gf_isom_text_dump"] =
            createExportWrapper("gf_isom_text_dump"));
        /** @type {function(...*):?} */
        var _gf_isom_dump = (Module["_gf_isom_dump"] = createExportWrapper("gf_isom_dump"));
        /** @type {function(...*):?} */
        var _gf_isom_get_avc_svc_type = (Module["_gf_isom_get_avc_svc_type"] = createExportWrapper(
            "gf_isom_get_avc_svc_type"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_get_hevc_lhvc_type = (Module["_gf_isom_get_hevc_lhvc_type"] =
            createExportWrapper("gf_isom_get_hevc_lhvc_type"));
        /** @type {function(...*):?} */
        var _gf_isom_get_vvc_type = (Module["_gf_isom_get_vvc_type"] =
            createExportWrapper("gf_isom_get_vvc_type"));
        /** @type {function(...*):?} */
        var _gf_webvtt_dump_iso_track = (Module["_gf_webvtt_dump_iso_track"] = createExportWrapper(
            "gf_webvtt_dump_iso_track"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_get_udta_count = (Module["_gf_isom_get_udta_count"] =
            createExportWrapper("gf_isom_get_udta_count"));
        /** @type {function(...*):?} */
        var _gf_isom_get_udta_type = (Module["_gf_isom_get_udta_type"] =
            createExportWrapper("gf_isom_get_udta_type"));
        /** @type {function(...*):?} */
        var _gf_isom_get_user_data_count = (Module["_gf_isom_get_user_data_count"] =
            createExportWrapper("gf_isom_get_user_data_count"));
        /** @type {function(...*):?} */
        var _gf_itags_find_by_itag = (Module["_gf_itags_find_by_itag"] =
            createExportWrapper("gf_itags_find_by_itag"));
        /** @type {function(...*):?} */
        var _gf_isom_get_user_data = (Module["_gf_isom_get_user_data"] =
            createExportWrapper("gf_isom_get_user_data"));
        /** @type {function(...*):?} */
        var _gf_utf8_is_legal = (Module["_gf_utf8_is_legal"] =
            createExportWrapper("gf_utf8_is_legal"));
        /** @type {function(...*):?} */
        var _gf_isom_get_chapter_count = (Module["_gf_isom_get_chapter_count"] =
            createExportWrapper("gf_isom_get_chapter_count"));
        /** @type {function(...*):?} */
        var _gf_isom_get_chapter = (Module["_gf_isom_get_chapter"] =
            createExportWrapper("gf_isom_get_chapter"));
        /** @type {function(...*):?} */
        var _gf_hevc_get_profile_name = (Module["_gf_hevc_get_profile_name"] = createExportWrapper(
            "gf_hevc_get_profile_name"
        ));
        /** @type {function(...*):?} */
        var _gf_avc_hevc_get_chroma_format_name = (Module["_gf_avc_hevc_get_chroma_format_name"] =
            createExportWrapper("gf_avc_hevc_get_chroma_format_name"));
        /** @type {function(...*):?} */
        var _gf_hevc_read_vps = (Module["_gf_hevc_read_vps"] =
            createExportWrapper("gf_hevc_read_vps"));
        /** @type {function(...*):?} */
        var _gf_hevc_get_sps_info_with_state = (Module["_gf_hevc_get_sps_info_with_state"] =
            createExportWrapper("gf_hevc_get_sps_info_with_state"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_layout_info = (Module["_gf_isom_get_track_layout_info"] =
            createExportWrapper("gf_isom_get_track_layout_info"));
        /** @type {function(...*):?} */
        var _gf_sha1_csum = (Module["_gf_sha1_csum"] = createExportWrapper("gf_sha1_csum"));
        /** @type {function(...*):?} */
        var _gf_vvc_get_sps_info = (Module["_gf_vvc_get_sps_info"] =
            createExportWrapper("gf_vvc_get_sps_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_media_original_duration = (Module["_gf_isom_get_media_original_duration"] =
            createExportWrapper("gf_isom_get_media_original_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_check_data_reference = (Module["_gf_isom_check_data_reference"] =
            createExportWrapper("gf_isom_check_data_reference"));
        /** @type {function(...*):?} */
        var _gf_isom_get_composition_offset_shift = (Module[
            "_gf_isom_get_composition_offset_shift"
        ] = createExportWrapper("gf_isom_get_composition_offset_shift"));
        /** @type {function(...*):?} */
        var _gf_isom_is_track_in_root_od = (Module["_gf_isom_is_track_in_root_od"] =
            createExportWrapper("gf_isom_is_track_in_root_od"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_flags = (Module["_gf_isom_get_track_flags"] =
            createExportWrapper("gf_isom_get_track_flags"));
        /** @type {function(...*):?} */
        var _gf_isom_get_media_language = (Module["_gf_isom_get_media_language"] =
            createExportWrapper("gf_isom_get_media_language"));
        /** @type {function(...*):?} */
        var _gf_isom_get_mpeg4_subtype = (Module["_gf_isom_get_mpeg4_subtype"] =
            createExportWrapper("gf_isom_get_mpeg4_subtype"));
        /** @type {function(...*):?} */
        var _gf_isom_is_track_referenced = (Module["_gf_isom_is_track_referenced"] =
            createExportWrapper("gf_isom_is_track_referenced"));
        /** @type {function(...*):?} */
        var _gf_isom_get_constant_sample_duration = (Module[
            "_gf_isom_get_constant_sample_duration"
        ] = createExportWrapper("gf_isom_get_constant_sample_duration"));
        /** @type {function(...*):?} */
        var _gf_media_get_reduced_frame_rate = (Module["_gf_media_get_reduced_frame_rate"] =
            createExportWrapper("gf_media_get_reduced_frame_rate"));
        /** @type {function(...*):?} */
        var _gf_isom_enum_track_group = (Module["_gf_isom_enum_track_group"] = createExportWrapper(
            "gf_isom_enum_track_group"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_kind_count = (Module["_gf_isom_get_track_kind_count"] =
            createExportWrapper("gf_isom_get_track_kind_count"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_kind = (Module["_gf_isom_get_track_kind"] =
            createExportWrapper("gf_isom_get_track_kind"));
        /** @type {function(...*):?} */
        var _gf_isom_is_track_fragmented = (Module["_gf_isom_is_track_fragmented"] =
            createExportWrapper("gf_isom_is_track_fragmented"));
        /** @type {function(...*):?} */
        var _gf_isom_get_fragmented_samples_info = (Module["_gf_isom_get_fragmented_samples_info"] =
            createExportWrapper("gf_isom_get_fragmented_samples_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_fragment_defaults = (Module["_gf_isom_get_fragment_defaults"] =
            createExportWrapper("gf_isom_get_fragment_defaults"));
        /** @type {function(...*):?} */
        var _gf_isom_get_handler_name = (Module["_gf_isom_get_handler_name"] = createExportWrapper(
            "gf_isom_get_handler_name"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_enum_track_references = (Module["_gf_isom_enum_track_references"] =
            createExportWrapper("gf_isom_enum_track_references"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_switch_parameter = (Module["_gf_isom_get_track_switch_parameter"] =
            createExportWrapper("gf_isom_get_track_switch_parameter"));
        /** @type {function(...*):?} */
        var _gf_isom_has_sync_points = (Module["_gf_isom_has_sync_points"] =
            createExportWrapper("gf_isom_has_sync_points"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sync_point_count = (Module["_gf_isom_get_sync_point_count"] =
            createExportWrapper("gf_isom_get_sync_point_count"));
        /** @type {function(...*):?} */
        var _gf_isom_get_max_sample_delta = (Module["_gf_isom_get_max_sample_delta"] =
            createExportWrapper("gf_isom_get_max_sample_delta"));
        /** @type {function(...*):?} */
        var _gf_isom_get_chunks_infos = (Module["_gf_isom_get_chunks_infos"] = createExportWrapper(
            "gf_isom_get_chunks_infos"
        ));
        /** @type {function(...*):?} */
        var _gf_lang_find = (Module["_gf_lang_find"] = createExportWrapper("gf_lang_find"));
        /** @type {function(...*):?} */
        var _gf_isom_get_meta_primary_item_id = (Module["_gf_isom_get_meta_primary_item_id"] =
            createExportWrapper("gf_isom_get_meta_primary_item_id"));
        /** @type {function(...*):?} */
        var _gf_isom_get_meta_item_info = (Module["_gf_isom_get_meta_item_info"] =
            createExportWrapper("gf_isom_get_meta_item_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_meta_image_props = (Module["_gf_isom_get_meta_image_props"] =
            createExportWrapper("gf_isom_get_meta_image_props"));
        /** @type {function(...*):?} */
        var _gf_isom_extract_meta_item_get_cenc_info = (Module[
            "_gf_isom_extract_meta_item_get_cenc_info"
        ] = createExportWrapper("gf_isom_extract_meta_item_get_cenc_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_original_format_type = (Module["_gf_isom_get_original_format_type"] =
            createExportWrapper("gf_isom_get_original_format_type"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_from_qt_type = (Module["_gf_pixel_fmt_from_qt_type"] =
            createExportWrapper("gf_pixel_fmt_from_qt_type"));
        /** @type {function(...*):?} */
        var _gf_codec_id_from_isobmf = (Module["_gf_codec_id_from_isobmf"] =
            createExportWrapper("gf_codec_id_from_isobmf"));
        /** @type {function(...*):?} */
        var _gf_isom_get_generic_sample_description = (Module[
            "_gf_isom_get_generic_sample_description"
        ] = createExportWrapper("gf_isom_get_generic_sample_description"));
        /** @type {function(...*):?} */
        var _gf_bs_read_utf8 = (Module["_gf_bs_read_utf8"] =
            createExportWrapper("gf_bs_read_utf8"));
        /** @type {function(...*):?} */
        var _gf_isom_is_self_contained = (Module["_gf_isom_is_self_contained"] =
            createExportWrapper("gf_isom_is_self_contained"));
        /** @type {function(...*):?} */
        var _gf_isom_get_data_reference = (Module["_gf_isom_get_data_reference"] =
            createExportWrapper("gf_isom_get_data_reference"));
        /** @type {function(...*):?} */
        var _gf_isom_get_visual_info = (Module["_gf_isom_get_visual_info"] =
            createExportWrapper("gf_isom_get_visual_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_visual_bit_depth = (Module["_gf_isom_get_visual_bit_depth"] =
            createExportWrapper("gf_isom_get_visual_bit_depth"));
        /** @type {function(...*):?} */
        var _gf_isom_dovi_config_get = (Module["_gf_isom_dovi_config_get"] =
            createExportWrapper("gf_isom_dovi_config_get"));
        /** @type {function(...*):?} */
        var _gf_odf_dovi_cfg_del = (Module["_gf_odf_dovi_cfg_del"] =
            createExportWrapper("gf_odf_dovi_cfg_del"));
        /** @type {function(...*):?} */
        var _gf_isom_get_audio_info = (Module["_gf_isom_get_audio_info"] =
            createExportWrapper("gf_isom_get_audio_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_dims_description = (Module["_gf_isom_get_dims_description"] =
            createExportWrapper("gf_isom_get_dims_description"));
        /** @type {function(...*):?} */
        var _gf_isom_ac3_config_get = (Module["_gf_isom_ac3_config_get"] =
            createExportWrapper("gf_isom_ac3_config_get"));
        /** @type {function(...*):?} */
        var _gf_av1_get_obu_name = (Module["_gf_av1_get_obu_name"] =
            createExportWrapper("gf_av1_get_obu_name"));
        /** @type {function(...*):?} */
        var _gf_ac3_get_total_channels = (Module["_gf_ac3_get_total_channels"] =
            createExportWrapper("gf_ac3_get_total_channels"));
        /** @type {function(...*):?} */
        var _gf_eac3_get_chan_loc_count = (Module["_gf_eac3_get_chan_loc_count"] =
            createExportWrapper("gf_eac3_get_chan_loc_count"));
        /** @type {function(...*):?} */
        var _gf_ac3_get_bitrate = (Module["_gf_ac3_get_bitrate"] =
            createExportWrapper("gf_ac3_get_bitrate"));
        /** @type {function(...*):?} */
        var _gf_m4v_get_profile_name = (Module["_gf_m4v_get_profile_name"] =
            createExportWrapper("gf_m4v_get_profile_name"));
        /** @type {function(...*):?} */
        var _gf_avc_get_profile_name = (Module["_gf_avc_get_profile_name"] =
            createExportWrapper("gf_avc_get_profile_name"));
        /** @type {function(...*):?} */
        var _gf_avc_get_sps_info = (Module["_gf_avc_get_sps_info"] =
            createExportWrapper("gf_avc_get_sps_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_tile_info = (Module["_gf_isom_get_tile_info"] =
            createExportWrapper("gf_isom_get_tile_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_group_info = (Module["_gf_isom_get_sample_group_info"] =
            createExportWrapper("gf_isom_get_sample_group_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_oinf_info = (Module["_gf_isom_get_oinf_info"] =
            createExportWrapper("gf_isom_get_oinf_info"));
        /** @type {function(...*):?} */
        var _gf_codecid_from_oti = (Module["_gf_codecid_from_oti"] =
            createExportWrapper("gf_codecid_from_oti"));
        /** @type {function(...*):?} */
        var _gf_m4a_object_type_name = (Module["_gf_m4a_object_type_name"] =
            createExportWrapper("gf_m4a_object_type_name"));
        /** @type {function(...*):?} */
        var _gf_mp3_version_name = (Module["_gf_mp3_version_name"] =
            createExportWrapper("gf_mp3_version_name"));
        /** @type {function(...*):?} */
        var _gf_mp3_num_channels = (Module["_gf_mp3_num_channels"] =
            createExportWrapper("gf_mp3_num_channels"));
        /** @type {function(...*):?} */
        var _gf_mp3_sampling_rate = (Module["_gf_mp3_sampling_rate"] =
            createExportWrapper("gf_mp3_sampling_rate"));
        /** @type {function(...*):?} */
        var _gf_mp3_layer = (Module["_gf_mp3_layer"] = createExportWrapper("gf_mp3_layer"));
        /** @type {function(...*):?} */
        var _gf_odf_get_bifs_config = (Module["_gf_odf_get_bifs_config"] =
            createExportWrapper("gf_odf_get_bifs_config"));
        /** @type {function(...*):?} */
        var _gf_stream_type_afx_name = (Module["_gf_stream_type_afx_name"] =
            createExportWrapper("gf_stream_type_afx_name"));
        /** @type {function(...*):?} */
        var _gf_odf_get_laser_config = (Module["_gf_odf_get_laser_config"] =
            createExportWrapper("gf_odf_get_laser_config"));
        /** @type {function(...*):?} */
        var _gf_isom_get_rvc_config = (Module["_gf_isom_get_rvc_config"] =
            createExportWrapper("gf_isom_get_rvc_config"));
        /** @type {function(...*):?} */
        var _gf_isom_stxt_get_description = (Module["_gf_isom_stxt_get_description"] =
            createExportWrapper("gf_isom_stxt_get_description"));
        /** @type {function(...*):?} */
        var _gf_isom_xml_subtitle_get_description = (Module[
            "_gf_isom_xml_subtitle_get_description"
        ] = createExportWrapper("gf_isom_xml_subtitle_get_description"));
        /** @type {function(...*):?} */
        var _gf_isom_get_text_description = (Module["_gf_isom_get_text_description"] =
            createExportWrapper("gf_isom_get_text_description"));
        /** @type {function(...*):?} */
        var _gf_isom_get_xml_metadata_description = (Module[
            "_gf_isom_get_xml_metadata_description"
        ] = createExportWrapper("gf_isom_get_xml_metadata_description"));
        /** @type {function(...*):?} */
        var _gf_isom_get_lpcm_config = (Module["_gf_isom_get_lpcm_config"] =
            createExportWrapper("gf_isom_get_lpcm_config"));
        /** @type {function(...*):?} */
        var _gf_media_map_esd = (Module["_gf_media_map_esd"] =
            createExportWrapper("gf_media_map_esd"));
        /** @type {function(...*):?} */
        var _gf_mpegh_get_mhas_pl = (Module["_gf_mpegh_get_mhas_pl"] =
            createExportWrapper("gf_mpegh_get_mhas_pl"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_get_layout_name = (Module["_gf_audio_fmt_get_layout_name"] =
            createExportWrapper("gf_audio_fmt_get_layout_name"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_get_layout_name_from_cicp = (Module[
            "_gf_audio_fmt_get_layout_name_from_cicp"
        ] = createExportWrapper("gf_audio_fmt_get_layout_name_from_cicp"));
        /** @type {function(...*):?} */
        var _gf_isom_get_mpegh_compatible_profiles = (Module[
            "_gf_isom_get_mpegh_compatible_profiles"
        ] = createExportWrapper("gf_isom_get_mpegh_compatible_profiles"));
        /** @type {function(...*):?} */
        var _gf_isom_truehd_config_get = (Module["_gf_isom_truehd_config_get"] =
            createExportWrapper("gf_isom_truehd_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_get_pcm_config = (Module["_gf_isom_get_pcm_config"] =
            createExportWrapper("gf_isom_get_pcm_config"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_name = (Module["_gf_pixel_fmt_name"] =
            createExportWrapper("gf_pixel_fmt_name"));
        /** @type {function(...*):?} */
        var _gf_isom_get_tmcd_config = (Module["_gf_isom_get_tmcd_config"] =
            createExportWrapper("gf_isom_get_tmcd_config"));
        /** @type {function(...*):?} */
        var _gf_inspect_format_timecode = (Module["_gf_inspect_format_timecode"] =
            createExportWrapper("gf_inspect_format_timecode"));
        /** @type {function(...*):?} */
        var _gf_isom_is_track_encrypted = (Module["_gf_isom_is_track_encrypted"] =
            createExportWrapper("gf_isom_is_track_encrypted"));
        /** @type {function(...*):?} */
        var _gf_isom_get_ismacryp_info = (Module["_gf_isom_get_ismacryp_info"] =
            createExportWrapper("gf_isom_get_ismacryp_info"));
        /** @type {function(...*):?} */
        var _gf_isom_is_omadrm_media = (Module["_gf_isom_is_omadrm_media"] =
            createExportWrapper("gf_isom_is_omadrm_media"));
        /** @type {function(...*):?} */
        var _gf_isom_get_omadrm_info = (Module["_gf_isom_get_omadrm_info"] =
            createExportWrapper("gf_isom_get_omadrm_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_cenc_info = (Module["_gf_isom_get_cenc_info"] =
            createExportWrapper("gf_isom_get_cenc_info"));
        /** @type {function(...*):?} */
        var _gf_isom_cenc_get_default_info = (Module["_gf_isom_cenc_get_default_info"] =
            createExportWrapper("gf_isom_cenc_get_default_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_adobe_protection_info = (Module["_gf_isom_get_adobe_protection_info"] =
            createExportWrapper("gf_isom_get_adobe_protection_info"));
        /** @type {function(...*):?} */
        var _gf_media_get_rfc_6381_codec_name = (Module["_gf_media_get_rfc_6381_codec_name"] =
            createExportWrapper("gf_media_get_rfc_6381_codec_name"));
        /** @type {function(...*):?} */
        var _gf_isom_has_movie = (Module["_gf_isom_has_movie"] =
            createExportWrapper("gf_isom_has_movie"));
        /** @type {function(...*):?} */
        var _gf_isom_has_segment = (Module["_gf_isom_has_segment"] =
            createExportWrapper("gf_isom_has_segment"));
        /** @type {function(...*):?} */
        var _gf_isom_segment_get_fragment_count = (Module["_gf_isom_segment_get_fragment_count"] =
            createExportWrapper("gf_isom_segment_get_fragment_count"));
        /** @type {function(...*):?} */
        var _gf_isom_segment_get_track_fragment_count = (Module[
            "_gf_isom_segment_get_track_fragment_count"
        ] = createExportWrapper("gf_isom_segment_get_track_fragment_count"));
        /** @type {function(...*):?} */
        var _gf_isom_segment_get_fragment_size = (Module["_gf_isom_segment_get_fragment_size"] =
            createExportWrapper("gf_isom_segment_get_fragment_size"));
        /** @type {function(...*):?} */
        var _gf_isom_segment_get_track_fragment_decode_time = (Module[
            "_gf_isom_segment_get_track_fragment_decode_time"
        ] = createExportWrapper("gf_isom_segment_get_track_fragment_decode_time"));
        /** @type {function(...*):?} */
        var _gf_isom_get_original_duration = (Module["_gf_isom_get_original_duration"] =
            createExportWrapper("gf_isom_get_original_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_get_fragmented_duration = (Module["_gf_isom_get_fragmented_duration"] =
            createExportWrapper("gf_isom_get_fragmented_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_get_fragments_count = (Module["_gf_isom_get_fragments_count"] =
            createExportWrapper("gf_isom_get_fragments_count"));
        /** @type {function(...*):?} */
        var _gf_isom_moov_first = (Module["_gf_isom_moov_first"] =
            createExportWrapper("gf_isom_moov_first"));
        /** @type {function(...*):?} */
        var _gf_isom_get_brand_info = (Module["_gf_isom_get_brand_info"] =
            createExportWrapper("gf_isom_get_brand_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_alternate_brand = (Module["_gf_isom_get_alternate_brand"] =
            createExportWrapper("gf_isom_get_alternate_brand"));
        /** @type {function(...*):?} */
        var _gf_isom_get_creation_time = (Module["_gf_isom_get_creation_time"] =
            createExportWrapper("gf_isom_get_creation_time"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_size = (Module["_gf_odf_desc_size"] =
            createExportWrapper("gf_odf_desc_size"));
        /** @type {function(...*):?} */
        var _gf_m4a_get_profile_name = (Module["_gf_m4a_get_profile_name"] =
            createExportWrapper("gf_m4a_get_profile_name"));
        /** @type {function(...*):?} */
        var _gf_isom_is_JPEG2000 = (Module["_gf_isom_is_JPEG2000"] =
            createExportWrapper("gf_isom_is_JPEG2000"));
        /** @type {function(...*):?} */
        var _gf_isom_get_copyright_count = (Module["_gf_isom_get_copyright_count"] =
            createExportWrapper("gf_isom_get_copyright_count"));
        /** @type {function(...*):?} */
        var _gf_isom_get_copyright = (Module["_gf_isom_get_copyright"] =
            createExportWrapper("gf_isom_get_copyright"));
        /** @type {function(...*):?} */
        var _gf_isom_parse_text_sample = (Module["_gf_isom_parse_text_sample"] =
            createExportWrapper("gf_isom_parse_text_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_delete_text_sample = (Module["_gf_isom_delete_text_sample"] =
            createExportWrapper("gf_isom_delete_text_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_apple_enum_tag = (Module["_gf_isom_apple_enum_tag"] =
            createExportWrapper("gf_isom_apple_enum_tag"));
        /** @type {function(...*):?} */
        var _gf_id3_get_genre = (Module["_gf_id3_get_genre"] =
            createExportWrapper("gf_id3_get_genre"));
        /** @type {function(...*):?} */
        var _gf_isom_enum_udta_keys = (Module["_gf_isom_enum_udta_keys"] =
            createExportWrapper("gf_isom_enum_udta_keys"));
        /** @type {function(...*):?} */
        var _gf_isom_wma_enum_tag = (Module["_gf_isom_wma_enum_tag"] =
            createExportWrapper("gf_isom_wma_enum_tag"));
        /** @type {function(...*):?} */
        var _gf_utf8_wcslen = (Module["_gf_utf8_wcslen"] = createExportWrapper("gf_utf8_wcslen"));
        /** @type {function(...*):?} */
        var _gf_utf8_wcstombs = (Module["_gf_utf8_wcstombs"] =
            createExportWrapper("gf_utf8_wcstombs"));
        /** @type {function(...*):?} */
        var _gf_m2ts_demux_new = (Module["_gf_m2ts_demux_new"] =
            createExportWrapper("gf_m2ts_demux_new"));
        /** @type {function(...*):?} */
        var _gf_m2ts_process_data = (Module["_gf_m2ts_process_data"] =
            createExportWrapper("gf_m2ts_process_data"));
        /** @type {function(...*):?} */
        var _gf_m2ts_reset_parsers = (Module["_gf_m2ts_reset_parsers"] =
            createExportWrapper("gf_m2ts_reset_parsers"));
        /** @type {function(...*):?} */
        var _gf_m2ts_demux_del = (Module["_gf_m2ts_demux_del"] =
            createExportWrapper("gf_m2ts_demux_del"));
        /** @type {function(...*):?} */
        var _gf_m2ts_set_pes_framing = (Module["_gf_m2ts_set_pes_framing"] =
            createExportWrapper("gf_m2ts_set_pes_framing"));
        /** @type {function(...*):?} */
        var _gf_m2ts_get_stream_name = (Module["_gf_m2ts_get_stream_name"] =
            createExportWrapper("gf_m2ts_get_stream_name"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_user_data = (Module["_gf_isom_remove_user_data"] = createExportWrapper(
            "gf_isom_remove_user_data"
        ));
        /** @type {function(...*):?} */
        var _gf_base64_decode = (Module["_gf_base64_decode"] =
            createExportWrapper("gf_base64_decode"));
        /** @type {function(...*):?} */
        var _gf_isom_add_user_data_boxes = (Module["_gf_isom_add_user_data_boxes"] =
            createExportWrapper("gf_isom_add_user_data_boxes"));
        /** @type {function(...*):?} */
        var _gf_isom_add_user_data = (Module["_gf_isom_add_user_data"] =
            createExportWrapper("gf_isom_add_user_data"));
        /** @type {function(...*):?} */
        var _gf_cicp_parse_color_primaries = (Module["_gf_cicp_parse_color_primaries"] =
            createExportWrapper("gf_cicp_parse_color_primaries"));
        /** @type {function(...*):?} */
        var _gf_cicp_parse_color_transfer = (Module["_gf_cicp_parse_color_transfer"] =
            createExportWrapper("gf_cicp_parse_color_transfer"));
        /** @type {function(...*):?} */
        var _gf_cicp_parse_color_matrix = (Module["_gf_cicp_parse_color_matrix"] =
            createExportWrapper("gf_cicp_parse_color_matrix"));
        /** @type {function(...*):?} */
        var _gf_isom_set_edit = (Module["_gf_isom_set_edit"] =
            createExportWrapper("gf_isom_set_edit"));
        /** @type {function(...*):?} */
        var _gf_isom_set_edit_with_rate = (Module["_gf_isom_set_edit_with_rate"] =
            createExportWrapper("gf_isom_set_edit_with_rate"));
        /** @type {function(...*):?} */
        var _gf_calloc = (Module["_gf_calloc"] = createExportWrapper("gf_calloc"));
        /** @type {function(...*):?} */
        var _gf_isom_get_next_alternate_group_id = (Module["_gf_isom_get_next_alternate_group_id"] =
            createExportWrapper("gf_isom_get_next_alternate_group_id"));
        /** @type {function(...*):?} */
        var _gf_sys_old_arch_compat = (Module["_gf_sys_old_arch_compat"] =
            createExportWrapper("gf_sys_old_arch_compat"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_magic = (Module["_gf_isom_get_track_magic"] =
            createExportWrapper("gf_isom_get_track_magic"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_flags = (Module["_gf_isom_set_track_flags"] =
            createExportWrapper("gf_isom_set_track_flags"));
        /** @type {function(...*):?} */
        var _gf_media_change_color = (Module["_gf_media_change_color"] =
            createExportWrapper("gf_media_change_color"));
        /** @type {function(...*):?} */
        var _gf_isom_set_visual_bit_depth = (Module["_gf_isom_set_visual_bit_depth"] =
            createExportWrapper("gf_isom_set_visual_bit_depth"));
        /** @type {function(...*):?} */
        var _gf_isom_set_visual_color_info = (Module["_gf_isom_set_visual_color_info"] =
            createExportWrapper("gf_isom_set_visual_color_info"));
        /** @type {function(...*):?} */
        var _gf_isom_set_image_sequence_coding_constraints = (Module[
            "_gf_isom_set_image_sequence_coding_constraints"
        ] = createExportWrapper("gf_isom_set_image_sequence_coding_constraints"));
        /** @type {function(...*):?} */
        var _gf_isom_use_compact_size = (Module["_gf_isom_use_compact_size"] = createExportWrapper(
            "gf_isom_use_compact_size"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_set_alternate_group_id = (Module["_gf_isom_set_alternate_group_id"] =
            createExportWrapper("gf_isom_set_alternate_group_id"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_group = (Module["_gf_isom_set_track_group"] =
            createExportWrapper("gf_isom_set_track_group"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_layout_info = (Module["_gf_isom_set_track_layout_info"] =
            createExportWrapper("gf_isom_set_track_layout_info"));
        /** @type {function(...*):?} */
        var _gf_isom_set_media_subtype = (Module["_gf_isom_set_media_subtype"] =
            createExportWrapper("gf_isom_set_media_subtype"));
        /** @type {function(...*):?} */
        var _gf_media_change_pl = (Module["_gf_media_change_pl"] =
            createExportWrapper("gf_media_change_pl"));
        /** @type {function(...*):?} */
        var _gf_isom_set_audio_info = (Module["_gf_isom_set_audio_info"] =
            createExportWrapper("gf_isom_set_audio_info"));
        /** @type {function(...*):?} */
        var _gf_isom_set_sample_roll_group = (Module["_gf_isom_set_sample_roll_group"] =
            createExportWrapper("gf_isom_set_sample_roll_group"));
        /** @type {function(...*):?} */
        var _gf_isom_set_media_timescale = (Module["_gf_isom_set_media_timescale"] =
            createExportWrapper("gf_isom_set_media_timescale"));
        /** @type {function(...*):?} */
        var _gf_isom_set_last_sample_duration_ex = (Module["_gf_isom_set_last_sample_duration_ex"] =
            createExportWrapper("gf_isom_set_last_sample_duration_ex"));
        /** @type {function(...*):?} */
        var _gf_isom_set_rvc_config = (Module["_gf_isom_set_rvc_config"] =
            createExportWrapper("gf_isom_set_rvc_config"));
        /** @type {function(...*):?} */
        var _gf_isom_set_composition_offset_mode = (Module["_gf_isom_set_composition_offset_mode"] =
            createExportWrapper("gf_isom_set_composition_offset_mode"));
        /** @type {function(...*):?} */
        var _gf_isom_text_set_display_flags = (Module["_gf_isom_text_set_display_flags"] =
            createExportWrapper("gf_isom_text_set_display_flags"));
        /** @type {function(...*):?} */
        var _gf_isom_update_bitrate = (Module["_gf_isom_update_bitrate"] =
            createExportWrapper("gf_isom_update_bitrate"));
        /** @type {function(...*):?} */
        var _gf_eac3_parser = (Module["_gf_eac3_parser"] = createExportWrapper("gf_eac3_parser"));
        /** @type {function(...*):?} */
        var _gf_isom_ac3_config_update = (Module["_gf_isom_ac3_config_update"] =
            createExportWrapper("gf_isom_ac3_config_update"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_index = (Module["_gf_isom_set_track_index"] =
            createExportWrapper("gf_isom_set_track_index"));
        /** @type {function(...*):?} */
        var _gf_isom_add_chapter = (Module["_gf_isom_add_chapter"] =
            createExportWrapper("gf_isom_add_chapter"));
        /** @type {function(...*):?} */
        var _gf_isom_rewrite_track_dependencies = (Module["_gf_isom_rewrite_track_dependencies"] =
            createExportWrapper("gf_isom_rewrite_track_dependencies"));
        /** @type {function(...*):?} */
        var _gf_media_filter_hevc = (Module["_gf_media_filter_hevc"] =
            createExportWrapper("gf_media_filter_hevc"));
        /** @type {function(...*):?} */
        var _gf_media_split_svc = (Module["_gf_media_split_svc"] =
            createExportWrapper("gf_media_split_svc"));
        /** @type {function(...*):?} */
        var _gf_media_merge_svc = (Module["_gf_media_merge_svc"] =
            createExportWrapper("gf_media_merge_svc"));
        /** @type {function(...*):?} */
        var _gf_media_split_lhvc = (Module["_gf_media_split_lhvc"] =
            createExportWrapper("gf_media_split_lhvc"));
        /** @type {function(...*):?} */
        var _gf_media_split_hevc_tiles = (Module["_gf_media_split_hevc_tiles"] =
            createExportWrapper("gf_media_split_hevc_tiles"));
        /** @type {function(...*):?} */
        var _gf_isom_new_track = (Module["_gf_isom_new_track"] =
            createExportWrapper("gf_isom_new_track"));
        /** @type {function(...*):?} */
        var _gf_isom_tmcd_config_new = (Module["_gf_isom_tmcd_config_new"] =
            createExportWrapper("gf_isom_tmcd_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_sample_new = (Module["_gf_isom_sample_new"] =
            createExportWrapper("gf_isom_sample_new"));
        /** @type {function(...*):?} */
        var _gf_bs_get_content = (Module["_gf_bs_get_content"] =
            createExportWrapper("gf_bs_get_content"));
        /** @type {function(...*):?} */
        var _gf_isom_add_sample = (Module["_gf_isom_add_sample"] =
            createExportWrapper("gf_isom_add_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_set_last_sample_duration = (Module["_gf_isom_set_last_sample_duration"] =
            createExportWrapper("gf_isom_set_last_sample_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_set_high_dynamic_range_info = (Module["_gf_isom_set_high_dynamic_range_info"] =
            createExportWrapper("gf_isom_set_high_dynamic_range_info"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_get_root = (Module["_gf_xml_dom_get_root"] =
            createExportWrapper("gf_xml_dom_get_root"));
        /** @type {function(...*):?} */
        var _gf_isom_set_dolby_vision_profile = (Module["_gf_isom_set_dolby_vision_profile"] =
            createExportWrapper("gf_isom_set_dolby_vision_profile"));
        /** @type {function(...*):?} */
        var _gf_bs_read_int = (Module["_gf_bs_read_int"] = createExportWrapper("gf_bs_read_int"));
        /** @type {function(...*):?} */
        var _gf_bs_read_u8 = (Module["_gf_bs_read_u8"] = createExportWrapper("gf_bs_read_u8"));
        /** @type {function(...*):?} */
        var _gf_av1_parse_obu_header = (Module["_gf_av1_parse_obu_header"] =
            createExportWrapper("gf_av1_parse_obu_header"));
        /** @type {function(...*):?} */
        var _gf_av1_leb128_read = (Module["_gf_av1_leb128_read"] =
            createExportWrapper("gf_av1_leb128_read"));
        /** @type {function(...*):?} */
        var _gf_bs_seek = (Module["_gf_bs_seek"] = createExportWrapper("gf_bs_seek"));
        /** @type {function(...*):?} */
        var _gf_dolby_vision_level = (Module["_gf_dolby_vision_level"] =
            createExportWrapper("gf_dolby_vision_level"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_duration = (Module["_gf_isom_get_sample_duration"] =
            createExportWrapper("gf_isom_get_sample_duration"));
        /** @type {function(...*):?} */
        var _gf_sys_find_global_arg = (Module["_gf_sys_find_global_arg"] =
            createExportWrapper("gf_sys_find_global_arg"));
        /** @type {function(...*):?} */
        var _gf_dir_exists = (Module["_gf_dir_exists"] = createExportWrapper("gf_dir_exists"));
        /** @type {function(...*):?} */
        var _gf_log_get_tool_level = (Module["_gf_log_get_tool_level"] =
            createExportWrapper("gf_log_get_tool_level"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_dts = (Module["_gf_isom_get_sample_dts"] =
            createExportWrapper("gf_isom_get_sample_dts"));
        /** @type {function(...*):?} */
        var _gf_timestamp_less = (Module["_gf_timestamp_less"] =
            createExportWrapper("gf_timestamp_less"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_original_id = (Module["_gf_isom_get_track_original_id"] =
            createExportWrapper("gf_isom_get_track_original_id"));
        /** @type {function(...*):?} */
        var _gf_isom_is_same_sample_description = (Module["_gf_isom_is_same_sample_description"] =
            createExportWrapper("gf_isom_is_same_sample_description"));
        /** @type {function(...*):?} */
        var _gf_isom_clone_sample_description = (Module["_gf_isom_clone_sample_description"] =
            createExportWrapper("gf_isom_clone_sample_description"));
        /** @type {function(...*):?} */
        var _gf_isom_clone_track = (Module["_gf_isom_clone_track"] =
            createExportWrapper("gf_isom_clone_track"));
        /** @type {function(...*):?} */
        var _gf_isom_clone_pl_indications = (Module["_gf_isom_clone_pl_indications"] =
            createExportWrapper("gf_isom_clone_pl_indications"));
        /** @type {function(...*):?} */
        var _gf_isom_get_edit = (Module["_gf_isom_get_edit"] =
            createExportWrapper("gf_isom_get_edit"));
        /** @type {function(...*):?} */
        var _gf_bs_write_int = (Module["_gf_bs_write_int"] =
            createExportWrapper("gf_bs_write_int"));
        /** @type {function(...*):?} */
        var _gf_isom_add_sample_reference = (Module["_gf_isom_add_sample_reference"] =
            createExportWrapper("gf_isom_add_sample_reference"));
        /** @type {function(...*):?} */
        var _gf_isom_copy_sample_info = (Module["_gf_isom_copy_sample_info"] = createExportWrapper(
            "gf_isom_copy_sample_info"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_update_duration = (Module["_gf_isom_update_duration"] =
            createExportWrapper("gf_isom_update_duration"));
        /** @type {function(...*):?} */
        var _gf_timestamp_rescale = (Module["_gf_timestamp_rescale"] =
            createExportWrapper("gf_timestamp_rescale"));
        /** @type {function(...*):?} */
        var _gf_isom_modify_edit = (Module["_gf_isom_modify_edit"] =
            createExportWrapper("gf_isom_modify_edit"));
        /** @type {function(...*):?} */
        var _gf_media_update_bitrate = (Module["_gf_media_update_bitrate"] =
            createExportWrapper("gf_media_update_bitrate"));
        /** @type {function(...*):?} */
        var _gf_media_nal_rewrite_samples = (Module["_gf_media_nal_rewrite_samples"] =
            createExportWrapper("gf_media_nal_rewrite_samples"));
        /** @type {function(...*):?} */
        var _gf_isom_avc_config_update = (Module["_gf_isom_avc_config_update"] =
            createExportWrapper("gf_isom_avc_config_update"));
        /** @type {function(...*):?} */
        var _gf_isom_avc_set_inband_config = (Module["_gf_isom_avc_set_inband_config"] =
            createExportWrapper("gf_isom_avc_set_inband_config"));
        /** @type {function(...*):?} */
        var _gf_isom_hevc_config_update = (Module["_gf_isom_hevc_config_update"] =
            createExportWrapper("gf_isom_hevc_config_update"));
        /** @type {function(...*):?} */
        var _gf_isom_hevc_set_inband_config = (Module["_gf_isom_hevc_set_inband_config"] =
            createExportWrapper("gf_isom_hevc_set_inband_config"));
        /** @type {function(...*):?} */
        var _gf_sg_command_new = (Module["_gf_sg_command_new"] =
            createExportWrapper("gf_sg_command_new"));
        /** @type {function(...*):?} */
        var _gf_sg_command_field_new = (Module["_gf_sg_command_field_new"] =
            createExportWrapper("gf_sg_command_field_new"));
        /** @type {function(...*):?} */
        var _gf_sm_encode_to_file = (Module["_gf_sm_encode_to_file"] =
            createExportWrapper("gf_sm_encode_to_file"));
        /** @type {function(...*):?} */
        var _gf_bifs_encoder_new = (Module["_gf_bifs_encoder_new"] =
            createExportWrapper("gf_bifs_encoder_new"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_esd_new = (Module["_gf_odf_desc_esd_new"] =
            createExportWrapper("gf_odf_desc_esd_new"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_new = (Module["_gf_odf_desc_new"] =
            createExportWrapper("gf_odf_desc_new"));
        /** @type {function(...*):?} */
        var _gf_bifs_encoder_new_stream = (Module["_gf_bifs_encoder_new_stream"] =
            createExportWrapper("gf_bifs_encoder_new_stream"));
        /** @type {function(...*):?} */
        var _gf_bifs_encoder_get_config = (Module["_gf_bifs_encoder_get_config"] =
            createExportWrapper("gf_bifs_encoder_get_config"));
        /** @type {function(...*):?} */
        var _gf_bifs_encoder_get_version = (Module["_gf_bifs_encoder_get_version"] =
            createExportWrapper("gf_bifs_encoder_get_version"));
        /** @type {function(...*):?} */
        var _gf_bifs_encode_au = (Module["_gf_bifs_encode_au"] =
            createExportWrapper("gf_bifs_encode_au"));
        /** @type {function(...*):?} */
        var _gf_bifs_encoder_del = (Module["_gf_bifs_encoder_del"] =
            createExportWrapper("gf_bifs_encoder_del"));
        /** @type {function(...*):?} */
        var _gf_sm_aggregate = (Module["_gf_sm_aggregate"] =
            createExportWrapper("gf_sm_aggregate"));
        /** @type {function(...*):?} */
        var _gf_xml_get_root_type = (Module["_gf_xml_get_root_type"] =
            createExportWrapper("gf_xml_get_root_type"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_new = (Module["_gf_xml_sax_new"] = createExportWrapper("gf_xml_sax_new"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_parse_file = (Module["_gf_xml_sax_parse_file"] =
            createExportWrapper("gf_xml_sax_parse_file"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_binary_file = (Module["_gf_xml_sax_binary_file"] =
            createExportWrapper("gf_xml_sax_binary_file"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_del = (Module["_gf_xml_sax_del"] = createExportWrapper("gf_xml_sax_del"));
        /** @type {function(...*):?} */
        var _gf_list_last = (Module["_gf_list_last"] = createExportWrapper("gf_list_last"));
        /** @type {function(...*):?} */
        var _gf_list_rem_last = (Module["_gf_list_rem_last"] =
            createExportWrapper("gf_list_rem_last"));
        /** @type {function(...*):?} */
        var _gf_gpac_abi_major = (Module["_gf_gpac_abi_major"] =
            createExportWrapper("gf_gpac_abi_major"));
        /** @type {function(...*):?} */
        var _gf_gpac_abi_minor = (Module["_gf_gpac_abi_minor"] =
            createExportWrapper("gf_gpac_abi_minor"));
        /** @type {function(...*):?} */
        var _gf_gpac_abi_micro = (Module["_gf_gpac_abi_micro"] =
            createExportWrapper("gf_gpac_abi_micro"));
        /** @type {function(...*):?} */
        var ___errno_location = createExportWrapper("__errno_location");
        /** @type {function(...*):?} */
        var _gf_rand_init = (Module["_gf_rand_init"] = createExportWrapper("gf_rand_init"));
        /** @type {function(...*):?} */
        var _gf_utc_time_since_1970 = (Module["_gf_utc_time_since_1970"] =
            createExportWrapper("gf_utc_time_since_1970"));
        /** @type {function(...*):?} */
        var _gf_get_user_name = (Module["_gf_get_user_name"] =
            createExportWrapper("gf_get_user_name"));
        /** @type {function(...*):?} */
        var _my_str_upr = (Module["_my_str_upr"] = createExportWrapper("my_str_upr"));
        /** @type {function(...*):?} */
        var _gf_prompt_set_echo_off = (Module["_gf_prompt_set_echo_off"] =
            createExportWrapper("gf_prompt_set_echo_off"));
        /** @type {function(...*):?} */
        var _gf_prompt_get_size = (Module["_gf_prompt_get_size"] =
            createExportWrapper("gf_prompt_get_size"));
        /** @type {function(...*):?} */
        var _gf_net_set_ntp_shift = (Module["_gf_net_set_ntp_shift"] =
            createExportWrapper("gf_net_set_ntp_shift"));
        /** @type {function(...*):?} */
        var _gf_sys_get_argv = (Module["_gf_sys_get_argv"] =
            createExportWrapper("gf_sys_get_argv"));
        /** @type {function(...*):?} */
        var _gf_sys_profiler_set_callback = (Module["_gf_sys_profiler_set_callback"] =
            createExportWrapper("gf_sys_profiler_set_callback"));
        /** @type {function(...*):?} */
        var _gf_sys_profiler_send = (Module["_gf_sys_profiler_send"] =
            createExportWrapper("gf_sys_profiler_send"));
        /** @type {function(...*):?} */
        var _gf_sys_profiler_enable_sampling = (Module["_gf_sys_profiler_enable_sampling"] =
            createExportWrapper("gf_sys_profiler_enable_sampling"));
        /** @type {function(...*):?} */
        var _gf_sys_profiler_sampling_enabled = (Module["_gf_sys_profiler_sampling_enabled"] =
            createExportWrapper("gf_sys_profiler_sampling_enabled"));
        /** @type {function(...*):?} */
        var _gf_blob_get = (Module["_gf_blob_get"] = createExportWrapper("gf_blob_get"));
        /** @type {function(...*):?} */
        var _gf_blob_release = (Module["_gf_blob_release"] =
            createExportWrapper("gf_blob_release"));
        /** @type {function(...*):?} */
        var _gf_blob_register = (Module["_gf_blob_register"] =
            createExportWrapper("gf_blob_register"));
        /** @type {function(...*):?} */
        var _gf_blob_unregister = (Module["_gf_blob_unregister"] =
            createExportWrapper("gf_blob_unregister"));
        /** @type {function(...*):?} */
        var _gf_opts_get_section_count = (Module["_gf_opts_get_section_count"] =
            createExportWrapper("gf_opts_get_section_count"));
        /** @type {function(...*):?} */
        var _gf_opts_get_section_name = (Module["_gf_opts_get_section_name"] = createExportWrapper(
            "gf_opts_get_section_name"
        ));
        /** @type {function(...*):?} */
        var _gf_opts_del_section = (Module["_gf_opts_del_section"] =
            createExportWrapper("gf_opts_del_section"));
        /** @type {function(...*):?} */
        var _gf_mkdir = (Module["_gf_mkdir"] = createExportWrapper("gf_mkdir"));
        /** @type {function(...*):?} */
        var _gf_sys_get_battery_state = (Module["_gf_sys_get_battery_state"] = createExportWrapper(
            "gf_sys_get_battery_state"
        ));
        /** @type {function(...*):?} */
        var _gf_net_get_ntp = (Module["_gf_net_get_ntp"] = createExportWrapper("gf_net_get_ntp"));
        /** @type {function(...*):?} */
        var _gf_net_get_ntp_ts = (Module["_gf_net_get_ntp_ts"] =
            createExportWrapper("gf_net_get_ntp_ts"));
        /** @type {function(...*):?} */
        var _gf_net_ntp_diff_ms = (Module["_gf_net_ntp_diff_ms"] =
            createExportWrapper("gf_net_ntp_diff_ms"));
        /** @type {function(...*):?} */
        var _gf_net_get_ntp_diff_ms = (Module["_gf_net_get_ntp_diff_ms"] =
            createExportWrapper("gf_net_get_ntp_diff_ms"));
        /** @type {function(...*):?} */
        var _gf_net_get_ntp_ms = (Module["_gf_net_get_ntp_ms"] =
            createExportWrapper("gf_net_get_ntp_ms"));
        /** @type {function(...*):?} */
        var _gf_net_get_timezone = (Module["_gf_net_get_timezone"] =
            createExportWrapper("gf_net_get_timezone"));
        /** @type {function(...*):?} */
        var _gf_net_time_is_dst = (Module["_gf_net_time_is_dst"] =
            createExportWrapper("gf_net_time_is_dst"));
        /** @type {function(...*):?} */
        var _gf_net_parse_date = (Module["_gf_net_parse_date"] =
            createExportWrapper("gf_net_parse_date"));
        /** @type {function(...*):?} */
        var _gf_net_get_utc_ts = (Module["_gf_net_get_utc_ts"] =
            createExportWrapper("gf_net_get_utc_ts"));
        /** @type {function(...*):?} */
        var _gf_net_ntp_to_utc = (Module["_gf_net_ntp_to_utc"] =
            createExportWrapper("gf_net_ntp_to_utc"));
        /** @type {function(...*):?} */
        var _gf_bin128_parse = (Module["_gf_bin128_parse"] =
            createExportWrapper("gf_bin128_parse"));
        /** @type {function(...*):?} */
        var _gf_file_load_data_filep = (Module["_gf_file_load_data_filep"] =
            createExportWrapper("gf_file_load_data_filep"));
        /** @type {function(...*):?} */
        var _gf_sys_get_process_id = (Module["_gf_sys_get_process_id"] =
            createExportWrapper("gf_sys_get_process_id"));
        /** @type {function(...*):?} */
        var _gf_creds_check_password = (Module["_gf_creds_check_password"] =
            createExportWrapper("gf_creds_check_password"));
        /** @type {function(...*):?} */
        var _gf_sha256_csum = (Module["_gf_sha256_csum"] = createExportWrapper("gf_sha256_csum"));
        /** @type {function(...*):?} */
        var _gf_cfg_save = (Module["_gf_cfg_save"] = createExportWrapper("gf_cfg_save"));
        /** @type {function(...*):?} */
        var _gf_creds_check_membership = (Module["_gf_creds_check_membership"] =
            createExportWrapper("gf_creds_check_membership"));
        /** @type {function(...*):?} */
        var _gf_token_find_word = (Module["_gf_token_find_word"] =
            createExportWrapper("gf_token_find_word"));
        /** @type {function(...*):?} */
        var _gf_rmdir = (Module["_gf_rmdir"] = createExportWrapper("gf_rmdir"));
        /** @type {function(...*):?} */
        var _gf_dir_cleanup = (Module["_gf_dir_cleanup"] = createExportWrapper("gf_dir_cleanup"));
        /** @type {function(...*):?} */
        var _gf_file_exists_ex = (Module["_gf_file_exists_ex"] =
            createExportWrapper("gf_file_exists_ex"));
        /** @type {function(...*):?} */
        var _gf_fileio_from_url = (Module["_gf_fileio_from_url"] =
            createExportWrapper("gf_fileio_from_url"));
        /** @type {function(...*):?} */
        var _gf_fileio_open_url = (Module["_gf_fileio_open_url"] =
            createExportWrapper("gf_fileio_open_url"));
        /** @type {function(...*):?} */
        var _gf_fileio_resource_url = (Module["_gf_fileio_resource_url"] =
            createExportWrapper("gf_fileio_resource_url"));
        /** @type {function(...*):?} */
        var _gf_file_modification_time = (Module["_gf_file_modification_time"] =
            createExportWrapper("gf_file_modification_time"));
        /** @type {function(...*):?} */
        var _gf_file_handles_count = (Module["_gf_file_handles_count"] =
            createExportWrapper("gf_file_handles_count"));
        /** @type {function(...*):?} */
        var _gf_file_temp = (Module["_gf_file_temp"] = createExportWrapper("gf_file_temp"));
        /** @type {function(...*):?} */
        var _gf_fopen_ex = (Module["_gf_fopen_ex"] = createExportWrapper("gf_fopen_ex"));
        /** @type {function(...*):?} */
        var _gf_fileio_check = (Module["_gf_fileio_check"] =
            createExportWrapper("gf_fileio_check"));
        /** @type {function(...*):?} */
        var _gf_fileio_write_ready = (Module["_gf_fileio_write_ready"] =
            createExportWrapper("gf_fileio_write_ready"));
        /** @type {function(...*):?} */
        var _gf_fileio_write_mode = (Module["_gf_fileio_write_mode"] =
            createExportWrapper("gf_fileio_write_mode"));
        /** @type {function(...*):?} */
        var _gf_fileio_read_mode = (Module["_gf_fileio_read_mode"] =
            createExportWrapper("gf_fileio_read_mode"));
        /** @type {function(...*):?} */
        var _gf_fileio_translate_url = (Module["_gf_fileio_translate_url"] =
            createExportWrapper("gf_fileio_translate_url"));
        /** @type {function(...*):?} */
        var _gf_fileio_factory = (Module["_gf_fileio_factory"] =
            createExportWrapper("gf_fileio_factory"));
        /** @type {function(...*):?} */
        var _gf_fileio_set_write_state = (Module["_gf_fileio_set_write_state"] =
            createExportWrapper("gf_fileio_set_write_state"));
        /** @type {function(...*):?} */
        var _gf_fileio_get_stats = (Module["_gf_fileio_get_stats"] =
            createExportWrapper("gf_fileio_get_stats"));
        /** @type {function(...*):?} */
        var _gf_fileio_tag_main_thread = (Module["_gf_fileio_tag_main_thread"] =
            createExportWrapper("gf_fileio_tag_main_thread"));
        /** @type {function(...*):?} */
        var _gf_fileio_is_main_thread = (Module["_gf_fileio_is_main_thread"] = createExportWrapper(
            "gf_fileio_is_main_thread"
        ));
        /** @type {function(...*):?} */
        var _gf_fgetc = (Module["_gf_fgetc"] = createExportWrapper("gf_fgetc"));
        /** @type {function(...*):?} */
        var _gf_fputc = (Module["_gf_fputc"] = createExportWrapper("gf_fputc"));
        /** @type {function(...*):?} */
        var _gf_fputs = (Module["_gf_fputs"] = createExportWrapper("gf_fputs"));
        /** @type {function(...*):?} */
        var _gf_fprintf = (Module["_gf_fprintf"] = createExportWrapper("gf_fprintf"));
        /** @type {function(...*):?} */
        var _gf_vfprintf = (Module["_gf_vfprintf"] = createExportWrapper("gf_vfprintf"));
        /** @type {function(...*):?} */
        var _gf_fflush = (Module["_gf_fflush"] = createExportWrapper("gf_fflush"));
        /** @type {function(...*):?} */
        var _gf_feof = (Module["_gf_feof"] = createExportWrapper("gf_feof"));
        /** @type {function(...*):?} */
        var _gf_ferror = (Module["_gf_ferror"] = createExportWrapper("gf_ferror"));
        /** @type {function(...*):?} */
        var _gf_list_reset = (Module["_gf_list_reset"] = createExportWrapper("gf_list_reset"));
        /** @type {function(...*):?} */
        var _gf_list_swap = (Module["_gf_list_swap"] = createExportWrapper("gf_list_swap"));
        /** @type {function(...*):?} */
        var _gf_list_transfer = (Module["_gf_list_transfer"] =
            createExportWrapper("gf_list_transfer"));
        /** @type {function(...*):?} */
        var _gf_list_clone = (Module["_gf_list_clone"] = createExportWrapper("gf_list_clone"));
        /** @type {function(...*):?} */
        var _gf_opts_get_int = (Module["_gf_opts_get_int"] =
            createExportWrapper("gf_opts_get_int"));
        /** @type {function(...*):?} */
        var _gf_bs_from_fd = (Module["_gf_bs_from_fd"] = createExportWrapper("gf_bs_from_fd"));
        /** @type {function(...*):?} */
        var _gf_bs_enable_emulation_byte_removal = (Module["_gf_bs_enable_emulation_byte_removal"] =
            createExportWrapper("gf_bs_enable_emulation_byte_removal"));
        /** @type {function(...*):?} */
        var _gf_bs_get_emulation_byte_removed = (Module["_gf_bs_get_emulation_byte_removed"] =
            createExportWrapper("gf_bs_get_emulation_byte_removed"));
        /** @type {function(...*):?} */
        var _gf_bs_read_bit = (Module["_gf_bs_read_bit"] = createExportWrapper("gf_bs_read_bit"));
        /** @type {function(...*):?} */
        var _gf_bs_read_u16 = (Module["_gf_bs_read_u16"] = createExportWrapper("gf_bs_read_u16"));
        /** @type {function(...*):?} */
        var _gf_bs_read_u24 = (Module["_gf_bs_read_u24"] = createExportWrapper("gf_bs_read_u24"));
        /** @type {function(...*):?} */
        var _gf_bs_read_long_int = (Module["_gf_bs_read_long_int"] =
            createExportWrapper("gf_bs_read_long_int"));
        /** @type {function(...*):?} */
        var _gf_bs_read_float = (Module["_gf_bs_read_float"] =
            createExportWrapper("gf_bs_read_float"));
        /** @type {function(...*):?} */
        var _gf_bs_read_double = (Module["_gf_bs_read_double"] =
            createExportWrapper("gf_bs_read_double"));
        /** @type {function(...*):?} */
        var _gf_bs_write_long_int = (Module["_gf_bs_write_long_int"] =
            createExportWrapper("gf_bs_write_long_int"));
        /** @type {function(...*):?} */
        var _gf_bs_write_u8 = (Module["_gf_bs_write_u8"] = createExportWrapper("gf_bs_write_u8"));
        /** @type {function(...*):?} */
        var _gf_bs_write_u16 = (Module["_gf_bs_write_u16"] =
            createExportWrapper("gf_bs_write_u16"));
        /** @type {function(...*):?} */
        var _gf_bs_write_u24 = (Module["_gf_bs_write_u24"] =
            createExportWrapper("gf_bs_write_u24"));
        /** @type {function(...*):?} */
        var _gf_bs_write_u64 = (Module["_gf_bs_write_u64"] =
            createExportWrapper("gf_bs_write_u64"));
        /** @type {function(...*):?} */
        var _gf_bs_write_byte = (Module["_gf_bs_write_byte"] =
            createExportWrapper("gf_bs_write_byte"));
        /** @type {function(...*):?} */
        var _gf_bs_write_float = (Module["_gf_bs_write_float"] =
            createExportWrapper("gf_bs_write_float"));
        /** @type {function(...*):?} */
        var _gf_bs_write_double = (Module["_gf_bs_write_double"] =
            createExportWrapper("gf_bs_write_double"));
        /** @type {function(...*):?} */
        var _gf_bs_align = (Module["_gf_bs_align"] = createExportWrapper("gf_bs_align"));
        /** @type {function(...*):?} */
        var _gf_bs_get_content_no_truncate = (Module["_gf_bs_get_content_no_truncate"] =
            createExportWrapper("gf_bs_get_content_no_truncate"));
        /** @type {function(...*):?} */
        var _gf_bs_peek_bits = (Module["_gf_bs_peek_bits"] =
            createExportWrapper("gf_bs_peek_bits"));
        /** @type {function(...*):?} */
        var _gf_bs_get_refreshed_size = (Module["_gf_bs_get_refreshed_size"] = createExportWrapper(
            "gf_bs_get_refreshed_size"
        ));
        /** @type {function(...*):?} */
        var _gf_bs_bits_available = (Module["_gf_bs_bits_available"] =
            createExportWrapper("gf_bs_bits_available"));
        /** @type {function(...*):?} */
        var _gf_bs_set_eos_callback = (Module["_gf_bs_set_eos_callback"] =
            createExportWrapper("gf_bs_set_eos_callback"));
        /** @type {function(...*):?} */
        var _gf_bs_read_u64_le = (Module["_gf_bs_read_u64_le"] =
            createExportWrapper("gf_bs_read_u64_le"));
        /** @type {function(...*):?} */
        var _gf_bs_read_u32_le = (Module["_gf_bs_read_u32_le"] =
            createExportWrapper("gf_bs_read_u32_le"));
        /** @type {function(...*):?} */
        var _gf_bs_read_u16_le = (Module["_gf_bs_read_u16_le"] =
            createExportWrapper("gf_bs_read_u16_le"));
        /** @type {function(...*):?} */
        var _gf_bs_write_u64_le = (Module["_gf_bs_write_u64_le"] =
            createExportWrapper("gf_bs_write_u64_le"));
        /** @type {function(...*):?} */
        var _gf_bs_write_u32_le = (Module["_gf_bs_write_u32_le"] =
            createExportWrapper("gf_bs_write_u32_le"));
        /** @type {function(...*):?} */
        var _gf_bs_write_u16_le = (Module["_gf_bs_write_u16_le"] =
            createExportWrapper("gf_bs_write_u16_le"));
        /** @type {function(...*):?} */
        var _gf_bs_get_bit_offset = (Module["_gf_bs_get_bit_offset"] =
            createExportWrapper("gf_bs_get_bit_offset"));
        /** @type {function(...*):?} */
        var _gf_bs_get_bit_position = (Module["_gf_bs_get_bit_position"] =
            createExportWrapper("gf_bs_get_bit_position"));
        /** @type {function(...*):?} */
        var _gf_bs_read_vluimsbf5 = (Module["_gf_bs_read_vluimsbf5"] =
            createExportWrapper("gf_bs_read_vluimsbf5"));
        /** @type {function(...*):?} */
        var _gf_bs_truncate = (Module["_gf_bs_truncate"] = createExportWrapper("gf_bs_truncate"));
        /** @type {function(...*):?} */
        var _gf_bs_transfer = (Module["_gf_bs_transfer"] = createExportWrapper("gf_bs_transfer"));
        /** @type {function(...*):?} */
        var _gf_bs_flush = (Module["_gf_bs_flush"] = createExportWrapper("gf_bs_flush"));
        /** @type {function(...*):?} */
        var _gf_bs_insert_data = (Module["_gf_bs_insert_data"] =
            createExportWrapper("gf_bs_insert_data"));
        /** @type {function(...*):?} */
        var _gf_bs_write_utf8 = (Module["_gf_bs_write_utf8"] =
            createExportWrapper("gf_bs_write_utf8"));
        /** @type {function(...*):?} */
        var _gf_codecid_parse = (Module["_gf_codecid_parse"] =
            createExportWrapper("gf_codecid_parse"));
        /** @type {function(...*):?} */
        var _gf_codecid_file_ext = (Module["_gf_codecid_file_ext"] =
            createExportWrapper("gf_codecid_file_ext"));
        /** @type {function(...*):?} */
        var _gf_codecid_oti = (Module["_gf_codecid_oti"] = createExportWrapper("gf_codecid_oti"));
        /** @type {function(...*):?} */
        var _gf_codecid_has_unframer = (Module["_gf_codecid_has_unframer"] =
            createExportWrapper("gf_codecid_has_unframer"));
        /** @type {function(...*):?} */
        var _gf_stream_type_short_name = (Module["_gf_stream_type_short_name"] =
            createExportWrapper("gf_stream_type_short_name"));
        /** @type {function(...*):?} */
        var _gf_stream_type_by_name = (Module["_gf_stream_type_by_name"] =
            createExportWrapper("gf_stream_type_by_name"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_parse = (Module["_gf_audio_fmt_parse"] =
            createExportWrapper("gf_audio_fmt_parse"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_name = (Module["_gf_audio_fmt_name"] =
            createExportWrapper("gf_audio_fmt_name"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_sname = (Module["_gf_audio_fmt_sname"] =
            createExportWrapper("gf_audio_fmt_sname"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_bit_depth = (Module["_gf_audio_fmt_bit_depth"] =
            createExportWrapper("gf_audio_fmt_bit_depth"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_is_planar = (Module["_gf_audio_fmt_is_planar"] =
            createExportWrapper("gf_audio_fmt_is_planar"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_from_isobmf = (Module["_gf_audio_fmt_from_isobmf"] = createExportWrapper(
            "gf_audio_fmt_from_isobmf"
        ));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_to_isobmf = (Module["_gf_audio_fmt_to_isobmf"] =
            createExportWrapper("gf_audio_fmt_to_isobmf"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_get_cicp_layout = (Module["_gf_audio_fmt_get_cicp_layout"] =
            createExportWrapper("gf_audio_fmt_get_cicp_layout"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_get_layout_from_cicp = (Module["_gf_audio_fmt_get_layout_from_cicp"] =
            createExportWrapper("gf_audio_fmt_get_layout_from_cicp"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_get_layout_from_name = (Module["_gf_audio_fmt_get_layout_from_name"] =
            createExportWrapper("gf_audio_fmt_get_layout_from_name"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_get_cicp_from_layout = (Module["_gf_audio_fmt_get_cicp_from_layout"] =
            createExportWrapper("gf_audio_fmt_get_cicp_from_layout"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_get_num_channels_from_layout = (Module[
            "_gf_audio_fmt_get_num_channels_from_layout"
        ] = createExportWrapper("gf_audio_fmt_get_num_channels_from_layout"));
        /** @type {function(...*):?} */
        var _gf_audio_fmt_get_dolby_chanmap = (Module["_gf_audio_fmt_get_dolby_chanmap"] =
            createExportWrapper("gf_audio_fmt_get_dolby_chanmap"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_parse = (Module["_gf_pixel_fmt_parse"] =
            createExportWrapper("gf_pixel_fmt_parse"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_probe = (Module["_gf_pixel_fmt_probe"] =
            createExportWrapper("gf_pixel_fmt_probe"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_sname = (Module["_gf_pixel_fmt_sname"] =
            createExportWrapper("gf_pixel_fmt_sname"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_is_yuv = (Module["_gf_pixel_fmt_is_yuv"] =
            createExportWrapper("gf_pixel_fmt_is_yuv"));
        /** @type {function(...*):?} */
        var _gf_pixel_get_size_info = (Module["_gf_pixel_get_size_info"] =
            createExportWrapper("gf_pixel_get_size_info"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_is_transparent = (Module["_gf_pixel_fmt_is_transparent"] =
            createExportWrapper("gf_pixel_fmt_is_transparent"));
        /** @type {function(...*):?} */
        var _gf_pixel_is_wide_depth = (Module["_gf_pixel_is_wide_depth"] =
            createExportWrapper("gf_pixel_is_wide_depth"));
        /** @type {function(...*):?} */
        var _gf_pixel_get_bytes_per_pixel = (Module["_gf_pixel_get_bytes_per_pixel"] =
            createExportWrapper("gf_pixel_get_bytes_per_pixel"));
        /** @type {function(...*):?} */
        var _gf_pixel_get_nb_comp = (Module["_gf_pixel_get_nb_comp"] =
            createExportWrapper("gf_pixel_get_nb_comp"));
        /** @type {function(...*):?} */
        var _gf_itags_find_by_id3tag = (Module["_gf_itags_find_by_id3tag"] =
            createExportWrapper("gf_itags_find_by_id3tag"));
        /** @type {function(...*):?} */
        var _gf_itags_get_id3tag = (Module["_gf_itags_get_id3tag"] =
            createExportWrapper("gf_itags_get_id3tag"));
        /** @type {function(...*):?} */
        var _gf_itags_enum_tags = (Module["_gf_itags_enum_tags"] =
            createExportWrapper("gf_itags_enum_tags"));
        /** @type {function(...*):?} */
        var _gf_id3_get_genre_tag = (Module["_gf_id3_get_genre_tag"] =
            createExportWrapper("gf_id3_get_genre_tag"));
        /** @type {function(...*):?} */
        var _gf_cicp_color_primaries_all_names = (Module["_gf_cicp_color_primaries_all_names"] =
            createExportWrapper("gf_cicp_color_primaries_all_names"));
        /** @type {function(...*):?} */
        var _gf_cicp_color_transfer_all_names = (Module["_gf_cicp_color_transfer_all_names"] =
            createExportWrapper("gf_cicp_color_transfer_all_names"));
        /** @type {function(...*):?} */
        var _gf_cicp_color_matrix_all_names = (Module["_gf_cicp_color_matrix_all_names"] =
            createExportWrapper("gf_cicp_color_matrix_all_names"));
        /** @type {function(...*):?} */
        var _gf_timestamp_rescale_signed = (Module["_gf_timestamp_rescale_signed"] =
            createExportWrapper("gf_timestamp_rescale_signed"));
        /** @type {function(...*):?} */
        var _gf_timestamp_less_or_equal = (Module["_gf_timestamp_less_or_equal"] =
            createExportWrapper("gf_timestamp_less_or_equal"));
        /** @type {function(...*):?} */
        var _gf_timestamp_greater = (Module["_gf_timestamp_greater"] =
            createExportWrapper("gf_timestamp_greater"));
        /** @type {function(...*):?} */
        var _gf_timestamp_greater_or_equal = (Module["_gf_timestamp_greater_or_equal"] =
            createExportWrapper("gf_timestamp_greater_or_equal"));
        /** @type {function(...*):?} */
        var _gf_timestamp_equal = (Module["_gf_timestamp_equal"] =
            createExportWrapper("gf_timestamp_equal"));
        /** @type {function(...*):?} */
        var _gf_pixel_fmt_get_uncc = (Module["_gf_pixel_fmt_get_uncc"] =
            createExportWrapper("gf_pixel_fmt_get_uncc"));
        /** @type {function(...*):?} */
        var _gf_4cc_to_str_safe = (Module["_gf_4cc_to_str_safe"] =
            createExportWrapper("gf_4cc_to_str_safe"));
        /** @type {function(...*):?} */
        var _gf_4cc_parse = (Module["_gf_4cc_parse"] = createExportWrapper("gf_4cc_parse"));
        /** @type {function(...*):?} */
        var _gf_log_set_strict_error = (Module["_gf_log_set_strict_error"] =
            createExportWrapper("gf_log_set_strict_error"));
        /** @type {function(...*):?} */
        var _gf_sys_set_console_code = (Module["_gf_sys_set_console_code"] =
            createExportWrapper("gf_sys_set_console_code"));
        /** @type {function(...*):?} */
        var _gf_log_tool_name = (Module["_gf_log_tool_name"] =
            createExportWrapper("gf_log_tool_name"));
        /** @type {function(...*):?} */
        var _gf_log_use_color = (Module["_gf_log_use_color"] =
            createExportWrapper("gf_log_use_color"));
        /** @type {function(...*):?} */
        var _gf_log_va_list = (Module["_gf_log_va_list"] = createExportWrapper("gf_log_va_list"));
        /** @type {function(...*):?} */
        var _malloc = createExportWrapper("malloc");
        /** @type {function(...*):?} */
        var _free = createExportWrapper("free");
        /** @type {function(...*):?} */
        var _gf_url_is_local = (Module["_gf_url_is_local"] =
            createExportWrapper("gf_url_is_local"));
        /** @type {function(...*):?} */
        var _gf_url_is_relative = (Module["_gf_url_is_relative"] =
            createExportWrapper("gf_url_is_relative"));
        /** @type {function(...*):?} */
        var _gf_url_get_absolute_path = (Module["_gf_url_get_absolute_path"] = createExportWrapper(
            "gf_url_get_absolute_path"
        ));
        /** @type {function(...*):?} */
        var _gf_url_concatenate_parent = (Module["_gf_url_concatenate_parent"] =
            createExportWrapper("gf_url_concatenate_parent"));
        /** @type {function(...*):?} */
        var _gf_url_to_fs_path = (Module["_gf_url_to_fs_path"] =
            createExportWrapper("gf_url_to_fs_path"));
        /** @type {function(...*):?} */
        var _gf_url_get_path = (Module["_gf_url_get_path"] =
            createExportWrapper("gf_url_get_path"));
        /** @type {function(...*):?} */
        var _gf_url_free = (Module["_gf_url_free"] = createExportWrapper("gf_url_free"));
        /** @type {function(...*):?} */
        var _gf_cfg_get_filename = (Module["_gf_cfg_get_filename"] =
            createExportWrapper("gf_cfg_get_filename"));
        /** @type {function(...*):?} */
        var _gf_cfg_get_section_count = (Module["_gf_cfg_get_section_count"] = createExportWrapper(
            "gf_cfg_get_section_count"
        ));
        /** @type {function(...*):?} */
        var _gf_cfg_get_section_name = (Module["_gf_cfg_get_section_name"] =
            createExportWrapper("gf_cfg_get_section_name"));
        /** @type {function(...*):?} */
        var _gf_gzopen = (Module["_gf_gzopen"] = createExportWrapper("gf_gzopen"));
        /** @type {function(...*):?} */
        var _gf_gzread = (Module["_gf_gzread"] = createExportWrapper("gf_gzread"));
        /** @type {function(...*):?} */
        var _gf_gzgetc = (Module["_gf_gzgetc"] = createExportWrapper("gf_gzgetc"));
        /** @type {function(...*):?} */
        var _gf_gzgets = (Module["_gf_gzgets"] = createExportWrapper("gf_gzgets"));
        /** @type {function(...*):?} */
        var _gf_gzrewind = (Module["_gf_gzrewind"] = createExportWrapper("gf_gzrewind"));
        /** @type {function(...*):?} */
        var _gf_gzseek = (Module["_gf_gzseek"] = createExportWrapper("gf_gzseek"));
        /** @type {function(...*):?} */
        var _gf_gztell = (Module["_gf_gztell"] = createExportWrapper("gf_gztell"));
        /** @type {function(...*):?} */
        var _gf_gzeof = (Module["_gf_gzeof"] = createExportWrapper("gf_gzeof"));
        /** @type {function(...*):?} */
        var _gf_gzdirect = (Module["_gf_gzdirect"] = createExportWrapper("gf_gzdirect"));
        /** @type {function(...*):?} */
        var _gf_gzclose = (Module["_gf_gzclose"] = createExportWrapper("gf_gzclose"));
        /** @type {function(...*):?} */
        var _gf_gzerror = (Module["_gf_gzerror"] = createExportWrapper("gf_gzerror"));
        /** @type {function(...*):?} */
        var _gf_gzclearerr = (Module["_gf_gzclearerr"] = createExportWrapper("gf_gzclearerr"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_parse = (Module["_gf_xml_sax_parse"] =
            createExportWrapper("gf_xml_sax_parse"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_init = (Module["_gf_xml_sax_init"] =
            createExportWrapper("gf_xml_sax_init"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_suspend = (Module["_gf_xml_sax_suspend"] =
            createExportWrapper("gf_xml_sax_suspend"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_get_line = (Module["_gf_xml_sax_get_line"] =
            createExportWrapper("gf_xml_sax_get_line"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_peek_node = (Module["_gf_xml_sax_peek_node"] =
            createExportWrapper("gf_xml_sax_peek_node"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_get_error = (Module["_gf_xml_sax_get_error"] =
            createExportWrapper("gf_xml_sax_get_error"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_get_node_start_pos = (Module["_gf_xml_sax_get_node_start_pos"] =
            createExportWrapper("gf_xml_sax_get_node_start_pos"));
        /** @type {function(...*):?} */
        var _gf_xml_sax_get_node_end_pos = (Module["_gf_xml_sax_get_node_end_pos"] =
            createExportWrapper("gf_xml_sax_get_node_end_pos"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_node_reset = (Module["_gf_xml_dom_node_reset"] =
            createExportWrapper("gf_xml_dom_node_reset"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_node_del = (Module["_gf_xml_dom_node_del"] =
            createExportWrapper("gf_xml_dom_node_del"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_detach_root = (Module["_gf_xml_dom_detach_root"] =
            createExportWrapper("gf_xml_dom_detach_root"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_parse_string = (Module["_gf_xml_dom_parse_string"] =
            createExportWrapper("gf_xml_dom_parse_string"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_get_root_nodes_count = (Module["_gf_xml_dom_get_root_nodes_count"] =
            createExportWrapper("gf_xml_dom_get_root_nodes_count"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_serialize = (Module["_gf_xml_dom_serialize"] =
            createExportWrapper("gf_xml_dom_serialize"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_serialize_root = (Module["_gf_xml_dom_serialize_root"] =
            createExportWrapper("gf_xml_dom_serialize_root"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_create_attribute = (Module["_gf_xml_dom_create_attribute"] =
            createExportWrapper("gf_xml_dom_create_attribute"));
        /** @type {function(...*):?} */
        var _gf_xml_dom_append_child = (Module["_gf_xml_dom_append_child"] =
            createExportWrapper("gf_xml_dom_append_child"));
        /** @type {function(...*):?} */
        var _gf_base64_encode = (Module["_gf_base64_encode"] =
            createExportWrapper("gf_base64_encode"));
        /** @type {function(...*):?} */
        var _gf_sha1_file_ptr = (Module["_gf_sha1_file_ptr"] =
            createExportWrapper("gf_sha1_file_ptr"));
        /** @type {function(...*):?} */
        var _gf_sha1_file = (Module["_gf_sha1_file"] = createExportWrapper("gf_sha1_file"));
        /** @type {function(...*):?} */
        var _gf_base16_encode = (Module["_gf_base16_encode"] =
            createExportWrapper("gf_base16_encode"));
        /** @type {function(...*):?} */
        var _gf_base16_decode = (Module["_gf_base16_decode"] =
            createExportWrapper("gf_base16_decode"));
        /** @type {function(...*):?} */
        var _gf_gz_compress_payload_ex = (Module["_gf_gz_compress_payload_ex"] =
            createExportWrapper("gf_gz_compress_payload_ex"));
        /** @type {function(...*):?} */
        var _gf_gz_decompress_payload_ex = (Module["_gf_gz_decompress_payload_ex"] =
            createExportWrapper("gf_gz_decompress_payload_ex"));
        /** @type {function(...*):?} */
        var _gf_gz_decompress_payload = (Module["_gf_gz_decompress_payload"] = createExportWrapper(
            "gf_gz_decompress_payload"
        ));
        /** @type {function(...*):?} */
        var _gf_lz_decompress_payload = (Module["_gf_lz_decompress_payload"] = createExportWrapper(
            "gf_lz_decompress_payload"
        ));
        /** @type {function(...*):?} */
        var _gf_lz_compress_payload = (Module["_gf_lz_compress_payload"] =
            createExportWrapper("gf_lz_compress_payload"));
        /** @type {function(...*):?} */
        var _gf_get_bit_size = (Module["_gf_get_bit_size"] =
            createExportWrapper("gf_get_bit_size"));
        /** @type {function(...*):?} */
        var _gf_irect_union = (Module["_gf_irect_union"] = createExportWrapper("gf_irect_union"));
        /** @type {function(...*):?} */
        var _gf_v2d_from_polar = (Module["_gf_v2d_from_polar"] =
            createExportWrapper("gf_v2d_from_polar"));
        /** @type {function(...*):?} */
        var _gf_v2d_len = (Module["_gf_v2d_len"] = createExportWrapper("gf_v2d_len"));
        /** @type {function(...*):?} */
        var _gf_v2d_distance = (Module["_gf_v2d_distance"] =
            createExportWrapper("gf_v2d_distance"));
        /** @type {function(...*):?} */
        var _gf_angle_diff = (Module["_gf_angle_diff"] = createExportWrapper("gf_angle_diff"));
        /** @type {function(...*):?} */
        var _gf_mx2d_add_matrix = (Module["_gf_mx2d_add_matrix"] =
            createExportWrapper("gf_mx2d_add_matrix"));
        /** @type {function(...*):?} */
        var _gf_mx2d_pre_multiply = (Module["_gf_mx2d_pre_multiply"] =
            createExportWrapper("gf_mx2d_pre_multiply"));
        /** @type {function(...*):?} */
        var _gf_mx2d_add_translation = (Module["_gf_mx2d_add_translation"] =
            createExportWrapper("gf_mx2d_add_translation"));
        /** @type {function(...*):?} */
        var _gf_mx2d_add_rotation = (Module["_gf_mx2d_add_rotation"] =
            createExportWrapper("gf_mx2d_add_rotation"));
        /** @type {function(...*):?} */
        var _gf_mx2d_add_scale = (Module["_gf_mx2d_add_scale"] =
            createExportWrapper("gf_mx2d_add_scale"));
        /** @type {function(...*):?} */
        var _gf_mx2d_add_scale_at = (Module["_gf_mx2d_add_scale_at"] =
            createExportWrapper("gf_mx2d_add_scale_at"));
        /** @type {function(...*):?} */
        var _gf_mx2d_add_skew = (Module["_gf_mx2d_add_skew"] =
            createExportWrapper("gf_mx2d_add_skew"));
        /** @type {function(...*):?} */
        var _gf_mx2d_add_skew_x = (Module["_gf_mx2d_add_skew_x"] =
            createExportWrapper("gf_mx2d_add_skew_x"));
        /** @type {function(...*):?} */
        var _gf_mx2d_add_skew_y = (Module["_gf_mx2d_add_skew_y"] =
            createExportWrapper("gf_mx2d_add_skew_y"));
        /** @type {function(...*):?} */
        var _gf_mx2d_inverse = (Module["_gf_mx2d_inverse"] =
            createExportWrapper("gf_mx2d_inverse"));
        /** @type {function(...*):?} */
        var _gf_mx2d_decompose = (Module["_gf_mx2d_decompose"] =
            createExportWrapper("gf_mx2d_decompose"));
        /** @type {function(...*):?} */
        var _gf_mx2d_apply_coords = (Module["_gf_mx2d_apply_coords"] =
            createExportWrapper("gf_mx2d_apply_coords"));
        /** @type {function(...*):?} */
        var _gf_mx2d_apply_point = (Module["_gf_mx2d_apply_point"] =
            createExportWrapper("gf_mx2d_apply_point"));
        /** @type {function(...*):?} */
        var _gf_mx2d_apply_rect = (Module["_gf_mx2d_apply_rect"] =
            createExportWrapper("gf_mx2d_apply_rect"));
        /** @type {function(...*):?} */
        var _gf_rect_pixelize = (Module["_gf_rect_pixelize"] =
            createExportWrapper("gf_rect_pixelize"));
        /** @type {function(...*):?} */
        var _gf_rect_union = (Module["_gf_rect_union"] = createExportWrapper("gf_rect_union"));
        /** @type {function(...*):?} */
        var _gf_rect_center = (Module["_gf_rect_center"] = createExportWrapper("gf_rect_center"));
        /** @type {function(...*):?} */
        var _gf_rect_overlaps = (Module["_gf_rect_overlaps"] =
            createExportWrapper("gf_rect_overlaps"));
        /** @type {function(...*):?} */
        var _gf_rect_equal = (Module["_gf_rect_equal"] = createExportWrapper("gf_rect_equal"));
        /** @type {function(...*):?} */
        var _gf_rect_intersect = (Module["_gf_rect_intersect"] =
            createExportWrapper("gf_rect_intersect"));
        /** @type {function(...*):?} */
        var _gf_vec_len_p = (Module["_gf_vec_len_p"] = createExportWrapper("gf_vec_len_p"));
        /** @type {function(...*):?} */
        var _gf_vec_len = (Module["_gf_vec_len"] = createExportWrapper("gf_vec_len"));
        /** @type {function(...*):?} */
        var _gf_vec_lensq_p = (Module["_gf_vec_lensq_p"] = createExportWrapper("gf_vec_lensq_p"));
        /** @type {function(...*):?} */
        var _gf_vec_lensq = (Module["_gf_vec_lensq"] = createExportWrapper("gf_vec_lensq"));
        /** @type {function(...*):?} */
        var _gf_vec_dot_p = (Module["_gf_vec_dot_p"] = createExportWrapper("gf_vec_dot_p"));
        /** @type {function(...*):?} */
        var _gf_vec_dot = (Module["_gf_vec_dot"] = createExportWrapper("gf_vec_dot"));
        /** @type {function(...*):?} */
        var _gf_vec_norm = (Module["_gf_vec_norm"] = createExportWrapper("gf_vec_norm"));
        /** @type {function(...*):?} */
        var _gf_vec_scale_p = (Module["_gf_vec_scale_p"] = createExportWrapper("gf_vec_scale_p"));
        /** @type {function(...*):?} */
        var _gf_vec_scale = (Module["_gf_vec_scale"] = createExportWrapper("gf_vec_scale"));
        /** @type {function(...*):?} */
        var _gf_vec_cross_p = (Module["_gf_vec_cross_p"] = createExportWrapper("gf_vec_cross_p"));
        /** @type {function(...*):?} */
        var _gf_vec_cross = (Module["_gf_vec_cross"] = createExportWrapper("gf_vec_cross"));
        /** @type {function(...*):?} */
        var _gf_mx2d_from_mx = (Module["_gf_mx2d_from_mx"] =
            createExportWrapper("gf_mx2d_from_mx"));
        /** @type {function(...*):?} */
        var _gf_mx_apply_rect = (Module["_gf_mx_apply_rect"] =
            createExportWrapper("gf_mx_apply_rect"));
        /** @type {function(...*):?} */
        var _gf_mx_add_matrix = (Module["_gf_mx_add_matrix"] =
            createExportWrapper("gf_mx_add_matrix"));
        /** @type {function(...*):?} */
        var _gf_mx_add_matrix_2d = (Module["_gf_mx_add_matrix_2d"] =
            createExportWrapper("gf_mx_add_matrix_2d"));
        /** @type {function(...*):?} */
        var _gf_mx_add_translation = (Module["_gf_mx_add_translation"] =
            createExportWrapper("gf_mx_add_translation"));
        /** @type {function(...*):?} */
        var _gf_mx_add_scale = (Module["_gf_mx_add_scale"] =
            createExportWrapper("gf_mx_add_scale"));
        /** @type {function(...*):?} */
        var _gf_mx_add_rotation = (Module["_gf_mx_add_rotation"] =
            createExportWrapper("gf_mx_add_rotation"));
        /** @type {function(...*):?} */
        var _gf_mx_from_mx2d = (Module["_gf_mx_from_mx2d"] =
            createExportWrapper("gf_mx_from_mx2d"));
        /** @type {function(...*):?} */
        var _gf_mx_equal = (Module["_gf_mx_equal"] = createExportWrapper("gf_mx_equal"));
        /** @type {function(...*):?} */
        var _gf_mx_inverse = (Module["_gf_mx_inverse"] = createExportWrapper("gf_mx_inverse"));
        /** @type {function(...*):?} */
        var _gf_mx_transpose = (Module["_gf_mx_transpose"] =
            createExportWrapper("gf_mx_transpose"));
        /** @type {function(...*):?} */
        var _gf_mx_apply_vec = (Module["_gf_mx_apply_vec"] =
            createExportWrapper("gf_mx_apply_vec"));
        /** @type {function(...*):?} */
        var _gf_mx_ortho = (Module["_gf_mx_ortho"] = createExportWrapper("gf_mx_ortho"));
        /** @type {function(...*):?} */
        var _gf_mx_ortho_reverse_z = (Module["_gf_mx_ortho_reverse_z"] =
            createExportWrapper("gf_mx_ortho_reverse_z"));
        /** @type {function(...*):?} */
        var _gf_mx_perspective = (Module["_gf_mx_perspective"] =
            createExportWrapper("gf_mx_perspective"));
        /** @type {function(...*):?} */
        var _gf_mx_perspective_reverse_z = (Module["_gf_mx_perspective_reverse_z"] =
            createExportWrapper("gf_mx_perspective_reverse_z"));
        /** @type {function(...*):?} */
        var _gf_mx_lookat = (Module["_gf_mx_lookat"] = createExportWrapper("gf_mx_lookat"));
        /** @type {function(...*):?} */
        var _gf_mx_get_yaw_pitch_roll = (Module["_gf_mx_get_yaw_pitch_roll"] = createExportWrapper(
            "gf_mx_get_yaw_pitch_roll"
        ));
        /** @type {function(...*):?} */
        var _gf_mx_decompose = (Module["_gf_mx_decompose"] =
            createExportWrapper("gf_mx_decompose"));
        /** @type {function(...*):?} */
        var _gf_quat_from_matrix = (Module["_gf_quat_from_matrix"] =
            createExportWrapper("gf_quat_from_matrix"));
        /** @type {function(...*):?} */
        var _gf_quat_to_rotation = (Module["_gf_quat_to_rotation"] =
            createExportWrapper("gf_quat_to_rotation"));
        /** @type {function(...*):?} */
        var _gf_mx_apply_bbox_sphere = (Module["_gf_mx_apply_bbox_sphere"] =
            createExportWrapper("gf_mx_apply_bbox_sphere"));
        /** @type {function(...*):?} */
        var _gf_bbox_refresh = (Module["_gf_bbox_refresh"] =
            createExportWrapper("gf_bbox_refresh"));
        /** @type {function(...*):?} */
        var _gf_mx_apply_bbox = (Module["_gf_mx_apply_bbox"] =
            createExportWrapper("gf_mx_apply_bbox"));
        /** @type {function(...*):?} */
        var _gf_mx_apply_bbox_4x4 = (Module["_gf_mx_apply_bbox_4x4"] =
            createExportWrapper("gf_mx_apply_bbox_4x4"));
        /** @type {function(...*):?} */
        var _gf_mx_apply_vec_4x4 = (Module["_gf_mx_apply_vec_4x4"] =
            createExportWrapper("gf_mx_apply_vec_4x4"));
        /** @type {function(...*):?} */
        var _gf_mx_rotate_vector = (Module["_gf_mx_rotate_vector"] =
            createExportWrapper("gf_mx_rotate_vector"));
        /** @type {function(...*):?} */
        var _gf_mx_rotation_matrix_from_vectors = (Module["_gf_mx_rotation_matrix_from_vectors"] =
            createExportWrapper("gf_mx_rotation_matrix_from_vectors"));
        /** @type {function(...*):?} */
        var _gf_mx_add_matrix_4x4 = (Module["_gf_mx_add_matrix_4x4"] =
            createExportWrapper("gf_mx_add_matrix_4x4"));
        /** @type {function(...*):?} */
        var _gf_mx_inverse_4x4 = (Module["_gf_mx_inverse_4x4"] =
            createExportWrapper("gf_mx_inverse_4x4"));
        /** @type {function(...*):?} */
        var _gf_plane_intersect_line = (Module["_gf_plane_intersect_line"] =
            createExportWrapper("gf_plane_intersect_line"));
        /** @type {function(...*):?} */
        var _gf_ray = (Module["_gf_ray"] = createExportWrapper("gf_ray"));
        /** @type {function(...*):?} */
        var _gf_mx_apply_ray = (Module["_gf_mx_apply_ray"] =
            createExportWrapper("gf_mx_apply_ray"));
        /** @type {function(...*):?} */
        var _gf_ray_hit_box = (Module["_gf_ray_hit_box"] = createExportWrapper("gf_ray_hit_box"));
        /** @type {function(...*):?} */
        var _gf_ray_hit_sphere = (Module["_gf_ray_hit_sphere"] =
            createExportWrapper("gf_ray_hit_sphere"));
        /** @type {function(...*):?} */
        var _gf_ray_hit_triangle = (Module["_gf_ray_hit_triangle"] =
            createExportWrapper("gf_ray_hit_triangle"));
        /** @type {function(...*):?} */
        var _gf_closest_point_to_line = (Module["_gf_closest_point_to_line"] = createExportWrapper(
            "gf_closest_point_to_line"
        ));
        /** @type {function(...*):?} */
        var _gf_quat_from_rotation = (Module["_gf_quat_from_rotation"] =
            createExportWrapper("gf_quat_from_rotation"));
        /** @type {function(...*):?} */
        var _gf_quat_from_axis_cos = (Module["_gf_quat_from_axis_cos"] =
            createExportWrapper("gf_quat_from_axis_cos"));
        /** @type {function(...*):?} */
        var _gf_quat_get_inv = (Module["_gf_quat_get_inv"] =
            createExportWrapper("gf_quat_get_inv"));
        /** @type {function(...*):?} */
        var _gf_quat_multiply = (Module["_gf_quat_multiply"] =
            createExportWrapper("gf_quat_multiply"));
        /** @type {function(...*):?} */
        var _gf_quat_rotate = (Module["_gf_quat_rotate"] = createExportWrapper("gf_quat_rotate"));
        /** @type {function(...*):?} */
        var _gf_quat_slerp = (Module["_gf_quat_slerp"] = createExportWrapper("gf_quat_slerp"));
        /** @type {function(...*):?} */
        var _gf_bbox_from_rect = (Module["_gf_bbox_from_rect"] =
            createExportWrapper("gf_bbox_from_rect"));
        /** @type {function(...*):?} */
        var _gf_rect_from_bbox = (Module["_gf_rect_from_bbox"] =
            createExportWrapper("gf_rect_from_bbox"));
        /** @type {function(...*):?} */
        var _gf_bbox_grow_point = (Module["_gf_bbox_grow_point"] =
            createExportWrapper("gf_bbox_grow_point"));
        /** @type {function(...*):?} */
        var _gf_bbox_union = (Module["_gf_bbox_union"] = createExportWrapper("gf_bbox_union"));
        /** @type {function(...*):?} */
        var _gf_bbox_equal = (Module["_gf_bbox_equal"] = createExportWrapper("gf_bbox_equal"));
        /** @type {function(...*):?} */
        var _gf_bbox_point_inside = (Module["_gf_bbox_point_inside"] =
            createExportWrapper("gf_bbox_point_inside"));
        /** @type {function(...*):?} */
        var _gf_bbox_get_vertices = (Module["_gf_bbox_get_vertices"] =
            createExportWrapper("gf_bbox_get_vertices"));
        /** @type {function(...*):?} */
        var _gf_mx_apply_plane = (Module["_gf_mx_apply_plane"] =
            createExportWrapper("gf_mx_apply_plane"));
        /** @type {function(...*):?} */
        var _gf_plane_get_distance = (Module["_gf_plane_get_distance"] =
            createExportWrapper("gf_plane_get_distance"));
        /** @type {function(...*):?} */
        var _gf_plane_get_p_vertex_idx = (Module["_gf_plane_get_p_vertex_idx"] =
            createExportWrapper("gf_plane_get_p_vertex_idx"));
        /** @type {function(...*):?} */
        var _gf_bbox_plane_relation = (Module["_gf_bbox_plane_relation"] =
            createExportWrapper("gf_bbox_plane_relation"));
        /** @type {function(...*):?} */
        var _gf_get_next_pow2 = (Module["_gf_get_next_pow2"] =
            createExportWrapper("gf_get_next_pow2"));
        /** @type {function(...*):?} */
        var _gf_htonl = (Module["_gf_htonl"] = createExportWrapper("gf_htonl"));
        /** @type {function(...*):?} */
        var _gf_ntohl = (Module["_gf_ntohl"] = createExportWrapper("gf_ntohl"));
        /** @type {function(...*):?} */
        var _gf_htons = (Module["_gf_htons"] = createExportWrapper("gf_htons"));
        /** @type {function(...*):?} */
        var _gf_ntohs = (Module["_gf_ntohs"] = createExportWrapper("gf_ntohs"));
        /** @type {function(...*):?} */
        var _gf_errno_str = (Module["_gf_errno_str"] = createExportWrapper("gf_errno_str"));
        /** @type {function(...*):?} */
        var _gf_get_default_font_dir = (Module["_gf_get_default_font_dir"] =
            createExportWrapper("gf_get_default_font_dir"));
        /** @type {function(...*):?} */
        var _gf_opts_get_key_restricted = (Module["_gf_opts_get_key_restricted"] =
            createExportWrapper("gf_opts_get_key_restricted"));
        /** @type {function(...*):?} */
        var _gf_opts_save = (Module["_gf_opts_save"] = createExportWrapper("gf_opts_save"));
        /** @type {function(...*):?} */
        var _gf_sys_set_cfg_option = (Module["_gf_sys_set_cfg_option"] =
            createExportWrapper("gf_sys_set_cfg_option"));
        /** @type {function(...*):?} */
        var _gf_dm_sess_new = (Module["_gf_dm_sess_new"] = createExportWrapper("gf_dm_sess_new"));
        /** @type {function(...*):?} */
        var _gf_dm_sess_push_header = (Module["_gf_dm_sess_push_header"] =
            createExportWrapper("gf_dm_sess_push_header"));
        /** @type {function(...*):?} */
        var _gf_dm_sess_async_reply = (Module["_gf_dm_sess_async_reply"] =
            createExportWrapper("gf_dm_sess_async_reply"));
        /** @type {function(...*):?} */
        var _gf_utf8_mbstowcs = (Module["_gf_utf8_mbstowcs"] =
            createExportWrapper("gf_utf8_mbstowcs"));
        /** @type {function(...*):?} */
        var _gf_utf_get_utf8_string_from_bom = (Module["_gf_utf_get_utf8_string_from_bom"] =
            createExportWrapper("gf_utf_get_utf8_string_from_bom"));
        /** @type {function(...*):?} */
        var _gf_token_get = (Module["_gf_token_get"] = createExportWrapper("gf_token_get"));
        /** @type {function(...*):?} */
        var _gf_token_get_strip = (Module["_gf_token_get_strip"] =
            createExportWrapper("gf_token_get_strip"));
        /** @type {function(...*):?} */
        var _gf_token_get_line = (Module["_gf_token_get_line"] =
            createExportWrapper("gf_token_get_line"));
        /** @type {function(...*):?} */
        var _gf_token_find = (Module["_gf_token_find"] = createExportWrapper("gf_token_find"));
        /** @type {function(...*):?} */
        var _gf_stretch_bits = (Module["_gf_stretch_bits"] =
            createExportWrapper("gf_stretch_bits"));
        /** @type {function(...*):?} */
        var _gf_cmx_apply_argb = (Module["_gf_cmx_apply_argb"] =
            createExportWrapper("gf_cmx_apply_argb"));
        /** @type {function(...*):?} */
        var _gf_cmx_init = (Module["_gf_cmx_init"] = createExportWrapper("gf_cmx_init"));
        /** @type {function(...*):?} */
        var _gf_cmx_set = (Module["_gf_cmx_set"] = createExportWrapper("gf_cmx_set"));
        /** @type {function(...*):?} */
        var _gf_cmx_copy = (Module["_gf_cmx_copy"] = createExportWrapper("gf_cmx_copy"));
        /** @type {function(...*):?} */
        var _gf_cmx_multiply = (Module["_gf_cmx_multiply"] =
            createExportWrapper("gf_cmx_multiply"));
        /** @type {function(...*):?} */
        var _gf_cmx_apply = (Module["_gf_cmx_apply"] = createExportWrapper("gf_cmx_apply"));
        /** @type {function(...*):?} */
        var _gf_cmx_apply_wide = (Module["_gf_cmx_apply_wide"] =
            createExportWrapper("gf_cmx_apply_wide"));
        /** @type {function(...*):?} */
        var _gf_cmx_apply_fixed = (Module["_gf_cmx_apply_fixed"] =
            createExportWrapper("gf_cmx_apply_fixed"));
        /** @type {function(...*):?} */
        var _gf_color_parse = (Module["_gf_color_parse"] = createExportWrapper("gf_color_parse"));
        /** @type {function(...*):?} */
        var _gf_color_get_name = (Module["_gf_color_get_name"] =
            createExportWrapper("gf_color_get_name"));
        /** @type {function(...*):?} */
        var _gf_utf8_is_right_to_left = (Module["_gf_utf8_is_right_to_left"] = createExportWrapper(
            "gf_utf8_is_right_to_left"
        ));
        /** @type {function(...*):?} */
        var _gf_utf8_reorder_bidi = (Module["_gf_utf8_reorder_bidi"] =
            createExportWrapper("gf_utf8_reorder_bidi"));
        /** @type {function(...*):?} */
        var _utf8_to_ucs4 = (Module["_utf8_to_ucs4"] = createExportWrapper("utf8_to_ucs4"));
        /** @type {function(...*):?} */
        var _gf_modules_refresh = (Module["_gf_modules_refresh"] =
            createExportWrapper("gf_modules_refresh"));
        /** @type {function(...*):?} */
        var _gf_module_load_static = (Module["_gf_module_load_static"] =
            createExportWrapper("gf_module_load_static"));
        /** @type {function(...*):?} */
        var _gf_modules_load = (Module["_gf_modules_load"] =
            createExportWrapper("gf_modules_load"));
        /** @type {function(...*):?} */
        var _gf_module_get_file_name = (Module["_gf_module_get_file_name"] =
            createExportWrapper("gf_module_get_file_name"));
        /** @type {function(...*):?} */
        var _gf_module_get_key = (Module["_gf_module_get_key"] =
            createExportWrapper("gf_module_get_key"));
        /** @type {function(...*):?} */
        var _gf_module_get_bool = (Module["_gf_module_get_bool"] =
            createExportWrapper("gf_module_get_bool"));
        /** @type {function(...*):?} */
        var _gf_module_get_int = (Module["_gf_module_get_int"] =
            createExportWrapper("gf_module_get_int"));
        /** @type {function(...*):?} */
        var _gf_path_new = (Module["_gf_path_new"] = createExportWrapper("gf_path_new"));
        /** @type {function(...*):?} */
        var _gf_path_reset = (Module["_gf_path_reset"] = createExportWrapper("gf_path_reset"));
        /** @type {function(...*):?} */
        var _gf_path_clone = (Module["_gf_path_clone"] = createExportWrapper("gf_path_clone"));
        /** @type {function(...*):?} */
        var _gf_path_del = (Module["_gf_path_del"] = createExportWrapper("gf_path_del"));
        /** @type {function(...*):?} */
        var _gf_path_add_move_to = (Module["_gf_path_add_move_to"] =
            createExportWrapper("gf_path_add_move_to"));
        /** @type {function(...*):?} */
        var _gf_path_add_move_to_vec = (Module["_gf_path_add_move_to_vec"] =
            createExportWrapper("gf_path_add_move_to_vec"));
        /** @type {function(...*):?} */
        var _gf_path_add_line_to = (Module["_gf_path_add_line_to"] =
            createExportWrapper("gf_path_add_line_to"));
        /** @type {function(...*):?} */
        var _gf_path_add_line_to_vec = (Module["_gf_path_add_line_to_vec"] =
            createExportWrapper("gf_path_add_line_to_vec"));
        /** @type {function(...*):?} */
        var _gf_path_close = (Module["_gf_path_close"] = createExportWrapper("gf_path_close"));
        /** @type {function(...*):?} */
        var _gf_path_add_cubic_to = (Module["_gf_path_add_cubic_to"] =
            createExportWrapper("gf_path_add_cubic_to"));
        /** @type {function(...*):?} */
        var _gf_path_add_cubic_to_vec = (Module["_gf_path_add_cubic_to_vec"] = createExportWrapper(
            "gf_path_add_cubic_to_vec"
        ));
        /** @type {function(...*):?} */
        var _gf_path_add_quadratic_to = (Module["_gf_path_add_quadratic_to"] = createExportWrapper(
            "gf_path_add_quadratic_to"
        ));
        /** @type {function(...*):?} */
        var _gf_path_add_quadratic_to_vec = (Module["_gf_path_add_quadratic_to_vec"] =
            createExportWrapper("gf_path_add_quadratic_to_vec"));
        /** @type {function(...*):?} */
        var _gf_path_add_rect_center = (Module["_gf_path_add_rect_center"] =
            createExportWrapper("gf_path_add_rect_center"));
        /** @type {function(...*):?} */
        var _gf_path_add_rect = (Module["_gf_path_add_rect"] =
            createExportWrapper("gf_path_add_rect"));
        /** @type {function(...*):?} */
        var _gf_path_add_ellipse = (Module["_gf_path_add_ellipse"] =
            createExportWrapper("gf_path_add_ellipse"));
        /** @type {function(...*):?} */
        var _gf_path_add_bezier = (Module["_gf_path_add_bezier"] =
            createExportWrapper("gf_path_add_bezier"));
        /** @type {function(...*):?} */
        var _gf_path_add_arc_to = (Module["_gf_path_add_arc_to"] =
            createExportWrapper("gf_path_add_arc_to"));
        /** @type {function(...*):?} */
        var _gf_path_add_svg_arc_to = (Module["_gf_path_add_svg_arc_to"] =
            createExportWrapper("gf_path_add_svg_arc_to"));
        /** @type {function(...*):?} */
        var _gf_path_add_arc = (Module["_gf_path_add_arc"] =
            createExportWrapper("gf_path_add_arc"));
        /** @type {function(...*):?} */
        var _gf_path_get_control_bounds = (Module["_gf_path_get_control_bounds"] =
            createExportWrapper("gf_path_get_control_bounds"));
        /** @type {function(...*):?} */
        var _gf_path_get_bounds = (Module["_gf_path_get_bounds"] =
            createExportWrapper("gf_path_get_bounds"));
        /** @type {function(...*):?} */
        var _gf_path_get_flatten = (Module["_gf_path_get_flatten"] =
            createExportWrapper("gf_path_get_flatten"));
        /** @type {function(...*):?} */
        var _gf_path_flatten = (Module["_gf_path_flatten"] =
            createExportWrapper("gf_path_flatten"));
        /** @type {function(...*):?} */
        var _gf_path_point_over = (Module["_gf_path_point_over"] =
            createExportWrapper("gf_path_point_over"));
        /** @type {function(...*):?} */
        var _gf_path_is_empty = (Module["_gf_path_is_empty"] =
            createExportWrapper("gf_path_is_empty"));
        /** @type {function(...*):?} */
        var _gf_path_iterator_new = (Module["_gf_path_iterator_new"] =
            createExportWrapper("gf_path_iterator_new"));
        /** @type {function(...*):?} */
        var _gf_path_iterator_get_length = (Module["_gf_path_iterator_get_length"] =
            createExportWrapper("gf_path_iterator_get_length"));
        /** @type {function(...*):?} */
        var _gf_path_iterator_get_transform = (Module["_gf_path_iterator_get_transform"] =
            createExportWrapper("gf_path_iterator_get_transform"));
        /** @type {function(...*):?} */
        var _gf_path_iterator_del = (Module["_gf_path_iterator_del"] =
            createExportWrapper("gf_path_iterator_del"));
        /** @type {function(...*):?} */
        var _gf_polygone2d_get_convexity = (Module["_gf_polygone2d_get_convexity"] =
            createExportWrapper("gf_polygone2d_get_convexity"));
        /** @type {function(...*):?} */
        var _gf_path_get_outline = (Module["_gf_path_get_outline"] =
            createExportWrapper("gf_path_get_outline"));
        /** @type {function(...*):?} */
        var _gf_crypt_open = (Module["_gf_crypt_open"] = createExportWrapper("gf_crypt_open"));
        /** @type {function(...*):?} */
        var _gf_crypt_close = (Module["_gf_crypt_close"] = createExportWrapper("gf_crypt_close"));
        /** @type {function(...*):?} */
        var _gf_crypt_set_key = (Module["_gf_crypt_set_key"] =
            createExportWrapper("gf_crypt_set_key"));
        /** @type {function(...*):?} */
        var _gf_crypt_set_IV = (Module["_gf_crypt_set_IV"] =
            createExportWrapper("gf_crypt_set_IV"));
        /** @type {function(...*):?} */
        var _gf_crypt_get_IV = (Module["_gf_crypt_get_IV"] =
            createExportWrapper("gf_crypt_get_IV"));
        /** @type {function(...*):?} */
        var _gf_crypt_init = (Module["_gf_crypt_init"] = createExportWrapper("gf_crypt_init"));
        /** @type {function(...*):?} */
        var _gf_crypt_encrypt = (Module["_gf_crypt_encrypt"] =
            createExportWrapper("gf_crypt_encrypt"));
        /** @type {function(...*):?} */
        var _gf_crypt_decrypt = (Module["_gf_crypt_decrypt"] =
            createExportWrapper("gf_crypt_decrypt"));
        /** @type {function(...*):?} */
        var _gf_sg_new_subscene = (Module["_gf_sg_new_subscene"] =
            createExportWrapper("gf_sg_new_subscene"));
        /** @type {function(...*):?} */
        var _gf_sg_set_node_callback = (Module["_gf_sg_set_node_callback"] =
            createExportWrapper("gf_sg_set_node_callback"));
        /** @type {function(...*):?} */
        var _gf_sg_set_scene_time_callback = (Module["_gf_sg_set_scene_time_callback"] =
            createExportWrapper("gf_sg_set_scene_time_callback"));
        /** @type {function(...*):?} */
        var _gf_node_get_scene_time = (Module["_gf_node_get_scene_time"] =
            createExportWrapper("gf_node_get_scene_time"));
        /** @type {function(...*):?} */
        var _gf_sg_reset = (Module["_gf_sg_reset"] = createExportWrapper("gf_sg_reset"));
        /** @type {function(...*):?} */
        var _gf_sg_route_del = (Module["_gf_sg_route_del"] =
            createExportWrapper("gf_sg_route_del"));
        /** @type {function(...*):?} */
        var _gf_node_replace = (Module["_gf_node_replace"] =
            createExportWrapper("gf_node_replace"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_del = (Module["_gf_sg_proto_del"] =
            createExportWrapper("gf_sg_proto_del"));
        /** @type {function(...*):?} */
        var _gf_dom_event_fire = (Module["_gf_dom_event_fire"] =
            createExportWrapper("gf_dom_event_fire"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_mf_remove = (Module["_gf_sg_vrml_mf_remove"] =
            createExportWrapper("gf_sg_vrml_mf_remove"));
        /** @type {function(...*):?} */
        var _gf_sg_set_private = (Module["_gf_sg_set_private"] =
            createExportWrapper("gf_sg_set_private"));
        /** @type {function(...*):?} */
        var _gf_sg_get_private = (Module["_gf_sg_get_private"] =
            createExportWrapper("gf_sg_get_private"));
        /** @type {function(...*):?} */
        var _gf_sg_set_scene_size_info = (Module["_gf_sg_set_scene_size_info"] =
            createExportWrapper("gf_sg_set_scene_size_info"));
        /** @type {function(...*):?} */
        var _gf_sg_use_pixel_metrics = (Module["_gf_sg_use_pixel_metrics"] =
            createExportWrapper("gf_sg_use_pixel_metrics"));
        /** @type {function(...*):?} */
        var _gf_sg_get_scene_size_info = (Module["_gf_sg_get_scene_size_info"] =
            createExportWrapper("gf_sg_get_scene_size_info"));
        /** @type {function(...*):?} */
        var _gf_sg_get_root_node = (Module["_gf_sg_get_root_node"] =
            createExportWrapper("gf_sg_get_root_node"));
        /** @type {function(...*):?} */
        var _gf_sg_set_root_node = (Module["_gf_sg_set_root_node"] =
            createExportWrapper("gf_sg_set_root_node"));
        /** @type {function(...*):?} */
        var _gf_sg_command_del = (Module["_gf_sg_command_del"] =
            createExportWrapper("gf_sg_command_del"));
        /** @type {function(...*):?} */
        var _gf_node_changed = (Module["_gf_node_changed"] =
            createExportWrapper("gf_node_changed"));
        /** @type {function(...*):?} */
        var _gf_node_set_id = (Module["_gf_node_set_id"] = createExportWrapper("gf_node_set_id"));
        /** @type {function(...*):?} */
        var _gf_node_remove_id = (Module["_gf_node_remove_id"] =
            createExportWrapper("gf_node_remove_id"));
        /** @type {function(...*):?} */
        var _gf_node_traverse = (Module["_gf_node_traverse"] =
            createExportWrapper("gf_node_traverse"));
        /** @type {function(...*):?} */
        var _gf_node_get_name = (Module["_gf_node_get_name"] =
            createExportWrapper("gf_node_get_name"));
        /** @type {function(...*):?} */
        var _gf_node_dirty_clear = (Module["_gf_node_dirty_clear"] =
            createExportWrapper("gf_node_dirty_clear"));
        /** @type {function(...*):?} */
        var _gf_node_dirty_set = (Module["_gf_node_dirty_set"] =
            createExportWrapper("gf_node_dirty_set"));
        /** @type {function(...*):?} */
        var _gf_node_allow_cyclic_traverse = (Module["_gf_node_allow_cyclic_traverse"] =
            createExportWrapper("gf_node_allow_cyclic_traverse"));
        /** @type {function(...*):?} */
        var _gf_node_set_cyclic_traverse_flag = (Module["_gf_node_set_cyclic_traverse_flag"] =
            createExportWrapper("gf_node_set_cyclic_traverse_flag"));
        /** @type {function(...*):?} */
        var _gf_node_traverse_children = (Module["_gf_node_traverse_children"] =
            createExportWrapper("gf_node_traverse_children"));
        /** @type {function(...*):?} */
        var _gf_node_get_graph = (Module["_gf_node_get_graph"] =
            createExportWrapper("gf_node_get_graph"));
        /** @type {function(...*):?} */
        var _gf_sg_find_node = (Module["_gf_sg_find_node"] =
            createExportWrapper("gf_sg_find_node"));
        /** @type {function(...*):?} */
        var _gf_sg_find_node_by_name = (Module["_gf_sg_find_node_by_name"] =
            createExportWrapper("gf_sg_find_node_by_name"));
        /** @type {function(...*):?} */
        var _gf_sg_get_next_available_node_id = (Module["_gf_sg_get_next_available_node_id"] =
            createExportWrapper("gf_sg_get_next_available_node_id"));
        /** @type {function(...*):?} */
        var _gf_sg_get_max_node_id = (Module["_gf_sg_get_max_node_id"] =
            createExportWrapper("gf_sg_get_max_node_id"));
        /** @type {function(...*):?} */
        var _gf_node_get_id = (Module["_gf_node_get_id"] = createExportWrapper("gf_node_get_id"));
        /** @type {function(...*):?} */
        var _gf_node_get_name_and_id = (Module["_gf_node_get_name_and_id"] =
            createExportWrapper("gf_node_get_name_and_id"));
        /** @type {function(...*):?} */
        var _gf_node_get_private = (Module["_gf_node_get_private"] =
            createExportWrapper("gf_node_get_private"));
        /** @type {function(...*):?} */
        var _gf_node_set_private = (Module["_gf_node_set_private"] =
            createExportWrapper("gf_node_set_private"));
        /** @type {function(...*):?} */
        var _gf_node_set_callback_function = (Module["_gf_node_set_callback_function"] =
            createExportWrapper("gf_node_set_callback_function"));
        /** @type {function(...*):?} */
        var _gf_node_unregister_children = (Module["_gf_node_unregister_children"] =
            createExportWrapper("gf_node_unregister_children"));
        /** @type {function(...*):?} */
        var _gf_node_list_insert_child = (Module["_gf_node_list_insert_child"] =
            createExportWrapper("gf_node_list_insert_child"));
        /** @type {function(...*):?} */
        var _gf_node_list_get_child = (Module["_gf_node_list_get_child"] =
            createExportWrapper("gf_node_list_get_child"));
        /** @type {function(...*):?} */
        var _gf_node_list_find_child = (Module["_gf_node_list_find_child"] =
            createExportWrapper("gf_node_list_find_child"));
        /** @type {function(...*):?} */
        var _gf_node_list_add_child = (Module["_gf_node_list_add_child"] =
            createExportWrapper("gf_node_list_add_child"));
        /** @type {function(...*):?} */
        var _gf_node_list_add_child_last = (Module["_gf_node_list_add_child_last"] =
            createExportWrapper("gf_node_list_add_child_last"));
        /** @type {function(...*):?} */
        var _gf_node_list_del_child = (Module["_gf_node_list_del_child"] =
            createExportWrapper("gf_node_list_del_child"));
        /** @type {function(...*):?} */
        var _gf_node_list_del_child_idx = (Module["_gf_node_list_del_child_idx"] =
            createExportWrapper("gf_node_list_del_child_idx"));
        /** @type {function(...*):?} */
        var _gf_node_list_get_count = (Module["_gf_node_list_get_count"] =
            createExportWrapper("gf_node_list_get_count"));
        /** @type {function(...*):?} */
        var _gf_node_get_parent_count = (Module["_gf_node_get_parent_count"] = createExportWrapper(
            "gf_node_get_parent_count"
        ));
        /** @type {function(...*):?} */
        var _gf_node_get_parent = (Module["_gf_node_get_parent"] =
            createExportWrapper("gf_node_get_parent"));
        /** @type {function(...*):?} */
        var _gf_node_dirty_parent_graph = (Module["_gf_node_dirty_parent_graph"] =
            createExportWrapper("gf_node_dirty_parent_graph"));
        /** @type {function(...*):?} */
        var _gf_node_dirty_parents = (Module["_gf_node_dirty_parents"] =
            createExportWrapper("gf_node_dirty_parents"));
        /** @type {function(...*):?} */
        var _gf_node_dirty_get = (Module["_gf_node_dirty_get"] =
            createExportWrapper("gf_node_dirty_get"));
        /** @type {function(...*):?} */
        var _gf_node_dirty_reset = (Module["_gf_node_dirty_reset"] =
            createExportWrapper("gf_node_dirty_reset"));
        /** @type {function(...*):?} */
        var _gf_node_init = (Module["_gf_node_init"] = createExportWrapper("gf_node_init"));
        /** @type {function(...*):?} */
        var _gf_node_get_attribute_by_name = (Module["_gf_node_get_attribute_by_name"] =
            createExportWrapper("gf_node_get_attribute_by_name"));
        /** @type {function(...*):?} */
        var _gf_node_clone = (Module["_gf_node_clone"] = createExportWrapper("gf_node_clone"));
        /** @type {function(...*):?} */
        var _gf_sg_add_namespace = (Module["_gf_sg_add_namespace"] =
            createExportWrapper("gf_sg_add_namespace"));
        /** @type {function(...*):?} */
        var _gf_node_replace_child = (Module["_gf_node_replace_child"] =
            createExportWrapper("gf_node_replace_child"));
        /** @type {function(...*):?} */
        var _gf_node_parent_of = (Module["_gf_node_parent_of"] =
            createExportWrapper("gf_node_parent_of"));
        /** @type {function(...*):?} */
        var _gf_dom_add_text_node = (Module["_gf_dom_add_text_node"] =
            createExportWrapper("gf_dom_add_text_node"));
        /** @type {function(...*):?} */
        var _gf_svg_create_attribute_value = (Module["_gf_svg_create_attribute_value"] =
            createExportWrapper("gf_svg_create_attribute_value"));
        /** @type {function(...*):?} */
        var _gf_sg_find_proto = (Module["_gf_sg_find_proto"] =
            createExportWrapper("gf_sg_find_proto"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_mf_reset = (Module["_gf_sg_vrml_mf_reset"] =
            createExportWrapper("gf_sg_vrml_mf_reset"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_field_copy = (Module["_gf_sg_vrml_field_copy"] =
            createExportWrapper("gf_sg_vrml_field_copy"));
        /** @type {function(...*):?} */
        var _gf_sg_script_event_in = (Module["_gf_sg_script_event_in"] =
            createExportWrapper("gf_sg_script_event_in"));
        /** @type {function(...*):?} */
        var _gf_node_event_out = (Module["_gf_node_event_out"] =
            createExportWrapper("gf_node_event_out"));
        /** @type {function(...*):?} */
        var _gf_node_get_attribute_by_tag = (Module["_gf_node_get_attribute_by_tag"] =
            createExportWrapper("gf_node_get_attribute_by_tag"));
        /** @type {function(...*):?} */
        var _gf_svg_attributes_copy = (Module["_gf_svg_attributes_copy"] =
            createExportWrapper("gf_svg_attributes_copy"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_mf_alloc = (Module["_gf_sg_vrml_mf_alloc"] =
            createExportWrapper("gf_sg_vrml_mf_alloc"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_field_clone = (Module["_gf_sg_vrml_field_clone"] =
            createExportWrapper("gf_sg_vrml_field_clone"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_mf_append = (Module["_gf_sg_vrml_mf_append"] =
            createExportWrapper("gf_sg_vrml_mf_append"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_mf_insert = (Module["_gf_sg_vrml_mf_insert"] =
            createExportWrapper("gf_sg_vrml_mf_insert"));
        /** @type {function(...*):?} */
        var _gf_sg_route_new = (Module["_gf_sg_route_new"] =
            createExportWrapper("gf_sg_route_new"));
        /** @type {function(...*):?} */
        var _gf_sg_route_set_id = (Module["_gf_sg_route_set_id"] =
            createExportWrapper("gf_sg_route_set_id"));
        /** @type {function(...*):?} */
        var _gf_sg_route_set_name = (Module["_gf_sg_route_set_name"] =
            createExportWrapper("gf_sg_route_set_name"));
        /** @type {function(...*):?} */
        var _gf_node_insert_child = (Module["_gf_node_insert_child"] =
            createExportWrapper("gf_node_insert_child"));
        /** @type {function(...*):?} */
        var _gf_sg_route_del_by_id = (Module["_gf_sg_route_del_by_id"] =
            createExportWrapper("gf_sg_route_del_by_id"));
        /** @type {function(...*):?} */
        var _gf_sg_route_find = (Module["_gf_sg_route_find"] =
            createExportWrapper("gf_sg_route_find"));
        /** @type {function(...*):?} */
        var _gf_sg_script_load = (Module["_gf_sg_script_load"] =
            createExportWrapper("gf_sg_script_load"));
        /** @type {function(...*):?} */
        var _gf_sg_command_apply_list = (Module["_gf_sg_command_apply_list"] = createExportWrapper(
            "gf_sg_command_apply_list"
        ));
        /** @type {function(...*):?} */
        var _gf_sg_mfurl_del = (Module["_gf_sg_mfurl_del"] =
            createExportWrapper("gf_sg_mfurl_del"));
        /** @type {function(...*):?} */
        var _gf_sg_sfrotation_interpolate = (Module["_gf_sg_sfrotation_interpolate"] =
            createExportWrapper("gf_sg_sfrotation_interpolate"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_new = (Module["_gf_sg_proto_new"] =
            createExportWrapper("gf_sg_proto_new"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_get_graph = (Module["_gf_sg_proto_get_graph"] =
            createExportWrapper("gf_sg_proto_get_graph"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_get_extern_url = (Module["_gf_sg_proto_get_extern_url"] =
            createExportWrapper("gf_sg_proto_get_extern_url"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_add_node_code = (Module["_gf_sg_proto_add_node_code"] =
            createExportWrapper("gf_sg_proto_add_node_code"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_field_find_by_name = (Module["_gf_sg_proto_field_find_by_name"] =
            createExportWrapper("gf_sg_proto_field_find_by_name"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_field_new = (Module["_gf_sg_proto_field_new"] =
            createExportWrapper("gf_sg_proto_field_new"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_field_get_field = (Module["_gf_sg_proto_field_get_field"] =
            createExportWrapper("gf_sg_proto_field_get_field"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_field_is_sftime_offset = (Module["_gf_sg_proto_field_is_sftime_offset"] =
            createExportWrapper("gf_sg_proto_field_is_sftime_offset"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_create_instance = (Module["_gf_sg_proto_create_instance"] =
            createExportWrapper("gf_sg_proto_create_instance"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_load_code = (Module["_gf_sg_proto_load_code"] =
            createExportWrapper("gf_sg_proto_load_code"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_field_set_ised = (Module["_gf_sg_proto_field_set_ised"] =
            createExportWrapper("gf_sg_proto_field_set_ised"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_instance_set_ised = (Module["_gf_sg_proto_instance_set_ised"] =
            createExportWrapper("gf_sg_proto_instance_set_ised"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_get_field_count = (Module["_gf_sg_proto_get_field_count"] =
            createExportWrapper("gf_sg_proto_get_field_count"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_field_find = (Module["_gf_sg_proto_field_find"] =
            createExportWrapper("gf_sg_proto_field_find"));
        /** @type {function(...*):?} */
        var _gf_node_get_proto = (Module["_gf_node_get_proto"] =
            createExportWrapper("gf_node_get_proto"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_get_id = (Module["_gf_sg_proto_get_id"] =
            createExportWrapper("gf_sg_proto_get_id"));
        /** @type {function(...*):?} */
        var _gf_sg_proto_get_class_name = (Module["_gf_sg_proto_get_class_name"] =
            createExportWrapper("gf_sg_proto_get_class_name"));
        /** @type {function(...*):?} */
        var _gf_node_proto_set_grouping = (Module["_gf_node_proto_set_grouping"] =
            createExportWrapper("gf_node_proto_set_grouping"));
        /** @type {function(...*):?} */
        var _gf_node_proto_is_grouping = (Module["_gf_node_proto_is_grouping"] =
            createExportWrapper("gf_node_proto_is_grouping"));
        /** @type {function(...*):?} */
        var _gf_node_get_proto_root = (Module["_gf_node_get_proto_root"] =
            createExportWrapper("gf_node_get_proto_root"));
        /** @type {function(...*):?} */
        var _gf_node_set_proto_eventin_handler = (Module["_gf_node_set_proto_eventin_handler"] =
            createExportWrapper("gf_node_set_proto_eventin_handler"));
        /** @type {function(...*):?} */
        var _gf_sg_activate_routes = (Module["_gf_sg_activate_routes"] =
            createExportWrapper("gf_sg_activate_routes"));
        /** @type {function(...*):?} */
        var _gf_sg_vrml_field_equal = (Module["_gf_sg_vrml_field_equal"] =
            createExportWrapper("gf_sg_vrml_field_equal"));
        /** @type {function(...*):?} */
        var _gf_sg_route_find_by_name = (Module["_gf_sg_route_find_by_name"] = createExportWrapper(
            "gf_sg_route_find_by_name"
        ));
        /** @type {function(...*):?} */
        var _gf_sg_route_get_name = (Module["_gf_sg_route_get_name"] =
            createExportWrapper("gf_sg_route_get_name"));
        /** @type {function(...*):?} */
        var _gf_node_event_out_str = (Module["_gf_node_event_out_str"] =
            createExportWrapper("gf_node_event_out_str"));
        /** @type {function(...*):?} */
        var _gf_sg_route_new_to_callback = (Module["_gf_sg_route_new_to_callback"] =
            createExportWrapper("gf_sg_route_new_to_callback"));
        /** @type {function(...*):?} */
        var _gf_sg_script_field_new = (Module["_gf_sg_script_field_new"] =
            createExportWrapper("gf_sg_script_field_new"));
        /** @type {function(...*):?} */
        var _gf_sg_script_field_get_info = (Module["_gf_sg_script_field_get_info"] =
            createExportWrapper("gf_sg_script_field_get_info"));
        /** @type {function(...*):?} */
        var _gf_js_vrml_flush_event_out = (Module["_gf_js_vrml_flush_event_out"] =
            createExportWrapper("gf_js_vrml_flush_event_out"));
        /** @type {function(...*):?} */
        var _gf_sg_handle_dom_event_for_vrml = (Module["_gf_sg_handle_dom_event_for_vrml"] =
            createExportWrapper("gf_sg_handle_dom_event_for_vrml"));
        /** @type {function(...*):?} */
        var _gf_sg_js_get_node = (Module["_gf_sg_js_get_node"] =
            createExportWrapper("gf_sg_js_get_node"));
        /** @type {function(...*):?} */
        var _gf_sg_has_scripting = (Module["_gf_sg_has_scripting"] =
            createExportWrapper("gf_sg_has_scripting"));
        /** @type {function(...*):?} */
        var _gf_x3d_get_node_type = (Module["_gf_x3d_get_node_type"] =
            createExportWrapper("gf_x3d_get_node_type"));
        /** @type {function(...*):?} */
        var _gf_sg_delete_all_protos = (Module["_gf_sg_delete_all_protos"] =
            createExportWrapper("gf_sg_delete_all_protos"));
        /** @type {function(...*):?} */
        var _gf_sg_set_proto_loader = (Module["_gf_sg_set_proto_loader"] =
            createExportWrapper("gf_sg_set_proto_loader"));
        /** @type {function(...*):?} */
        var _gf_sg_get_next_available_route_id = (Module["_gf_sg_get_next_available_route_id"] =
            createExportWrapper("gf_sg_get_next_available_route_id"));
        /** @type {function(...*):?} */
        var _gf_sg_set_max_defined_route_id = (Module["_gf_sg_set_max_defined_route_id"] =
            createExportWrapper("gf_sg_set_max_defined_route_id"));
        /** @type {function(...*):?} */
        var _gf_sg_get_next_available_proto_id = (Module["_gf_sg_get_next_available_proto_id"] =
            createExportWrapper("gf_sg_get_next_available_proto_id"));
        /** @type {function(...*):?} */
        var _gf_sg_sfcolor_to_rgba = (Module["_gf_sg_sfcolor_to_rgba"] =
            createExportWrapper("gf_sg_sfcolor_to_rgba"));
        /** @type {function(...*):?} */
        var _gf_dom_event_type_by_name = (Module["_gf_dom_event_type_by_name"] =
            createExportWrapper("gf_dom_event_type_by_name"));
        /** @type {function(...*):?} */
        var _gf_dom_event_get_name = (Module["_gf_dom_event_get_name"] =
            createExportWrapper("gf_dom_event_get_name"));
        /** @type {function(...*):?} */
        var _gf_dom_get_key_name = (Module["_gf_dom_get_key_name"] =
            createExportWrapper("gf_dom_get_key_name"));
        /** @type {function(...*):?} */
        var _gf_dom_get_friendly_name = (Module["_gf_dom_get_friendly_name"] = createExportWrapper(
            "gf_dom_get_friendly_name"
        ));
        /** @type {function(...*):?} */
        var _gf_dom_get_key_type = (Module["_gf_dom_get_key_type"] =
            createExportWrapper("gf_dom_get_key_type"));
        /** @type {function(...*):?} */
        var _gf_svg_parse_attribute = (Module["_gf_svg_parse_attribute"] =
            createExportWrapper("gf_svg_parse_attribute"));
        /** @type {function(...*):?} */
        var _gf_svg_parse_element_id = (Module["_gf_svg_parse_element_id"] =
            createExportWrapper("gf_svg_parse_element_id"));
        /** @type {function(...*):?} */
        var _gf_node_register_iri = (Module["_gf_node_register_iri"] =
            createExportWrapper("gf_node_register_iri"));
        /** @type {function(...*):?} */
        var _gf_svg_parse_style = (Module["_gf_svg_parse_style"] =
            createExportWrapper("gf_svg_parse_style"));
        /** @type {function(...*):?} */
        var _gf_svg_is_animation_tag = (Module["_gf_svg_is_animation_tag"] =
            createExportWrapper("gf_svg_is_animation_tag"));
        /** @type {function(...*):?} */
        var _gf_dom_listener_count = (Module["_gf_dom_listener_count"] =
            createExportWrapper("gf_dom_listener_count"));
        /** @type {function(...*):?} */
        var _gf_sg_handle_dom_event = (Module["_gf_sg_handle_dom_event"] =
            createExportWrapper("gf_sg_handle_dom_event"));
        /** @type {function(...*):?} */
        var _gf_smil_timing_init_runtime_info = (Module["_gf_smil_timing_init_runtime_info"] =
            createExportWrapper("gf_smil_timing_init_runtime_info"));
        /** @type {function(...*):?} */
        var _gf_node_unregister_iri = (Module["_gf_node_unregister_iri"] =
            createExportWrapper("gf_node_unregister_iri"));
        /** @type {function(...*):?} */
        var _gf_js_lock = (Module["_gf_js_lock"] = createExportWrapper("gf_js_lock"));
        /** @type {function(...*):?} */
        var _gf_sg_js_dom_pre_destroy = (Module["_gf_sg_js_dom_pre_destroy"] = createExportWrapper(
            "gf_sg_js_dom_pre_destroy"
        ));
        /** @type {function(...*):?} */
        var _gf_sm_load_bt_from_string = (Module["_gf_sm_load_bt_from_string"] =
            createExportWrapper("gf_sm_load_bt_from_string"));
        /** @type {function(...*):?} */
        var _gf_dom_flatten_textContent = (Module["_gf_dom_flatten_textContent"] =
            createExportWrapper("gf_dom_flatten_textContent"));
        /** @type {function(...*):?} */
        var _gf_svg_apply_animations = (Module["_gf_svg_apply_animations"] =
            createExportWrapper("gf_svg_apply_animations"));
        /** @type {function(...*):?} */
        var _gf_svg_flatten_attributes = (Module["_gf_svg_flatten_attributes"] =
            createExportWrapper("gf_svg_flatten_attributes"));
        /** @type {function(...*):?} */
        var _gf_smil_set_media_duration = (Module["_gf_smil_set_media_duration"] =
            createExportWrapper("gf_smil_set_media_duration"));
        /** @type {function(...*):?} */
        var _gf_dom_listener_del = (Module["_gf_dom_listener_del"] =
            createExportWrapper("gf_dom_listener_del"));
        /** @type {function(...*):?} */
        var _gf_smil_timing_is_active = (Module["_gf_smil_timing_is_active"] = createExportWrapper(
            "gf_smil_timing_is_active"
        ));
        /** @type {function(...*):?} */
        var _gf_smil_timing_insert_clock = (Module["_gf_smil_timing_insert_clock"] =
            createExportWrapper("gf_smil_timing_insert_clock"));
        /** @type {function(...*):?} */
        var _gf_svg_properties_init_pointers = (Module["_gf_svg_properties_init_pointers"] =
            createExportWrapper("gf_svg_properties_init_pointers"));
        /** @type {function(...*):?} */
        var _gf_svg_properties_reset_pointers = (Module["_gf_svg_properties_reset_pointers"] =
            createExportWrapper("gf_svg_properties_reset_pointers"));
        /** @type {function(...*):?} */
        var _gf_svg_apply_inheritance = (Module["_gf_svg_apply_inheritance"] = createExportWrapper(
            "gf_svg_apply_inheritance"
        ));
        /** @type {function(...*):?} */
        var _gf_node_dom_listener_add = (Module["_gf_node_dom_listener_add"] = createExportWrapper(
            "gf_node_dom_listener_add"
        ));
        /** @type {function(...*):?} */
        var _gf_dom_listener_get = (Module["_gf_dom_listener_get"] =
            createExportWrapper("gf_dom_listener_get"));
        /** @type {function(...*):?} */
        var _gf_sg_fire_dom_event = (Module["_gf_sg_fire_dom_event"] =
            createExportWrapper("gf_sg_fire_dom_event"));
        /** @type {function(...*):?} */
        var _gf_dom_event_fire_ex = (Module["_gf_dom_event_fire_ex"] =
            createExportWrapper("gf_dom_event_fire_ex"));
        /** @type {function(...*):?} */
        var _gf_dom_listener_build = (Module["_gf_dom_listener_build"] =
            createExportWrapper("gf_dom_listener_build"));
        /** @type {function(...*):?} */
        var _gf_dom_set_textContent = (Module["_gf_dom_set_textContent"] =
            createExportWrapper("gf_dom_set_textContent"));
        /** @type {function(...*):?} */
        var _gf_xml_get_element_tag = (Module["_gf_xml_get_element_tag"] =
            createExportWrapper("gf_xml_get_element_tag"));
        /** @type {function(...*):?} */
        var _gf_node_store_embedded_data = (Module["_gf_node_store_embedded_data"] =
            createExportWrapper("gf_node_store_embedded_data"));
        /** @type {function(...*):?} */
        var _gf_bifs_decoder_new = (Module["_gf_bifs_decoder_new"] =
            createExportWrapper("gf_bifs_decoder_new"));
        /** @type {function(...*):?} */
        var _gf_bifs_decoder_configure_stream = (Module["_gf_bifs_decoder_configure_stream"] =
            createExportWrapper("gf_bifs_decoder_configure_stream"));
        /** @type {function(...*):?} */
        var _gf_bifs_decoder_del = (Module["_gf_bifs_decoder_del"] =
            createExportWrapper("gf_bifs_decoder_del"));
        /** @type {function(...*):?} */
        var _gf_bifs_decode_has_conditionnals = (Module["_gf_bifs_decode_has_conditionnals"] =
            createExportWrapper("gf_bifs_decode_has_conditionnals"));
        /** @type {function(...*):?} */
        var _gf_bifs_decode_au = (Module["_gf_bifs_decode_au"] =
            createExportWrapper("gf_bifs_decode_au"));
        /** @type {function(...*):?} */
        var _gf_bifs_encoder_set_source_url = (Module["_gf_bifs_encoder_set_source_url"] =
            createExportWrapper("gf_bifs_encoder_set_source_url"));
        /** @type {function(...*):?} */
        var _gf_bifs_encoder_get_rap = (Module["_gf_bifs_encoder_get_rap"] =
            createExportWrapper("gf_bifs_encoder_get_rap"));
        /** @type {function(...*):?} */
        var _gf_bifs_decode_command_list = (Module["_gf_bifs_decode_command_list"] =
            createExportWrapper("gf_bifs_decode_command_list"));
        /** @type {function(...*):?} */
        var _gf_isom_avc_config_new = (Module["_gf_isom_avc_config_new"] =
            createExportWrapper("gf_isom_avc_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_ex = (Module["_gf_isom_get_sample_ex"] =
            createExportWrapper("gf_isom_get_sample_ex"));
        /** @type {function(...*):?} */
        var _gf_odf_hevc_cfg_write_bs = (Module["_gf_odf_hevc_cfg_write_bs"] = createExportWrapper(
            "gf_odf_hevc_cfg_write_bs"
        ));
        /** @type {function(...*):?} */
        var _gf_odf_hevc_cfg_read_bs = (Module["_gf_odf_hevc_cfg_read_bs"] =
            createExportWrapper("gf_odf_hevc_cfg_read_bs"));
        /** @type {function(...*):?} */
        var _gf_odf_vvc_cfg_write_bs = (Module["_gf_odf_vvc_cfg_write_bs"] =
            createExportWrapper("gf_odf_vvc_cfg_write_bs"));
        /** @type {function(...*):?} */
        var _gf_odf_vvc_cfg_read_bs = (Module["_gf_odf_vvc_cfg_read_bs"] =
            createExportWrapper("gf_odf_vvc_cfg_read_bs"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_copy = (Module["_gf_odf_desc_copy"] =
            createExportWrapper("gf_odf_desc_copy"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_add_desc = (Module["_gf_odf_desc_add_desc"] =
            createExportWrapper("gf_odf_desc_add_desc"));
        /** @type {function(...*):?} */
        var _gf_odf_avc_cfg_write = (Module["_gf_odf_avc_cfg_write"] =
            createExportWrapper("gf_odf_avc_cfg_write"));
        /** @type {function(...*):?} */
        var _gf_odf_avc_cfg_new = (Module["_gf_odf_avc_cfg_new"] =
            createExportWrapper("gf_odf_avc_cfg_new"));
        /** @type {function(...*):?} */
        var _gf_odf_hevc_cfg_write = (Module["_gf_odf_hevc_cfg_write"] =
            createExportWrapper("gf_odf_hevc_cfg_write"));
        /** @type {function(...*):?} */
        var _gf_odf_hevc_cfg_read = (Module["_gf_odf_hevc_cfg_read"] =
            createExportWrapper("gf_odf_hevc_cfg_read"));
        /** @type {function(...*):?} */
        var _gf_odf_avc_cfg_read = (Module["_gf_odf_avc_cfg_read"] =
            createExportWrapper("gf_odf_avc_cfg_read"));
        /** @type {function(...*):?} */
        var _gf_odf_av1_cfg_write = (Module["_gf_odf_av1_cfg_write"] =
            createExportWrapper("gf_odf_av1_cfg_write"));
        /** @type {function(...*):?} */
        var _gf_odf_vp_cfg_new = (Module["_gf_odf_vp_cfg_new"] =
            createExportWrapper("gf_odf_vp_cfg_new"));
        /** @type {function(...*):?} */
        var _gf_odf_vp_cfg_write = (Module["_gf_odf_vp_cfg_write"] =
            createExportWrapper("gf_odf_vp_cfg_write"));
        /** @type {function(...*):?} */
        var _gf_odf_vp_cfg_del = (Module["_gf_odf_vp_cfg_del"] =
            createExportWrapper("gf_odf_vp_cfg_del"));
        /** @type {function(...*):?} */
        var _gf_isom_svc_config_update = (Module["_gf_isom_svc_config_update"] =
            createExportWrapper("gf_isom_svc_config_update"));
        /** @type {function(...*):?} */
        var _gf_isom_svc_config_new = (Module["_gf_isom_svc_config_new"] =
            createExportWrapper("gf_isom_svc_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_mvc_config_new = (Module["_gf_isom_mvc_config_new"] =
            createExportWrapper("gf_isom_mvc_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_hevc_config_new = (Module["_gf_isom_hevc_config_new"] =
            createExportWrapper("gf_isom_hevc_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_vvc_config_new = (Module["_gf_isom_vvc_config_new"] =
            createExportWrapper("gf_isom_vvc_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_vp_config_new = (Module["_gf_isom_vp_config_new"] =
            createExportWrapper("gf_isom_vp_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_av1_config_new = (Module["_gf_isom_av1_config_new"] =
            createExportWrapper("gf_isom_av1_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_lhvc_force_inband_config = (Module["_gf_isom_lhvc_force_inband_config"] =
            createExportWrapper("gf_isom_lhvc_force_inband_config"));
        /** @type {function(...*):?} */
        var _gf_isom_hevc_set_tile_config = (Module["_gf_isom_hevc_set_tile_config"] =
            createExportWrapper("gf_isom_hevc_set_tile_config"));
        /** @type {function(...*):?} */
        var _gf_isom_lhvc_config_update = (Module["_gf_isom_lhvc_config_update"] =
            createExportWrapper("gf_isom_lhvc_config_update"));
        /** @type {function(...*):?} */
        var _gf_isom_vvc_set_inband_config = (Module["_gf_isom_vvc_set_inband_config"] =
            createExportWrapper("gf_isom_vvc_set_inband_config"));
        /** @type {function(...*):?} */
        var _gf_isom_vvc_config_update = (Module["_gf_isom_vvc_config_update"] =
            createExportWrapper("gf_isom_vvc_config_update"));
        /** @type {function(...*):?} */
        var _gf_isom_box_size = (Module["_gf_isom_box_size"] =
            createExportWrapper("gf_isom_box_size"));
        /** @type {function(...*):?} */
        var _gf_isom_box_write = (Module["_gf_isom_box_write"] =
            createExportWrapper("gf_isom_box_write"));
        /** @type {function(...*):?} */
        var _gf_isom_box_parse = (Module["_gf_isom_box_parse"] =
            createExportWrapper("gf_isom_box_parse"));
        /** @type {function(...*):?} */
        var _gf_odf_vvc_cfg_new = (Module["_gf_odf_vvc_cfg_new"] =
            createExportWrapper("gf_odf_vvc_cfg_new"));
        /** @type {function(...*):?} */
        var _gf_isom_vp_config_get = (Module["_gf_isom_vp_config_get"] =
            createExportWrapper("gf_isom_vp_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_box_write_header = (Module["_gf_isom_box_write_header"] = createExportWrapper(
            "gf_isom_box_write_header"
        ));
        /** @type {function(...*):?} */
        var _gf_odf_desc_list_del = (Module["_gf_odf_desc_list_del"] =
            createExportWrapper("gf_odf_desc_list_del"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_list_read = (Module["_gf_odf_desc_list_read"] =
            createExportWrapper("gf_odf_desc_list_read"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_list_write = (Module["_gf_odf_desc_list_write"] =
            createExportWrapper("gf_odf_desc_list_write"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_list_size = (Module["_gf_odf_desc_list_size"] =
            createExportWrapper("gf_odf_desc_list_size"));
        /** @type {function(...*):?} */
        var _gf_avc_read_sps = (Module["_gf_avc_read_sps"] =
            createExportWrapper("gf_avc_read_sps"));
        /** @type {function(...*):?} */
        var _gf_odf_av1_cfg_read_bs_size = (Module["_gf_odf_av1_cfg_read_bs_size"] =
            createExportWrapper("gf_odf_av1_cfg_read_bs_size"));
        /** @type {function(...*):?} */
        var _gf_odf_av1_cfg_write_bs = (Module["_gf_odf_av1_cfg_write_bs"] =
            createExportWrapper("gf_odf_av1_cfg_write_bs"));
        /** @type {function(...*):?} */
        var _gf_odf_vp_cfg_read_bs = (Module["_gf_odf_vp_cfg_read_bs"] =
            createExportWrapper("gf_odf_vp_cfg_read_bs"));
        /** @type {function(...*):?} */
        var _gf_odf_vp_cfg_write_bs = (Module["_gf_odf_vp_cfg_write_bs"] =
            createExportWrapper("gf_odf_vp_cfg_write_bs"));
        /** @type {function(...*):?} */
        var _gf_odf_dump_desc = (Module["_gf_odf_dump_desc"] =
            createExportWrapper("gf_odf_dump_desc"));
        /** @type {function(...*):?} */
        var _gf_webvtt_parse_cues_from_data = (Module["_gf_webvtt_parse_cues_from_data"] =
            createExportWrapper("gf_webvtt_parse_cues_from_data"));
        /** @type {function(...*):?} */
        var _gf_webvtt_cue_del = (Module["_gf_webvtt_cue_del"] =
            createExportWrapper("gf_webvtt_cue_del"));
        /** @type {function(...*):?} */
        var _gf_isom_get_ismacryp_sample = (Module["_gf_isom_get_ismacryp_sample"] =
            createExportWrapper("gf_isom_get_ismacryp_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_ismacryp_delete_sample = (Module["_gf_isom_ismacryp_delete_sample"] =
            createExportWrapper("gf_isom_ismacryp_delete_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_cenc_samp_aux_info_del = (Module["_gf_isom_cenc_samp_aux_info_del"] =
            createExportWrapper("gf_isom_cenc_samp_aux_info_del"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_read = (Module["_gf_odf_desc_read"] =
            createExportWrapper("gf_odf_desc_read"));
        /** @type {function(...*):?} */
        var _gf_odf_slc_set_pref = (Module["_gf_odf_slc_set_pref"] =
            createExportWrapper("gf_odf_slc_set_pref"));
        /** @type {function(...*):?} */
        var _gf_isom_set_ismacryp_protection = (Module["_gf_isom_set_ismacryp_protection"] =
            createExportWrapper("gf_isom_set_ismacryp_protection"));
        /** @type {function(...*):?} */
        var _gf_isom_cenc_get_sample_aux_info = (Module["_gf_isom_cenc_get_sample_aux_info"] =
            createExportWrapper("gf_isom_cenc_get_sample_aux_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_mode = (Module["_gf_isom_get_mode"] =
            createExportWrapper("gf_isom_get_mode"));
        /** @type {function(...*):?} */
        var _gf_isom_probe_file_range = (Module["_gf_isom_probe_file_range"] = createExportWrapper(
            "gf_isom_probe_file_range"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_probe_data = (Module["_gf_isom_probe_data"] =
            createExportWrapper("gf_isom_probe_data"));
        /** @type {function(...*):?} */
        var _gf_isom_open_progressive_ex = (Module["_gf_isom_open_progressive_ex"] =
            createExportWrapper("gf_isom_open_progressive_ex"));
        /** @type {function(...*):?} */
        var _gf_media_nalu_next_start_code = (Module["_gf_media_nalu_next_start_code"] =
            createExportWrapper("gf_media_nalu_next_start_code"));
        /** @type {function(...*):?} */
        var _gf_m4a_write_config = (Module["_gf_m4a_write_config"] =
            createExportWrapper("gf_m4a_write_config"));
        /** @type {function(...*):?} */
        var _gf_isom_write = (Module["_gf_isom_write"] = createExportWrapper("gf_isom_write"));
        /** @type {function(...*):?} */
        var _gf_isom_close_fragments = (Module["_gf_isom_close_fragments"] =
            createExportWrapper("gf_isom_close_fragments"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_creation_time = (Module["_gf_isom_get_track_creation_time"] =
            createExportWrapper("gf_isom_get_track_creation_time"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_duration_orig = (Module["_gf_isom_get_track_duration_orig"] =
            createExportWrapper("gf_isom_get_track_duration_orig"));
        /** @type {function(...*):?} */
        var _gf_isom_has_track_reference = (Module["_gf_isom_has_track_reference"] =
            createExportWrapper("gf_isom_has_track_reference"));
        /** @type {function(...*):?} */
        var _gf_isom_get_media_time = (Module["_gf_isom_get_media_time"] =
            createExportWrapper("gf_isom_get_media_time"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_description_index = (Module[
            "_gf_isom_get_sample_description_index"
        ] = createExportWrapper("gf_isom_get_sample_description_index"));
        /** @type {function(...*):?} */
        var _gf_isom_get_decoder_config = (Module["_gf_isom_get_decoder_config"] =
            createExportWrapper("gf_isom_get_decoder_config"));
        /** @type {function(...*):?} */
        var _gf_isom_has_sync_shadows = (Module["_gf_isom_has_sync_shadows"] = createExportWrapper(
            "gf_isom_has_sync_shadows"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_has_sample_dependency = (Module["_gf_isom_has_sample_dependency"] =
            createExportWrapper("gf_isom_has_sample_dependency"));
        /** @type {function(...*):?} */
        var _gf_isom_get_max_sample_size = (Module["_gf_isom_get_max_sample_size"] =
            createExportWrapper("gf_isom_get_max_sample_size"));
        /** @type {function(...*):?} */
        var _gf_isom_get_avg_sample_size = (Module["_gf_isom_get_avg_sample_size"] =
            createExportWrapper("gf_isom_get_avg_sample_size"));
        /** @type {function(...*):?} */
        var _gf_isom_get_avg_sample_delta = (Module["_gf_isom_get_avg_sample_delta"] =
            createExportWrapper("gf_isom_get_avg_sample_delta"));
        /** @type {function(...*):?} */
        var _gf_isom_get_max_sample_cts_offset = (Module["_gf_isom_get_max_sample_cts_offset"] =
            createExportWrapper("gf_isom_get_max_sample_cts_offset"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_sync = (Module["_gf_isom_get_sample_sync"] =
            createExportWrapper("gf_isom_get_sample_sync"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_info_ex = (Module["_gf_isom_get_sample_info_ex"] =
            createExportWrapper("gf_isom_get_sample_info_ex"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_from_dts = (Module["_gf_isom_get_sample_from_dts"] =
            createExportWrapper("gf_isom_get_sample_from_dts"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_for_media_time = (Module["_gf_isom_get_sample_for_media_time"] =
            createExportWrapper("gf_isom_get_sample_for_media_time"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_for_movie_time = (Module["_gf_isom_get_sample_for_movie_time"] =
            createExportWrapper("gf_isom_get_sample_for_movie_time"));
        /** @type {function(...*):?} */
        var _gf_isom_get_missing_bytes = (Module["_gf_isom_get_missing_bytes"] =
            createExportWrapper("gf_isom_get_missing_bytes"));
        /** @type {function(...*):?} */
        var _gf_isom_set_sample_padding = (Module["_gf_isom_set_sample_padding"] =
            createExportWrapper("gf_isom_set_sample_padding"));
        /** @type {function(...*):?} */
        var _gf_isom_get_brands = (Module["_gf_isom_get_brands"] =
            createExportWrapper("gf_isom_get_brands"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_padding_bits = (Module["_gf_isom_get_sample_padding_bits"] =
            createExportWrapper("gf_isom_get_sample_padding_bits"));
        /** @type {function(...*):?} */
        var _gf_isom_has_padding_bits = (Module["_gf_isom_has_padding_bits"] = createExportWrapper(
            "gf_isom_has_padding_bits"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_refresh_fragmented = (Module["_gf_isom_refresh_fragmented"] =
            createExportWrapper("gf_isom_refresh_fragmented"));
        /** @type {function(...*):?} */
        var _gf_isom_set_single_moof_mode = (Module["_gf_isom_set_single_moof_mode"] =
            createExportWrapper("gf_isom_set_single_moof_mode"));
        /** @type {function(...*):?} */
        var _gf_isom_reset_data_offset = (Module["_gf_isom_reset_data_offset"] =
            createExportWrapper("gf_isom_reset_data_offset"));
        /** @type {function(...*):?} */
        var _gf_isom_get_current_top_box_offset = (Module["_gf_isom_get_current_top_box_offset"] =
            createExportWrapper("gf_isom_get_current_top_box_offset"));
        /** @type {function(...*):?} */
        var _gf_isom_set_removed_bytes = (Module["_gf_isom_set_removed_bytes"] =
            createExportWrapper("gf_isom_set_removed_bytes"));
        /** @type {function(...*):?} */
        var _gf_isom_reset_tables = (Module["_gf_isom_reset_tables"] =
            createExportWrapper("gf_isom_reset_tables"));
        /** @type {function(...*):?} */
        var _gf_isom_release_segment = (Module["_gf_isom_release_segment"] =
            createExportWrapper("gf_isom_release_segment"));
        /** @type {function(...*):?} */
        var _gf_isom_needs_layer_reconstruction = (Module["_gf_isom_needs_layer_reconstruction"] =
            createExportWrapper("gf_isom_needs_layer_reconstruction"));
        /** @type {function(...*):?} */
        var _gf_isom_get_highest_track_in_scalable_segment = (Module[
            "_gf_isom_get_highest_track_in_scalable_segment"
        ] = createExportWrapper("gf_isom_get_highest_track_in_scalable_segment"));
        /** @type {function(...*):?} */
        var _gf_isom_text_set_streaming_mode = (Module["_gf_isom_text_set_streaming_mode"] =
            createExportWrapper("gf_isom_text_set_streaming_mode"));
        /** @type {function(...*):?} */
        var _gf_isom_get_audio_layout = (Module["_gf_isom_get_audio_layout"] = createExportWrapper(
            "gf_isom_get_audio_layout"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_get_pixel_aspect_ratio = (Module["_gf_isom_get_pixel_aspect_ratio"] =
            createExportWrapper("gf_isom_get_pixel_aspect_ratio"));
        /** @type {function(...*):?} */
        var _gf_isom_get_color_info = (Module["_gf_isom_get_color_info"] =
            createExportWrapper("gf_isom_get_color_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_icc_profile = (Module["_gf_isom_get_icc_profile"] =
            createExportWrapper("gf_isom_get_icc_profile"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_matrix = (Module["_gf_isom_get_track_matrix"] = createExportWrapper(
            "gf_isom_get_track_matrix"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_get_media_data_size = (Module["_gf_isom_get_media_data_size"] =
            createExportWrapper("gf_isom_get_media_data_size"));
        /** @type {function(...*):?} */
        var _gf_isom_set_default_sync_track = (Module["_gf_isom_set_default_sync_track"] =
            createExportWrapper("gf_isom_set_default_sync_track"));
        /** @type {function(...*):?} */
        var _gf_isom_is_single_av = (Module["_gf_isom_is_single_av"] =
            createExportWrapper("gf_isom_is_single_av"));
        /** @type {function(...*):?} */
        var _gf_isom_guess_specification = (Module["_gf_isom_guess_specification"] =
            createExportWrapper("gf_isom_guess_specification"));
        /** @type {function(...*):?} */
        var _gf_isom_sample_get_subsamples_buffer = (Module[
            "_gf_isom_sample_get_subsamples_buffer"
        ] = createExportWrapper("gf_isom_sample_get_subsamples_buffer"));
        /** @type {function(...*):?} */
        var _gf_isom_sample_has_subsamples = (Module["_gf_isom_sample_has_subsamples"] =
            createExportWrapper("gf_isom_sample_has_subsamples"));
        /** @type {function(...*):?} */
        var _gf_isom_sample_get_subsample = (Module["_gf_isom_sample_get_subsample"] =
            createExportWrapper("gf_isom_sample_get_subsample"));
        /** @type {function(...*):?} */
        var _gf_isom_extract_meta_item_mem = (Module["_gf_isom_extract_meta_item_mem"] =
            createExportWrapper("gf_isom_extract_meta_item_mem"));
        /** @type {function(...*):?} */
        var _gf_isom_reset_fragment_info = (Module["_gf_isom_reset_fragment_info"] =
            createExportWrapper("gf_isom_reset_fragment_info"));
        /** @type {function(...*):?} */
        var _gf_isom_reset_seq_num = (Module["_gf_isom_reset_seq_num"] =
            createExportWrapper("gf_isom_reset_seq_num"));
        /** @type {function(...*):?} */
        var _gf_isom_reset_sample_count = (Module["_gf_isom_reset_sample_count"] =
            createExportWrapper("gf_isom_reset_sample_count"));
        /** @type {function(...*):?} */
        var _gf_isom_has_cenc_sample_group = (Module["_gf_isom_has_cenc_sample_group"] =
            createExportWrapper("gf_isom_has_cenc_sample_group"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sample_to_group_info = (Module["_gf_isom_get_sample_to_group_info"] =
            createExportWrapper("gf_isom_get_sample_to_group_info"));
        /** @type {function(...*):?} */
        var _gf_isom_has_keep_utc_times = (Module["_gf_isom_has_keep_utc_times"] =
            createExportWrapper("gf_isom_has_keep_utc_times"));
        /** @type {function(...*):?} */
        var _gf_isom_get_pssh_count = (Module["_gf_isom_get_pssh_count"] =
            createExportWrapper("gf_isom_get_pssh_count"));
        /** @type {function(...*):?} */
        var _gf_isom_get_pssh_info = (Module["_gf_isom_get_pssh_info"] =
            createExportWrapper("gf_isom_get_pssh_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_last_producer_time_box = (Module["_gf_isom_get_last_producer_time_box"] =
            createExportWrapper("gf_isom_get_last_producer_time_box"));
        /** @type {function(...*):?} */
        var _gf_isom_get_current_tfdt = (Module["_gf_isom_get_current_tfdt"] = createExportWrapper(
            "gf_isom_get_current_tfdt"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_get_smooth_next_tfdt = (Module["_gf_isom_get_smooth_next_tfdt"] =
            createExportWrapper("gf_isom_get_smooth_next_tfdt"));
        /** @type {function(...*):?} */
        var _gf_isom_is_smooth_streaming_moov = (Module["_gf_isom_is_smooth_streaming_moov"] =
            createExportWrapper("gf_isom_is_smooth_streaming_moov"));
        /** @type {function(...*):?} */
        var _gf_isom_set_byte_offset = (Module["_gf_isom_set_byte_offset"] =
            createExportWrapper("gf_isom_set_byte_offset"));
        /** @type {function(...*):?} */
        var _gf_isom_get_nalu_length_field = (Module["_gf_isom_get_nalu_length_field"] =
            createExportWrapper("gf_isom_get_nalu_length_field"));
        /** @type {function(...*):?} */
        var _gf_isom_get_bitrate = (Module["_gf_isom_get_bitrate"] =
            createExportWrapper("gf_isom_get_bitrate"));
        /** @type {function(...*):?} */
        var _gf_isom_get_root_sidx_offsets = (Module["_gf_isom_get_root_sidx_offsets"] =
            createExportWrapper("gf_isom_get_root_sidx_offsets"));
        /** @type {function(...*):?} */
        var _gf_isom_get_jp2_config = (Module["_gf_isom_get_jp2_config"] =
            createExportWrapper("gf_isom_get_jp2_config"));
        /** @type {function(...*):?} */
        var _gf_isom_get_file_offset_for_time = (Module["_gf_isom_get_file_offset_for_time"] =
            createExportWrapper("gf_isom_get_file_offset_for_time"));
        /** @type {function(...*):?} */
        var _gf_isom_get_sidx_duration = (Module["_gf_isom_get_sidx_duration"] =
            createExportWrapper("gf_isom_get_sidx_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_get_clean_aperture = (Module["_gf_isom_get_clean_aperture"] =
            createExportWrapper("gf_isom_get_clean_aperture"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_group = (Module["_gf_isom_get_track_group"] =
            createExportWrapper("gf_isom_get_track_group"));
        /** @type {function(...*):?} */
        var _gf_isom_get_mastering_display_colour_info = (Module[
            "_gf_isom_get_mastering_display_colour_info"
        ] = createExportWrapper("gf_isom_get_mastering_display_colour_info"));
        /** @type {function(...*):?} */
        var _gf_isom_get_content_light_level_info = (Module[
            "_gf_isom_get_content_light_level_info"
        ] = createExportWrapper("gf_isom_get_content_light_level_info"));
        /** @type {function(...*):?} */
        var _gf_isom_add_track_to_root_od = (Module["_gf_isom_add_track_to_root_od"] =
            createExportWrapper("gf_isom_add_track_to_root_od"));
        /** @type {function(...*):?} */
        var _gf_isom_add_desc_to_root_od = (Module["_gf_isom_add_desc_to_root_od"] =
            createExportWrapper("gf_isom_add_desc_to_root_od"));
        /** @type {function(...*):?} */
        var _gf_isom_set_root_od_id = (Module["_gf_isom_set_root_od_id"] =
            createExportWrapper("gf_isom_set_root_od_id"));
        /** @type {function(...*):?} */
        var _gf_isom_set_root_od_url = (Module["_gf_isom_set_root_od_url"] =
            createExportWrapper("gf_isom_set_root_od_url"));
        /** @type {function(...*):?} */
        var _gf_isom_get_last_created_track_id = (Module["_gf_isom_get_last_created_track_id"] =
            createExportWrapper("gf_isom_get_last_created_track_id"));
        /** @type {function(...*):?} */
        var _gf_isom_load_extra_boxes = (Module["_gf_isom_load_extra_boxes"] = createExportWrapper(
            "gf_isom_load_extra_boxes"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_new_track_from_template = (Module["_gf_isom_new_track_from_template"] =
            createExportWrapper("gf_isom_new_track_from_template"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_stream_description = (Module["_gf_isom_remove_stream_description"] =
            createExportWrapper("gf_isom_remove_stream_description"));
        /** @type {function(...*):?} */
        var _gf_isom_new_mpeg4_description = (Module["_gf_isom_new_mpeg4_description"] =
            createExportWrapper("gf_isom_new_mpeg4_description"));
        /** @type {function(...*):?} */
        var _gf_isom_add_sample_shadow = (Module["_gf_isom_add_sample_shadow"] =
            createExportWrapper("gf_isom_add_sample_shadow"));
        /** @type {function(...*):?} */
        var _gf_isom_append_sample_data = (Module["_gf_isom_append_sample_data"] =
            createExportWrapper("gf_isom_append_sample_data"));
        /** @type {function(...*):?} */
        var _gf_isom_patch_last_sample_duration = (Module["_gf_isom_patch_last_sample_duration"] =
            createExportWrapper("gf_isom_patch_last_sample_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_update_sample = (Module["_gf_isom_update_sample"] =
            createExportWrapper("gf_isom_update_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_update_sample_reference = (Module["_gf_isom_update_sample_reference"] =
            createExportWrapper("gf_isom_update_sample_reference"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_sample = (Module["_gf_isom_remove_sample"] =
            createExportWrapper("gf_isom_remove_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_add_desc_to_description = (Module["_gf_isom_add_desc_to_description"] =
            createExportWrapper("gf_isom_add_desc_to_description"));
        /** @type {function(...*):?} */
        var _gf_isom_change_mpeg4_description = (Module["_gf_isom_change_mpeg4_description"] =
            createExportWrapper("gf_isom_change_mpeg4_description"));
        /** @type {function(...*):?} */
        var _gf_isom_set_visual_info = (Module["_gf_isom_set_visual_info"] =
            createExportWrapper("gf_isom_set_visual_info"));
        /** @type {function(...*):?} */
        var _gf_isom_set_pixel_aspect_ratio = (Module["_gf_isom_set_pixel_aspect_ratio"] =
            createExportWrapper("gf_isom_set_pixel_aspect_ratio"));
        /** @type {function(...*):?} */
        var _gf_isom_set_image_sequence_alpha = (Module["_gf_isom_set_image_sequence_alpha"] =
            createExportWrapper("gf_isom_set_image_sequence_alpha"));
        /** @type {function(...*):?} */
        var _gf_isom_set_audio_layout = (Module["_gf_isom_set_audio_layout"] = createExportWrapper(
            "gf_isom_set_audio_layout"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_remove_edit = (Module["_gf_isom_remove_edit"] =
            createExportWrapper("gf_isom_remove_edit"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_chapter = (Module["_gf_isom_remove_chapter"] =
            createExportWrapper("gf_isom_remove_chapter"));
        /** @type {function(...*):?} */
        var _gf_isom_set_interleave_time = (Module["_gf_isom_set_interleave_time"] =
            createExportWrapper("gf_isom_set_interleave_time"));
        /** @type {function(...*):?} */
        var _gf_isom_reset_alt_brands = (Module["_gf_isom_reset_alt_brands"] = createExportWrapper(
            "gf_isom_reset_alt_brands"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_remove_user_data_item = (Module["_gf_isom_remove_user_data_item"] =
            createExportWrapper("gf_isom_remove_user_data_item"));
        /** @type {function(...*):?} */
        var _gf_isom_get_raw_user_data = (Module["_gf_isom_get_raw_user_data"] =
            createExportWrapper("gf_isom_get_raw_user_data"));
        /** @type {function(...*):?} */
        var _gf_isom_get_track_template = (Module["_gf_isom_get_track_template"] =
            createExportWrapper("gf_isom_get_track_template"));
        /** @type {function(...*):?} */
        var _gf_isom_get_trex_template = (Module["_gf_isom_get_trex_template"] =
            createExportWrapper("gf_isom_get_trex_template"));
        /** @type {function(...*):?} */
        var _gf_isom_get_stsd_template = (Module["_gf_isom_get_stsd_template"] =
            createExportWrapper("gf_isom_get_stsd_template"));
        /** @type {function(...*):?} */
        var _gf_isom_new_generic_sample_description = (Module[
            "_gf_isom_new_generic_sample_description"
        ] = createExportWrapper("gf_isom_new_generic_sample_description"));
        /** @type {function(...*):?} */
        var _gf_isom_purge_track_reference = (Module["_gf_isom_purge_track_reference"] =
            createExportWrapper("gf_isom_purge_track_reference"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_track_references = (Module["_gf_isom_remove_track_references"] =
            createExportWrapper("gf_isom_remove_track_references"));
        /** @type {function(...*):?} */
        var _gf_isom_shift_cts_offset = (Module["_gf_isom_shift_cts_offset"] = createExportWrapper(
            "gf_isom_shift_cts_offset"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_set_cts_packing = (Module["_gf_isom_set_cts_packing"] =
            createExportWrapper("gf_isom_set_cts_packing"));
        /** @type {function(...*):?} */
        var _gf_isom_box_equal = (Module["_gf_isom_box_equal"] =
            createExportWrapper("gf_isom_box_equal"));
        /** @type {function(...*):?} */
        var _gf_isom_estimate_size = (Module["_gf_isom_estimate_size"] =
            createExportWrapper("gf_isom_estimate_size"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_interleaving_group = (Module[
            "_gf_isom_set_track_interleaving_group"
        ] = createExportWrapper("gf_isom_set_track_interleaving_group"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_priority_in_group = (Module["_gf_isom_set_track_priority_in_group"] =
            createExportWrapper("gf_isom_set_track_priority_in_group"));
        /** @type {function(...*):?} */
        var _gf_isom_hint_max_chunk_size = (Module["_gf_isom_hint_max_chunk_size"] =
            createExportWrapper("gf_isom_hint_max_chunk_size"));
        /** @type {function(...*):?} */
        var _gf_isom_hint_max_chunk_duration = (Module["_gf_isom_hint_max_chunk_duration"] =
            createExportWrapper("gf_isom_hint_max_chunk_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_set_extraction_slc = (Module["_gf_isom_set_extraction_slc"] =
            createExportWrapper("gf_isom_set_extraction_slc"));
        /** @type {function(...*):?} */
        var _gf_isom_make_interleave_ex = (Module["_gf_isom_make_interleave_ex"] =
            createExportWrapper("gf_isom_make_interleave_ex"));
        /** @type {function(...*):?} */
        var _gf_isom_add_uuid = (Module["_gf_isom_add_uuid"] =
            createExportWrapper("gf_isom_add_uuid"));
        /** @type {function(...*):?} */
        var _gf_isom_add_meta_item_memory = (Module["_gf_isom_add_meta_item_memory"] =
            createExportWrapper("gf_isom_add_meta_item_memory"));
        /** @type {function(...*):?} */
        var _gf_isom_add_sample_group_info = (Module["_gf_isom_add_sample_group_info"] =
            createExportWrapper("gf_isom_add_sample_group_info"));
        /** @type {function(...*):?} */
        var _gf_isom_remove_sample_group = (Module["_gf_isom_remove_sample_group"] =
            createExportWrapper("gf_isom_remove_sample_group"));
        /** @type {function(...*):?} */
        var _gf_isom_add_sample_info = (Module["_gf_isom_add_sample_info"] =
            createExportWrapper("gf_isom_add_sample_info"));
        /** @type {function(...*):?} */
        var _gf_isom_set_sample_rap_group = (Module["_gf_isom_set_sample_rap_group"] =
            createExportWrapper("gf_isom_set_sample_rap_group"));
        /** @type {function(...*):?} */
        var _gf_isom_fragment_set_sample_roll_group = (Module[
            "_gf_isom_fragment_set_sample_roll_group"
        ] = createExportWrapper("gf_isom_fragment_set_sample_roll_group"));
        /** @type {function(...*):?} */
        var _gf_isom_set_sample_cenc_group = (Module["_gf_isom_set_sample_cenc_group"] =
            createExportWrapper("gf_isom_set_sample_cenc_group"));
        /** @type {function(...*):?} */
        var _gf_isom_set_sample_cenc_default_group = (Module[
            "_gf_isom_set_sample_cenc_default_group"
        ] = createExportWrapper("gf_isom_set_sample_cenc_default_group"));
        /** @type {function(...*):?} */
        var _gf_isom_update_edit_list_duration = (Module["_gf_isom_update_edit_list_duration"] =
            createExportWrapper("gf_isom_update_edit_list_duration"));
        /** @type {function(...*):?} */
        var _gf_isom_clone_pssh = (Module["_gf_isom_clone_pssh"] =
            createExportWrapper("gf_isom_clone_pssh"));
        /** @type {function(...*):?} */
        var _gf_isom_set_nalu_length_field = (Module["_gf_isom_set_nalu_length_field"] =
            createExportWrapper("gf_isom_set_nalu_length_field"));
        /** @type {function(...*):?} */
        var _gf_isom_set_progress_callback = (Module["_gf_isom_set_progress_callback"] =
            createExportWrapper("gf_isom_set_progress_callback"));
        /** @type {function(...*):?} */
        var _gf_isom_set_track_magic = (Module["_gf_isom_set_track_magic"] =
            createExportWrapper("gf_isom_set_track_magic"));
        /** @type {function(...*):?} */
        var _gf_isom_set_mpegh_compatible_profiles = (Module[
            "_gf_isom_set_mpegh_compatible_profiles"
        ] = createExportWrapper("gf_isom_set_mpegh_compatible_profiles"));
        /** @type {function(...*):?} */
        var _gf_odf_codec_new = (Module["_gf_odf_codec_new"] =
            createExportWrapper("gf_odf_codec_new"));
        /** @type {function(...*):?} */
        var _gf_odf_codec_set_au = (Module["_gf_odf_codec_set_au"] =
            createExportWrapper("gf_odf_codec_set_au"));
        /** @type {function(...*):?} */
        var _gf_odf_codec_decode = (Module["_gf_odf_codec_decode"] =
            createExportWrapper("gf_odf_codec_decode"));
        /** @type {function(...*):?} */
        var _gf_odf_codec_get_com = (Module["_gf_odf_codec_get_com"] =
            createExportWrapper("gf_odf_codec_get_com"));
        /** @type {function(...*):?} */
        var _gf_odf_com_new = (Module["_gf_odf_com_new"] = createExportWrapper("gf_odf_com_new"));
        /** @type {function(...*):?} */
        var _gf_odf_com_del = (Module["_gf_odf_com_del"] = createExportWrapper("gf_odf_com_del"));
        /** @type {function(...*):?} */
        var _gf_odf_codec_add_com = (Module["_gf_odf_codec_add_com"] =
            createExportWrapper("gf_odf_codec_add_com"));
        /** @type {function(...*):?} */
        var _gf_odf_codec_encode = (Module["_gf_odf_codec_encode"] =
            createExportWrapper("gf_odf_codec_encode"));
        /** @type {function(...*):?} */
        var _gf_odf_codec_get_au = (Module["_gf_odf_codec_get_au"] =
            createExportWrapper("gf_odf_codec_get_au"));
        /** @type {function(...*):?} */
        var _gf_odf_codec_del = (Module["_gf_odf_codec_del"] =
            createExportWrapper("gf_odf_codec_del"));
        /** @type {function(...*):?} */
        var _gf_isom_find_od_id_for_track = (Module["_gf_isom_find_od_id_for_track"] =
            createExportWrapper("gf_isom_find_od_id_for_track"));
        /** @type {function(...*):?} */
        var _gf_isom_get_meta_item_flags = (Module["_gf_isom_get_meta_item_flags"] =
            createExportWrapper("gf_isom_get_meta_item_flags"));
        /** @type {function(...*):?} */
        var _gf_odf_avc_cfg_write_bs = (Module["_gf_odf_avc_cfg_write_bs"] =
            createExportWrapper("gf_odf_avc_cfg_write_bs"));
        /** @type {function(...*):?} */
        var _gf_isom_add_meta_item_sample_ref = (Module["_gf_isom_add_meta_item_sample_ref"] =
            createExportWrapper("gf_isom_add_meta_item_sample_ref"));
        /** @type {function(...*):?} */
        var _gf_isom_meta_get_item_ref_count = (Module["_gf_isom_meta_get_item_ref_count"] =
            createExportWrapper("gf_isom_meta_get_item_ref_count"));
        /** @type {function(...*):?} */
        var _gf_isom_meta_item_has_ref = (Module["_gf_isom_meta_item_has_ref"] =
            createExportWrapper("gf_isom_meta_item_has_ref"));
        /** @type {function(...*):?} */
        var _gf_isom_meta_get_item_ref_id = (Module["_gf_isom_meta_get_item_ref_id"] =
            createExportWrapper("gf_isom_meta_get_item_ref_id"));
        /** @type {function(...*):?} */
        var _gf_isom_finalize_for_fragment = (Module["_gf_isom_finalize_for_fragment"] =
            createExportWrapper("gf_isom_finalize_for_fragment"));
        /** @type {function(...*):?} */
        var _gf_isom_setup_track_fragment = (Module["_gf_isom_setup_track_fragment"] =
            createExportWrapper("gf_isom_setup_track_fragment"));
        /** @type {function(...*):?} */
        var _gf_isom_setup_track_fragment_template = (Module[
            "_gf_isom_setup_track_fragment_template"
        ] = createExportWrapper("gf_isom_setup_track_fragment_template"));
        /** @type {function(...*):?} */
        var _gf_isom_set_fragment_option = (Module["_gf_isom_set_fragment_option"] =
            createExportWrapper("gf_isom_set_fragment_option"));
        /** @type {function(...*):?} */
        var _gf_isom_flush_fragments = (Module["_gf_isom_flush_fragments"] =
            createExportWrapper("gf_isom_flush_fragments"));
        /** @type {function(...*):?} */
        var _gf_isom_close_segment = (Module["_gf_isom_close_segment"] =
            createExportWrapper("gf_isom_close_segment"));
        /** @type {function(...*):?} */
        var _gf_isom_flush_sidx = (Module["_gf_isom_flush_sidx"] =
            createExportWrapper("gf_isom_flush_sidx"));
        /** @type {function(...*):?} */
        var _gf_isom_start_segment = (Module["_gf_isom_start_segment"] =
            createExportWrapper("gf_isom_start_segment"));
        /** @type {function(...*):?} */
        var _gf_isom_set_fragment_reference_time = (Module["_gf_isom_set_fragment_reference_time"] =
            createExportWrapper("gf_isom_set_fragment_reference_time"));
        /** @type {function(...*):?} */
        var _gf_isom_set_traf_mss_timeext = (Module["_gf_isom_set_traf_mss_timeext"] =
            createExportWrapper("gf_isom_set_traf_mss_timeext"));
        /** @type {function(...*):?} */
        var _gf_isom_start_fragment = (Module["_gf_isom_start_fragment"] =
            createExportWrapper("gf_isom_start_fragment"));
        /** @type {function(...*):?} */
        var _gf_isom_fragment_add_sample_ex = (Module["_gf_isom_fragment_add_sample_ex"] =
            createExportWrapper("gf_isom_fragment_add_sample_ex"));
        /** @type {function(...*):?} */
        var _gf_isom_fragment_add_sample = (Module["_gf_isom_fragment_add_sample"] =
            createExportWrapper("gf_isom_fragment_add_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_fragment_set_cenc_sai = (Module["_gf_isom_fragment_set_cenc_sai"] =
            createExportWrapper("gf_isom_fragment_set_cenc_sai"));
        /** @type {function(...*):?} */
        var _gf_isom_fragment_append_data_ex = (Module["_gf_isom_fragment_append_data_ex"] =
            createExportWrapper("gf_isom_fragment_append_data_ex"));
        /** @type {function(...*):?} */
        var _gf_isom_fragment_append_data = (Module["_gf_isom_fragment_append_data"] =
            createExportWrapper("gf_isom_fragment_append_data"));
        /** @type {function(...*):?} */
        var _gf_isom_set_traf_base_media_decode_time = (Module[
            "_gf_isom_set_traf_base_media_decode_time"
        ] = createExportWrapper("gf_isom_set_traf_base_media_decode_time"));
        /** @type {function(...*):?} */
        var _gf_isom_set_next_moof_number = (Module["_gf_isom_set_next_moof_number"] =
            createExportWrapper("gf_isom_set_next_moof_number"));
        /** @type {function(...*):?} */
        var _gf_isom_get_next_moof_number = (Module["_gf_isom_get_next_moof_number"] =
            createExportWrapper("gf_isom_get_next_moof_number"));
        /** @type {function(...*):?} */
        var _gf_isom_3gp_config_get = (Module["_gf_isom_3gp_config_get"] =
            createExportWrapper("gf_isom_3gp_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_flac_config_get = (Module["_gf_isom_flac_config_get"] =
            createExportWrapper("gf_isom_flac_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_opus_config_new = (Module["_gf_isom_opus_config_new"] =
            createExportWrapper("gf_isom_opus_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_opus_config_get = (Module["_gf_isom_opus_config_get"] =
            createExportWrapper("gf_isom_opus_config_get"));
        /** @type {function(...*):?} */
        var _gf_isom_3gp_config_new = (Module["_gf_isom_3gp_config_new"] =
            createExportWrapper("gf_isom_3gp_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_3gp_config_update = (Module["_gf_isom_3gp_config_update"] =
            createExportWrapper("gf_isom_3gp_config_update"));
        /** @type {function(...*):?} */
        var _gf_isom_ac3_config_new = (Module["_gf_isom_ac3_config_new"] =
            createExportWrapper("gf_isom_ac3_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_flac_config_new = (Module["_gf_isom_flac_config_new"] =
            createExportWrapper("gf_isom_flac_config_new"));
        /** @type {function(...*):?} */
        var _gf_isom_new_mj2k_description = (Module["_gf_isom_new_mj2k_description"] =
            createExportWrapper("gf_isom_new_mj2k_description"));
        /** @type {function(...*):?} */
        var _gf_isom_new_dims_description = (Module["_gf_isom_new_dims_description"] =
            createExportWrapper("gf_isom_new_dims_description"));
        /** @type {function(...*):?} */
        var _gf_isom_subtitle_get_mime = (Module["_gf_isom_subtitle_get_mime"] =
            createExportWrapper("gf_isom_subtitle_get_mime"));
        /** @type {function(...*):?} */
        var _gf_isom_subtitle_set_mime = (Module["_gf_isom_subtitle_set_mime"] =
            createExportWrapper("gf_isom_subtitle_set_mime"));
        /** @type {function(...*):?} */
        var _gf_isom_new_xml_subtitle_description = (Module[
            "_gf_isom_new_xml_subtitle_description"
        ] = createExportWrapper("gf_isom_new_xml_subtitle_description"));
        /** @type {function(...*):?} */
        var _gf_isom_get_webvtt_config = (Module["_gf_isom_get_webvtt_config"] =
            createExportWrapper("gf_isom_get_webvtt_config"));
        /** @type {function(...*):?} */
        var _gf_isom_refresh_size_info = (Module["_gf_isom_refresh_size_info"] =
            createExportWrapper("gf_isom_refresh_size_info"));
        /** @type {function(...*):?} */
        var _gf_isom_new_text_description = (Module["_gf_isom_new_text_description"] =
            createExportWrapper("gf_isom_new_text_description"));
        /** @type {function(...*):?} */
        var _gf_isom_text_add_text = (Module["_gf_isom_text_add_text"] =
            createExportWrapper("gf_isom_text_add_text"));
        /** @type {function(...*):?} */
        var _gf_isom_text_add_style = (Module["_gf_isom_text_add_style"] =
            createExportWrapper("gf_isom_text_add_style"));
        /** @type {function(...*):?} */
        var _gf_isom_text_add_highlight = (Module["_gf_isom_text_add_highlight"] =
            createExportWrapper("gf_isom_text_add_highlight"));
        /** @type {function(...*):?} */
        var _gf_isom_text_set_highlight_color = (Module["_gf_isom_text_set_highlight_color"] =
            createExportWrapper("gf_isom_text_set_highlight_color"));
        /** @type {function(...*):?} */
        var _gf_isom_text_add_karaoke = (Module["_gf_isom_text_add_karaoke"] = createExportWrapper(
            "gf_isom_text_add_karaoke"
        ));
        /** @type {function(...*):?} */
        var _gf_isom_text_set_karaoke_segment = (Module["_gf_isom_text_set_karaoke_segment"] =
            createExportWrapper("gf_isom_text_set_karaoke_segment"));
        /** @type {function(...*):?} */
        var _gf_isom_text_set_scroll_delay = (Module["_gf_isom_text_set_scroll_delay"] =
            createExportWrapper("gf_isom_text_set_scroll_delay"));
        /** @type {function(...*):?} */
        var _gf_isom_text_add_hyperlink = (Module["_gf_isom_text_add_hyperlink"] =
            createExportWrapper("gf_isom_text_add_hyperlink"));
        /** @type {function(...*):?} */
        var _gf_isom_text_set_box = (Module["_gf_isom_text_set_box"] =
            createExportWrapper("gf_isom_text_set_box"));
        /** @type {function(...*):?} */
        var _gf_isom_text_add_blink = (Module["_gf_isom_text_add_blink"] =
            createExportWrapper("gf_isom_text_add_blink"));
        /** @type {function(...*):?} */
        var _gf_isom_text_set_wrap = (Module["_gf_isom_text_set_wrap"] =
            createExportWrapper("gf_isom_text_set_wrap"));
        /** @type {function(...*):?} */
        var _gf_isom_text_set_forced = (Module["_gf_isom_text_set_forced"] =
            createExportWrapper("gf_isom_text_set_forced"));
        /** @type {function(...*):?} */
        var _gf_isom_text_sample_write_bs = (Module["_gf_isom_text_sample_write_bs"] =
            createExportWrapper("gf_isom_text_sample_write_bs"));
        /** @type {function(...*):?} */
        var _gf_isom_text_to_sample = (Module["_gf_isom_text_to_sample"] =
            createExportWrapper("gf_isom_text_to_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_new_text_sample = (Module["_gf_isom_new_text_sample"] =
            createExportWrapper("gf_isom_new_text_sample"));
        /** @type {function(...*):?} */
        var _gf_isom_text_reset_styles = (Module["_gf_isom_text_reset_styles"] =
            createExportWrapper("gf_isom_text_reset_styles"));
        /** @type {function(...*):?} */
        var _gf_isom_text_reset = (Module["_gf_isom_text_reset"] =
            createExportWrapper("gf_isom_text_reset"));
        /** @type {function(...*):?} */
        var _gf_odf_write_descriptor = (Module["_gf_odf_write_descriptor"] =
            createExportWrapper("gf_odf_write_descriptor"));
        /** @type {function(...*):?} */
        var _gf_odf_parse_descriptor = (Module["_gf_odf_parse_descriptor"] =
            createExportWrapper("gf_odf_parse_descriptor"));
        /** @type {function(...*):?} */
        var _gf_odf_encode_ui_config = (Module["_gf_odf_encode_ui_config"] =
            createExportWrapper("gf_odf_encode_ui_config"));
        /** @type {function(...*):?} */
        var _gf_odf_tx3g_read = (Module["_gf_odf_tx3g_read"] =
            createExportWrapper("gf_odf_tx3g_read"));
        /** @type {function(...*):?} */
        var _gf_odf_get_text_config = (Module["_gf_odf_get_text_config"] =
            createExportWrapper("gf_odf_get_text_config"));
        /** @type {function(...*):?} */
        var _gf_odf_hevc_cfg_new = (Module["_gf_odf_hevc_cfg_new"] =
            createExportWrapper("gf_odf_hevc_cfg_new"));
        /** @type {function(...*):?} */
        var _gf_odf_vvc_cfg_write = (Module["_gf_odf_vvc_cfg_write"] =
            createExportWrapper("gf_odf_vvc_cfg_write"));
        /** @type {function(...*):?} */
        var _gf_odf_vvc_cfg_read = (Module["_gf_odf_vvc_cfg_read"] =
            createExportWrapper("gf_odf_vvc_cfg_read"));
        /** @type {function(...*):?} */
        var _gf_odf_av1_cfg_new = (Module["_gf_odf_av1_cfg_new"] =
            createExportWrapper("gf_odf_av1_cfg_new"));
        /** @type {function(...*):?} */
        var _gf_odf_vp_cfg_read = (Module["_gf_odf_vp_cfg_read"] =
            createExportWrapper("gf_odf_vp_cfg_read"));
        /** @type {function(...*):?} */
        var _gf_odf_av1_cfg_read_bs = (Module["_gf_odf_av1_cfg_read_bs"] =
            createExportWrapper("gf_odf_av1_cfg_read_bs"));
        /** @type {function(...*):?} */
        var _gf_odf_av1_cfg_read = (Module["_gf_odf_av1_cfg_read"] =
            createExportWrapper("gf_odf_av1_cfg_read"));
        /** @type {function(...*):?} */
        var _gf_odf_desc_write_bs = (Module["_gf_odf_desc_write_bs"] =
            createExportWrapper("gf_odf_desc_write_bs"));
        /** @type {function(...*):?} */
        var _gf_sl_packetize = (Module["_gf_sl_packetize"] =
            createExportWrapper("gf_sl_packetize"));
        /** @type {function(...*):?} */
        var _gf_sl_get_header_size = (Module["_gf_sl_get_header_size"] =
            createExportWrapper("gf_sl_get_header_size"));
        /** @type {function(...*):?} */
        var _gf_sl_depacketize = (Module["_gf_sl_depacketize"] =
            createExportWrapper("gf_sl_depacketize"));
        /** @type {function(...*):?} */
        var _gf_odf_dump_com = (Module["_gf_odf_dump_com"] =
            createExportWrapper("gf_odf_dump_com"));
        /** @type {function(...*):?} */
        var _gf_odf_dump_com_list = (Module["_gf_odf_dump_com_list"] =
            createExportWrapper("gf_odf_dump_com_list"));
        /** @type {function(...*):?} */
        var _gf_odf_dump_txtcfg = (Module["_gf_odf_dump_txtcfg"] =
            createExportWrapper("gf_odf_dump_txtcfg"));
        /** @type {function(...*):?} */
        var _gf_avc_change_par = (Module["_gf_avc_change_par"] =
            createExportWrapper("gf_avc_change_par"));
        /** @type {function(...*):?} */
        var _gf_hevc_get_sps_info = (Module["_gf_hevc_get_sps_info"] =
            createExportWrapper("gf_hevc_get_sps_info"));
        /** @type {function(...*):?} */
        var _gf_hevc_change_par = (Module["_gf_hevc_change_par"] =
            createExportWrapper("gf_hevc_change_par"));
        /** @type {function(...*):?} */
        var _gf_vvc_change_par = (Module["_gf_vvc_change_par"] =
            createExportWrapper("gf_vvc_change_par"));
        /** @type {function(...*):?} */
        var _gf_avc_change_color = (Module["_gf_avc_change_color"] =
            createExportWrapper("gf_avc_change_color"));
        /** @type {function(...*):?} */
        var _gf_hevc_change_color = (Module["_gf_hevc_change_color"] =
            createExportWrapper("gf_hevc_change_color"));
        /** @type {function(...*):?} */
        var _gf_vvc_change_color = (Module["_gf_vvc_change_color"] =
            createExportWrapper("gf_vvc_change_color"));
        /** @type {function(...*):?} */
        var _gf_hevc_read_sps = (Module["_gf_hevc_read_sps"] =
            createExportWrapper("gf_hevc_read_sps"));
        /** @type {function(...*):?} */
        var _gf_media_map_item_esd = (Module["_gf_media_map_item_esd"] =
            createExportWrapper("gf_media_map_item_esd"));
        /** @type {function(...*):?} */
        var _gf_avc_read_pps = (Module["_gf_avc_read_pps"] =
            createExportWrapper("gf_avc_read_pps"));
        /** @type {function(...*):?} */
        var _gf_avc_parse_nalu = (Module["_gf_avc_parse_nalu"] =
            createExportWrapper("gf_avc_parse_nalu"));
        /** @type {function(...*):?} */
        var _gf_hevc_read_pps = (Module["_gf_hevc_read_pps"] =
            createExportWrapper("gf_hevc_read_pps"));
        /** @type {function(...*):?} */
        var _gf_hevc_parse_nalu = (Module["_gf_hevc_parse_nalu"] =
            createExportWrapper("gf_hevc_parse_nalu"));
        /** @type {function(...*):?} */
        var _gf_dasher_clean_inputs = (Module["_gf_dasher_clean_inputs"] =
            createExportWrapper("gf_dasher_clean_inputs"));
        /** @type {function(...*):?} */
        var _gf_fs_print_unused_args = (Module["_gf_fs_print_unused_args"] =
            createExportWrapper("gf_fs_print_unused_args"));
        /** @type {function(...*):?} */
        var _gf_filter_send_update = (Module["_gf_filter_send_update"] =
            createExportWrapper("gf_filter_send_update"));
        /** @type {function(...*):?} */
        var _gf_filter_send_event = (Module["_gf_filter_send_event"] =
            createExportWrapper("gf_filter_send_event"));
        /** @type {function(...*):?} */
        var _gf_media_reduce_aspect_ratio = (Module["_gf_media_reduce_aspect_ratio"] =
            createExportWrapper("gf_media_reduce_aspect_ratio"));
        /** @type {function(...*):?} */
        var _gf_m4v_parser_new = (Module["_gf_m4v_parser_new"] =
            createExportWrapper("gf_m4v_parser_new"));
        /** @type {function(...*):?} */
        var _gf_m4v_parser_del = (Module["_gf_m4v_parser_del"] =
            createExportWrapper("gf_m4v_parser_del"));
        /** @type {function(...*):?} */
        var _gf_m4v_parser_del_no_bs = (Module["_gf_m4v_parser_del_no_bs"] =
            createExportWrapper("gf_m4v_parser_del_no_bs"));
        /** @type {function(...*):?} */
        var _gf_m4v_parser_set_inspect = (Module["_gf_m4v_parser_set_inspect"] =
            createExportWrapper("gf_m4v_parser_set_inspect"));
        /** @type {function(...*):?} */
        var _gf_m4v_parser_get_obj_type = (Module["_gf_m4v_parser_get_obj_type"] =
            createExportWrapper("gf_m4v_parser_get_obj_type"));
        /** @type {function(...*):?} */
        var _gf_m4v_rewrite_pl = (Module["_gf_m4v_rewrite_pl"] =
            createExportWrapper("gf_m4v_rewrite_pl"));
        /** @type {function(...*):?} */
        var _gf_m4v_parse_config = (Module["_gf_m4v_parse_config"] =
            createExportWrapper("gf_m4v_parse_config"));
        /** @type {function(...*):?} */
        var _gf_m4v_parse_frame = (Module["_gf_m4v_parse_frame"] =
            createExportWrapper("gf_m4v_parse_frame"));
        /** @type {function(...*):?} */
        var _gf_m4v_get_object_start = (Module["_gf_m4v_get_object_start"] =
            createExportWrapper("gf_m4v_get_object_start"));
        /** @type {function(...*):?} */
        var _gf_mpegv12_get_config = (Module["_gf_mpegv12_get_config"] =
            createExportWrapper("gf_mpegv12_get_config"));
        /** @type {function(...*):?} */
        var _gf_m4a_get_profile = (Module["_gf_m4a_get_profile"] =
            createExportWrapper("gf_m4a_get_profile"));
        /** @type {function(...*):?} */
        var _gf_m4a_parse_program_config_element = (Module["_gf_m4a_parse_program_config_element"] =
            createExportWrapper("gf_m4a_parse_program_config_element"));
        /** @type {function(...*):?} */
        var _gf_m4a_parse_config = (Module["_gf_m4a_parse_config"] =
            createExportWrapper("gf_m4a_parse_config"));
        /** @type {function(...*):?} */
        var _gf_m4a_get_channel_cfg = (Module["_gf_m4a_get_channel_cfg"] =
            createExportWrapper("gf_m4a_get_channel_cfg"));
        /** @type {function(...*):?} */
        var _gf_m4a_write_program_config_element_bs = (Module[
            "_gf_m4a_write_program_config_element_bs"
        ] = createExportWrapper("gf_m4a_write_program_config_element_bs"));
        /** @type {function(...*):?} */
        var _gf_m4a_write_config_bs = (Module["_gf_m4a_write_config_bs"] =
            createExportWrapper("gf_m4a_write_config_bs"));
        /** @type {function(...*):?} */
        var _gf_media_prores_parse_bs = (Module["_gf_media_prores_parse_bs"] = createExportWrapper(
            "gf_media_prores_parse_bs"
        ));
        /** @type {function(...*):?} */
        var _gf_mp3_version = (Module["_gf_mp3_version"] = createExportWrapper("gf_mp3_version"));
        /** @type {function(...*):?} */
        var _gf_mp3_window_size = (Module["_gf_mp3_window_size"] =
            createExportWrapper("gf_mp3_window_size"));
        /** @type {function(...*):?} */
        var _gf_mp3_object_type_indication = (Module["_gf_mp3_object_type_indication"] =
            createExportWrapper("gf_mp3_object_type_indication"));
        /** @type {function(...*):?} */
        var _gf_mp3_frame_size = (Module["_gf_mp3_frame_size"] =
            createExportWrapper("gf_mp3_frame_size"));
        /** @type {function(...*):?} */
        var _gf_mp3_get_next_header = (Module["_gf_mp3_get_next_header"] =
            createExportWrapper("gf_mp3_get_next_header"));
        /** @type {function(...*):?} */
        var _gf_mp3_get_next_header_mem = (Module["_gf_mp3_get_next_header_mem"] =
            createExportWrapper("gf_mp3_get_next_header_mem"));
        /** @type {function(...*):?} */
        var _gf_media_nalu_remove_emulation_bytes = (Module[
            "_gf_media_nalu_remove_emulation_bytes"
        ] = createExportWrapper("gf_media_nalu_remove_emulation_bytes"));
        /** @type {function(...*):?} */
        var _gf_avc_read_sps_bs = (Module["_gf_avc_read_sps_bs"] =
            createExportWrapper("gf_avc_read_sps_bs"));
        /** @type {function(...*):?} */
        var _gf_avc_read_pps_bs = (Module["_gf_avc_read_pps_bs"] =
            createExportWrapper("gf_avc_read_pps_bs"));
        /** @type {function(...*):?} */
        var _gf_avc_get_pps_info = (Module["_gf_avc_get_pps_info"] =
            createExportWrapper("gf_avc_get_pps_info"));
        /** @type {function(...*):?} */
        var _gf_hevc_read_vps_ex = (Module["_gf_hevc_read_vps_ex"] =
            createExportWrapper("gf_hevc_read_vps_ex"));
        /** @type {function(...*):?} */
        var _gf_hevc_read_vps_bs = (Module["_gf_hevc_read_vps_bs"] =
            createExportWrapper("gf_hevc_read_vps_bs"));
        /** @type {function(...*):?} */
        var _gf_hevc_read_sps_ex = (Module["_gf_hevc_read_sps_ex"] =
            createExportWrapper("gf_hevc_read_sps_ex"));
        /** @type {function(...*):?} */
        var _gf_hevc_read_sps_bs = (Module["_gf_hevc_read_sps_bs"] =
            createExportWrapper("gf_hevc_read_sps_bs"));
        /** @type {function(...*):?} */
        var _gf_hevc_read_pps_bs = (Module["_gf_hevc_read_pps_bs"] =
            createExportWrapper("gf_hevc_read_pps_bs"));
        /** @type {function(...*):?} */
        var _gf_hevc_parse_nalu_bs = (Module["_gf_hevc_parse_nalu_bs"] =
            createExportWrapper("gf_hevc_parse_nalu_bs"));
        /** @type {function(...*):?} */
        var _gf_hevc_change_vui = (Module["_gf_hevc_change_vui"] =
            createExportWrapper("gf_hevc_change_vui"));
        /** @type {function(...*):?} */
        var _gf_ac3_get_surround_channels = (Module["_gf_ac3_get_surround_channels"] =
            createExportWrapper("gf_ac3_get_surround_channels"));
        /** @type {function(...*):?} */
        var _gf_ac3_parser_bs = (Module["_gf_ac3_parser_bs"] =
            createExportWrapper("gf_ac3_parser_bs"));
        /** @type {function(...*):?} */
        var _gf_eac3_parser_bs = (Module["_gf_eac3_parser_bs"] =
            createExportWrapper("gf_eac3_parser_bs"));
        /** @type {function(...*):?} */
        var _gf_vorbis_parse_header = (Module["_gf_vorbis_parse_header"] =
            createExportWrapper("gf_vorbis_parse_header"));
        /** @type {function(...*):?} */
        var _gf_vorbis_check_frame = (Module["_gf_vorbis_check_frame"] =
            createExportWrapper("gf_vorbis_check_frame"));
        /** @type {function(...*):?} */
        var _gf_opus_parse_packet_header = (Module["_gf_opus_parse_packet_header"] =
            createExportWrapper("gf_opus_parse_packet_header"));
        /** @type {function(...*):?} */
        var _gf_vvc_parse_sei = (Module["_gf_vvc_parse_sei"] =
            createExportWrapper("gf_vvc_parse_sei"));
        /** @type {function(...*):?} */
        var _gf_vvc_parse_nalu_bs = (Module["_gf_vvc_parse_nalu_bs"] =
            createExportWrapper("gf_vvc_parse_nalu_bs"));
        /** @type {function(...*):?} */
        var _gf_vvc_parse_nalu = (Module["_gf_vvc_parse_nalu"] =
            createExportWrapper("gf_vvc_parse_nalu"));
        /** @type {function(...*):?} */
        var _gf_vvc_change_vui = (Module["_gf_vvc_change_vui"] =
            createExportWrapper("gf_vvc_change_vui"));
        /** @type {function(...*):?} */
        var _gf_vvc_get_profile_name = (Module["_gf_vvc_get_profile_name"] =
            createExportWrapper("gf_vvc_get_profile_name"));
        /** @type {function(...*):?} */
        var _gf_img_parse = (Module["_gf_img_parse"] = createExportWrapper("gf_img_parse"));
        /** @type {function(...*):?} */
        var _gf_img_jpeg_dec = (Module["_gf_img_jpeg_dec"] =
            createExportWrapper("gf_img_jpeg_dec"));
        /** @type {function(...*):?} */
        var _gf_img_png_dec = (Module["_gf_img_png_dec"] = createExportWrapper("gf_img_png_dec"));
        /** @type {function(...*):?} */
        var _saveSetjmp = createExportWrapper("saveSetjmp");
        /** @type {function(...*):?} */
        var _gf_media_import_chapters_file = (Module["_gf_media_import_chapters_file"] =
            createExportWrapper("gf_media_import_chapters_file"));
        /** @type {function(...*):?} */
        var _gf_filter_set_setup_failure_callback = (Module[
            "_gf_filter_set_setup_failure_callback"
        ] = createExportWrapper("gf_filter_set_setup_failure_callback"));
        /** @type {function(...*):?} */
        var _gf_filter_get_id = (Module["_gf_filter_get_id"] =
            createExportWrapper("gf_filter_get_id"));
        /** @type {function(...*):?} */
        var _gf_filter_assign_id = (Module["_gf_filter_assign_id"] =
            createExportWrapper("gf_filter_assign_id"));
        /** @type {function(...*):?} */
        var _gf_m2ts_get_sdt_info = (Module["_gf_m2ts_get_sdt_info"] =
            createExportWrapper("gf_m2ts_get_sdt_info"));
        /** @type {function(...*):?} */
        var _gf_m2ts_reset_parsers_for_program = (Module["_gf_m2ts_reset_parsers_for_program"] =
            createExportWrapper("gf_m2ts_reset_parsers_for_program"));
        /** @type {function(...*):?} */
        var _gf_m2ts_demux_dmscc_init = (Module["_gf_m2ts_demux_dmscc_init"] = createExportWrapper(
            "gf_m2ts_demux_dmscc_init"
        ));
        /** @type {function(...*):?} */
        var _gf_m2ts_probe_file = (Module["_gf_m2ts_probe_file"] =
            createExportWrapper("gf_m2ts_probe_file"));
        /** @type {function(...*):?} */
        var _gf_m2ts_probe_data = (Module["_gf_m2ts_probe_data"] =
            createExportWrapper("gf_m2ts_probe_data"));
        /** @type {function(...*):?} */
        var _gf_m2ts_restamp = (Module["_gf_m2ts_restamp"] =
            createExportWrapper("gf_m2ts_restamp"));
        /** @type {function(...*):?} */
        var _gf_m3u8_parse_master_playlist = (Module["_gf_m3u8_parse_master_playlist"] =
            createExportWrapper("gf_m3u8_parse_master_playlist"));
        /** @type {function(...*):?} */
        var _gf_mpd_complete_from_dom = (Module["_gf_mpd_complete_from_dom"] = createExportWrapper(
            "gf_mpd_complete_from_dom"
        ));
        /** @type {function(...*):?} */
        var _gf_mpd_init_from_dom = (Module["_gf_mpd_init_from_dom"] =
            createExportWrapper("gf_mpd_init_from_dom"));
        /** @type {function(...*):?} */
        var _htonl = createExportWrapper("htonl");
        /** @type {function(...*):?} */
        var _htons = createExportWrapper("htons");
        /** @type {function(...*):?} */
        var _ntohs = createExportWrapper("ntohs");
        /** @type {function(...*):?} */
        var _gf_m3u8_solve_representation_xlink = (Module["_gf_m3u8_solve_representation_xlink"] =
            createExportWrapper("gf_m3u8_solve_representation_xlink"));
        /** @type {function(...*):?} */
        var _gf_mpd_solve_segment_list_xlink = (Module["_gf_mpd_solve_segment_list_xlink"] =
            createExportWrapper("gf_mpd_solve_segment_list_xlink"));
        /** @type {function(...*):?} */
        var _gf_mpd_delete_segment_list = (Module["_gf_mpd_delete_segment_list"] =
            createExportWrapper("gf_mpd_delete_segment_list"));
        /** @type {function(...*):?} */
        var _gf_mpd_get_base_url_count = (Module["_gf_mpd_get_base_url_count"] =
            createExportWrapper("gf_mpd_get_base_url_count"));
        /** @type {function(...*):?} */
        var _gf_mpd_resolve_url = (Module["_gf_mpd_resolve_url"] =
            createExportWrapper("gf_mpd_resolve_url"));
        /** @type {function(...*):?} */
        var _gf_mpd_resolve_segment_duration = (Module["_gf_mpd_resolve_segment_duration"] =
            createExportWrapper("gf_mpd_resolve_segment_duration"));
        /** @type {function(...*):?} */
        var _gf_mpd_get_duration = (Module["_gf_mpd_get_duration"] =
            createExportWrapper("gf_mpd_get_duration"));
        /** @type {function(...*):?} */
        var _gf_mpd_get_segment_start_time_with_timescale = (Module[
            "_gf_mpd_get_segment_start_time_with_timescale"
        ] = createExportWrapper("gf_mpd_get_segment_start_time_with_timescale"));
        /** @type {function(...*):?} */
        var _gf_mpd_seek_in_period = (Module["_gf_mpd_seek_in_period"] =
            createExportWrapper("gf_mpd_seek_in_period"));
        /** @type {function(...*):?} */
        var _gf_mpd_init_smooth_from_dom = (Module["_gf_mpd_init_smooth_from_dom"] =
            createExportWrapper("gf_mpd_init_smooth_from_dom"));
        /** @type {function(...*):?} */
        var _gf_media_mpd_format_segment_name = (Module["_gf_media_mpd_format_segment_name"] =
            createExportWrapper("gf_media_mpd_format_segment_name"));
        /** @type {function(...*):?} */
        var _gf_dash_group_check_bandwidth = (Module["_gf_dash_group_check_bandwidth"] =
            createExportWrapper("gf_dash_group_check_bandwidth"));
        /** @type {function(...*):?} */
        var _gf_dash_group_has_dependent_group = (Module["_gf_dash_group_has_dependent_group"] =
            createExportWrapper("gf_dash_group_has_dependent_group"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_num_groups_depending_on = (Module[
            "_gf_dash_group_get_num_groups_depending_on"
        ] = createExportWrapper("gf_dash_group_get_num_groups_depending_on"));
        /** @type {function(...*):?} */
        var _gf_dash_get_dependent_group_index = (Module["_gf_dash_get_dependent_group_index"] =
            createExportWrapper("gf_dash_get_dependent_group_index"));
        /** @type {function(...*):?} */
        var _gf_dash_get_base_group_index = (Module["_gf_dash_get_base_group_index"] =
            createExportWrapper("gf_dash_get_base_group_index"));
        /** @type {function(...*):?} */
        var _gf_dash_open = (Module["_gf_dash_open"] = createExportWrapper("gf_dash_open"));
        /** @type {function(...*):?} */
        var _gf_dash_group_seek = (Module["_gf_dash_group_seek"] =
            createExportWrapper("gf_dash_group_seek"));
        /** @type {function(...*):?} */
        var _gf_dash_close = (Module["_gf_dash_close"] = createExportWrapper("gf_dash_close"));
        /** @type {function(...*):?} */
        var _gf_dash_set_algo = (Module["_gf_dash_set_algo"] =
            createExportWrapper("gf_dash_set_algo"));
        /** @type {function(...*):?} */
        var _gf_dash_set_algo_custom = (Module["_gf_dash_set_algo_custom"] =
            createExportWrapper("gf_dash_set_algo_custom"));
        /** @type {function(...*):?} */
        var _gf_dash_new = (Module["_gf_dash_new"] = createExportWrapper("gf_dash_new"));
        /** @type {function(...*):?} */
        var _gf_dash_del = (Module["_gf_dash_del"] = createExportWrapper("gf_dash_del"));
        /** @type {function(...*):?} */
        var _gf_dash_enable_utc_drift_compensation = (Module[
            "_gf_dash_enable_utc_drift_compensation"
        ] = createExportWrapper("gf_dash_enable_utc_drift_compensation"));
        /** @type {function(...*):?} */
        var _gf_dash_set_switching_probe_count = (Module["_gf_dash_set_switching_probe_count"] =
            createExportWrapper("gf_dash_set_switching_probe_count"));
        /** @type {function(...*):?} */
        var _gf_dash_enable_single_range_llhls = (Module["_gf_dash_enable_single_range_llhls"] =
            createExportWrapper("gf_dash_enable_single_range_llhls"));
        /** @type {function(...*):?} */
        var _gf_dash_enable_group_selection = (Module["_gf_dash_enable_group_selection"] =
            createExportWrapper("gf_dash_enable_group_selection"));
        /** @type {function(...*):?} */
        var _gf_dash_set_agressive_adaptation = (Module["_gf_dash_set_agressive_adaptation"] =
            createExportWrapper("gf_dash_set_agressive_adaptation"));
        /** @type {function(...*):?} */
        var _gf_dash_set_auto_switch = (Module["_gf_dash_set_auto_switch"] =
            createExportWrapper("gf_dash_set_auto_switch"));
        /** @type {function(...*):?} */
        var _gf_dash_get_group_count = (Module["_gf_dash_get_group_count"] =
            createExportWrapper("gf_dash_get_group_count"));
        /** @type {function(...*):?} */
        var _gf_dash_get_group_udta = (Module["_gf_dash_get_group_udta"] =
            createExportWrapper("gf_dash_get_group_udta"));
        /** @type {function(...*):?} */
        var _gf_dash_set_group_udta = (Module["_gf_dash_set_group_udta"] =
            createExportWrapper("gf_dash_set_group_udta"));
        /** @type {function(...*):?} */
        var _gf_dash_is_group_selected = (Module["_gf_dash_is_group_selected"] =
            createExportWrapper("gf_dash_is_group_selected"));
        /** @type {function(...*):?} */
        var _gf_dash_is_group_selectable = (Module["_gf_dash_is_group_selectable"] =
            createExportWrapper("gf_dash_is_group_selectable"));
        /** @type {function(...*):?} */
        var _gf_dash_get_info = (Module["_gf_dash_get_info"] =
            createExportWrapper("gf_dash_get_info"));
        /** @type {function(...*):?} */
        var _gf_dash_switch_quality = (Module["_gf_dash_switch_quality"] =
            createExportWrapper("gf_dash_switch_quality"));
        /** @type {function(...*):?} */
        var _gf_dash_get_duration = (Module["_gf_dash_get_duration"] =
            createExportWrapper("gf_dash_get_duration"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_time_shift_buffer_depth = (Module[
            "_gf_dash_group_get_time_shift_buffer_depth"
        ] = createExportWrapper("gf_dash_group_get_time_shift_buffer_depth"));
        /** @type {function(...*):?} */
        var _gf_dash_get_url = (Module["_gf_dash_get_url"] =
            createExportWrapper("gf_dash_get_url"));
        /** @type {function(...*):?} */
        var _gf_dash_is_m3u8 = (Module["_gf_dash_is_m3u8"] =
            createExportWrapper("gf_dash_is_m3u8"));
        /** @type {function(...*):?} */
        var _gf_dash_is_smooth_streaming = (Module["_gf_dash_is_smooth_streaming"] =
            createExportWrapper("gf_dash_is_smooth_streaming"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_segment_mime = (Module["_gf_dash_group_get_segment_mime"] =
            createExportWrapper("gf_dash_group_get_segment_mime"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_segment_init_url = (Module["_gf_dash_group_get_segment_init_url"] =
            createExportWrapper("gf_dash_group_get_segment_init_url"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_segment_init_keys = (Module["_gf_dash_group_get_segment_init_keys"] =
            createExportWrapper("gf_dash_group_get_segment_init_keys"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_id = (Module["_gf_dash_group_get_id"] =
            createExportWrapper("gf_dash_group_get_id"));
        /** @type {function(...*):?} */
        var _gf_dash_get_period_id = (Module["_gf_dash_get_period_id"] =
            createExportWrapper("gf_dash_get_period_id"));
        /** @type {function(...*):?} */
        var _gf_dash_group_select = (Module["_gf_dash_group_select"] =
            createExportWrapper("gf_dash_group_select"));
        /** @type {function(...*):?} */
        var _gf_dash_groups_set_language = (Module["_gf_dash_groups_set_language"] =
            createExportWrapper("gf_dash_groups_set_language"));
        /** @type {function(...*):?} */
        var _gf_dash_is_running = (Module["_gf_dash_is_running"] =
            createExportWrapper("gf_dash_is_running"));
        /** @type {function(...*):?} */
        var _gf_dash_is_in_setup = (Module["_gf_dash_is_in_setup"] =
            createExportWrapper("gf_dash_is_in_setup"));
        /** @type {function(...*):?} */
        var _gf_dash_get_period_switch_status = (Module["_gf_dash_get_period_switch_status"] =
            createExportWrapper("gf_dash_get_period_switch_status"));
        /** @type {function(...*):?} */
        var _gf_dash_request_period_switch = (Module["_gf_dash_request_period_switch"] =
            createExportWrapper("gf_dash_request_period_switch"));
        /** @type {function(...*):?} */
        var _gf_dash_in_last_period = (Module["_gf_dash_in_last_period"] =
            createExportWrapper("gf_dash_in_last_period"));
        /** @type {function(...*):?} */
        var _gf_dash_in_period_setup = (Module["_gf_dash_in_period_setup"] =
            createExportWrapper("gf_dash_in_period_setup"));
        /** @type {function(...*):?} */
        var _gf_dash_set_speed = (Module["_gf_dash_set_speed"] =
            createExportWrapper("gf_dash_set_speed"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_segment_duration = (Module["_gf_dash_group_get_segment_duration"] =
            createExportWrapper("gf_dash_group_get_segment_duration"));
        /** @type {function(...*):?} */
        var _gf_dash_group_next_seg_info = (Module["_gf_dash_group_next_seg_info"] =
            createExportWrapper("gf_dash_group_next_seg_info"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_representation_id = (Module["_gf_dash_group_get_representation_id"] =
            createExportWrapper("gf_dash_group_get_representation_id"));
        /** @type {function(...*):?} */
        var _gf_dash_group_discard_segment = (Module["_gf_dash_group_discard_segment"] =
            createExportWrapper("gf_dash_group_discard_segment"));
        /** @type {function(...*):?} */
        var _gf_dash_set_group_done = (Module["_gf_dash_set_group_done"] =
            createExportWrapper("gf_dash_set_group_done"));
        /** @type {function(...*):?} */
        var _gf_dash_get_group_done = (Module["_gf_dash_get_group_done"] =
            createExportWrapper("gf_dash_get_group_done"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_presentation_time_offset = (Module[
            "_gf_dash_group_get_presentation_time_offset"
        ] = createExportWrapper("gf_dash_group_get_presentation_time_offset"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_next_segment_location = (Module[
            "_gf_dash_group_get_next_segment_location"
        ] = createExportWrapper("gf_dash_group_get_next_segment_location"));
        /** @type {function(...*):?} */
        var _gf_dash_seek = (Module["_gf_dash_seek"] = createExportWrapper("gf_dash_seek"));
        /** @type {function(...*):?} */
        var _gf_dash_group_segment_switch_forced = (Module["_gf_dash_group_segment_switch_forced"] =
            createExportWrapper("gf_dash_group_segment_switch_forced"));
        /** @type {function(...*):?} */
        var _gf_dash_set_utc_shift = (Module["_gf_dash_set_utc_shift"] =
            createExportWrapper("gf_dash_set_utc_shift"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_video_info = (Module["_gf_dash_group_get_video_info"] =
            createExportWrapper("gf_dash_group_get_video_info"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_srd_max_size_info = (Module["_gf_dash_group_get_srd_max_size_info"] =
            createExportWrapper("gf_dash_group_get_srd_max_size_info"));
        /** @type {function(...*):?} */
        var _gf_dash_set_min_timeout_between_404 = (Module["_gf_dash_set_min_timeout_between_404"] =
            createExportWrapper("gf_dash_set_min_timeout_between_404"));
        /** @type {function(...*):?} */
        var _gf_dash_set_segment_expiration_threshold = (Module[
            "_gf_dash_set_segment_expiration_threshold"
        ] = createExportWrapper("gf_dash_set_segment_expiration_threshold"));
        /** @type {function(...*):?} */
        var _gf_dash_group_loop_detected = (Module["_gf_dash_group_loop_detected"] =
            createExportWrapper("gf_dash_group_loop_detected"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_start_range = (Module["_gf_dash_group_get_start_range"] =
            createExportWrapper("gf_dash_group_get_start_range"));
        /** @type {function(...*):?} */
        var _gf_dash_is_dynamic_mpd = (Module["_gf_dash_is_dynamic_mpd"] =
            createExportWrapper("gf_dash_is_dynamic_mpd"));
        /** @type {function(...*):?} */
        var _gf_dash_get_min_buffer_time = (Module["_gf_dash_get_min_buffer_time"] =
            createExportWrapper("gf_dash_get_min_buffer_time"));
        /** @type {function(...*):?} */
        var _gf_dash_set_max_resolution = (Module["_gf_dash_set_max_resolution"] =
            createExportWrapper("gf_dash_set_max_resolution"));
        /** @type {function(...*):?} */
        var _gf_dash_debug_groups = (Module["_gf_dash_debug_groups"] =
            createExportWrapper("gf_dash_debug_groups"));
        /** @type {function(...*):?} */
        var _gf_dash_split_adaptation_sets = (Module["_gf_dash_split_adaptation_sets"] =
            createExportWrapper("gf_dash_split_adaptation_sets"));
        /** @type {function(...*):?} */
        var _gf_dash_set_low_latency_mode = (Module["_gf_dash_set_low_latency_mode"] =
            createExportWrapper("gf_dash_set_low_latency_mode"));
        /** @type {function(...*):?} */
        var _gf_dash_set_user_buffer = (Module["_gf_dash_set_user_buffer"] =
            createExportWrapper("gf_dash_set_user_buffer"));
        /** @type {function(...*):?} */
        var _gf_dash_get_period_start = (Module["_gf_dash_get_period_start"] = createExportWrapper(
            "gf_dash_get_period_start"
        ));
        /** @type {function(...*):?} */
        var _gf_dash_get_period_duration = (Module["_gf_dash_get_period_duration"] =
            createExportWrapper("gf_dash_get_period_duration"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_language = (Module["_gf_dash_group_get_language"] =
            createExportWrapper("gf_dash_group_get_language"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_audio_channels = (Module["_gf_dash_group_get_audio_channels"] =
            createExportWrapper("gf_dash_group_get_audio_channels"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_num_qualities = (Module["_gf_dash_group_get_num_qualities"] =
            createExportWrapper("gf_dash_group_get_num_qualities"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_num_components = (Module["_gf_dash_group_get_num_components"] =
            createExportWrapper("gf_dash_group_get_num_components"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_template = (Module["_gf_dash_group_get_template"] =
            createExportWrapper("gf_dash_group_get_template"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_quality_info = (Module["_gf_dash_group_get_quality_info"] =
            createExportWrapper("gf_dash_group_get_quality_info"));
        /** @type {function(...*):?} */
        var _gf_dash_group_enum_descriptor = (Module["_gf_dash_group_enum_descriptor"] =
            createExportWrapper("gf_dash_group_enum_descriptor"));
        /** @type {function(...*):?} */
        var _gf_dash_get_automatic_switching = (Module["_gf_dash_get_automatic_switching"] =
            createExportWrapper("gf_dash_get_automatic_switching"));
        /** @type {function(...*):?} */
        var _gf_dash_set_automatic_switching = (Module["_gf_dash_set_automatic_switching"] =
            createExportWrapper("gf_dash_set_automatic_switching"));
        /** @type {function(...*):?} */
        var _gf_dash_group_select_quality = (Module["_gf_dash_group_select_quality"] =
            createExportWrapper("gf_dash_group_select_quality"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_active_quality = (Module["_gf_dash_group_get_active_quality"] =
            createExportWrapper("gf_dash_group_get_active_quality"));
        /** @type {function(...*):?} */
        var _gf_dash_set_timeshift = (Module["_gf_dash_set_timeshift"] =
            createExportWrapper("gf_dash_set_timeshift"));
        /** @type {function(...*):?} */
        var _gf_dash_get_timeshift_buffer_pos = (Module["_gf_dash_get_timeshift_buffer_pos"] =
            createExportWrapper("gf_dash_get_timeshift_buffer_pos"));
        /** @type {function(...*):?} */
        var _gf_dash_group_set_codec_stat = (Module["_gf_dash_group_set_codec_stat"] =
            createExportWrapper("gf_dash_group_set_codec_stat"));
        /** @type {function(...*):?} */
        var _gf_dash_group_set_buffer_levels = (Module["_gf_dash_group_set_buffer_levels"] =
            createExportWrapper("gf_dash_group_set_buffer_levels"));
        /** @type {function(...*):?} */
        var _gf_dash_disable_speed_adaptation = (Module["_gf_dash_disable_speed_adaptation"] =
            createExportWrapper("gf_dash_disable_speed_adaptation"));
        /** @type {function(...*):?} */
        var _gf_dash_override_ntp = (Module["_gf_dash_override_ntp"] =
            createExportWrapper("gf_dash_override_ntp"));
        /** @type {function(...*):?} */
        var _gf_dash_get_utc_drift_estimate = (Module["_gf_dash_get_utc_drift_estimate"] =
            createExportWrapper("gf_dash_get_utc_drift_estimate"));
        /** @type {function(...*):?} */
        var _gf_dash_get_tile_adaptation_mode = (Module["_gf_dash_get_tile_adaptation_mode"] =
            createExportWrapper("gf_dash_get_tile_adaptation_mode"));
        /** @type {function(...*):?} */
        var _gf_dash_set_tile_adaptation_mode = (Module["_gf_dash_set_tile_adaptation_mode"] =
            createExportWrapper("gf_dash_set_tile_adaptation_mode"));
        /** @type {function(...*):?} */
        var _gf_dash_disable_low_quality_tiles = (Module["_gf_dash_disable_low_quality_tiles"] =
            createExportWrapper("gf_dash_disable_low_quality_tiles"));
        /** @type {function(...*):?} */
        var _gf_dash_set_chaining_mode = (Module["_gf_dash_set_chaining_mode"] =
            createExportWrapper("gf_dash_set_chaining_mode"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_srd_info = (Module["_gf_dash_group_get_srd_info"] =
            createExportWrapper("gf_dash_group_get_srd_info"));
        /** @type {function(...*):?} */
        var _gf_dash_ignore_xlink = (Module["_gf_dash_ignore_xlink"] =
            createExportWrapper("gf_dash_ignore_xlink"));
        /** @type {function(...*):?} */
        var _gf_dash_set_suggested_presentation_delay = (Module[
            "_gf_dash_set_suggested_presentation_delay"
        ] = createExportWrapper("gf_dash_set_suggested_presentation_delay"));
        /** @type {function(...*):?} */
        var _gf_dash_set_route_ast_shift = (Module["_gf_dash_set_route_ast_shift"] =
            createExportWrapper("gf_dash_set_route_ast_shift"));
        /** @type {function(...*):?} */
        var _gf_dash_group_set_max_buffer_playout = (Module[
            "_gf_dash_group_set_max_buffer_playout"
        ] = createExportWrapper("gf_dash_group_set_max_buffer_playout"));
        /** @type {function(...*):?} */
        var _gf_dash_group_set_quality_degradation_hint = (Module[
            "_gf_dash_group_set_quality_degradation_hint"
        ] = createExportWrapper("gf_dash_group_set_quality_degradation_hint"));
        /** @type {function(...*):?} */
        var _gf_dash_group_set_visible_rect = (Module["_gf_dash_group_set_visible_rect"] =
            createExportWrapper("gf_dash_group_set_visible_rect"));
        /** @type {function(...*):?} */
        var _gf_dash_all_groups_done = (Module["_gf_dash_all_groups_done"] =
            createExportWrapper("gf_dash_all_groups_done"));
        /** @type {function(...*):?} */
        var _gf_dash_set_period_xlink_query_string = (Module[
            "_gf_dash_set_period_xlink_query_string"
        ] = createExportWrapper("gf_dash_set_period_xlink_query_string"));
        /** @type {function(...*):?} */
        var _gf_dash_group_get_as_id = (Module["_gf_dash_group_get_as_id"] =
            createExportWrapper("gf_dash_group_get_as_id"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_program_get_pmt_pid = (Module["_gf_m2ts_mux_program_get_pmt_pid"] =
            createExportWrapper("gf_m2ts_mux_program_get_pmt_pid"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_program_get_pcr_pid = (Module["_gf_m2ts_mux_program_get_pcr_pid"] =
            createExportWrapper("gf_m2ts_mux_program_get_pcr_pid"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_program_get_stream_count = (Module[
            "_gf_m2ts_mux_program_get_stream_count"
        ] = createExportWrapper("gf_m2ts_mux_program_get_stream_count"));
        /** @type {function(...*):?} */
        var _gf_m2ts_program_stream_add = (Module["_gf_m2ts_program_stream_add"] =
            createExportWrapper("gf_m2ts_program_stream_add"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_program_find = (Module["_gf_m2ts_mux_program_find"] = createExportWrapper(
            "gf_m2ts_mux_program_find"
        ));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_program_count = (Module["_gf_m2ts_mux_program_count"] =
            createExportWrapper("gf_m2ts_mux_program_count"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_program_add = (Module["_gf_m2ts_mux_program_add"] =
            createExportWrapper("gf_m2ts_mux_program_add"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_program_set_name = (Module["_gf_m2ts_mux_program_set_name"] =
            createExportWrapper("gf_m2ts_mux_program_set_name"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_new = (Module["_gf_m2ts_mux_new"] =
            createExportWrapper("gf_m2ts_mux_new"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_enable_sdt = (Module["_gf_m2ts_mux_enable_sdt"] =
            createExportWrapper("gf_m2ts_mux_enable_sdt"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_set_pcr_max_interval = (Module["_gf_m2ts_mux_set_pcr_max_interval"] =
            createExportWrapper("gf_m2ts_mux_set_pcr_max_interval"));
        /** @type {function(...*):?} */
        var _gf_m2ts_program_stream_remove = (Module["_gf_m2ts_program_stream_remove"] =
            createExportWrapper("gf_m2ts_program_stream_remove"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_del = (Module["_gf_m2ts_mux_del"] =
            createExportWrapper("gf_m2ts_mux_del"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_update_config = (Module["_gf_m2ts_mux_update_config"] =
            createExportWrapper("gf_m2ts_mux_update_config"));
        /** @type {function(...*):?} */
        var _gf_m2ts_get_sys_clock = (Module["_gf_m2ts_get_sys_clock"] =
            createExportWrapper("gf_m2ts_get_sys_clock"));
        /** @type {function(...*):?} */
        var _gf_m2ts_get_ts_clock = (Module["_gf_m2ts_get_ts_clock"] =
            createExportWrapper("gf_m2ts_get_ts_clock"));
        /** @type {function(...*):?} */
        var _gf_m2ts_get_ts_clock_90k = (Module["_gf_m2ts_get_ts_clock_90k"] = createExportWrapper(
            "gf_m2ts_get_ts_clock_90k"
        ));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_use_single_au_pes_mode = (Module["_gf_m2ts_mux_use_single_au_pes_mode"] =
            createExportWrapper("gf_m2ts_mux_use_single_au_pes_mode"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_set_initial_pcr = (Module["_gf_m2ts_mux_set_initial_pcr"] =
            createExportWrapper("gf_m2ts_mux_set_initial_pcr"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_enable_pcr_only_packets = (Module["_gf_m2ts_mux_enable_pcr_only_packets"] =
            createExportWrapper("gf_m2ts_mux_enable_pcr_only_packets"));
        /** @type {function(...*):?} */
        var _gf_m2ts_mux_process = (Module["_gf_m2ts_mux_process"] =
            createExportWrapper("gf_m2ts_mux_process"));
        /** @type {function(...*):?} */
        var _AVI_open_output_file = (Module["_AVI_open_output_file"] =
            createExportWrapper("AVI_open_output_file"));
        /** @type {function(...*):?} */
        var _AVI_set_video = (Module["_AVI_set_video"] = createExportWrapper("AVI_set_video"));
        /** @type {function(...*):?} */
        var _AVI_set_audio = (Module["_AVI_set_audio"] = createExportWrapper("AVI_set_audio"));
        /** @type {function(...*):?} */
        var _AVI_write_frame = (Module["_AVI_write_frame"] =
            createExportWrapper("AVI_write_frame"));
        /** @type {function(...*):?} */
        var _AVI_write_audio = (Module["_AVI_write_audio"] =
            createExportWrapper("AVI_write_audio"));
        /** @type {function(...*):?} */
        var _AVI_close = (Module["_AVI_close"] = createExportWrapper("AVI_close"));
        /** @type {function(...*):?} */
        var _gf_webvtt_parse_iso_cues = (Module["_gf_webvtt_parse_iso_cues"] = createExportWrapper(
            "gf_webvtt_parse_iso_cues"
        ));
        /** @type {function(...*):?} */
        var _gf_sm_stream_new = (Module["_gf_sm_stream_new"] =
            createExportWrapper("gf_sm_stream_new"));
        /** @type {function(...*):?} */
        var _gf_sm_get_mux_info = (Module["_gf_sm_get_mux_info"] =
            createExportWrapper("gf_sm_get_mux_info"));
        /** @type {function(...*):?} */
        var _gf_sm_stream_au_new = (Module["_gf_sm_stream_au_new"] =
            createExportWrapper("gf_sm_stream_au_new"));
        /** @type {function(...*):?} */
        var _gf_sm_load_string = (Module["_gf_sm_load_string"] =
            createExportWrapper("gf_sm_load_string"));
        /** @type {function(...*):?} */
        var _gf_sm_import_bifs_subtitle = (Module["_gf_sm_import_bifs_subtitle"] =
            createExportWrapper("gf_sm_import_bifs_subtitle"));
        /** @type {function(...*):?} */
        var _gf_laser_decoder_new = (Module["_gf_laser_decoder_new"] =
            createExportWrapper("gf_laser_decoder_new"));
        /** @type {function(...*):?} */
        var _gf_laser_decoder_configure_stream = (Module["_gf_laser_decoder_configure_stream"] =
            createExportWrapper("gf_laser_decoder_configure_stream"));
        /** @type {function(...*):?} */
        var _gf_laser_decode_command_list = (Module["_gf_laser_decode_command_list"] =
            createExportWrapper("gf_laser_decode_command_list"));
        /** @type {function(...*):?} */
        var _gf_laser_decoder_del = (Module["_gf_laser_decoder_del"] =
            createExportWrapper("gf_laser_decoder_del"));
        /** @type {function(...*):?} */
        var _gf_sm_dumper_new = (Module["_gf_sm_dumper_new"] =
            createExportWrapper("gf_sm_dumper_new"));
        /** @type {function(...*):?} */
        var _gf_sm_dumper_set_extra_graph = (Module["_gf_sm_dumper_set_extra_graph"] =
            createExportWrapper("gf_sm_dumper_set_extra_graph"));
        /** @type {function(...*):?} */
        var _gf_sm_dumper_del = (Module["_gf_sm_dumper_del"] =
            createExportWrapper("gf_sm_dumper_del"));
        /** @type {function(...*):?} */
        var _gf_sm_dump_command_list = (Module["_gf_sm_dump_command_list"] =
            createExportWrapper("gf_sm_dump_command_list"));
        /** @type {function(...*):?} */
        var _gf_sm_dump_graph = (Module["_gf_sm_dump_graph"] =
            createExportWrapper("gf_sm_dump_graph"));
        /** @type {function(...*):?} */
        var _gf_laser_encoder_new = (Module["_gf_laser_encoder_new"] =
            createExportWrapper("gf_laser_encoder_new"));
        /** @type {function(...*):?} */
        var _gf_laser_encoder_new_stream = (Module["_gf_laser_encoder_new_stream"] =
            createExportWrapper("gf_laser_encoder_new_stream"));
        /** @type {function(...*):?} */
        var _gf_laser_encoder_get_config = (Module["_gf_laser_encoder_get_config"] =
            createExportWrapper("gf_laser_encoder_get_config"));
        /** @type {function(...*):?} */
        var _gf_laser_encoder_get_rap = (Module["_gf_laser_encoder_get_rap"] = createExportWrapper(
            "gf_laser_encoder_get_rap"
        ));
        /** @type {function(...*):?} */
        var _gf_laser_encode_au = (Module["_gf_laser_encode_au"] =
            createExportWrapper("gf_laser_encode_au"));
        /** @type {function(...*):?} */
        var _gf_laser_encoder_del = (Module["_gf_laser_encoder_del"] =
            createExportWrapper("gf_laser_encoder_del"));
        /** @type {function(...*):?} */
        var _gf_mixer_new = (Module["_gf_mixer_new"] = createExportWrapper("gf_mixer_new"));
        /** @type {function(...*):?} */
        var _gf_mixer_del = (Module["_gf_mixer_del"] = createExportWrapper("gf_mixer_del"));
        /** @type {function(...*):?} */
        var _gf_mixer_lock = (Module["_gf_mixer_lock"] = createExportWrapper("gf_mixer_lock"));
        /** @type {function(...*):?} */
        var _gf_mixer_empty = (Module["_gf_mixer_empty"] = createExportWrapper("gf_mixer_empty"));
        /** @type {function(...*):?} */
        var _gf_mixer_buffering = (Module["_gf_mixer_buffering"] =
            createExportWrapper("gf_mixer_buffering"));
        /** @type {function(...*):?} */
        var _gf_mixer_is_eos = (Module["_gf_mixer_is_eos"] =
            createExportWrapper("gf_mixer_is_eos"));
        /** @type {function(...*):?} */
        var _gf_mixer_add_input = (Module["_gf_mixer_add_input"] =
            createExportWrapper("gf_mixer_add_input"));
        /** @type {function(...*):?} */
        var _gf_mixer_get_config = (Module["_gf_mixer_get_config"] =
            createExportWrapper("gf_mixer_get_config"));
        /** @type {function(...*):?} */
        var _gf_mixer_set_config = (Module["_gf_mixer_set_config"] =
            createExportWrapper("gf_mixer_set_config"));
        /** @type {function(...*):?} */
        var _gf_mixer_reconfig = (Module["_gf_mixer_reconfig"] =
            createExportWrapper("gf_mixer_reconfig"));
        /** @type {function(...*):?} */
        var _gf_mixer_get_output = (Module["_gf_mixer_get_output"] =
            createExportWrapper("gf_mixer_get_output"));
        /** @type {function(...*):?} */
        var _gf_font_manager_new = (Module["_gf_font_manager_new"] =
            createExportWrapper("gf_font_manager_new"));
        /** @type {function(...*):?} */
        var _gf_font_manager_set_font_ex = (Module["_gf_font_manager_set_font_ex"] =
            createExportWrapper("gf_font_manager_set_font_ex"));
        /** @type {function(...*):?} */
        var _gf_font_manager_create_span = (Module["_gf_font_manager_create_span"] =
            createExportWrapper("gf_font_manager_create_span"));
        /** @type {function(...*):?} */
        var _gf_font_manager_refresh_span_bounds = (Module["_gf_font_manager_refresh_span_bounds"] =
            createExportWrapper("gf_font_manager_refresh_span_bounds"));
        /** @type {function(...*):?} */
        var _gf_sc_audio_setup = (Module["_gf_sc_audio_setup"] =
            createExportWrapper("gf_sc_audio_setup"));
        /** @type {function(...*):?} */
        var _gf_sc_audio_stop = (Module["_gf_sc_audio_stop"] =
            createExportWrapper("gf_sc_audio_stop"));
        /** @type {function(...*):?} */
        var _gf_sc_audio_unregister = (Module["_gf_sc_audio_unregister"] =
            createExportWrapper("gf_sc_audio_unregister"));
        /** @type {function(...*):?} */
        var _gf_sc_audio_open = (Module["_gf_sc_audio_open"] =
            createExportWrapper("gf_sc_audio_open"));
        /** @type {function(...*):?} */
        var _gf_sc_audio_restart = (Module["_gf_sc_audio_restart"] =
            createExportWrapper("gf_sc_audio_restart"));
        /** @type {function(...*):?} */
        var _gf_sc_audio_check_url = (Module["_gf_sc_audio_check_url"] =
            createExportWrapper("gf_sc_audio_check_url"));
        /** @type {function(...*):?} */
        var _gf_sc_audio_register = (Module["_gf_sc_audio_register"] =
            createExportWrapper("gf_sc_audio_register"));
        /** @type {function(...*):?} */
        var _gf_sc_send_event = (Module["_gf_sc_send_event"] =
            createExportWrapper("gf_sc_send_event"));
        /** @type {function(...*):?} */
        var _gf_filter_forward_gf_event = (Module["_gf_filter_forward_gf_event"] =
            createExportWrapper("gf_filter_forward_gf_event"));
        /** @type {function(...*):?} */
        var _gf_sc_draw_frame = (Module["_gf_sc_draw_frame"] =
            createExportWrapper("gf_sc_draw_frame"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_data = (Module["_gf_filter_pck_get_data"] =
            createExportWrapper("gf_filter_pck_get_data"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_property = (Module["_gf_filter_pid_set_property"] =
            createExportWrapper("gf_filter_pid_set_property"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_max_buffer = (Module["_gf_filter_pid_set_max_buffer"] =
            createExportWrapper("gf_filter_pid_set_max_buffer"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_shared = (Module["_gf_filter_pck_new_shared"] = createExportWrapper(
            "gf_filter_pck_new_shared"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_readonly = (Module["_gf_filter_pck_set_readonly"] =
            createExportWrapper("gf_filter_pck_set_readonly"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_send = (Module["_gf_filter_pck_send"] =
            createExportWrapper("gf_filter_pck_send"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_would_block = (Module["_gf_filter_pid_would_block"] =
            createExportWrapper("gf_filter_pid_would_block"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_alloc_destructor = (Module["_gf_filter_pck_new_alloc_destructor"] =
            createExportWrapper("gf_filter_pck_new_alloc_destructor"));
        /** @type {function(...*):?} */
        var _gf_filter_get_clock_hint = (Module["_gf_filter_get_clock_hint"] = createExportWrapper(
            "gf_filter_get_clock_hint"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pck_truncate = (Module["_gf_filter_pck_truncate"] =
            createExportWrapper("gf_filter_pck_truncate"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_discard = (Module["_gf_filter_pck_discard"] =
            createExportWrapper("gf_filter_pck_discard"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_eos = (Module["_gf_filter_pid_set_eos"] =
            createExportWrapper("gf_filter_pid_set_eos"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_sap = (Module["_gf_filter_pck_set_sap"] =
            createExportWrapper("gf_filter_pck_set_sap"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_cts = (Module["_gf_filter_pck_set_cts"] =
            createExportWrapper("gf_filter_pck_set_cts"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_duration = (Module["_gf_filter_pck_set_duration"] =
            createExportWrapper("gf_filter_pck_set_duration"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_udta = (Module["_gf_filter_pid_get_udta"] =
            createExportWrapper("gf_filter_pid_get_udta"));
        /** @type {function(...*):?} */
        var _gf_mo_get_min_frame_dur = (Module["_gf_mo_get_min_frame_dur"] =
            createExportWrapper("gf_mo_get_min_frame_dur"));
        /** @type {function(...*):?} */
        var _gf_mo_map_timestamp_to_sys_clock = (Module["_gf_mo_map_timestamp_to_sys_clock"] =
            createExportWrapper("gf_mo_map_timestamp_to_sys_clock"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_release_stream = (Module["_gf_sc_texture_release_stream"] =
            createExportWrapper("gf_sc_texture_release_stream"));
        /** @type {function(...*):?} */
        var _gf_filter_request_opengl = (Module["_gf_filter_request_opengl"] = createExportWrapper(
            "gf_filter_request_opengl"
        ));
        /** @type {function(...*):?} */
        var _gf_sc_get_clock = (Module["_gf_sc_get_clock"] =
            createExportWrapper("gf_sc_get_clock"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_frame_interface = (Module["_gf_filter_pck_new_frame_interface"] =
            createExportWrapper("gf_filter_pck_new_frame_interface"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_alloc = (Module["_gf_filter_pck_new_alloc"] =
            createExportWrapper("gf_filter_pck_new_alloc"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_merge_properties = (Module["_gf_filter_pck_merge_properties"] =
            createExportWrapper("gf_filter_pck_merge_properties"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_duration = (Module["_gf_filter_pck_get_duration"] =
            createExportWrapper("gf_filter_pck_get_duration"));
        /** @type {function(...*):?} */
        var _gf_sc_reset_graphics = (Module["_gf_sc_reset_graphics"] =
            createExportWrapper("gf_sc_reset_graphics"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_clone = (Module["_gf_filter_pck_new_clone"] =
            createExportWrapper("gf_filter_pck_new_clone"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_timescale = (Module["_gf_filter_pck_get_timescale"] =
            createExportWrapper("gf_filter_pck_get_timescale"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_copy_properties = (Module["_gf_filter_pid_copy_properties"] =
            createExportWrapper("gf_filter_pid_copy_properties"));
        /** @type {function(...*):?} */
        var _gf_sc_reload_config = (Module["_gf_sc_reload_config"] =
            createExportWrapper("gf_sc_reload_config"));
        /** @type {function(...*):?} */
        var _gf_sc_lock = (Module["_gf_sc_lock"] = createExportWrapper("gf_sc_lock"));
        /** @type {function(...*):?} */
        var _gf_sc_set_scene_size = (Module["_gf_sc_set_scene_size"] =
            createExportWrapper("gf_sc_set_scene_size"));
        /** @type {function(...*):?} */
        var _gf_sc_svg_convert_length_to_display = (Module["_gf_sc_svg_convert_length_to_display"] =
            createExportWrapper("gf_sc_svg_convert_length_to_display"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_delete = (Module["_gf_evg_surface_delete"] =
            createExportWrapper("gf_evg_surface_delete"));
        /** @type {function(...*):?} */
        var _gf_sc_focus_switch_ring = (Module["_gf_sc_focus_switch_ring"] =
            createExportWrapper("gf_sc_focus_switch_ring"));
        /** @type {function(...*):?} */
        var _gf_sc_navigation_supported = (Module["_gf_sc_navigation_supported"] =
            createExportWrapper("gf_sc_navigation_supported"));
        /** @type {function(...*):?} */
        var _gf_sc_is_over = (Module["_gf_sc_is_over"] = createExportWrapper("gf_sc_is_over"));
        /** @type {function(...*):?} */
        var _gf_sc_map_point = (Module["_gf_sc_map_point"] =
            createExportWrapper("gf_sc_map_point"));
        /** @type {function(...*):?} */
        var _gf_sc_register_time_node = (Module["_gf_sc_register_time_node"] = createExportWrapper(
            "gf_sc_register_time_node"
        ));
        /** @type {function(...*):?} */
        var _gf_sc_unregister_time_node = (Module["_gf_sc_unregister_time_node"] =
            createExportWrapper("gf_sc_unregister_time_node"));
        /** @type {function(...*):?} */
        var _gf_sc_invalidate_next_frame = (Module["_gf_sc_invalidate_next_frame"] =
            createExportWrapper("gf_sc_invalidate_next_frame"));
        /** @type {function(...*):?} */
        var _gf_sc_frame_was_produced = (Module["_gf_sc_frame_was_produced"] = createExportWrapper(
            "gf_sc_frame_was_produced"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_frame_interface = (Module["_gf_filter_pck_get_frame_interface"] =
            createExportWrapper("gf_filter_pck_get_frame_interface"));
        /** @type {function(...*):?} */
        var _gf_sc_on_event = (Module["_gf_sc_on_event"] = createExportWrapper("gf_sc_on_event"));
        /** @type {function(...*):?} */
        var _gf_sc_input_sensor_keyboard_input = (Module["_gf_sc_input_sensor_keyboard_input"] =
            createExportWrapper("gf_sc_input_sensor_keyboard_input"));
        /** @type {function(...*):?} */
        var _gf_sc_input_sensor_string_input = (Module["_gf_sc_input_sensor_string_input"] =
            createExportWrapper("gf_sc_input_sensor_string_input"));
        /** @type {function(...*):?} */
        var _gf_sc_paste_text = (Module["_gf_sc_paste_text"] =
            createExportWrapper("gf_sc_paste_text"));
        /** @type {function(...*):?} */
        var _gf_sc_get_selected_text = (Module["_gf_sc_get_selected_text"] =
            createExportWrapper("gf_sc_get_selected_text"));
        /** @type {function(...*):?} */
        var _gf_sc_register_extra_graph = (Module["_gf_sc_register_extra_graph"] =
            createExportWrapper("gf_sc_register_extra_graph"));
        /** @type {function(...*):?} */
        var _gf_sc_has_text_selection = (Module["_gf_sc_has_text_selection"] = createExportWrapper(
            "gf_sc_has_text_selection"
        ));
        /** @type {function(...*):?} */
        var _gf_sc_get_compositor = (Module["_gf_sc_get_compositor"] =
            createExportWrapper("gf_sc_get_compositor"));
        /** @type {function(...*):?} */
        var _gf_filter_post_process_task = (Module["_gf_filter_post_process_task"] =
            createExportWrapper("gf_filter_post_process_task"));
        /** @type {function(...*):?} */
        var _gf_filter_ask_rt_reschedule = (Module["_gf_filter_ask_rt_reschedule"] =
            createExportWrapper("gf_filter_ask_rt_reschedule"));
        /** @type {function(...*):?} */
        var _gf_clock_time = (Module["_gf_clock_time"] = createExportWrapper("gf_clock_time"));
        /** @type {function(...*):?} */
        var _gf_scene_switch_quality = (Module["_gf_scene_switch_quality"] =
            createExportWrapper("gf_scene_switch_quality"));
        /** @type {function(...*):?} */
        var _gf_filter_is_supported_source = (Module["_gf_filter_is_supported_source"] =
            createExportWrapper("gf_filter_is_supported_source"));
        /** @type {function(...*):?} */
        var _gf_scene_disconnect = (Module["_gf_scene_disconnect"] =
            createExportWrapper("gf_scene_disconnect"));
        /** @type {function(...*):?} */
        var _gf_scene_new = (Module["_gf_scene_new"] = createExportWrapper("gf_scene_new"));
        /** @type {function(...*):?} */
        var _gf_odm_new = (Module["_gf_odm_new"] = createExportWrapper("gf_odm_new"));
        /** @type {function(...*):?} */
        var _gf_odm_disconnect = (Module["_gf_odm_disconnect"] =
            createExportWrapper("gf_odm_disconnect"));
        /** @type {function(...*):?} */
        var _gf_sc_dump_scene_ex = (Module["_gf_sc_dump_scene_ex"] =
            createExportWrapper("gf_sc_dump_scene_ex"));
        /** @type {function(...*):?} */
        var _gf_scene_register_associated_media = (Module["_gf_scene_register_associated_media"] =
            createExportWrapper("gf_scene_register_associated_media"));
        /** @type {function(...*):?} */
        var _gf_scene_select_object = (Module["_gf_scene_select_object"] =
            createExportWrapper("gf_scene_select_object"));
        /** @type {function(...*):?} */
        var _gf_scene_get_time = (Module["_gf_scene_get_time"] =
            createExportWrapper("gf_scene_get_time"));
        /** @type {function(...*):?} */
        var _gf_scene_attach_to_compositor = (Module["_gf_scene_attach_to_compositor"] =
            createExportWrapper("gf_scene_attach_to_compositor"));
        /** @type {function(...*):?} */
        var _gf_scene_set_service_id = (Module["_gf_scene_set_service_id"] =
            createExportWrapper("gf_scene_set_service_id"));
        /** @type {function(...*):?} */
        var _gf_sc_get_world_info = (Module["_gf_sc_get_world_info"] =
            createExportWrapper("gf_sc_get_world_info"));
        /** @type {function(...*):?} */
        var _gf_sc_add_object = (Module["_gf_sc_add_object"] =
            createExportWrapper("gf_sc_add_object"));
        /** @type {function(...*):?} */
        var _gf_sc_get_simulation_frame_rate = (Module["_gf_sc_get_simulation_frame_rate"] =
            createExportWrapper("gf_sc_get_simulation_frame_rate"));
        /** @type {function(...*):?} */
        var _gf_sc_get_elapsed_time_in_ms = (Module["_gf_sc_get_elapsed_time_in_ms"] =
            createExportWrapper("gf_sc_get_elapsed_time_in_ms"));
        /** @type {function(...*):?} */
        var _gf_sc_get_current_service_id = (Module["_gf_sc_get_current_service_id"] =
            createExportWrapper("gf_sc_get_current_service_id"));
        /** @type {function(...*):?} */
        var _gf_sc_input_sensor_mouse_input = (Module["_gf_sc_input_sensor_mouse_input"] =
            createExportWrapper("gf_sc_input_sensor_mouse_input"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_clear = (Module["_gf_evg_surface_clear"] =
            createExportWrapper("gf_evg_surface_clear"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_attach_to_buffer = (Module["_gf_evg_surface_attach_to_buffer"] =
            createExportWrapper("gf_evg_surface_attach_to_buffer"));
        /** @type {function(...*):?} */
        var _gf_mo_get_object_time = (Module["_gf_mo_get_object_time"] =
            createExportWrapper("gf_mo_get_object_time"));
        /** @type {function(...*):?} */
        var _gf_sc_invalidate = (Module["_gf_sc_invalidate"] =
            createExportWrapper("gf_sc_invalidate"));
        /** @type {function(...*):?} */
        var _gf_mo_register = (Module["_gf_mo_register"] = createExportWrapper("gf_mo_register"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_get_handler = (Module["_gf_sc_texture_get_handler"] =
            createExportWrapper("gf_sc_texture_get_handler"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_setup = (Module["_gf_sc_texture_setup"] =
            createExportWrapper("gf_sc_texture_setup"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_destroy = (Module["_gf_sc_texture_destroy"] =
            createExportWrapper("gf_sc_texture_destroy"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_play_from_to = (Module["_gf_sc_texture_play_from_to"] =
            createExportWrapper("gf_sc_texture_play_from_to"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_stop_no_unregister = (Module["_gf_sc_texture_stop_no_unregister"] =
            createExportWrapper("gf_sc_texture_stop_no_unregister"));
        /** @type {function(...*):?} */
        var _gf_mo_get_speed = (Module["_gf_mo_get_speed"] =
            createExportWrapper("gf_mo_get_speed"));
        /** @type {function(...*):?} */
        var _gf_mo_is_done = (Module["_gf_mo_is_done"] = createExportWrapper("gf_mo_is_done"));
        /** @type {function(...*):?} */
        var _gf_mo_get_loop = (Module["_gf_mo_get_loop"] = createExportWrapper("gf_mo_get_loop"));
        /** @type {function(...*):?} */
        var _gf_mo_restart = (Module["_gf_mo_restart"] = createExportWrapper("gf_mo_restart"));
        /** @type {function(...*):?} */
        var _gf_mo_should_deactivate = (Module["_gf_mo_should_deactivate"] =
            createExportWrapper("gf_mo_should_deactivate"));
        /** @type {function(...*):?} */
        var _gf_mo_play = (Module["_gf_mo_play"] = createExportWrapper("gf_mo_play"));
        /** @type {function(...*):?} */
        var _gf_mo_set_speed = (Module["_gf_mo_set_speed"] =
            createExportWrapper("gf_mo_set_speed"));
        /** @type {function(...*):?} */
        var _gf_mo_set_flag = (Module["_gf_mo_set_flag"] = createExportWrapper("gf_mo_set_flag"));
        /** @type {function(...*):?} */
        var _gf_mo_stop = (Module["_gf_mo_stop"] = createExportWrapper("gf_mo_stop"));
        /** @type {function(...*):?} */
        var _gf_mo_url_changed = (Module["_gf_mo_url_changed"] =
            createExportWrapper("gf_mo_url_changed"));
        /** @type {function(...*):?} */
        var _gf_mo_unregister = (Module["_gf_mo_unregister"] =
            createExportWrapper("gf_mo_unregister"));
        /** @type {function(...*):?} */
        var _gf_mo_fetch_data = (Module["_gf_mo_fetch_data"] =
            createExportWrapper("gf_mo_fetch_data"));
        /** @type {function(...*):?} */
        var _gf_mo_is_started = (Module["_gf_mo_is_started"] =
            createExportWrapper("gf_mo_is_started"));
        /** @type {function(...*):?} */
        var _gf_mo_adjust_clock = (Module["_gf_mo_adjust_clock"] =
            createExportWrapper("gf_mo_adjust_clock"));
        /** @type {function(...*):?} */
        var _gf_mo_release_data = (Module["_gf_mo_release_data"] =
            createExportWrapper("gf_mo_release_data"));
        /** @type {function(...*):?} */
        var _gf_mo_get_current_speed = (Module["_gf_mo_get_current_speed"] =
            createExportWrapper("gf_mo_get_current_speed"));
        /** @type {function(...*):?} */
        var _gf_mo_get_audio_info = (Module["_gf_mo_get_audio_info"] =
            createExportWrapper("gf_mo_get_audio_info"));
        /** @type {function(...*):?} */
        var _gf_mo_is_muted = (Module["_gf_mo_is_muted"] = createExportWrapper("gf_mo_is_muted"));
        /** @type {function(...*):?} */
        var _gf_mo_get_duration = (Module["_gf_mo_get_duration"] =
            createExportWrapper("gf_mo_get_duration"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_update_frame = (Module["_gf_sc_texture_update_frame"] =
            createExportWrapper("gf_sc_texture_update_frame"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_restart = (Module["_gf_sc_texture_restart"] =
            createExportWrapper("gf_sc_texture_restart"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_play = (Module["_gf_sc_texture_play"] =
            createExportWrapper("gf_sc_texture_play"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_check_url_change = (Module["_gf_sc_texture_check_url_change"] =
            createExportWrapper("gf_sc_texture_check_url_change"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_stop = (Module["_gf_sc_texture_stop"] =
            createExportWrapper("gf_sc_texture_stop"));
        /** @type {function(...*):?} */
        var _gf_mo_get_visual_info_ex = (Module["_gf_mo_get_visual_info_ex"] = createExportWrapper(
            "gf_mo_get_visual_info_ex"
        ));
        /** @type {function(...*):?} */
        var _gf_evg_surface_attach_to_texture = (Module["_gf_evg_surface_attach_to_texture"] =
            createExportWrapper("gf_evg_surface_attach_to_texture"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_new = (Module["_gf_evg_surface_new"] =
            createExportWrapper("gf_evg_surface_new"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_new = (Module["_gf_evg_stencil_new"] =
            createExportWrapper("gf_evg_stencil_new"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_texture = (Module["_gf_evg_stencil_set_texture"] =
            createExportWrapper("gf_evg_stencil_set_texture"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_linear_gradient = (Module["_gf_evg_stencil_set_linear_gradient"] =
            createExportWrapper("gf_evg_stencil_set_linear_gradient"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_gradient_interpolation = (Module[
            "_gf_evg_stencil_set_gradient_interpolation"
        ] = createExportWrapper("gf_evg_stencil_set_gradient_interpolation"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_matrix = (Module["_gf_evg_stencil_set_matrix"] =
            createExportWrapper("gf_evg_stencil_set_matrix"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_auto_matrix = (Module["_gf_evg_stencil_set_auto_matrix"] =
            createExportWrapper("gf_evg_stencil_set_auto_matrix"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_delete = (Module["_gf_evg_stencil_delete"] =
            createExportWrapper("gf_evg_stencil_delete"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_gradient_mode = (Module["_gf_evg_stencil_set_gradient_mode"] =
            createExportWrapper("gf_evg_stencil_set_gradient_mode"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_radial_gradient = (Module["_gf_evg_stencil_set_radial_gradient"] =
            createExportWrapper("gf_evg_stencil_set_radial_gradient"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_set_raster_level = (Module["_gf_evg_surface_set_raster_level"] =
            createExportWrapper("gf_evg_surface_set_raster_level"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_set_path = (Module["_gf_evg_surface_set_path"] =
            createExportWrapper("gf_evg_surface_set_path"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_fill = (Module["_gf_evg_surface_fill"] =
            createExportWrapper("gf_evg_surface_fill"));
        /** @type {function(...*):?} */
        var _gf_scene_process_anchor = (Module["_gf_scene_process_anchor"] =
            createExportWrapper("gf_scene_process_anchor"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_brush_color = (Module["_gf_evg_stencil_set_brush_color"] =
            createExportWrapper("gf_evg_stencil_set_brush_color"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_set_matrix = (Module["_gf_evg_surface_set_matrix"] =
            createExportWrapper("gf_evg_surface_set_matrix"));
        /** @type {function(...*):?} */
        var _gf_mo_pause = (Module["_gf_mo_pause"] = createExportWrapper("gf_mo_pause"));
        /** @type {function(...*):?} */
        var _gf_mo_resume = (Module["_gf_mo_resume"] = createExportWrapper("gf_mo_resume"));
        /** @type {function(...*):?} */
        var _gf_sc_get_viewpoint = (Module["_gf_sc_get_viewpoint"] =
            createExportWrapper("gf_sc_get_viewpoint"));
        /** @type {function(...*):?} */
        var _gf_sc_set_viewpoint = (Module["_gf_sc_set_viewpoint"] =
            createExportWrapper("gf_sc_set_viewpoint"));
        /** @type {function(...*):?} */
        var _gf_mo_load_xlink_resource = (Module["_gf_mo_load_xlink_resource"] =
            createExportWrapper("gf_mo_load_xlink_resource"));
        /** @type {function(...*):?} */
        var _gf_mo_get_scenegraph = (Module["_gf_mo_get_scenegraph"] =
            createExportWrapper("gf_mo_get_scenegraph"));
        /** @type {function(...*):?} */
        var _gf_mo_unload_xlink_resource = (Module["_gf_mo_unload_xlink_resource"] =
            createExportWrapper("gf_mo_unload_xlink_resource"));
        /** @type {function(...*):?} */
        var _gf_filter_is_supported_mime = (Module["_gf_filter_is_supported_mime"] =
            createExportWrapper("gf_filter_is_supported_mime"));
        /** @type {function(...*):?} */
        var _gf_sc_texture_open = (Module["_gf_sc_texture_open"] =
            createExportWrapper("gf_sc_texture_open"));
        /** @type {function(...*):?} */
        var _gf_mo_has_audio = (Module["_gf_mo_has_audio"] =
            createExportWrapper("gf_mo_has_audio"));
        /** @type {function(...*):?} */
        var _gf_sc_get_mfurl_from_xlink = (Module["_gf_sc_get_mfurl_from_xlink"] =
            createExportWrapper("gf_sc_get_mfurl_from_xlink"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_query_buffer_duration = (Module["_gf_filter_pid_query_buffer_duration"] =
            createExportWrapper("gf_filter_pid_query_buffer_duration"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_texture_planes = (Module["_gf_evg_stencil_set_texture_planes"] =
            createExportWrapper("gf_evg_stencil_set_texture_planes"));
        /** @type {function(...*):?} */
        var _gf_mo_get_nb_views = (Module["_gf_mo_get_nb_views"] =
            createExportWrapper("gf_mo_get_nb_views"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_set_clipper = (Module["_gf_evg_surface_set_clipper"] =
            createExportWrapper("gf_evg_surface_set_clipper"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_alpha = (Module["_gf_evg_stencil_set_alpha"] = createExportWrapper(
            "gf_evg_stencil_set_alpha"
        ));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_color_matrix = (Module["_gf_evg_stencil_set_color_matrix"] =
            createExportWrapper("gf_evg_stencil_set_color_matrix"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_mapping = (Module["_gf_evg_stencil_set_mapping"] =
            createExportWrapper("gf_evg_stencil_set_mapping"));
        /** @type {function(...*):?} */
        var _gf_scene_get_media_object_ex = (Module["_gf_scene_get_media_object_ex"] =
            createExportWrapper("gf_scene_get_media_object_ex"));
        /** @type {function(...*):?} */
        var _gf_mo_event_target_remove_by_node = (Module["_gf_mo_event_target_remove_by_node"] =
            createExportWrapper("gf_mo_event_target_remove_by_node"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_unref = (Module["_gf_filter_pck_unref"] =
            createExportWrapper("gf_filter_pck_unref"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_ref = (Module["_gf_filter_pck_ref"] =
            createExportWrapper("gf_filter_pck_ref"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_first_packet_cts = (Module["_gf_filter_pid_get_first_packet_cts"] =
            createExportWrapper("gf_filter_pid_get_first_packet_cts"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_is_eos = (Module["_gf_filter_pid_is_eos"] =
            createExportWrapper("gf_filter_pid_is_eos"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_try_pull = (Module["_gf_filter_pid_try_pull"] =
            createExportWrapper("gf_filter_pid_try_pull"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_first_packet_is_empty = (Module["_gf_filter_pid_first_packet_is_empty"] =
            createExportWrapper("gf_filter_pid_first_packet_is_empty"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_packet_count = (Module["_gf_filter_pid_get_packet_count"] =
            createExportWrapper("gf_filter_pid_get_packet_count"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_property = (Module["_gf_filter_pck_get_property"] =
            createExportWrapper("gf_filter_pck_get_property"));
        /** @type {function(...*):?} */
        var _gf_filter_release_property = (Module["_gf_filter_release_property"] =
            createExportWrapper("gf_filter_release_property"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_enum_properties = (Module["_gf_filter_pck_enum_properties"] =
            createExportWrapper("gf_filter_pck_enum_properties"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_is_blocking_ref = (Module["_gf_filter_pck_is_blocking_ref"] =
            createExportWrapper("gf_filter_pck_is_blocking_ref"));
        /** @type {function(...*):?} */
        var _gf_mo_event_target_add_node = (Module["_gf_mo_event_target_add_node"] =
            createExportWrapper("gf_mo_event_target_add_node"));
        /** @type {function(...*):?} */
        var _gf_event_target_get_node = (Module["_gf_event_target_get_node"] = createExportWrapper(
            "gf_event_target_get_node"
        ));
        /** @type {function(...*):?} */
        var _gf_mo_event_target_get = (Module["_gf_mo_event_target_get"] =
            createExportWrapper("gf_mo_event_target_get"));
        /** @type {function(...*):?} */
        var _gf_filter_send_gf_event = (Module["_gf_filter_send_gf_event"] =
            createExportWrapper("gf_filter_send_gf_event"));
        /** @type {function(...*):?} */
        var _gf_filter_remove_src = (Module["_gf_filter_remove_src"] =
            createExportWrapper("gf_filter_remove_src"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_is_filter_in_parents = (Module["_gf_filter_pid_is_filter_in_parents"] =
            createExportWrapper("gf_filter_pid_is_filter_in_parents"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_is_sparse = (Module["_gf_filter_pid_is_sparse"] =
            createExportWrapper("gf_filter_pid_is_sparse"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_udta = (Module["_gf_filter_pid_set_udta"] =
            createExportWrapper("gf_filter_pid_set_udta"));
        /** @type {function(...*):?} */
        var _gf_odm_setup_object = (Module["_gf_odm_setup_object"] =
            createExportWrapper("gf_odm_setup_object"));
        /** @type {function(...*):?} */
        var _gf_filter_get_sep = (Module["_gf_filter_get_sep"] =
            createExportWrapper("gf_filter_get_sep"));
        /** @type {function(...*):?} */
        var _gf_filter_lock_all = (Module["_gf_filter_lock_all"] =
            createExportWrapper("gf_filter_lock_all"));
        /** @type {function(...*):?} */
        var _gf_filter_connect_source = (Module["_gf_filter_connect_source"] = createExportWrapper(
            "gf_filter_connect_source"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_post_task = (Module["_gf_filter_post_task"] =
            createExportWrapper("gf_filter_post_task"));
        /** @type {function(...*):?} */
        var _gf_filter_set_source_restricted = (Module["_gf_filter_set_source_restricted"] =
            createExportWrapper("gf_filter_set_source_restricted"));
        /** @type {function(...*):?} */
        var _gf_odm_setup_pid = (Module["_gf_odm_setup_pid"] =
            createExportWrapper("gf_odm_setup_pid"));
        /** @type {function(...*):?} */
        var _gf_scene_set_timeshift_depth = (Module["_gf_scene_set_timeshift_depth"] =
            createExportWrapper("gf_scene_set_timeshift_depth"));
        /** @type {function(...*):?} */
        var _gf_scene_setup_object = (Module["_gf_scene_setup_object"] =
            createExportWrapper("gf_scene_setup_object"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_exec_event = (Module["_gf_filter_pid_exec_event"] = createExportWrapper(
            "gf_filter_pid_exec_event"
        ));
        /** @type {function(...*):?} */
        var _gf_scene_del = (Module["_gf_scene_del"] = createExportWrapper("gf_scene_del"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_info = (Module["_gf_filter_pid_get_info"] =
            createExportWrapper("gf_filter_pid_get_info"));
        /** @type {function(...*):?} */
        var _gf_scene_set_duration = (Module["_gf_scene_set_duration"] =
            createExportWrapper("gf_scene_set_duration"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_clock_info = (Module["_gf_filter_pid_get_clock_info"] =
            createExportWrapper("gf_filter_pid_get_clock_info"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_timescale = (Module["_gf_filter_pid_get_timescale"] =
            createExportWrapper("gf_filter_pid_get_timescale"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_first_packet_is_blocking_ref = (Module[
            "_gf_filter_pid_first_packet_is_blocking_ref"
        ] = createExportWrapper("gf_filter_pid_first_packet_is_blocking_ref"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_has_seen_eos = (Module["_gf_filter_pid_has_seen_eos"] =
            createExportWrapper("gf_filter_pid_has_seen_eos"));
        /** @type {function(...*):?} */
        var _gf_odm_get_object_info = (Module["_gf_odm_get_object_info"] =
            createExportWrapper("gf_odm_get_object_info"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_filter_name = (Module["_gf_filter_pid_get_filter_name"] =
            createExportWrapper("gf_filter_pid_get_filter_name"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_buffer_occupancy = (Module["_gf_filter_pid_get_buffer_occupancy"] =
            createExportWrapper("gf_filter_pid_get_buffer_occupancy"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_statistics = (Module["_gf_filter_pid_get_statistics"] =
            createExportWrapper("gf_filter_pid_get_statistics"));
        /** @type {function(...*):?} */
        var _gf_filter_ui_event = (Module["_gf_filter_ui_event"] =
            createExportWrapper("gf_filter_ui_event"));
        /** @type {function(...*):?} */
        var _gf_scene_node_callback = (Module["_gf_scene_node_callback"] =
            createExportWrapper("gf_scene_node_callback"));
        /** @type {function(...*):?} */
        var _gf_filter_get_download_manager = (Module["_gf_filter_get_download_manager"] =
            createExportWrapper("gf_filter_get_download_manager"));
        /** @type {function(...*):?} */
        var _gf_filter_relocate_url = (Module["_gf_filter_relocate_url"] =
            createExportWrapper("gf_filter_relocate_url"));
        /** @type {function(...*):?} */
        var _gf_scene_find_odm = (Module["_gf_scene_find_odm"] =
            createExportWrapper("gf_scene_find_odm"));
        /** @type {function(...*):?} */
        var _gf_scene_force_size = (Module["_gf_scene_force_size"] =
            createExportWrapper("gf_scene_force_size"));
        /** @type {function(...*):?} */
        var _gf_scene_register_extra_graph = (Module["_gf_scene_register_extra_graph"] =
            createExportWrapper("gf_scene_register_extra_graph"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_property_str = (Module["_gf_filter_pid_get_property_str"] =
            createExportWrapper("gf_filter_pid_get_property_str"));
        /** @type {function(...*):?} */
        var _gf_scene_set_addon_layout_info = (Module["_gf_scene_set_addon_layout_info"] =
            createExportWrapper("gf_scene_set_addon_layout_info"));
        /** @type {function(...*):?} */
        var _gf_scene_resume_live = (Module["_gf_scene_resume_live"] =
            createExportWrapper("gf_scene_resume_live"));
        /** @type {function(...*):?} */
        var _gf_laser_decoder_remove_stream = (Module["_gf_laser_decoder_remove_stream"] =
            createExportWrapper("gf_laser_decoder_remove_stream"));
        /** @type {function(...*):?} */
        var _gf_laser_decode_has_conditionnals = (Module["_gf_laser_decode_has_conditionnals"] =
            createExportWrapper("gf_laser_decode_has_conditionnals"));
        /** @type {function(...*):?} */
        var _gf_laser_decode_au = (Module["_gf_laser_decode_au"] =
            createExportWrapper("gf_laser_decode_au"));
        /** @type {function(...*):?} */
        var _gf_laser_decoder_set_clock = (Module["_gf_laser_decoder_set_clock"] =
            createExportWrapper("gf_laser_decoder_set_clock"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_clear_depth = (Module["_gf_evg_surface_clear_depth"] =
            createExportWrapper("gf_evg_surface_clear_depth"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_viewport = (Module["_gf_evg_surface_viewport"] =
            createExportWrapper("gf_evg_surface_viewport"));
        /** @type {function(...*):?} */
        var _gf_evg_set_depth_test = (Module["_gf_evg_set_depth_test"] =
            createExportWrapper("gf_evg_set_depth_test"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_push_gradient_interpolation = (Module[
            "_gf_evg_stencil_push_gradient_interpolation"
        ] = createExportWrapper("gf_evg_stencil_push_gradient_interpolation"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_auto_matrix = (Module["_gf_evg_stencil_get_auto_matrix"] =
            createExportWrapper("gf_evg_stencil_get_auto_matrix"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_matrix = (Module["_gf_evg_stencil_get_matrix"] =
            createExportWrapper("gf_evg_stencil_get_matrix"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_type = (Module["_gf_evg_stencil_type"] =
            createExportWrapper("gf_evg_stencil_type"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_brush_color = (Module["_gf_evg_stencil_get_brush_color"] =
            createExportWrapper("gf_evg_stencil_get_brush_color"));
        /** @type {function(...*):?} */
        var _gf_evg_texture_format_ok = (Module["_gf_evg_texture_format_ok"] = createExportWrapper(
            "gf_evg_texture_format_ok"
        ));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_palette = (Module["_gf_evg_stencil_set_palette"] =
            createExportWrapper("gf_evg_stencil_set_palette"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_texture_planes = (Module["_gf_evg_stencil_get_texture_planes"] =
            createExportWrapper("gf_evg_stencil_get_texture_planes"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_texture_parametric = (Module[
            "_gf_evg_stencil_set_texture_parametric"
        ] = createExportWrapper("gf_evg_stencil_set_texture_parametric"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_pad_color = (Module["_gf_evg_stencil_set_pad_color"] =
            createExportWrapper("gf_evg_stencil_set_pad_color"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_pad_color = (Module["_gf_evg_stencil_get_pad_color"] =
            createExportWrapper("gf_evg_stencil_get_pad_color"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_set_filter = (Module["_gf_evg_stencil_set_filter"] =
            createExportWrapper("gf_evg_stencil_set_filter"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_color_matrix = (Module["_gf_evg_stencil_get_color_matrix"] =
            createExportWrapper("gf_evg_stencil_get_color_matrix"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_pixel = (Module["_gf_evg_stencil_get_pixel"] = createExportWrapper(
            "gf_evg_stencil_get_pixel"
        ));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_pixel_yuv = (Module["_gf_evg_stencil_get_pixel_yuv"] =
            createExportWrapper("gf_evg_stencil_get_pixel_yuv"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_pixel_wide = (Module["_gf_evg_stencil_get_pixel_wide"] =
            createExportWrapper("gf_evg_stencil_get_pixel_wide"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_pixel_yuv_wide = (Module["_gf_evg_stencil_get_pixel_yuv_wide"] =
            createExportWrapper("gf_evg_stencil_get_pixel_yuv_wide"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_pixel_f = (Module["_gf_evg_stencil_get_pixel_f"] =
            createExportWrapper("gf_evg_stencil_get_pixel_f"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_pixel_yuv_f = (Module["_gf_evg_stencil_get_pixel_yuv_f"] =
            createExportWrapper("gf_evg_stencil_get_pixel_yuv_f"));
        /** @type {function(...*):?} */
        var _gf_evg_stencil_get_alpha = (Module["_gf_evg_stencil_get_alpha"] = createExportWrapper(
            "gf_evg_stencil_get_alpha"
        ));
        /** @type {function(...*):?} */
        var _gf_evg_surface_enable_3d = (Module["_gf_evg_surface_enable_3d"] = createExportWrapper(
            "gf_evg_surface_enable_3d"
        ));
        /** @type {function(...*):?} */
        var _gf_evg_enable_threading = (Module["_gf_evg_enable_threading"] =
            createExportWrapper("gf_evg_enable_threading"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_set_center_coords = (Module["_gf_evg_surface_set_center_coords"] =
            createExportWrapper("gf_evg_surface_set_center_coords"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_set_matrix_3d = (Module["_gf_evg_surface_set_matrix_3d"] =
            createExportWrapper("gf_evg_surface_set_matrix_3d"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_format_ok = (Module["_gf_evg_surface_format_ok"] = createExportWrapper(
            "gf_evg_surface_format_ok"
        ));
        /** @type {function(...*):?} */
        var _gf_evg_surface_get_raster_level = (Module["_gf_evg_surface_get_raster_level"] =
            createExportWrapper("gf_evg_surface_get_raster_level"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_force_aa = (Module["_gf_evg_surface_force_aa"] =
            createExportWrapper("gf_evg_surface_force_aa"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_use_clipper = (Module["_gf_evg_surface_use_clipper"] =
            createExportWrapper("gf_evg_surface_use_clipper"));
        /** @type {function(...*):?} */
        var _gf_evg_surface_multi_fill = (Module["_gf_evg_surface_multi_fill"] =
            createExportWrapper("gf_evg_surface_multi_fill"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_merge_properties_filter = (Module[
            "_gf_filter_pck_merge_properties_filter"
        ] = createExportWrapper("gf_filter_pck_merge_properties_filter"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_dangling_copy = (Module["_gf_filter_pck_dangling_copy"] =
            createExportWrapper("gf_filter_pck_dangling_copy"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_shared_internal = (Module["_gf_filter_pck_new_shared_internal"] =
            createExportWrapper("gf_filter_pck_new_shared_internal"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_copy = (Module["_gf_filter_pck_new_copy"] =
            createExportWrapper("gf_filter_pck_new_copy"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_ref_destructor = (Module["_gf_filter_pck_new_ref_destructor"] =
            createExportWrapper("gf_filter_pck_new_ref_destructor"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_new_ref = (Module["_gf_filter_pck_new_ref"] =
            createExportWrapper("gf_filter_pck_new_ref"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_forward = (Module["_gf_filter_pck_forward"] =
            createExportWrapper("gf_filter_pck_forward"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_ref_ex = (Module["_gf_filter_pck_ref_ex"] =
            createExportWrapper("gf_filter_pck_ref_ex"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_ref_props = (Module["_gf_filter_pck_ref_props"] =
            createExportWrapper("gf_filter_pck_ref_props"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_property = (Module["_gf_filter_pck_set_property"] =
            createExportWrapper("gf_filter_pck_set_property"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_property_str = (Module["_gf_filter_pck_set_property_str"] =
            createExportWrapper("gf_filter_pck_set_property_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_property_dyn = (Module["_gf_filter_pck_set_property_dyn"] =
            createExportWrapper("gf_filter_pck_set_property_dyn"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_has_properties = (Module["_gf_filter_pck_has_properties"] =
            createExportWrapper("gf_filter_pck_has_properties"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_property_str = (Module["_gf_filter_pck_get_property_str"] =
            createExportWrapper("gf_filter_pck_get_property_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_framing = (Module["_gf_filter_pck_set_framing"] =
            createExportWrapper("gf_filter_pck_set_framing"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_framing = (Module["_gf_filter_pck_get_framing"] =
            createExportWrapper("gf_filter_pck_get_framing"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_dts = (Module["_gf_filter_pck_set_dts"] =
            createExportWrapper("gf_filter_pck_set_dts"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_dts = (Module["_gf_filter_pck_get_dts"] =
            createExportWrapper("gf_filter_pck_get_dts"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_sap = (Module["_gf_filter_pck_get_sap"] =
            createExportWrapper("gf_filter_pck_get_sap"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_roll_info = (Module["_gf_filter_pck_set_roll_info"] =
            createExportWrapper("gf_filter_pck_set_roll_info"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_roll_info = (Module["_gf_filter_pck_get_roll_info"] =
            createExportWrapper("gf_filter_pck_get_roll_info"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_interlaced = (Module["_gf_filter_pck_set_interlaced"] =
            createExportWrapper("gf_filter_pck_set_interlaced"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_interlaced = (Module["_gf_filter_pck_get_interlaced"] =
            createExportWrapper("gf_filter_pck_get_interlaced"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_corrupted = (Module["_gf_filter_pck_set_corrupted"] =
            createExportWrapper("gf_filter_pck_set_corrupted"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_corrupted = (Module["_gf_filter_pck_get_corrupted"] =
            createExportWrapper("gf_filter_pck_get_corrupted"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_seek_flag = (Module["_gf_filter_pck_set_seek_flag"] =
            createExportWrapper("gf_filter_pck_set_seek_flag"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_seek_flag = (Module["_gf_filter_pck_get_seek_flag"] =
            createExportWrapper("gf_filter_pck_get_seek_flag"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_dependency_flags = (Module["_gf_filter_pck_set_dependency_flags"] =
            createExportWrapper("gf_filter_pck_set_dependency_flags"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_dependency_flags = (Module["_gf_filter_pck_get_dependency_flags"] =
            createExportWrapper("gf_filter_pck_get_dependency_flags"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_carousel_version = (Module["_gf_filter_pck_set_carousel_version"] =
            createExportWrapper("gf_filter_pck_set_carousel_version"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_carousel_version = (Module["_gf_filter_pck_get_carousel_version"] =
            createExportWrapper("gf_filter_pck_get_carousel_version"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_byte_offset = (Module["_gf_filter_pck_set_byte_offset"] =
            createExportWrapper("gf_filter_pck_set_byte_offset"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_byte_offset = (Module["_gf_filter_pck_get_byte_offset"] =
            createExportWrapper("gf_filter_pck_get_byte_offset"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_crypt_flags = (Module["_gf_filter_pck_set_crypt_flags"] =
            createExportWrapper("gf_filter_pck_set_crypt_flags"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_crypt_flags = (Module["_gf_filter_pck_get_crypt_flags"] =
            createExportWrapper("gf_filter_pck_get_crypt_flags"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_seq_num = (Module["_gf_filter_pck_set_seq_num"] =
            createExportWrapper("gf_filter_pck_set_seq_num"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_seq_num = (Module["_gf_filter_pck_get_seq_num"] =
            createExportWrapper("gf_filter_pck_get_seq_num"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_set_clock_type = (Module["_gf_filter_pck_set_clock_type"] =
            createExportWrapper("gf_filter_pck_set_clock_type"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_get_clock_type = (Module["_gf_filter_pck_get_clock_type"] =
            createExportWrapper("gf_filter_pck_get_clock_type"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_expand = (Module["_gf_filter_pck_expand"] =
            createExportWrapper("gf_filter_pck_expand"));
        /** @type {function(...*):?} */
        var _gf_filter_pck_check_realloc = (Module["_gf_filter_pck_check_realloc"] =
            createExportWrapper("gf_filter_pck_check_realloc"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_remove = (Module["_gf_filter_pid_remove"] =
            createExportWrapper("gf_filter_pid_remove"));
        /** @type {function(...*):?} */
        var _gf_filter_notification_failure = (Module["_gf_filter_notification_failure"] =
            createExportWrapper("gf_filter_notification_failure"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_name = (Module["_gf_filter_pid_set_name"] =
            createExportWrapper("gf_filter_pid_set_name"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_orig_src_args = (Module["_gf_filter_pid_orig_src_args"] =
            createExportWrapper("gf_filter_pid_orig_src_args"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_source_filter_name = (Module[
            "_gf_filter_pid_get_source_filter_name"
        ] = createExportWrapper("gf_filter_pid_get_source_filter_name"));
        /** @type {function(...*):?} */
        var _gf_filter_in_parent_chain = (Module["_gf_filter_in_parent_chain"] =
            createExportWrapper("gf_filter_in_parent_chain"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_check_caps = (Module["_gf_filter_pid_check_caps"] = createExportWrapper(
            "gf_filter_pid_check_caps"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pid_push_properties = (Module["_gf_filter_pid_push_properties"] =
            createExportWrapper("gf_filter_pid_push_properties"));
        /** @type {function(...*):?} */
        var _gf_props_4cc_get_type = (Module["_gf_props_4cc_get_type"] =
            createExportWrapper("gf_props_4cc_get_type"));
        /** @type {function(...*):?} */
        var _gf_props_get_id = (Module["_gf_props_get_id"] =
            createExportWrapper("gf_props_get_id"));
        /** @type {function(...*):?} */
        var _gf_props_reset_single = (Module["_gf_props_reset_single"] =
            createExportWrapper("gf_props_reset_single"));
        /** @type {function(...*):?} */
        var _gf_props_parse_type = (Module["_gf_props_parse_type"] =
            createExportWrapper("gf_props_parse_type"));
        /** @type {function(...*):?} */
        var _gf_filter_setup_failure = (Module["_gf_filter_setup_failure"] =
            createExportWrapper("gf_filter_setup_failure"));
        /** @type {function(...*):?} */
        var _gf_filter_set_name = (Module["_gf_filter_set_name"] =
            createExportWrapper("gf_filter_set_name"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_new = (Module["_gf_filter_pid_new"] =
            createExportWrapper("gf_filter_pid_new"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_property_str = (Module["_gf_filter_pid_set_property_str"] =
            createExportWrapper("gf_filter_pid_set_property_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_property_dyn = (Module["_gf_filter_pid_set_property_dyn"] =
            createExportWrapper("gf_filter_pid_set_property_dyn"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_info = (Module["_gf_filter_pid_set_info"] =
            createExportWrapper("gf_filter_pid_set_info"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_info_str = (Module["_gf_filter_pid_set_info_str"] =
            createExportWrapper("gf_filter_pid_set_info_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_info_dyn = (Module["_gf_filter_pid_set_info_dyn"] =
            createExportWrapper("gf_filter_pid_set_info_dyn"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_negociate_property = (Module["_gf_filter_pid_negociate_property"] =
            createExportWrapper("gf_filter_pid_negociate_property"));
        /** @type {function(...*):?} */
        var _gf_props_dump = (Module["_gf_props_dump"] = createExportWrapper("gf_props_dump"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_negociate_property_str = (Module[
            "_gf_filter_pid_negociate_property_str"
        ] = createExportWrapper("gf_filter_pid_negociate_property_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_negociate_property_dyn = (Module[
            "_gf_filter_pid_negociate_property_dyn"
        ] = createExportWrapper("gf_filter_pid_negociate_property_dyn"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_property_entry_str = (Module[
            "_gf_filter_pid_get_property_entry_str"
        ] = createExportWrapper("gf_filter_pid_get_property_entry_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_enum_info = (Module["_gf_filter_pid_enum_info"] =
            createExportWrapper("gf_filter_pid_enum_info"));
        /** @type {function(...*):?} */
        var _gf_filter_get_info = (Module["_gf_filter_get_info"] =
            createExportWrapper("gf_filter_get_info"));
        /** @type {function(...*):?} */
        var _gf_filter_get_info_str = (Module["_gf_filter_get_info_str"] =
            createExportWrapper("gf_filter_get_info_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_reset_properties = (Module["_gf_filter_pid_reset_properties"] =
            createExportWrapper("gf_filter_pid_reset_properties"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_merge_properties = (Module["_gf_filter_pid_merge_properties"] =
            createExportWrapper("gf_filter_pid_merge_properties"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_is_flush_eos = (Module["_gf_filter_pid_is_flush_eos"] =
            createExportWrapper("gf_filter_pid_is_flush_eos"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_enum_properties = (Module["_gf_filter_pid_enum_properties"] =
            createExportWrapper("gf_filter_pid_enum_properties"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_eos_received = (Module["_gf_filter_pid_eos_received"] =
            createExportWrapper("gf_filter_pid_eos_received"));
        /** @type {function(...*):?} */
        var _gf_filter_event_name = (Module["_gf_filter_event_name"] =
            createExportWrapper("gf_filter_event_name"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_discard = (Module["_gf_filter_pid_set_discard"] =
            createExportWrapper("gf_filter_pid_set_discard"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_share_origin = (Module["_gf_filter_pid_share_origin"] =
            createExportWrapper("gf_filter_pid_share_origin"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_clear_eos = (Module["_gf_filter_pid_clear_eos"] =
            createExportWrapper("gf_filter_pid_clear_eos"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_clock_mode = (Module["_gf_filter_pid_set_clock_mode"] =
            createExportWrapper("gf_filter_pid_set_clock_mode"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_args = (Module["_gf_filter_pid_get_args"] =
            createExportWrapper("gf_filter_pid_get_args"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_max_buffer = (Module["_gf_filter_pid_get_max_buffer"] =
            createExportWrapper("gf_filter_pid_get_max_buffer"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_loose_connect = (Module["_gf_filter_pid_set_loose_connect"] =
            createExportWrapper("gf_filter_pid_set_loose_connect"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_caps_query = (Module["_gf_filter_pid_caps_query"] = createExportWrapper(
            "gf_filter_pid_caps_query"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pid_caps_query_str = (Module["_gf_filter_pid_caps_query_str"] =
            createExportWrapper("gf_filter_pid_caps_query_str"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_resolve_file_template_ex = (Module[
            "_gf_filter_pid_resolve_file_template_ex"
        ] = createExportWrapper("gf_filter_pid_resolve_file_template_ex"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_resolve_file_template = (Module["_gf_filter_pid_resolve_file_template"] =
            createExportWrapper("gf_filter_pid_resolve_file_template"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_destination_ex = (Module["_gf_filter_pid_get_destination_ex"] =
            createExportWrapper("gf_filter_pid_get_destination_ex"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_destination = (Module["_gf_filter_pid_get_destination"] =
            createExportWrapper("gf_filter_pid_get_destination"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_source = (Module["_gf_filter_pid_get_source"] = createExportWrapper(
            "gf_filter_pid_get_source"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pid_discard_block = (Module["_gf_filter_pid_discard_block"] =
            createExportWrapper("gf_filter_pid_discard_block"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_require_source_id = (Module["_gf_filter_pid_require_source_id"] =
            createExportWrapper("gf_filter_pid_require_source_id"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_min_pck_duration = (Module["_gf_filter_pid_get_min_pck_duration"] =
            createExportWrapper("gf_filter_pid_get_min_pck_duration"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_recompute_dts = (Module["_gf_filter_pid_recompute_dts"] =
            createExportWrapper("gf_filter_pid_recompute_dts"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_is_playing = (Module["_gf_filter_pid_is_playing"] = createExportWrapper(
            "gf_filter_pid_is_playing"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_pid_allow_direct_dispatch = (Module["_gf_filter_pid_allow_direct_dispatch"] =
            createExportWrapper("gf_filter_pid_allow_direct_dispatch"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_alias_udta = (Module["_gf_filter_pid_get_alias_udta"] =
            createExportWrapper("gf_filter_pid_get_alias_udta"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_source_filter = (Module["_gf_filter_pid_get_source_filter"] =
            createExportWrapper("gf_filter_pid_get_source_filter"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_enum_destinations = (Module["_gf_filter_pid_enum_destinations"] =
            createExportWrapper("gf_filter_pid_enum_destinations"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_ignore_blocking = (Module["_gf_filter_pid_ignore_blocking"] =
            createExportWrapper("gf_filter_pid_ignore_blocking"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_next_ts = (Module["_gf_filter_pid_get_next_ts"] =
            createExportWrapper("gf_filter_pid_get_next_ts"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_get_udta_flags = (Module["_gf_filter_pid_get_udta_flags"] =
            createExportWrapper("gf_filter_pid_get_udta_flags"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_udta_flags = (Module["_gf_filter_pid_set_udta_flags"] =
            createExportWrapper("gf_filter_pid_set_udta_flags"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_has_decoder = (Module["_gf_filter_pid_has_decoder"] =
            createExportWrapper("gf_filter_pid_has_decoder"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_set_rt_stats = (Module["_gf_filter_pid_set_rt_stats"] =
            createExportWrapper("gf_filter_pid_set_rt_stats"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_send_flush = (Module["_gf_filter_pid_send_flush"] = createExportWrapper(
            "gf_filter_pid_send_flush"
        ));
        /** @type {function(...*):?} */
        var _gf_props_parse_enum = (Module["_gf_props_parse_enum"] =
            createExportWrapper("gf_props_parse_enum"));
        /** @type {function(...*):?} */
        var _gf_props_enum_name = (Module["_gf_props_enum_name"] =
            createExportWrapper("gf_props_enum_name"));
        /** @type {function(...*):?} */
        var _gf_props_4cc_get_flags = (Module["_gf_props_4cc_get_flags"] =
            createExportWrapper("gf_props_4cc_get_flags"));
        /** @type {function(...*):?} */
        var _gf_fs_add_filter_register = (Module["_gf_fs_add_filter_register"] =
            createExportWrapper("gf_fs_add_filter_register"));
        /** @type {function(...*):?} */
        var _gf_fs_set_max_resolution_chain_length = (Module[
            "_gf_fs_set_max_resolution_chain_length"
        ] = createExportWrapper("gf_fs_set_max_resolution_chain_length"));
        /** @type {function(...*):?} */
        var _gf_fs_set_max_sleep_time = (Module["_gf_fs_set_max_sleep_time"] = createExportWrapper(
            "gf_fs_set_max_sleep_time"
        ));
        /** @type {function(...*):?} */
        var _gf_fs_remove_filter_register = (Module["_gf_fs_remove_filter_register"] =
            createExportWrapper("gf_fs_remove_filter_register"));
        /** @type {function(...*):?} */
        var _gf_filter_add_event_listener = (Module["_gf_filter_add_event_listener"] =
            createExportWrapper("gf_filter_add_event_listener"));
        /** @type {function(...*):?} */
        var _gf_filter_remove_event_listener = (Module["_gf_filter_remove_event_listener"] =
            createExportWrapper("gf_filter_remove_event_listener"));
        /** @type {function(...*):?} */
        var _gf_fs_forward_gf_event = (Module["_gf_fs_forward_gf_event"] =
            createExportWrapper("gf_fs_forward_gf_event"));
        /** @type {function(...*):?} */
        var _gf_filter_print_all_connections = (Module["_gf_filter_print_all_connections"] =
            createExportWrapper("gf_filter_print_all_connections"));
        /** @type {function(...*):?} */
        var _gf_filter_get_session_caps = (Module["_gf_filter_get_session_caps"] =
            createExportWrapper("gf_filter_get_session_caps"));
        /** @type {function(...*):?} */
        var _gf_filter_set_session_caps = (Module["_gf_filter_set_session_caps"] =
            createExportWrapper("gf_filter_set_session_caps"));
        /** @type {function(...*):?} */
        var _gf_fs_get_font_manager = (Module["_gf_fs_get_font_manager"] =
            createExportWrapper("gf_fs_get_font_manager"));
        /** @type {function(...*):?} */
        var _gf_filter_get_font_manager = (Module["_gf_filter_get_font_manager"] =
            createExportWrapper("gf_filter_get_font_manager"));
        /** @type {function(...*):?} */
        var _gf_fs_in_final_flush = (Module["_gf_fs_in_final_flush"] =
            createExportWrapper("gf_fs_in_final_flush"));
        /** @type {function(...*):?} */
        var _gf_fs_is_supported_mime = (Module["_gf_fs_is_supported_mime"] =
            createExportWrapper("gf_fs_is_supported_mime"));
        /** @type {function(...*):?} */
        var _gf_fs_get_filter = (Module["_gf_fs_get_filter"] =
            createExportWrapper("gf_fs_get_filter"));
        /** @type {function(...*):?} */
        var _gf_filter_get_stats = (Module["_gf_filter_get_stats"] =
            createExportWrapper("gf_filter_get_stats"));
        /** @type {function(...*):?} */
        var _gf_fs_get_http_max_rate = (Module["_gf_fs_get_http_max_rate"] =
            createExportWrapper("gf_fs_get_http_max_rate"));
        /** @type {function(...*):?} */
        var _gf_fs_set_http_max_rate = (Module["_gf_fs_set_http_max_rate"] =
            createExportWrapper("gf_fs_set_http_max_rate"));
        /** @type {function(...*):?} */
        var _gf_fs_get_http_rate = (Module["_gf_fs_get_http_rate"] =
            createExportWrapper("gf_fs_get_http_rate"));
        /** @type {function(...*):?} */
        var _gf_fs_is_supported_source = (Module["_gf_fs_is_supported_source"] =
            createExportWrapper("gf_fs_is_supported_source"));
        /** @type {function(...*):?} */
        var _gf_fs_fire_event = (Module["_gf_fs_fire_event"] =
            createExportWrapper("gf_fs_fire_event"));
        /** @type {function(...*):?} */
        var _gf_fs_set_filter_creation_callback = (Module["_gf_fs_set_filter_creation_callback"] =
            createExportWrapper("gf_fs_set_filter_creation_callback"));
        /** @type {function(...*):?} */
        var _gf_fs_get_rt_udta = (Module["_gf_fs_get_rt_udta"] =
            createExportWrapper("gf_fs_get_rt_udta"));
        /** @type {function(...*):?} */
        var _gf_fs_set_external_gl_provider = (Module["_gf_fs_set_external_gl_provider"] =
            createExportWrapper("gf_fs_set_external_gl_provider"));
        /** @type {function(...*):?} */
        var _gf_filter_force_main_thread = (Module["_gf_filter_force_main_thread"] =
            createExportWrapper("gf_filter_force_main_thread"));
        /** @type {function(...*):?} */
        var _gf_filter_reset_source = (Module["_gf_filter_reset_source"] =
            createExportWrapper("gf_filter_reset_source"));
        /** @type {function(...*):?} */
        var _gf_filter_connections_pending = (Module["_gf_filter_connections_pending"] =
            createExportWrapper("gf_filter_connections_pending"));
        /** @type {function(...*):?} */
        var _gf_filter_get_opid_count = (Module["_gf_filter_get_opid_count"] = createExportWrapper(
            "gf_filter_get_opid_count"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_get_opid = (Module["_gf_filter_get_opid"] =
            createExportWrapper("gf_filter_get_opid"));
        /** @type {function(...*):?} */
        var _gf_filter_url_is_filter = (Module["_gf_filter_url_is_filter"] =
            createExportWrapper("gf_filter_url_is_filter"));
        /** @type {function(...*):?} */
        var _gf_filter_connect_destination = (Module["_gf_filter_connect_destination"] =
            createExportWrapper("gf_filter_connect_destination"));
        /** @type {function(...*):?} */
        var _gf_filter_get_output_buffer_max = (Module["_gf_filter_get_output_buffer_max"] =
            createExportWrapper("gf_filter_get_output_buffer_max"));
        /** @type {function(...*):?} */
        var _gf_filter_make_sticky = (Module["_gf_filter_make_sticky"] =
            createExportWrapper("gf_filter_make_sticky"));
        /** @type {function(...*):?} */
        var _gf_filter_get_num_events_queued = (Module["_gf_filter_get_num_events_queued"] =
            createExportWrapper("gf_filter_get_num_events_queued"));
        /** @type {function(...*):?} */
        var _gf_filter_hint_single_clock = (Module["_gf_filter_hint_single_clock"] =
            createExportWrapper("gf_filter_hint_single_clock"));
        /** @type {function(...*):?} */
        var _gf_filter_override_caps = (Module["_gf_filter_override_caps"] =
            createExportWrapper("gf_filter_override_caps"));
        /** @type {function(...*):?} */
        var _gf_filter_act_as_sink = (Module["_gf_filter_act_as_sink"] =
            createExportWrapper("gf_filter_act_as_sink"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_init_play_event = (Module["_gf_filter_pid_init_play_event"] =
            createExportWrapper("gf_filter_pid_init_play_event"));
        /** @type {function(...*):?} */
        var _gf_filter_set_max_extra_input_pids = (Module["_gf_filter_set_max_extra_input_pids"] =
            createExportWrapper("gf_filter_set_max_extra_input_pids"));
        /** @type {function(...*):?} */
        var _gf_filter_get_max_extra_input_pids = (Module["_gf_filter_get_max_extra_input_pids"] =
            createExportWrapper("gf_filter_get_max_extra_input_pids"));
        /** @type {function(...*):?} */
        var _gf_filter_block_enabled = (Module["_gf_filter_block_enabled"] =
            createExportWrapper("gf_filter_block_enabled"));
        /** @type {function(...*):?} */
        var _gf_filter_pid_raw_new = (Module["_gf_filter_pid_raw_new"] =
            createExportWrapper("gf_filter_pid_raw_new"));
        /** @type {function(...*):?} */
        var _gf_filter_probe_data = (Module["_gf_filter_probe_data"] =
            createExportWrapper("gf_filter_probe_data"));
        /** @type {function(...*):?} */
        var _gf_filter_get_arg_str = (Module["_gf_filter_get_arg_str"] =
            createExportWrapper("gf_filter_get_arg_str"));
        /** @type {function(...*):?} */
        var _gf_filter_get_arg = (Module["_gf_filter_get_arg"] =
            createExportWrapper("gf_filter_get_arg"));
        /** @type {function(...*):?} */
        var _gf_filter_all_sinks_done = (Module["_gf_filter_all_sinks_done"] = createExportWrapper(
            "gf_filter_all_sinks_done"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_register_opengl_provider = (Module["_gf_filter_register_opengl_provider"] =
            createExportWrapper("gf_filter_register_opengl_provider"));
        /** @type {function(...*):?} */
        var _gf_filter_set_active_opengl_context = (Module["_gf_filter_set_active_opengl_context"] =
            createExportWrapper("gf_filter_set_active_opengl_context"));
        /** @type {function(...*):?} */
        var _gf_filter_count_source_by_protocol = (Module["_gf_filter_count_source_by_protocol"] =
            createExportWrapper("gf_filter_count_source_by_protocol"));
        /** @type {function(...*):?} */
        var _gf_filter_disable_probe = (Module["_gf_filter_disable_probe"] =
            createExportWrapper("gf_filter_disable_probe"));
        /** @type {function(...*):?} */
        var _gf_filter_disable_inputs = (Module["_gf_filter_disable_inputs"] = createExportWrapper(
            "gf_filter_disable_inputs"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_has_pid_connection_pending = (Module[
            "_gf_filter_has_pid_connection_pending"
        ] = createExportWrapper("gf_filter_has_pid_connection_pending"));
        /** @type {function(...*):?} */
        var _gf_filter_reporting_enabled = (Module["_gf_filter_reporting_enabled"] =
            createExportWrapper("gf_filter_reporting_enabled"));
        /** @type {function(...*):?} */
        var _gf_filter_update_status = (Module["_gf_filter_update_status"] =
            createExportWrapper("gf_filter_update_status"));
        /** @type {function(...*):?} */
        var _gf_filter_load_filter = (Module["_gf_filter_load_filter"] =
            createExportWrapper("gf_filter_load_filter"));
        /** @type {function(...*):?} */
        var _gf_filter_end_of_session = (Module["_gf_filter_end_of_session"] = createExportWrapper(
            "gf_filter_end_of_session"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_is_alias = (Module["_gf_filter_is_alias"] =
            createExportWrapper("gf_filter_is_alias"));
        /** @type {function(...*):?} */
        var _gf_filter_prevent_blocking = (Module["_gf_filter_prevent_blocking"] =
            createExportWrapper("gf_filter_prevent_blocking"));
        /** @type {function(...*):?} */
        var _gf_filter_is_dynamic = (Module["_gf_filter_is_dynamic"] =
            createExportWrapper("gf_filter_is_dynamic"));
        /** @type {function(...*):?} */
        var _gf_filter_block_eos = (Module["_gf_filter_block_eos"] =
            createExportWrapper("gf_filter_block_eos"));
        /** @type {function(...*):?} */
        var _gf_filter_set_event_target = (Module["_gf_filter_set_event_target"] =
            createExportWrapper("gf_filter_set_event_target"));
        /** @type {function(...*):?} */
        var _gf_filter_enumerate_args = (Module["_gf_filter_enumerate_args"] = createExportWrapper(
            "gf_filter_enumerate_args"
        ));
        /** @type {function(...*):?} */
        var _gf_filter_set_rt_udta = (Module["_gf_filter_set_rt_udta"] =
            createExportWrapper("gf_filter_set_rt_udta"));
        /** @type {function(...*):?} */
        var _gf_filter_get_rt_udta = (Module["_gf_filter_get_rt_udta"] =
            createExportWrapper("gf_filter_get_rt_udta"));
        /** @type {function(...*):?} */
        var _gf_filter_abort = (Module["_gf_filter_abort"] =
            createExportWrapper("gf_filter_abort"));
        /** @type {function(...*):?} */
        var _gf_filter_lock = (Module["_gf_filter_lock"] = createExportWrapper("gf_filter_lock"));
        /** @type {function(...*):?} */
        var _gf_filter_require_source_id = (Module["_gf_filter_require_source_id"] =
            createExportWrapper("gf_filter_require_source_id"));
        /** @type {function(...*):?} */
        var _gf_filter_has_connect_errors = (Module["_gf_filter_has_connect_errors"] =
            createExportWrapper("gf_filter_has_connect_errors"));
        /** @type {function(...*):?} */
        var _gf_filter_is_temporary = (Module["_gf_filter_is_temporary"] =
            createExportWrapper("gf_filter_is_temporary"));
        /** @type {function(...*):?} */
        var _gf_filter_meta_set_instances = (Module["_gf_filter_meta_set_instances"] =
            createExportWrapper("gf_filter_meta_set_instances"));
        /** @type {function(...*):?} */
        var _gf_filter_meta_get_instances = (Module["_gf_filter_meta_get_instances"] =
            createExportWrapper("gf_filter_meta_get_instances"));
        /** @type {function(...*):?} */
        var _gf_filter_bind_dash_algo_callbacks = (Module["_gf_filter_bind_dash_algo_callbacks"] =
            createExportWrapper("gf_filter_bind_dash_algo_callbacks"));
        /** @type {function(...*):?} */
        var _wcdec_on_error = (Module["_wcdec_on_error"] = createExportWrapper("wcdec_on_error"));
        /** @type {function(...*):?} */
        var _wcdec_on_frame_copy = (Module["_wcdec_on_frame_copy"] =
            createExportWrapper("wcdec_on_frame_copy"));
        /** @type {function(...*):?} */
        var _wcdec_on_video = (Module["_wcdec_on_video"] = createExportWrapper("wcdec_on_video"));
        /** @type {function(...*):?} */
        var _wcdec_on_audio = (Module["_wcdec_on_audio"] = createExportWrapper("wcdec_on_audio"));
        /** @type {function(...*):?} */
        var _wcdec_on_flush = (Module["_wcdec_on_flush"] = createExportWrapper("wcdec_on_flush"));
        /** @type {function(...*):?} */
        var _wcenc_on_error = (Module["_wcenc_on_error"] = createExportWrapper("wcenc_on_error"));
        /** @type {function(...*):?} */
        var _wcenc_on_flush = (Module["_wcenc_on_flush"] = createExportWrapper("wcenc_on_flush"));
        /** @type {function(...*):?} */
        var _wcenc_on_config = (Module["_wcenc_on_config"] =
            createExportWrapper("wcenc_on_config"));
        /** @type {function(...*):?} */
        var _wcenc_on_frame = (Module["_wcenc_on_frame"] = createExportWrapper("wcenc_on_frame"));
        /** @type {function(...*):?} */
        var _webgrab_on_error = (Module["_webgrab_on_error"] =
            createExportWrapper("webgrab_on_error"));
        /** @type {function(...*):?} */
        var _webgrab_on_frame_copy = (Module["_webgrab_on_frame_copy"] =
            createExportWrapper("webgrab_on_frame_copy"));
        /** @type {function(...*):?} */
        var _webgrab_on_video_frame = (Module["_webgrab_on_video_frame"] =
            createExportWrapper("webgrab_on_video_frame"));
        /** @type {function(...*):?} */
        var _webgrab_on_audio_data = (Module["_webgrab_on_audio_data"] =
            createExportWrapper("webgrab_on_audio_data"));
        /** @type {function(...*):?} */
        var _gf_js_try_lock = (Module["_gf_js_try_lock"] = createExportWrapper("gf_js_try_lock"));
        /** @type {function(...*):?} */
        var ___dl_seterr = createExportWrapper("__dl_seterr");
        /** @type {function(...*):?} */
        var _emscripten_builtin_memalign = createExportWrapper("emscripten_builtin_memalign");
        /** @type {function(...*):?} */
        var _setThrew = createExportWrapper("setThrew");
        /** @type {function(...*):?} */
        var _emscripten_stack_init = function () {
            return (_emscripten_stack_init = Module["asm"]["emscripten_stack_init"]).apply(
                null,
                arguments
            );
        };

        /** @type {function(...*):?} */
        var _emscripten_stack_get_free = function () {
            return (_emscripten_stack_get_free = Module["asm"]["emscripten_stack_get_free"]).apply(
                null,
                arguments
            );
        };

        /** @type {function(...*):?} */
        var _emscripten_stack_get_base = function () {
            return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(
                null,
                arguments
            );
        };

        /** @type {function(...*):?} */
        var _emscripten_stack_get_end = function () {
            return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(
                null,
                arguments
            );
        };

        /** @type {function(...*):?} */
        var stackSave = createExportWrapper("stackSave");
        /** @type {function(...*):?} */
        var stackRestore = createExportWrapper("stackRestore");
        /** @type {function(...*):?} */
        var stackAlloc = createExportWrapper("stackAlloc");
        /** @type {function(...*):?} */
        var _emscripten_stack_get_current = function () {
            return (_emscripten_stack_get_current =
                Module["asm"]["emscripten_stack_get_current"]).apply(null, arguments);
        };

        var _ff_h264_cabac_tables = (Module["_ff_h264_cabac_tables"] = 3725043);
        var ___start_em_js = (Module["___start_em_js"] = 6442521);
        var ___stop_em_js = (Module["___stop_em_js"] = 6460144);
        function invoke_ii(index, a1) {
            var sp = stackSave();
            try {
                return getWasmTableEntry(index)(a1);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_iii(index, a1, a2) {
            var sp = stackSave();
            try {
                return getWasmTableEntry(index)(a1, a2);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_vii(index, a1, a2) {
            var sp = stackSave();
            try {
                getWasmTableEntry(index)(a1, a2);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_vi(index, a1) {
            var sp = stackSave();
            try {
                getWasmTableEntry(index)(a1);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_viii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
                getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_iiii(index, a1, a2, a3) {
            var sp = stackSave();
            try {
                return getWasmTableEntry(index)(a1, a2, a3);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_iiiii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
                return getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_viiii(index, a1, a2, a3, a4) {
            var sp = stackSave();
            try {
                getWasmTableEntry(index)(a1, a2, a3, a4);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
            var sp = stackSave();
            try {
                return getWasmTableEntry(index)(a1, a2, a3, a4, a5);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            var sp = stackSave();
            try {
                getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
            } catch (e) {
                stackRestore(sp);
                if (e !== e + 0) throw e;
                _setThrew(1, 0);
            }
        }

        // include: postamble.js
        // === Auto-generated postamble setup entry stuff ===

        Module["UTF8ToString"] = UTF8ToString;
        Module["callMain"] = callMain;
        Module["stackAlloc"] = stackAlloc;
        Module["stackSave"] = stackSave;
        Module["stackRestore"] = stackRestore;
        Module["cwrap"] = cwrap;
        Module["addFunction"] = addFunction;
        Module["setValue"] = setValue;
        Module["getValue"] = getValue;
        Module["allocateUTF8OnStack"] = allocateUTF8OnStack;
        Module["FS"] = FS;
        Module["IDBFS"] = IDBFS;
        var missingLibrarySymbols = [
            "getHostByName",
            "traverseStack",
            "convertPCtoSourceLocation",
            "jstoi_s",
            "getDynCaller",
            "runtimeKeepalivePush",
            "runtimeKeepalivePop",
            "maybeExit",
            "asmjsMangle",
            "HandleAllocator",
            "getNativeTypeSize",
            "STACK_SIZE",
            "STACK_ALIGN",
            "POINTER_SIZE",
            "ASSERTIONS",
            "writeI53ToI64Clamped",
            "writeI53ToI64Signaling",
            "writeI53ToU64Clamped",
            "writeI53ToU64Signaling",
            "convertI32PairToI53",
            "convertI32PairToI53Checked",
            "convertU32PairToI53",
            "removeFunction",
            "reallyNegative",
            "unSign",
            "strLen",
            "reSign",
            "formatString",
            "intArrayToString",
            "AsciiToString",
            "stringToAscii",
            "UTF16ToString",
            "stringToUTF16",
            "lengthBytesUTF16",
            "UTF32ToString",
            "stringToUTF32",
            "lengthBytesUTF32",
            "writeStringToMemory",
            "fillDeviceOrientationEventData",
            "registerDeviceOrientationEventCallback",
            "fillDeviceMotionEventData",
            "registerDeviceMotionEventCallback",
            "screenOrientation",
            "fillOrientationChangeEventData",
            "registerOrientationChangeEventCallback",
            "hideEverythingExceptGivenElement",
            "restoreHiddenElements",
            "softFullscreenResizeWebGLRenderTarget",
            "registerPointerlockErrorEventCallback",
            "fillBatteryEventData",
            "battery",
            "registerBatteryEventCallback",
            "jsStackTrace",
            "stackTrace",
            "checkWasiClock",
            "createDyncallWrapper",
            "setImmediateWrapped",
            "clearImmediateWrapped",
            "polyfillSetImmediate",
            "getPromise",
            "makePromise",
            "makePromiseCallback",
            "ExceptionInfo",
            "exception_addRef",
            "exception_decRef",
            "_setNetworkCallback",
            "writeGLArray",
            "SDL_unicode",
            "SDL_ttfContext",
            "SDL_audio",
            "GLFW_Window",
            "runAndAbortIfError",
            "ALLOC_NORMAL",
            "ALLOC_STACK",
            "allocate"
        ];
        missingLibrarySymbols.forEach(missingLibrarySymbol);

        var unexportedSymbols = [
            "run",
            "UTF8ArrayToString",
            "stringToUTF8Array",
            "stringToUTF8",
            "lengthBytesUTF8",
            "addOnPreRun",
            "addOnInit",
            "addOnPreMain",
            "addOnExit",
            "addOnPostRun",
            "addRunDependency",
            "removeRunDependency",
            "FS_createFolder",
            "FS_createPath",
            "FS_createDataFile",
            "FS_createPreloadedFile",
            "FS_createLazyFile",
            "FS_createLink",
            "FS_createDevice",
            "FS_unlink",
            "out",
            "err",
            "abort",
            "keepRuntimeAlive",
            "wasmMemory",
            "getTempRet0",
            "setTempRet0",
            "writeStackCookie",
            "checkStackCookie",
            "ptrToString",
            "zeroMemory",
            "stringToNewUTF8",
            "exitJS",
            "getHeapMax",
            "emscripten_realloc_buffer",
            "ENV",
            "ERRNO_CODES",
            "ERRNO_MESSAGES",
            "setErrNo",
            "inetPton4",
            "inetNtop4",
            "inetPton6",
            "inetNtop6",
            "readSockaddr",
            "writeSockaddr",
            "DNS",
            "Protocols",
            "Sockets",
            "getRandomDevice",
            "timers",
            "warnOnce",
            "UNWIND_CACHE",
            "readEmAsmArgsArray",
            "readEmAsmArgs",
            "runEmAsmFunction",
            "runMainThreadEmAsm",
            "jstoi_q",
            "getExecutableName",
            "listenOnce",
            "autoResumeAudioContext",
            "dynCall",
            "handleException",
            "callUserCallback",
            "safeSetTimeout",
            "asyncLoad",
            "alignMemory",
            "mmapAlloc",
            "writeI53ToI64",
            "readI53FromI64",
            "readI53FromU64",
            "MAX_INT53",
            "MIN_INT53",
            "bigintToI53Checked",
            "getCFunc",
            "ccall",
            "uleb128Encode",
            "sigToWasmTypes",
            "generateFuncType",
            "convertJsFunctionToWasm",
            "freeTableIndexes",
            "functionsInTableMap",
            "getEmptyTableSlot",
            "updateTableMap",
            "getFunctionAddress",
            "PATH",
            "PATH_FS",
            "intArrayFromString",
            "UTF16Decoder",
            "allocateUTF8",
            "writeArrayToMemory",
            "writeAsciiToMemory",
            "SYSCALLS",
            "getSocketFromFD",
            "getSocketAddress",
            "JSEvents",
            "registerKeyEventCallback",
            "specialHTMLTargets",
            "maybeCStringToJsString",
            "findEventTarget",
            "findCanvasEventTarget",
            "getBoundingClientRect",
            "fillMouseEventData",
            "registerMouseEventCallback",
            "registerWheelEventCallback",
            "registerUiEventCallback",
            "registerFocusEventCallback",
            "fillFullscreenChangeEventData",
            "registerFullscreenChangeEventCallback",
            "JSEvents_requestFullscreen",
            "JSEvents_resizeCanvasForFullscreen",
            "registerRestoreOldStyle",
            "setLetterbox",
            "currentFullscreenStrategy",
            "restoreOldWindowedStyle",
            "doRequestFullscreen",
            "fillPointerlockChangeEventData",
            "registerPointerlockChangeEventCallback",
            "requestPointerLock",
            "fillVisibilityChangeEventData",
            "registerVisibilityChangeEventCallback",
            "registerTouchEventCallback",
            "fillGamepadEventData",
            "registerGamepadEventCallback",
            "registerBeforeUnloadEventCallback",
            "setCanvasElementSize",
            "getCanvasElementSize",
            "demangle",
            "demangleAll",
            "ExitStatus",
            "getEnvStrings",
            "doReadv",
            "doWritev",
            "dlopenMissingError",
            "promiseMap",
            "uncaughtExceptionCount",
            "exceptionLast",
            "exceptionCaught",
            "Browser",
            "setMainLoop",
            "wget",
            "MEMFS",
            "TTY",
            "PIPEFS",
            "SOCKFS",
            "tempFixedLengthArray",
            "miniTempWebGLFloatBuffers",
            "heapObjectForWebGLType",
            "heapAccessShiftForWebGLHeap",
            "GL",
            "emscriptenWebGLGet",
            "computeUnpackAlignedImageSize",
            "emscriptenWebGLGetTexPixelData",
            "emscriptenWebGLGetUniform",
            "webglGetUniformLocation",
            "webglPrepareUniformLocationsBeforeFirstUse",
            "webglGetLeftBracePos",
            "emscriptenWebGLGetVertexAttrib",
            "AL",
            "SDL",
            "SDL_gfx",
            "GLUT",
            "EGL",
            "GLFW",
            "GLEW",
            "IDBStore"
        ];
        unexportedSymbols.forEach(unexportedRuntimeSymbol);

        var calledRun;

        dependenciesFulfilled = function runCaller() {
            // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
        };

        function callMain(args = []) {
            assert(
                runDependencies == 0,
                'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])'
            );
            assert(
                __ATPRERUN__.length == 0,
                "cannot call main when preRun functions remain to be called"
            );

            var entryFunction = _main;

            args.unshift(thisProgram);

            var argc = args.length;
            var argv = stackAlloc((argc + 1) * 4);
            var argv_ptr = argv >> 2;
            args.forEach((arg) => {
                HEAP32[argv_ptr++] = allocateUTF8OnStack(arg);
            });
            HEAP32[argv_ptr] = 0;

            try {
                var ret = entryFunction(argc, argv);

                // if we're not running an evented main loop, it's time to exit
                exitJS(ret, /* implicit = */ true);
                return ret;
            } catch (e) {
                return handleException(e);
            }
        }

        function stackCheckInit() {
            // This is normally called automatically during __wasm_call_ctors but need to
            // get these values before even running any of the ctors so we call it redundantly
            // here.
            _emscripten_stack_init();
            // TODO(sbc): Move writeStackCookie to native to to avoid this.
            writeStackCookie();
        }

        function run(args = arguments_) {
            if (runDependencies > 0) {
                return;
            }

            stackCheckInit();

            preRun();

            // a preRun added a dependency, run will be called later
            if (runDependencies > 0) {
                return;
            }

            function doRun() {
                // run may have just been called through dependencies being fulfilled just in this very frame,
                // or while the async setStatus time below was happening
                if (calledRun) return;
                calledRun = true;
                Module["calledRun"] = true;

                if (ABORT) return;

                initRuntime();

                preMain();

                readyPromiseResolve(Module);
                if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();

                if (shouldRunNow) callMain(args);

                postRun();
            }

            if (Module["setStatus"]) {
                Module["setStatus"]("Running...");
                setTimeout(function () {
                    setTimeout(function () {
                        Module["setStatus"]("");
                    }, 1);
                    doRun();
                }, 1);
            } else {
                doRun();
            }
            checkStackCookie();
        }

        function checkUnflushedContent() {
            // Compiler settings do not allow exiting the runtime, so flushing
            // the streams is not possible. but in ASSERTIONS mode we check
            // if there was something to flush, and if so tell the user they
            // should request that the runtime be exitable.
            // Normally we would not even include flush() at all, but in ASSERTIONS
            // builds we do so just for this check, and here we see if there is any
            // content to flush, that is, we check if there would have been
            // something a non-ASSERTIONS build would have not seen.
            // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
            // mode (which has its own special function for this; otherwise, all
            // the code is inside libc)
            var oldOut = out;
            var oldErr = err;
            var has = false;
            out = err = (x) => {
                has = true;
            };
            try {
                // it doesn't matter if it fails
                _fflush(0);
                // also flush in the JS FS layer
                ["stdout", "stderr"].forEach(function (name) {
                    var info = FS.analyzePath("/dev/" + name);
                    if (!info) return;
                    var stream = info.object;
                    var rdev = stream.rdev;
                    var tty = TTY.ttys[rdev];
                    if (tty && tty.output && tty.output.length) {
                        has = true;
                    }
                });
            } catch (e) {}
            out = oldOut;
            err = oldErr;
            if (has) {
                warnOnce(
                    "stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc."
                );
            }
        }

        if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
                Module["preInit"].pop()();
            }
        }

        // shouldRunNow refers to calling main(), not run().
        var shouldRunNow = true;

        if (Module["noInitialRun"]) shouldRunNow = false;

        run();

        // end include: postamble.js

        return libgpac.ready;
    };
})();
if (typeof exports === "object" && typeof module === "object") module.exports = libgpac;
else if (typeof define === "function" && define["amd"])
    define([], function () {
        return libgpac;
    });
else if (typeof exports === "object") exports["libgpac"] = libgpac;
