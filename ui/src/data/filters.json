[
    {
        "name": "inspect",
        "description": "Inspect packets",
        "body": "The inspect filter can be used to dump PID and packets. It may also be used to check parts of payload of the packets.\n\nThe default options inspect only PID changes.\nIf full is not set, mode=frame is forced and PID properties are formatted in human-readable form, one PID per line.\nOtherwise, all properties are dumped.\nNote: specifying xml, analyze, fmt or using -for-test will force full to true.\n\nCustom property duming\n\nThe packet inspector can be configured to dump specific properties of packets using fmt.\nWhen the option is not present, all properties are dumped. Otherwise, only properties identified by $TOKEN$ are printed. You may use '$', '@' or '%' for TOKEN separator. TOKEN can be:\n\t* pn: packet (frame in framed mode) number\n\t* dts: decoding time stamp in stream timescale, N/A if not available\n\t* ddts: difference between current and previous packets decoding time stamp in stream timescale, N/A if not available\n\t* cts: composition time stamp in stream timescale, N/A if not available\n\t* dcts: difference between current and previous packets composition time stamp in stream timescale, N/A if not available\n\t* ctso: difference between composition time stamp and decoding time stamp in stream timescale, N/A if not available\n\t* dur: duration in stream timescale\n\t* frame: framing status\n\t  * interface: complete AU, interface object (no size info). Typically a GL texture\n\t  * frame_full: complete AU\n\t  * frame_start: beginning of frame\n\t  * frame_end: end of frame\n\t  * frame_cont: frame continuation (not beginning, not end)\n\t* sap or rap: SAP type of the frame\n\t* ilace: interlacing flag (0: progressive, 1: top field, 2: bottom field)\n\t* corr: corrupted packet flag\n\t* seek: seek flag\n\t* bo: byte offset in source, N/A if not available\n\t* roll: roll info\n\t* crypt: crypt flag\n\t* vers: carousel version number\n\t* size: size of packet\n\t* csize: total size of packets received so far\n\t* crc: 32 bit CRC of packet\n\t* lf or n: insert new line\n\t* t: insert tab\n\t* data: hex dump of packet (big output!) or as string if legal UTF-8\n\t* lp: leading picture flag\n\t* depo: depends on other packet flag\n\t* depf: is depended on other packet flag\n\t* red: redundant coding flag\n\t* start: packet composition time as HH:MM:SS.ms\n\t* startc: packet composition time as HH:MM:SS,ms\n\t* end: packet end time as HH:MM:SS.ms\n\t* endc: packet end time as HH:MM:SS,ms\n\t* ck: clock type used for PCR discontinuities\n\t* pcr: MPEG-2 TS last PCR, n/a if not available\n\t* pcrd: difference between last PCR and decoding time, n/a if no PCR available\n\t* pcrc: difference between last PCR and composition time, n/a if no PCR available\n\t* P4CC: 4CC of packet property\n\t* PropName: Name of packet property\n\t* pid.P4CC: 4CC of PID property\n\t* pid.PropName: Name of PID property\n\t* fn: Filter name\n\nExample:\nfmt=\"PID $pid.ID$ packet $pn$ DTS $dts$ CTS $cts$ $lf$\"\nThis dumps packet number, cts and dts as follows: PID 1 packet 10 DTS 100 CTS 108 \\n\n  \nAn unrecognized keyword or missing property will resolve to an empty string.\n\nNote: when dumping in interleaved mode, there is no guarantee that the packets will be dumped in their original sequence order since the inspector fetches one packet at a time on each PID.\n\nNote on playback\n\nBuffering can be enabled to check the input filter chain behaviour, e.g. check HAS adaptation logic.\nThe various buffering options control when packets are consumed. Buffering events are logged using media@info for state changes and media@debug for media filling events.\nThe speed option is only used to configure the filter chain but is ignored by the filter when consuming packets.\nIf real-time consumption is required, a reframer filter must be setup before the inspect filter.\nExample:\ngpac -i SRC reframer:rt=on inspect:buffer=10000:rbuffer=1000:mbuffer=30000:speed=2\nThis will play the session at 2x speed, using 30s of maximum buffering, consumming packets after 10s of media are ready and rebuffering if less than 1s of media.\n\n\n",
        "options": {
            "log": {
                "type": "str",
                "description": "set probe log filename to print number of streams, GLOG uses GPAC logs app@info(default for android)",
                "default": "stdout"
            },
            "mode": {
                "type": "enum",
                "description": "dump mode",
                "default": "pck",
                "enum": {
                    "pck": "dump full packet",
                    "blk": "dump packets before reconstruction",
                    "frame": "force reframer",
                    "raw": "dump source packets without demultiplexing"
                }
            },
            "interleave": {
                "type": "bool",
                "description": "dump packets as they are received on each PID. If false, logs are reported for each PID at end of session",
                "default": true
            },
            "deep": {
                "type": "bool",
                "description": "dump packets along with PID state change, implied when fmt is set",
                "default": true
            },
            "props": {
                "type": "bool",
                "description": "dump packet properties, ignored when fmt is set",
                "default": true
            },
            "dump_data": {
                "type": "bool",
                "description": "enable full data dump (very large output), ignored when fmt is set",
                "default": true
            },
            "fmt": {
                "type": "str",
                "description": "set packet dump format"
            },
            "hdr": {
                "type": "bool",
                "description": "print a header corresponding to fmt string without '$' or \"pid\"",
                "default": true
            },
            "allp": {
                "type": "bool",
                "description": "analyse for the entire duration, rather than stopping when all PIDs are found",
                "default": true
            },
            "info": {
                "type": "bool",
                "description": "monitor PID info changes",
                "default": true
            },
            "full": {
                "type": "bool",
                "description": "full dump of PID properties (always on if XML)",
                "default": true
            },
            "pcr": {
                "type": "bool",
                "description": "dump M2TS PCR info",
                "default": true
            },
            "speed": {
                "type": "dbl",
                "description": "set playback command speed. If negative and start is 0, start is set to -1",
                "default": "1.0"
            },
            "start": {
                "type": "dbl",
                "description": "set playback start offset. A negative value means percent of media duration with -1 equal to duration",
                "default": "0.0"
            },
            "dur": {
                "type": "frac",
                "description": "set inspect duration",
                "default": "0/0"
            },
            "analyze": {
                "type": "enum",
                "description": "analyze sample content (NALU, OBU)",
                "default": "off",
                "enum": {
                    "off": "no analyzing",
                    "on": "simple analyzing",
                    "bs": "log bitstream syntax (all elements read from bitstream)",
                    "full": "log bitstream syntax and bit sizes signaled as (N) after field value, except 1-bit fields (omitted)"
                }
            },
            "xml": {
                "type": "bool",
                "description": "use xml formatting (implied if (-analyze]() is set) and disable fmt",
                "default": true
            },
            "crc": {
                "type": "bool",
                "description": "dump crc of samples of subsamples (NALU or OBU) when analyzing",
                "default": true
            },
            "fftmcd": {
                "type": "bool",
                "description": "consider timecodes use ffmpeg-compatible signaling rather than QT compliant one",
                "default": true
            },
            "dtype": {
                "type": "bool",
                "description": "dump property type",
                "default": true
            },
            "buffer": {
                "type": "uint",
                "description": "set playback buffer in ms",
                "default": 0
            },
            "mbuffer": {
                "type": "uint",
                "description": "set max buffer occupancy in ms. If less than buffer, use buffer",
                "default": 0
            },
            "rbuffer": {
                "type": "uint",
                "description": "rebuffer trigger in ms. If 0 or more than buffer, disable rebuffering",
                "default": 0
            },
            "test": {
                "type": "enum",
                "description": "skip predefined set of properties, used for test mode",
                "default": "no",
                "enum": {
                    "no": "no properties skipped",
                    "noprop": "all properties/info changes on PID are skipped, only packets are dumped",
                    "network": "URL/path dump, cache state, file size properties skipped (used for hashing network results)",
                    "netx": "same as network but skip track duration and templates (used for hashing progressive load of fmp4)",
                    "encode": "same as network plus skip decoder config (used for hashing encoding results)",
                    "encx": "same as encode and skip bitrates, media data size and co",
                    "nocrc": "disable packet CRC dump",
                    "nobr": "skip bitrate"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["Unknown"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "fin",
            "btplay",
            "httpin",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "routein",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "ohevcdec"
        ],
        "sinks": []
    },
    {
        "name": "probe",
        "description": "Probe source",
        "body": "The Probe filter is used by applications (typically MP4Box) to query demultiplexed PIDs (audio, video, ...) available in a source chain.\n\nThe filter outputs the number of input PIDs in the file specified by log.\nIt is up to the app developer to query input PIDs of the prober and take appropriated decisions.\n\n\n",
        "options": {
            "log": {
                "type": "str",
                "description": "set probe log filename to print number of streams, GLOG uses GPAC logs app@info(default for android)",
                "default": "stdout"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media", "Codec Not Supported"],
                "stream_type": ["ObjectDescriptor", "File", "Text", "SceneDescription"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": []
    },
    {
        "name": "compositor",
        "description": "Compositor",
        "body": "The GPAC compositor allows mixing audio, video, text and graphics in a timed fashion.\nThe compositor operates either in media-client or filter-only mode.\n\nMedia-client mode\n\nIn this mode, the compositor acts as a pseudo-sink for the video side and creates its own output window.\nThe video frames are dispatched to the output video PID in the form of frame pointers requiring later GPU read if used.\nThe audio part acts as a regular filter, potentially mixing and resampling the audio inputs to generate its output.\nUser events are directly processed by the filter in this mode.\n\nFilter mode\n\nIn this mode, the compositor acts as a regular filter generating frames based on the loaded scene.\nIt will generate its outputs based on the input video frames, and will process user event sent by consuming filter(s).\nIf no input video frames (e.g. pure BIFS / SVG / VRML), the filter will generate frames based on the fps, at constant or variable frame rate.\nIt will stop generating frames as soon as all input streams are done, unless extended/reduced by dur.\nIf audio streams are loaded, an audio output PID is created.\n\nThe default output pixel format in filter mode is:\n- rgb when the filter is explicitly loaded by the application\n- rgba when the filter is loaded during a link resolution\nThis can be changed by assigning the opfmt option.\nIf either opfmt specifies alpha channel or bc is not 0 but has alpha=0, background creation in default scene will be skipped.\n\nIn filter-only mode, the special URL gpid:// is used to locate PIDs in the scene description, in order to design scenes independently from source media.\nWhen such a PID is associated to a Background2D node in BIFS (no SVG mapping yet), the compositor operates in pass-through mode.\nIn this mode, only new input frames on the pass-through PID will generate new frames, and the scene clock matches the input packet time.\nThe output size and pixel format will be set to the input size and pixel format, unless specified otherwise in the filter options.\n\nIf only 2D graphics are used and display driver is not forced, 2D rasterizer will happen in the output pixel format (including YUV pixel formats).\nIn this case, in-place processing (rasterizing over the input frame data) will be used whenever allowed by input data.\n\nIf 3D graphics are used or display driver is forced, OpenGL will be used on offscreen surface and the output packet will be an OpenGL texture.\n\nSpecific URL syntaxes\n\nThe compositor accepts any URL type supported by GPAC. It also accepts the following schemes for URLs:\n\t* views:// : creates an auto-stereo scene of N views from views://v1::.::vN\n\t* mosaic:// : creates a mosaic of N views from mosaic://v1::.::vN\n\nFor both syntaxes, vN can be any type of URL supported by GPAC.\nFor views:// syntax, the number of rendered views is set by nbviews:\n- If the URL gives less views than rendered, the views will be repeated\n- If the URL gives more views than rendered, the extra views will be ignored\n\nThe compositor can act as a source filter when the src option is explicitly set, independently from the operating mode:\nExample:\ngpac compositor:src=source.mp4 vout\n\nThe compositor can act as a source filter when the source url uses one of the compositor built-in protocol schemes:\nExample:\ngpac -i mosaic://URL1:URL2 vout\n\n\n",
        "options": {
            "aa": {
                "type": "enum",
                "description": "set anti-aliasing mode for raster graphics; whether the setting is applied or not depends on the graphics module or graphic card",
                "default": "all",
                "enum": {
                    "none": "no anti-aliasing",
                    "text": "anti-aliasing for text only",
                    "all": "complete anti-aliasing"
                }
            },
            "hlfill": {
                "type": "uint",
                "description": "set highlight fill color (ARGB)",
                "default": "0x0"
            },
            "hlline": {
                "type": "uint",
                "description": "set highlight stroke color (ARGB)",
                "default": "0xFF000000"
            },
            "hllinew": {
                "type": "flt",
                "description": "set highlight stroke width",
                "default": 1.0
            },
            "sz": {
                "type": "bool",
                "description": "enable scalable zoom. When scalable zoom is enabled, resizing the output window will also recompute all vectorial objects. Otherwise only the final buffer is stretched",
                "default": true
            },
            "bc": {
                "type": "uint",
                "description": "default background color to use when displaying transparent images or video with no scene composition instructions",
                "default": 0
            },
            "yuvhw": {
                "type": "bool",
                "description": "enable YUV hardware for 2D blit",
                "default": true
            },
            "blitp": {
                "type": "bool",
                "description": "partial hardware blit. If not set, will force more redraw",
                "default": true
            },
            "softblt": {
                "type": "bool",
                "description": "enable software blit/stretch in 2D. If disabled, vector graphics rasterizer will always be used",
                "default": true
            },
            "stress": {
                "type": "bool",
                "description": "enable stress mode of compositor (rebuild all vector graphics and texture states at each frame)",
                "default": true
            },
            "fast": {
                "type": "bool",
                "description": "enable speed optimization - whether the setting is applied or not depends on the graphics module / graphic card",
                "default": true
            },
            "bvol": {
                "type": "enum",
                "description": "draw bounding volume of objects",
                "default": "no",
                "enum": {
                    "no": "disable bounding box",
                    "box": "draws a rectangle (2D) or box (3D)",
                    "aabb": "draws axis-aligned bounding-box tree (3D) or rectangle (2D)"
                }
            },
            "textxt": {
                "type": "enum",
                "description": "specify whether text shall be drawn to a texture and then rendered or directly rendered. Using textured text can improve text rendering in 3D and also improve text-on-video like content",
                "default": "default",
                "enum": {
                    "default": "use texturing for OpenGL rendering, no texture for 2D rasterizer",
                    "never": "never uses text textures",
                    "always": "always render text to texture before drawing"
                }
            },
            "out8b": {
                "type": "bool",
                "description": "convert 10-bit video to 8 bit texture before GPU upload",
                "default": true
            },
            "drop": {
                "type": "bool",
                "description": "drop late frame when drawing. If not set, frames are not dropped until a desynchronization of 1 second or more is observed",
                "default": true
            },
            "sclock": {
                "type": "bool",
                "description": "force synchronizing all streams on a single clock",
                "default": true
            },
            "sgaze": {
                "type": "bool",
                "description": "simulate gaze events through mouse",
                "default": true
            },
            "ckey": {
                "type": "uint",
                "description": "color key to use in windowless mode (0xFFRRGGBB). GPAC currently does not support true alpha blitting to desktop due to limitations in most windowing toolkit, it therefore uses color keying mechanism. The alpha part of the key is used for global transparency of the output, if supported",
                "default": 0
            },
            "timeout": {
                "type": "uint",
                "description": "timeout in ms after which a source is considered dead (0 disable timeout)",
                "default": 10000
            },
            "fps": {
                "type": "frac",
                "description": "simulation frame rate when animation-only sources are played (ignored when video is present)",
                "default": "30/1"
            },
            "timescale": {
                "type": "uint",
                "description": "timescale used for output packets when no input video PID. A value of 0 means fps numerator",
                "default": 0
            },
            "autofps": {
                "type": "bool",
                "description": "use video input fps for output, ignored in player mode. If no video or not set, uses fps",
                "default": true
            },
            "vfr": {
                "type": "bool",
                "description": "only emit frames when changes are detected. (always true in player mode and when filter is dynamically loaded)",
                "default": true
            },
            "dur": {
                "type": "dbl",
                "description": "duration of generation. Mostly used when no video input is present. Negative values mean number of frames, positive values duration in second, 0 stops as soon as all streams are done",
                "default": "0"
            },
            "fsize": {
                "type": "bool",
                "description": "force the scene to resize to the biggest bitmap available if no size info is given in the BIFS configuration",
                "default": true
            },
            "mode2d": {
                "type": "enum",
                "description": "specify whether immediate drawing should be used or not",
                "default": "defer",
                "enum": {
                    "immediate": "the screen is completely redrawn at each frame (always on if pass-through mode is detected)",
                    "defer": "object positioning is tracked from frame to frame and dirty rectangles info is collected in order to redraw the minimal amount of the screen buffer",
                    "debug": "only renders changed areas, resetting other areas"
                }
            },
            "amc": {
                "type": "bool",
                "description": "audio multichannel support; if disabled always down-mix to stereo. Useful if the multichannel output does not work properly",
                "default": true
            },
            "asr": {
                "type": "uint",
                "description": "force output sample rate (0 for auto)",
                "default": 0
            },
            "ach": {
                "type": "uint",
                "description": "force output channels (0 for auto)",
                "default": 0
            },
            "alayout": {
                "type": "uint",
                "description": "force output channel layout (0 for auto)",
                "default": 0
            },
            "afmt": {
                "type": "afmt",
                "description": "force output channel format (0 for auto)",
                "default": "s16"
            },
            "asize": {
                "type": "uint",
                "description": "audio output packet size in samples",
                "default": 1024
            },
            "abuf": {
                "type": "uint",
                "description": "audio output buffer duration in ms - the audio renderer fills the output PID up to this value. A too low value will lower latency but can have real-time playback issues",
                "default": 100
            },
            "avol": {
                "type": "uint",
                "description": "audio volume in percent",
                "default": 100
            },
            "apan": {
                "type": "uint",
                "description": "audio pan in percent, 50 is no pan",
                "default": 50
            },
            "async": {
                "type": "bool",
                "description": "audio resynchronization; if disabled, audio data is never dropped but may get out of sync",
                "default": true
            },
            "max_aspeed": {
                "type": "dbl",
                "description": "silence audio if playback speed is greater than specified value",
                "default": "2.0"
            },
            "max_vspeed": {
                "type": "dbl",
                "description": "move to i-frame only decoding if playback speed is greater than specified value",
                "default": "4.0"
            },
            "buffer": {
                "type": "uint",
                "description": "playout buffer in ms (overridden by BufferLength property of input PID)",
                "default": 3000
            },
            "rbuffer": {
                "type": "uint",
                "description": "rebuffer trigger in ms (overridden by RebufferLength property of input PID)",
                "default": 1000
            },
            "mbuffer": {
                "type": "uint",
                "description": "max buffer in ms, must be greater than playout buffer (overridden by BufferMaxOccupancy property of input PID)",
                "default": 3000
            },
            "ntpsync": {
                "type": "uint",
                "description": "ntp resync threshold in ms (drops frame if their NTP is more than the given threshold above local ntp), 0 disables ntp drop",
                "default": 0
            },
            "nojs": {
                "type": "bool",
                "description": "disable javascript",
                "default": true
            },
            "noback": {
                "type": "bool",
                "description": "ignore background nodes and viewport fill (useful when dumping to PNG)",
                "default": true
            },
            "ogl": {
                "type": "enum",
                "description": "specify 2D rendering mode",
                "default": "auto",
                "enum": {
                    "auto": "automatically decides between on, off and hybrid based on content",
                    "off": "disables OpenGL; 3D will not be rendered",
                    "on": "uses OpenGL for all graphics; this will involve polygon tesselation and 2D graphics will not look as nice as 2D mode",
                    "hybrid": "the compositor performs software drawing of 2D graphics with no textures (better quality) and uses OpenGL for all 2D objects with textures and 3D objects"
                }
            },
            "pbo": {
                "type": "bool",
                "description": "enable PixelBufferObjects to push YUV textures to GPU in OpenGL Mode. This may slightly increase the performances of the playback",
                "default": true
            },
            "nav": {
                "type": "enum",
                "description": "override the default navigation mode of MPEG-4/VRML (Walk) and X3D (Examine)",
                "default": "none",
                "enum": {
                    "none": "disables navigation",
                    "walk": "3D world walk",
                    "fly": "3D world fly (no ground detection)",
                    "pan": "2D/3D world zoom/pan",
                    "game": "3D world game (mouse gives walk direction)",
                    "slide": "2D/3D world slide",
                    "exam": "2D/3D object examine",
                    "orbit": "3D object orbit",
                    "vr": "3D world VR (yaw/pitch/roll)"
                }
            },
            "linegl": {
                "type": "bool",
                "description": "indicate that outlining shall be done through OpenGL pen width rather than vectorial outlining",
                "default": true
            },
            "epow2": {
                "type": "bool",
                "description": "emulate power-of-2 textures for OpenGL (old hardware). Ignored if OpenGL rectangular texture extension is enabled",
                "default": true,
                "enum": {
                    "yes": "video texture is not resized but emulated with padding. This usually speeds up video mapping on shapes but disables texture transformations",
                    "no": "video is resized to a power of 2 texture when mapping to a shape"
                }
            },
            "paa": {
                "type": "bool",
                "description": "indicate whether polygon antialiasing should be used in full antialiasing mode. If not set, only lines and points antialiasing are used",
                "default": true
            },
            "bcull": {
                "type": "enum",
                "description": "indicate whether backface culling shall be disable or not",
                "default": "on",
                "enum": {
                    "on": "enables backface culling",
                    "off": "disables backface culling",
                    "alpha": "only enables backface culling for transparent meshes"
                }
            },
            "wire": {
                "type": "enum",
                "description": "wireframe mode",
                "default": "none",
                "enum": {
                    "none": "objects are drawn as solid",
                    "only": "objects are drawn as wireframe only",
                    "solid": "objects are drawn as solid and wireframe is then drawn"
                }
            },
            "norms": {
                "type": "enum",
                "description": "normal vector drawing for debug",
                "default": "none",
                "enum": {
                    "none": "no normals drawn",
                    "face": "one normal per face drawn",
                    "vertex": "one normal per vertex drawn"
                }
            },
            "rext": {
                "type": "bool",
                "description": "use non power of two (rectangular) texture GL extension",
                "default": true
            },
            "cull": {
                "type": "bool",
                "description": "use aabb culling: large objects are rendered in multiple calls when not fully in viewport",
                "default": true
            },
            "depth_gl_scale": {
                "type": "flt",
                "description": "set depth scaler",
                "default": 100.0
            },
            "depth_gl_type": {
                "type": "enum",
                "description": "set geometry type used to draw depth video",
                "default": "none",
                "enum": {
                    "none": "no geometric conversion",
                    "point": "compute point cloud from pixel+depth",
                    "strip": "same as point but thins point set"
                }
            },
            "nbviews": {
                "type": "uint",
                "description": "number of views to use in stereo mode",
                "default": 0
            },
            "stereo": {
                "type": "enum",
                "description": "stereo output type. If your graphic card does not support OpenGL shaders, only top and side modes will be available",
                "default": "none",
                "enum": {
                    "none": "no stereo",
                    "side": "images are displayed side by side from left to right",
                    "top": "images are displayed from top (laft view) to bottom (right view)",
                    "hmd": "same as side except that view aspect ratio is not changed",
                    "ana": "standard color anaglyph (red for left view, green and blue for right view) is used (forces views=2)",
                    "cols": "images are interleaved by columns, left view on even columns and left view on odd columns (forces views=2)",
                    "rows": "images are interleaved by columns, left view on even rows and left view on odd rows (forces views=2)",
                    "spv5": "images are interleaved by for SpatialView 5 views display, fullscreen mode (forces views=5)",
                    "alio8": "images are interleaved by for Alioscopy 8 views displays, fullscreen mode (forces views=8)",
                    "custom": "images are interleaved according to the shader file indicated in mvshader. The shader is exposed each view as uniform sampler2D gfViewX, where X is the view number starting from the left"
                }
            },
            "mvshader": {
                "type": "str",
                "description": "file path to the custom multiview interleaving shader"
            },
            "fpack": {
                "type": "enum",
                "description": "default frame packing of input video",
                "default": "none",
                "enum": {
                    "none": "no frame packing",
                    "top": "top bottom frame packing",
                    "side": "side by side packing"
                }
            },
            "camlay": {
                "type": "enum",
                "description": "camera layout in multiview modes",
                "default": "offaxis",
                "enum": {
                    "straight": "camera is moved along a straight line, no rotation",
                    "offaxis": "off-axis projection is used",
                    "linear": "camera is moved along a straight line with rotation",
                    "circular": "camera is moved along a circle with rotation"
                }
            },
            "iod": {
                "type": "flt",
                "description": "inter-ocular distance (eye separation) in cm (distance between the cameras). ",
                "default": 6.4
            },
            "rview": {
                "type": "bool",
                "description": "reverse view order",
                "default": true
            },
            "dbgpack": {
                "type": "bool",
                "description": "view packed stereo video as single image (show all)",
                "default": true
            },
            "tvtn": {
                "type": "uint",
                "description": "number of point sampling for tile visibility algorithm",
                "default": 30
            },
            "tvtt": {
                "type": "uint",
                "description": "number of points above which the tile is considered visible",
                "default": 8
            },
            "tvtd": {
                "type": "enum",
                "description": "debug tiles and full coverage SRD",
                "default": "off",
                "enum": {
                    "off": "regular draw",
                    "partial": "only displaying partial tiles, not the full sphere video",
                    "full": "only display the full sphere video"
                }
            },
            "tvtf": {
                "type": "bool",
                "description": "force all tiles to be considered visible, regardless of viewpoint",
                "default": true
            },
            "fov": {
                "type": "flt",
                "description": "default field of view for VR",
                "default": 1.570796326794897
            },
            "vertshader": {
                "type": "str",
                "description": "path to vertex shader file"
            },
            "fragshader": {
                "type": "str",
                "description": "path to fragment shader file"
            },
            "autocal": {
                "type": "bool",
                "description": "auto calibration of znear/zfar in depth rendering mode",
                "default": true
            },
            "dispdepth": {
                "type": "sint",
                "description": "display depth, negative value uses default screen height",
                "default": "-1"
            },
            "dispdist": {
                "type": "flt",
                "description": "distance in cm between the camera and the zero-disparity plane. There is currently no automatic calibration of depth in GPAC",
                "default": 50.0
            },
            "focdist": {
                "type": "flt",
                "description": "distance of focus point",
                "default": 0.0
            },
            "osize": {
                "type": "v2di",
                "description": "force output size. If not set, size is derived from inputs",
                "default": "0x0"
            },
            "dpi": {
                "type": "v2di",
                "description": "default dpi if not indicated by video output",
                "default": "96x96"
            },
            "dbgpvr": {
                "type": "flt",
                "description": "debug scene used by PVR addon",
                "default": 0.0
            },
            "player": {
                "type": "enum",
                "description": "set compositor in player mode",
                "default": "no",
                "enum": {
                    "no": "regular mode",
                    "base": "player mode",
                    "gui": "player mode with GUI auto-start"
                }
            },
            "noaudio": {
                "type": "bool",
                "description": "disable audio output",
                "default": true
            },
            "opfmt": {
                "type": "pfmt",
                "description": "pixel format to use for output. Ignored in player mode",
                "default": "none"
            },
            "drv": {
                "type": "enum",
                "description": "indicate if graphics driver should be used",
                "default": "auto",
                "enum": {
                    "no": "never loads a graphics driver, software blit is used, no 3D possible (in player mode, disables OpenGL)",
                    "yes": "always loads a graphics driver, output pixel format will be RGB (in player mode, same as auto)",
                    "auto": "decides based on the loaded content"
                }
            },
            "src": {
                "type": "cstr",
                "description": "URL of source content"
            },
            "gaze_x": {
                "type": "sint",
                "description": "horizontal gaze coordinate (0=left, width=right)",
                "default": "0"
            },
            "gaze_y": {
                "type": "sint",
                "description": "vertical gaze coordinate (0=top, height=bottom)",
                "default": "0"
            },
            "gazer_enabled": {
                "type": "bool",
                "description": "enable gaze event dispatch",
                "default": true
            },
            "subtx": {
                "type": "sint",
                "description": "horizontal translation in pixels towards right for subtitles renderers",
                "default": "0"
            },
            "subty": {
                "type": "sint",
                "description": "vertical translation in pixels towards top for subtitles renderers",
                "default": "0"
            },
            "subfs": {
                "type": "uint",
                "description": "font size for subtitles renderers (0 means automatic)",
                "default": 0
            },
            "subd": {
                "type": "sint",
                "description": "subtitle delay in milliseconds for subtitles renderers",
                "default": "0"
            },
            "audd": {
                "type": "sint",
                "description": "audio delay in milliseconds",
                "default": "0"
            },
            "clipframe": {
                "type": "bool",
                "description": "visual output is clipped to bounding rectangle",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": [
                    "Audio",
                    "SceneDescription",
                    "ObjectDescriptor",
                    "File",
                    "Visual",
                    "Text"
                ]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "a52dec",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "mp4dmx",
        "description": "ISOBMFF/QT demultiplexer",
        "body": "This filter demultiplexes ISOBMF and QT files.\nInput ISOBMFF/QT can be regular or fragmented, and available as files or as raw bytestream.\n\nTrack Selection\n\nThe filter can use fragment identifiers of source to select a single track for playback. The allowed fragments are:\n\t * #audio: only use the first audio track\n\t * #video: only use the first video track\n\t * #auxv: only use the first auxiliary video track\n\t * #pict: only use the first picture track\n\t * #text: only use the first text track\n\t * #trackID=VAL: only use the track with given ID\n\t * #itemID=VAL: only use the item with given ID\n\t * #ID=VAL: only use the track/item with given ID\n\t * #VAL: only use the track/item with given ID\n\nScalable Tracks\n\nWhen scalable tracks are present in a file, the reader can operate in 3 modes using smode option:\n\t* smode=single: resolves all extractors to extract a single bitstream from a scalable set. The highest level is used\nIn this mode, there is no enhancement decoder config, only a base one resulting from the merge of the layers configurations\n\t* smode=split: all extractors are removed and every track of the scalable set is declared. In this mode, each enhancement track has no base decoder config\nand an enhancement decoder config.\n\t* smode=splitx: extractors are kept in the bitstream, and every track of the scalable set is declared. In this mode, each enhancement track has a base decoder config\n (copied from base) and an enhancement decoder config. This is mostly used for DASHing content.\n\nWarning: smode=splitx will result in extractor NAL units still present in the output bitstream, which shall only be true if the output is ISOBMFF based\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "local file name of source content (only used when explicitly loading the filter)"
            },
            "allt": {
                "type": "bool",
                "description": "load all tracks even if unknown media type",
                "default": true
            },
            "noedit": {
                "type": "bool",
                "description": "do not use edit lists",
                "default": true
            },
            "itt": {
                "type": "bool",
                "description": "convert all items of root meta into a single PID",
                "default": true
            },
            "itemid": {
                "type": "bool",
                "description": "keep item IDs in PID properties",
                "default": true
            },
            "smode": {
                "type": "enum",
                "description": "load mode for scalable/tile tracks",
                "default": "split",
                "enum": {
                    "split": "each track is declared, extractors are removed",
                    "splitx": "each track is declared, extractors are kept",
                    "single": "a single track is declared (highest level for scalable, tile base for tiling)"
                }
            },
            "alltk": {
                "type": "bool",
                "description": "declare disabled tracks",
                "default": true
            },
            "frame_size": {
                "type": "uint",
                "description": "frame size for raw audio samples (dispatches frame_size samples per packet)",
                "default": 1024
            },
            "expart": {
                "type": "bool",
                "description": "expose cover art as a dedicated video PID",
                "default": true
            },
            "sigfrag": {
                "type": "bool",
                "description": "signal fragment and segment boundaries of source on output packets",
                "default": true
            },
            "tkid": {
                "type": "str",
                "description": "declare only track based on given param",
                "enum": {
                    "integer value": "declares track with the given ID",
                    "audio": "declares first audio track",
                    "video": "declares first video track",
                    "4CC": "declares first track with matching 4CC for handler type"
                }
            },
            "stsd": {
                "type": "uint",
                "description": "only extract sample mapped to the given sample description index (0 means extract all)",
                "default": 0
            },
            "nocrypt": {
                "type": "bool",
                "description": "signal encrypted tracks as non encrypted (mostly used for export)"
            },
            "mstore_size": {
                "type": "uint",
                "description": "target buffer size in bytes when reading from memory stream (pipe etc...)",
                "default": 1000000
            },
            "mstore_purge": {
                "type": "uint",
                "description": "minimum size in bytes between memory purges when reading from memory stream, 0 means purge as soon as possible",
                "default": 50000
            },
            "mstore_samples": {
                "type": "uint",
                "description": "minimum number of samples to be present before purging sample tables when reading from memory stream (pipe etc...), 0 means purge as soon as possible",
                "default": 50
            },
            "strtxt": {
                "type": "bool",
                "description": "load text tracks (apple/tx3g) as MPEG-4 streaming text tracks",
                "default": true
            },
            "xps_check": {
                "type": "enum",
                "description": "parameter sets extraction mode from AVC/HEVC/VVC samples",
                "default": "auto",
                "enum": {
                    "keep": "do not inspect sample (assumes input file is compliant when generating DASH/HLS/CMAF)",
                    "rem": "removes all inband xPS and notify configuration changes accordingly",
                    "auto": "resolves to keep for smode=splix (dasher mode), rem otherwise"
                }
            },
            "nodata": {
                "type": "bool",
                "description": "do not load sample data",
                "default": true
            },
            "initseg": {
                "type": "str",
                "description": "local init segment name when input is a single ISOBMFF segment"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": [
                    "Audio",
                    "SceneDescription",
                    "ObjectDescriptor",
                    "File",
                    "Encrypted",
                    "Visual",
                    "Text",
                    "Metadata"
                ]
            }
        },
        "sources": [
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "mp4mx",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "fout",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "vobsubdmx",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pout",
            "gsfmx",
            "gsfdmx",
            "sockout",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "ttml2vtt",
            "ttml2srt",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "bifsdec",
        "description": "MPEG-4 BIFS decoder",
        "body": "This filter decodes MPEG-4 BIFS binary frames directly into the scene graph of the compositor.\nNote: This filter cannot be used to dump BIFS content to text or xml, use MP4Box for that.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-4 BIFS v1 Scene Description",
                    "MPEG-4 BIFS v2 Scene Description"
                ],
                "stream_type": ["SceneDescription"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["SceneDescription"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "compositor",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "odfdec",
        "description": "MPEG-4 OD decoder",
        "body": "This filter decodes MPEG-4 OD binary frames directly into the scene manager of the compositor.\nNote: This filter cannot be used to dump OD content to text or xml, use MP4Box for that.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-4 BIFS v1 Scene Description",
                    "MPEG-4 BIFS v2 Scene Description"
                ],
                "stream_type": ["ObjectDescriptor"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["ObjectDescriptor"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "compositor",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "fin",
        "description": "File input",
        "body": "This filter dispatch raw blocks from input file into a filter chain.\nBlock size can be adjusted using block_size.\nContent format can be forced through mime and file extension can be changed through ext.\nNote: Unless disabled at session level (see -no-probe ), file extensions are usually ignored and format probing is done on the first data block.\nThe special file name null is used for creating a file with no data, needed by some filters such as dasher.\nThe special file name rand is used to generate random data.\nThe special file name randsc is used to generate random data with 0x000001 start-code prefix.\n\nThe filter handles both files and GF_FileIO objects as input URL.\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "location of source file"
            },
            "block_size": {
                "type": "uint",
                "description": "block size used to read file. 0 means 5000 if file less than 500m, 1M otherwise",
                "default": 0
            },
            "range": {
                "type": "lfrac",
                "description": "byte range",
                "default": "0-0"
            },
            "ext": {
                "type": "cstr",
                "description": "override file extension"
            },
            "mime": {
                "type": "cstr",
                "description": "set file mime type"
            },
            "pck": {
                "type": "mem",
                "description": "data to use instead of file"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": []
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "dashin",
            "cdcrypt",
            "nhmlr",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            ""
        ]
    },
    {
        "name": "btplay",
        "description": "BT/XMT/X3D loader",
        "body": "This filter parses MPEG-4 BIFS (BT and XMT), VRML97 and X3D (wrl and XML) files directly into the scene graph of the compositor.\n\nWhen sax_dur=N is set, the filter will do a progressive load of the source and cancel current loading when processing time is higher than N.\n\n\n",
        "options": {
            "sax_dur": {
                "type": "uint",
                "description": "duration for SAX parsing (XMT), 0 disables SAX parsing",
                "default": 0
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["SceneDescription"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "compositor",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "httpin",
        "description": "HTTP input",
        "body": "This filter dispatch raw blocks from a remote HTTP resource into a filter chain.\nBlock size can be adjusted using block_size, and disk caching policies can be adjusted.\nContent format can be forced through mime and file extension can be changed through ext.\n\nThe filter supports both http and https schemes, and will attempt reconnecting as TLS if TCP connection fails.\n\nNote: Unless disabled at session level (see -no-probe ), file extensions are usually ignored and format probing is done on the first data block.\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "URL of source content"
            },
            "block_size": {
                "type": "uint",
                "description": "block size used to read file",
                "default": 100000
            },
            "cache": {
                "type": "enum",
                "description": "set cache mode",
                "default": "disk",
                "enum": {
                    "auto": "cache to disk if content length is known, no cache otherwise",
                    "disk": "cache to disk,  discard once session is no longer used",
                    "keep": "cache to disk and keep",
                    "mem": "stores to memory, discard once session is no longer used",
                    "mem_keep": "stores to memory, keep after session is reassigned but move to mem after first download",
                    "none": "no cache",
                    "none_keep": "stores to memory, keep after session is reassigned but move to none after first download"
                }
            },
            "range": {
                "type": "lfrac",
                "description": "set byte range, as fraction",
                "default": "0-0"
            },
            "ext": {
                "type": "cstr",
                "description": "override file extension"
            },
            "mime": {
                "type": "cstr",
                "description": "set file mime type"
            },
            "blockio": {
                "type": "bool",
                "description": "use blocking IO",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": []
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "dashin",
            "cdcrypt",
            "nhmlr",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            ""
        ]
    },
    {
        "name": "svgplay",
        "description": "SVG loader",
        "body": "This filter parses SVG files directly into the scene graph of the compositor.\n\nWhen sax_dur=N is set, the filter will do a progressive load of the source and cancel current loading when processing time is higher than N.\n\n\n",
        "options": {
            "sax_dur": {
                "type": "uint",
                "description": "loading duration for SAX parsing, 0 disables SAX parsing",
                "default": 0
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["3GPP DIMS Scene", "SVG over RTP", "SVG+gz over RTP"],
                "stream_type": ["File", "SceneDescription"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["SceneDescription"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "compositor",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rfimg",
        "description": "JPG/J2K/PNG/BMP reframer",
        "body": "This filter parses JPG/J2K/PNG/BMP files/data and outputs corresponding visual PID and frames.\n\nThe following extensions for PNG change the pixel format for RGBA images:\n\t* pngd: use RGB+depth map pixel format\n\t* pngds: use RGB+depth(7bits)+shape(MSB of alpha channel) pixel format\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["JPEG Image", "JPEG2000 Image", "Raw media", "PNG Image"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "imgdec",
            "j2kdec",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "imgdec",
        "description": "PNG/JPG decoder",
        "body": "This filter decodes JPEG and PNG images.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["JPEG Image", "PNG Image"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfimg",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "jpgenc",
            "pngenc",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "rfadts",
        "description": "ADTS reframer",
        "body": "This filter parses AAC files/data and outputs corresponding audio PID and frames.\n\n\n",
        "options": {
            "frame_size": {
                "type": "uint",
                "description": "size of AAC frame in audio samples",
                "default": 1024
            },
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            },
            "ovsbr": {
                "type": "bool",
                "description": "force oversampling SBR (does not multiply timescales by 2)",
                "default": true
            },
            "sbr": {
                "type": "enum",
                "description": "set SBR signaling",
                "default": "no",
                "enum": {
                    "no": "no SBR signaling at all",
                    "imp": "backward-compatible SBR signaling (audio signaled as AAC-LC)",
                    "exp": "explicit SBR signaling (audio signaled as AAC-SBR)"
                }
            },
            "ps": {
                "type": "enum",
                "description": "set PS signaling",
                "default": "no",
                "enum": {
                    "no": "no PS signaling at all",
                    "imp": "backward-compatible PS signaling (audio signaled as AAC-LC)",
                    "exp": "explicit PS signaling (audio signaled as AAC-PS)"
                }
            },
            "expart": {
                "type": "bool",
                "description": "expose pictures as a dedicated video PID",
                "default": true
            },
            "aacchcfg": {
                "type": "sint",
                "description": "set AAC channel configuration to this value if missing from ADTS header, use negative value to always override",
                "default": "0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-4 AAC Audio"],
                "stream_type": ["File", "Encrypted", "Audio"]
            },
            "output": {
                "codec_id": [
                    "MPEG-4 AAC Audio",
                    "MPEG-2 AAC Audio Main",
                    "MPEG-2 AAC Audio Low Complexity",
                    "MPEG-2 AAC Audio Scalable Sampling Rate"
                ],
                "stream_type": ["Encrypted", "Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rflatm",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "cecrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "ufadts",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "faad",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "uflatm",
            "ufadts",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rflatm",
        "description": "LATM reframer",
        "body": "This filter parses AAC in LATM files/data and outputs corresponding audio PID and frames.\n\n\n",
        "options": {
            "frame_size": {
                "type": "uint",
                "description": "size of AAC frame in audio samples",
                "default": 1024
            },
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-4 AAC Audio"],
                "stream_type": ["File", "Audio"]
            },
            "output": {
                "codec_id": [
                    "MPEG-4 AAC Audio",
                    "MPEG-2 AAC Audio Main",
                    "MPEG-2 AAC Audio Low Complexity",
                    "MPEG-2 AAC Audio Scalable Sampling Rate"
                ],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "uflatm",
            "ufadts",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "rfadts",
            "faad",
            "cecrypt",
            "mp4mx",
            "uflatm",
            "ufadts",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rfmp3",
        "description": "MP3 reframer",
        "body": "This filter parses MPEG-1/2 audio files/data and outputs corresponding audio PID and frames.\n\n\n",
        "options": {
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            },
            "expart": {
                "type": "bool",
                "description": "expose pictures as a dedicated video PID",
                "default": true
            },
            "forcemp3": {
                "type": "bool",
                "description": "force mp3 signaling for MPEG-2 Audio layer 3",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-1 Audio Layer 1", "MPEG-1 Audio", "MPEG-2 Audio"],
                "stream_type": ["File", "Audio"]
            },
            "output": {
                "codec_id": ["MPEG-1 Audio Layer 1", "MPEG-1 Audio", "MPEG-2 Audio"],
                "stream_type": ["File", "Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "maddec",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "vobsubdmx",
            "avimx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "m2tsmx",
            "dasher",
            "pout",
            "gsfmx",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "rtspout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "faad",
        "description": "FAAD decoder",
        "body": "This filter decodes AAC streams through faad library.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-4 AAC Audio",
                    "MPEG-2 AAC Audio Main",
                    "MPEG-2 AAC Audio Low Complexity",
                    "MPEG-2 AAC Audio Scalable Sampling Rate"
                ],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfadts",
            "rflatm",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "maddec",
        "description": "MAD decoder",
        "body": "This filter decodes MPEG 1/2 audio streams through libmad library.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-1 Audio Layer 1", "MPEG-1 Audio", "MPEG-2 Audio"],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfmp3",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "xviddec",
        "description": "XVid decoder",
        "body": "This filter decodes MPEG-4 part 2 (and DivX) through libxvidcore library.\n\n\n",
        "options": {
            "deblock_y": {
                "type": "bool",
                "description": "enable Y deblocking",
                "default": true
            },
            "deblock_uv": {
                "type": "bool",
                "description": "enable UV deblocking",
                "default": true
            },
            "film_effect": {
                "type": "bool",
                "description": "enable film effect",
                "default": true
            },
            "dering_y": {
                "type": "bool",
                "description": "enable Y deblocking",
                "default": true
            },
            "dering_uv": {
                "type": "bool",
                "description": "enable UV deblocking",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-4 Visual part 2"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "j2kdec",
        "description": "OpenJPEG2000 decoder",
        "version": "2.x",
        "body": "This filter decodes JPEG2000 streams through OpenJPEG2000 library.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["JPEG2000 Image"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfimg",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "rfac3",
        "description": "AC3 reframer",
        "body": "This filter parses AC3 and E-AC3 files/data and outputs corresponding audio PID and frames.\n\n\n",
        "options": {
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Enhanced AC3 Audio", "AC3 Audio"],
                "stream_type": ["File", "Encrypted", "Audio"]
            },
            "output": {
                "codec_id": ["Enhanced AC3 Audio", "AC3 Audio"],
                "stream_type": ["Encrypted", "Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "cecrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "a52dec",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "a52dec",
        "description": "A52 decoder",
        "body": "This filter decodes AC3 streams through a52dec library.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["AC3 Audio"],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfac3",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "rfamr",
        "description": "AMR/EVRC reframer",
        "body": "This filter parses AMR, AMR Wideband, EVRC and SMV files/data and outputs corresponding audio PID and frames.\n\n\n",
        "options": {
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["AMR Audio", "SMV Voice", "AMR WideBand Audio", "EVRC Voice"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "oggdmx",
        "description": "OGG demultiplexer",
        "body": "This filter demultiplexes OGG files/data into a set of media PIDs and frames.\n\n\n",
        "options": {
            "index": {
                "type": "dbl",
                "description": "indexing window length (not implemented), use 0 to disable stream probing for duration), ",
                "default": "1.0"
            },
            "expart": {
                "type": "bool",
                "description": "expose pictures as a dedicated video PID",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [
                    "Vorbis Audio",
                    "Flac Audio",
                    "Opus Audio",
                    "Theora Video",
                    "Speex Audio"
                ],
                "stream_type": ["File", "Audio", "Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "vobsubdmx",
            "avimx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "m2tsmx",
            "dasher",
            "pout",
            "gsfmx",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "rtspout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "vorbisdec",
        "description": "Vorbis decoder",
        "body": "This filter decodes Vorbis streams through libvorbis library.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Vorbis Audio"],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "theoradec",
        "description": "Theora decoder",
        "body": "This filter decodes Theora streams through libtheora library.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Theora Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "m2tsdmx",
        "description": "MPEG-2 TS demultiplexer",
        "body": "This filter demultiplexes MPEG-2 Transport Stream files/data into a set of media PIDs and frames.\n\n\n",
        "options": {
            "temi_url": {
                "type": "cstr",
                "description": "force TEMI URL"
            },
            "dsmcc": {
                "type": "bool",
                "description": "enable DSMCC receiver",
                "default": true
            },
            "seeksrc": {
                "type": "bool",
                "description": "seek local source file back to origin once all programs are setup",
                "default": true
            },
            "sigfrag": {
                "type": "bool",
                "description": "signal segment boundaries on output packets for DASH or HLS sources",
                "default": true
            },
            "dvbtxt": {
                "type": "bool",
                "description": "export DVB teletext streams",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": [
                    "Audio",
                    "SceneDescription",
                    "ObjectDescriptor",
                    "Encrypted",
                    "Visual",
                    "Text",
                    "Metadata",
                    "Unknown"
                ]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "rtpin",
            "writegen",
            "m2tsmx",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "tssplit",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "bifsdec",
            "odfdec",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "ufm4v",
            "ufvc1",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdec",
            "ffmx",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "sockin",
        "description": "UDP/TCP input",
        "body": "This filter handles generic TCP and UDP input sockets. It can also probe for MPEG-2 TS over RTP input. Probing of MPEG-2 TS over UDP/RTP is enabled by default but can be turned off.\n\nData format can be specified by setting either ext or mime options. If not set, the format will be guessed by probing the first data packet\n\n- UDP sockets are used for source URLs formatted as udp://NAME\n- TCP sockets are used for source URLs formatted as tcp://NAME\n- UDP unix domain sockets are used for source URLs formatted as udpu://NAME\n- TCP unix domain sockets are used for source URLs formatted as tcpu://NAME\n\nWhen ports are specified in the URL and the default option separators are used (see gpac -h doc), the URL must either:\n- have a trailing '/', e.g. udp://localhost:1234/[:opts]\n- use gpac separator, e.g. udp://localhost:1234[:gpac:opts]\n\nOn OSX with VM packet replay you will need to force multicast routing, e.g. route add -net 239.255.1.4/32 -interface vboxnet0\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "address of source content"
            },
            "block_size": {
                "type": "uint",
                "description": "block size used to read socket",
                "default": "0x60000"
            },
            "port": {
                "type": "uint",
                "description": "default port if not specified",
                "default": 1234
            },
            "ifce": {
                "type": "cstr",
                "description": "default multicast interface"
            },
            "listen": {
                "type": "bool",
                "description": "indicate the input socket works in server mode",
                "default": true
            },
            "ka": {
                "type": "bool",
                "description": "keep socket alive if no more connections",
                "default": true
            },
            "maxc": {
                "type": "uint",
                "description": "max number of concurrent connections",
                "default": "+I"
            },
            "tsprobe": {
                "type": "bool",
                "description": "probe for MPEG-2 TS data, either RTP or raw UDP. Disabled if mime or ext are given and do not match MPEG-2 TS mimes/extensions",
                "default": true
            },
            "ext": {
                "type": "str",
                "description": "indicate file extension of udp data"
            },
            "mime": {
                "type": "str",
                "description": "indicate mime type of udp data"
            },
            "block": {
                "type": "bool",
                "description": "set blocking mode for socket(s)",
                "default": true
            },
            "timeout": {
                "type": "uint",
                "description": "set timeout in ms for UDP socket(s), 0 to disable timeout",
                "default": 10000
            },
            "reorder_pck": {
                "type": "uint",
                "description": "number of packets delay for RTP reordering (M2TS over RTP) ",
                "default": 100
            },
            "reorder_delay": {
                "type": "uint",
                "description": "number of ms delay for RTP reordering (M2TS over RTP)",
                "default": 10
            },
            "ssm": {
                "type": "strl",
                "description": "list of IP to include for source-specific multicast"
            },
            "ssmx": {
                "type": "strl",
                "description": "list of IP to exclude for source-specific multicast"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": []
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "dashin",
            "cdcrypt",
            "nhmlr",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            ""
        ]
    },
    {
        "name": "dvbin",
        "description": "DVB for Linux",
        "body": "Warning: DVB4Linux NOT AVAILABLE IN THIS BUILD !\n\n\nExperimental DVB support for linux, requires a channel config file through chcfg\n  \nThe URL syntax is dvb://CHANNAME[@FRONTEND], with:\n\t * CHANNAME: the channel name as listed in the channel config file\n\t * frontend: the index of the DVB adapter to use (optional, default is 0)\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "URL of source content"
            },
            "block_size": {
                "type": "uint",
                "description": "block size used to read file",
                "default": 65536
            },
            "chcfg": {
                "type": "cstr",
                "description": "path to channels.conf file"
            }
        }
    },
    {
        "name": "osvcdec",
        "description": "OpenSVC decoder",
        "body": "This filter decodes scalable AVC|H264 streams through OpenSVC library.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-4 AVC|H264 Scalable Video Coding", "MPEG-4 AVC|H264 Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "vtbdec",
        "description": "VideoToolBox decoder",
        "body": "This filter decodes video streams through OSX/iOS VideoToolBox (MPEG-2, H263, AVC|H264, HEVC, ProRes). It allows GPU frame dispatch or direct frame copy.\n\n\n",
        "options": {
            "reorder": {
                "type": "uint",
                "description": "number of frames to wait for temporal re-ordering",
                "default": 6
            },
            "no_copy": {
                "type": "bool",
                "description": "dispatch decoded frames as OpenGL textures (true) or as copied packets (false) ",
                "default": true
            },
            "ofmt": {
                "type": "pfmt",
                "description": "set default pixel format for decoded video. If not found, fall back to nv12",
                "default": "nv12"
            },
            "disable_hw": {
                "type": "bool",
                "description": "disable hardware decoding",
                "default": true
            },
            "wait_sync": {
                "type": "bool",
                "description": "wait for sync frame before decoding",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-2 Visual Main",
                    "MPEG-4 Visual part 2",
                    "ProRes Video 4444 XQ",
                    "ProRes Video 4444",
                    "MPEG-2 Visual High",
                    "ProRes Video 422 HQ",
                    "ProRes Video 422 Proxy",
                    "MPEG-2 Visual SNR",
                    "ProRes Video 422 LT",
                    "H263 Video",
                    "MPEG-2 Visual 422",
                    "MPEG-2 Visual Spatial",
                    "MPEG-2 Visual Simple",
                    "MPEG-4 AVC|H264 Video",
                    "ProRes Video 422 STD",
                    "HEVC Video"
                ],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "hevcsplit",
            "hevcmerge",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "mcdec",
        "description": "MediaCodec decoder",
        "body": "Warning: MediaCodec SDK NOT AVAILABLE IN THIS BUILD !\n\n\nThis filter decodes video streams using hardware decoder on android devices\n\n\n",
        "options": {
            "disable_gl": {
                "type": "bool",
                "description": "disable OpenGL texture transfer",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-4 AVC|H264 Video", "HEVC Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "lsrdec",
        "description": "MPEG-4 LASeR decoder",
        "body": "This filter decodes MPEG-4 LASeR binary frames directly into the scene graph of the compositor.\nNote: This filter cannot be used to dump LASeR content to text or xml, use MP4Box for that.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-4 LASeR"],
                "stream_type": ["SceneDescription"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["SceneDescription"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "compositor",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "safdmx",
        "description": "SAF demultiplexer",
        "body": "This filter demultiplexes SAF (MPEG-4 Simple Aggregation Format for LASeR) files/data into a set of media PIDs and frames.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["Audio", "Visual", "SceneDescription"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "dashin",
        "description": "MPEG-DASH and HLS client",
        "body": "This filter reads MPEG-DASH, HLS and MS Smooth manifests.\n\nRegular mode\n\nThis is the default mode, in which the filter produces media PIDs and frames from sources indicated in the manifest.\nThe default behavior is to perform adaptation according to algo, but the filter can:\n- run with no adaptation, to grab maximum quality.\nExample:\ngpac -i MANIFEST_URL:algo=none:start_with=max_bw -o dest.mp4\n- run with no adaptation, fetching all qualities.\nExample:\ngpac -i MANIFEST_URL:split_as -o dst=$File$.mp4:clone\n\nFile mode\n\nWhen forward is set to file, the client forwards media files without demultiplexing them.\nThis is mostly used to expose the DASH session to a file server such as ROUTE or HTTP.\nIn this mode, the manifest is forwarded as an output PID.\n\nWarning: This mode cannot be set through inheritance as it changes the link capabilities of the filter. The filter MUST be explicitly declared.\n\nTo expose a live DASH session to route:\nExample:\ngpac -i MANIFEST_URL dashin:forward=file -o route://225.0.0.1:8000/\n\nIf the source has dependent media streams (scalability) and all qualities and initialization segments need to be forwarded, add split_as.\n\nSegment bound modes\n\nWhen forward is set to segb or mani, the client forwards media frames (after demultiplexing) together with segment and fragment boundaries of source files.\n\nThis mode can be used to process media data and regenerate the same manifest/segmentation.\n\nExample:\ngpac -i MANIFEST_URL:forward=mani cecrypt:cfile=DRM.xml -o encrypted/live.mpd:pssh=mv\nThis will encrypt an existing DASH session, inject PSSH in manifest and segments.\n\nExample:\ngpac -i MANIFEST_URL:forward=segb cecrypt:cfile=DRM.xml -o encrypted/live.m3u8\nThis will encrypt an existing DASH session and republish it as HLS, using same segment names and boundaries.\n\nThis mode will force noseek=true to ensure the first segment fetched is complete, and split_as=true to fetch all qualities.\n\nEach first packet of a segment will have the following properties attached:\n\t* `CueStart`: indicate this is a segment start\n\t* `FileNumber`: current segment number\n\t* `FileName`: current segment file name without manifest (MPD or master HLS) base url\n\t* `DFPStart`: set with value 0 if this is the first packet in the period, absent otherwise\n\nIf forward is set to mani, the first packet of a segment dispatched after a manifest update will also carry the manifest payload as a property:\n\t* `DFManifest`: contains main manifest (MPD, M3U8 master)\n\t* `DFVariant`: contains list of HLS child playlists as strings for the given quality\n\t* `DFVariantName`: contains list of associated HLS child playlists name, in same order as manifests in DFVariant\n\nEach output PID will have the following properties assigned:\n\t* `DFMode`: set to 1 for segb or 2 for mani\n\t* `DCue`: set to inband\n\t* `DFPStart`: set to current period start value\n\t* `FileName`: set to associated init segment if any\n\t* `Representation`: set to the associated representation ID in the manifest\n\t* `DashDur`: set to the average segment duration as indicated in the manifest\n\t* `source_template`: set to true to indicate the source template is known\n\t* `stl_timescale`: timescale used by SegmentTimeline, or 0 if no SegmentTimeline\n\t* `init_url`: unresolved intialization URL (as it appears in the MPD or in the variant playlist)\n\t* `manifest_url`: manifest URL\n\t* `hls_variant_name`: HLS variant playlist name (as it appears in the HLS master playlist)\n\nWhen the dasher is used together with this mode, this will force all generated segments to have the same name, duration and fragmentation properties as the input ones. It is therefore not recommended for sessions stored/generated on local storage to generate the output in the same directory.\n\n\n",
        "options": {
            "auto_switch": {
                "type": "sint",
                "description": "switch quality every N segments",
                "default": "0",
                "enum": {
                    "positive": "go to higher quality or loop to lowest",
                    "negative": "go to lower quality or loop to highest",
                    "0": "disabled"
                }
            },
            "segstore": {
                "type": "enum",
                "description": "enable file caching",
                "default": "mem",
                "enum": {
                    "mem": "all files are stored in memory, no disk IO",
                    "disk": "files are stored to disk but discarded once played",
                    "cache": "all files are stored to disk and kept"
                }
            },
            "algo": {
                "type": "str",
                "description": "adaptation algorithm to use",
                "default": "gbuf",
                "enum": {
                    "none": "no adaptation logic",
                    "grate": "GPAC legacy algo based on available rate",
                    "gbuf": "GPAC legacy algo based on buffer occupancy",
                    "bba0": "BBA-0",
                    "bolaf": "BOLA Finite",
                    "bolab": "BOLA Basic",
                    "bolau": "BOLA-U",
                    "bolao": "BOLA-O",
                    "JS": "use file JS (either with specified path or in $GSHARE/scripts/) for algo (.js extension may be omitted)"
                }
            },
            "start_with": {
                "type": "enum",
                "description": "initial selection criteria",
                "default": "max_bw",
                "enum": {
                    "min_q": "start with lowest quality",
                    "max_q": "start with highest quality",
                    "min_bw": "start with lowest bitrate",
                    "max_bw": "start with highest bitrate; if tiles are used, all low priority tiles will have the lower (below max) bandwidth selected",
                    "max_bw_tiles": "start with highest bitrate; if tiles are used, all low priority tiles will have their lowest bandwidth selected"
                }
            },
            "max_res": {
                "type": "bool",
                "description": "use max media resolution to configure display",
                "default": true
            },
            "abort": {
                "type": "bool",
                "description": "allow abort during a segment download",
                "default": true
            },
            "use_bmin": {
                "type": "enum",
                "description": "playout buffer handling",
                "default": "auto",
                "enum": {
                    "no": "use default player settings",
                    "auto": "notify player of segment duration if not low latency",
                    "mpd": "use the indicated min buffer time of the MPD"
                }
            },
            "shift_utc": {
                "type": "sint",
                "description": "shift DASH UTC clock in ms",
                "default": "0"
            },
            "spd": {
                "type": "sint",
                "description": "suggested presentation delay in ms",
                "default": "-I"
            },
            "route_shift": {
                "type": "sint",
                "description": "shift ROUTE requests time by given ms",
                "default": "0"
            },
            "server_utc": {
                "type": "bool",
                "description": "use ServerUTC or Date HTTP headers instead of local UTC",
                "default": true
            },
            "screen_res": {
                "type": "bool",
                "description": "use screen resolution in selection phase",
                "default": true
            },
            "init_timeshift": {
                "type": "sint",
                "description": "set initial timeshift in ms (if >0) or in per-cent of timeshift buffer (if <0)",
                "default": "0"
            },
            "tile_mode": {
                "type": "enum",
                "description": "tile adaptation mode",
                "default": "none",
                "enum": {
                    "none": "bitrate is shared equally across all tiles",
                    "rows": "bitrate decreases for each row of tiles starting from the top, same rate for each tile on the row",
                    "rrows": "bitrate decreases for each row of tiles starting from the bottom, same rate for each tile on the row",
                    "mrows": "bitrate decreased for top and bottom rows only, same rate for each tile on the row",
                    "cols": "bitrate decreases for each columns of tiles starting from the left, same rate for each tile on the columns",
                    "rcols": "bitrate decreases for each columns of tiles starting from the right, same rate for each tile on the columns",
                    "mcols": "bitrate decreased for left and right columns only, same rate for each tile on the columns",
                    "center": "bitrate decreased for all tiles on the edge of the picture",
                    "edges": "bitrate decreased for all tiles on the center of the picture"
                }
            },
            "tiles_rate": {
                "type": "uint",
                "description": "indicate the amount of bandwidth to use at each quality level. The rate is recursively applied at each level, e.g. if 50%, Level1 gets 50%, level2 gets 25%, ... If 100, automatic rate allocation will be done by maximizing the quality in order of priority. If 0, bitstream will not be smoothed across tiles/qualities, and concurrency may happen between different media",
                "default": 100
            },
            "delay40X": {
                "type": "uint",
                "description": "delay in milliseconds to wait between two 40X on the same segment",
                "default": 500
            },
            "exp_threshold": {
                "type": "uint",
                "description": "delay in milliseconds to wait after the segment AvailabilityEndDate before considering the segment lost",
                "default": 100
            },
            "switch_count": {
                "type": "uint",
                "description": "indicate how many segments the client shall wait before switching up bandwidth. If 0, switch will happen as soon as the bandwidth is enough, but this is more prone to network variations",
                "default": 1
            },
            "aggressive": {
                "type": "bool",
                "description": "if enabled, switching algo targets the closest bandwidth fitting the available download rate. If no, switching algo targets the lowest bitrate representation that is above the currently played (e.g. does not try to switch to max bandwidth)",
                "default": true
            },
            "debug_as": {
                "type": "uintl",
                "description": "play only the adaptation sets indicated by their indices (0-based) in the MPD"
            },
            "speedadapt": {
                "type": "bool",
                "description": "enable adaptation based on playback speed",
                "default": true
            },
            "noxlink": {
                "type": "bool",
                "description": "disable xlink if period has both xlink and adaptation sets",
                "default": true
            },
            "query": {
                "type": "str",
                "description": "set query string (without initial '?') to append to xlink of periods"
            },
            "split_as": {
                "type": "bool",
                "description": "separate all qualities into different adaptation sets and stream all qualities. Dependent representations (scalable) are treated as independent",
                "default": true
            },
            "noseek": {
                "type": "bool",
                "description": "disable seeking of initial segment(s) in dynamic mode (useful when UTC clocks do not match)",
                "default": true
            },
            "bwcheck": {
                "type": "uint",
                "description": "minimum time in milliseconds between two bandwidth checks when allowing segment download abort",
                "default": 5
            },
            "lowlat": {
                "type": "enum",
                "description": "segment scheduling policy in low latency mode",
                "default": "early",
                "enum": {
                    "no": "disable low latency",
                    "strict": "strict respect of AST offset in low latency",
                    "early": "allow fetching segments earlier than their AST in low latency when input PID is empty"
                }
            },
            "forward": {
                "type": "enum",
                "description": "segment forwarding mode",
                "default": "none",
                "enum": {
                    "none": "regular DASH read",
                    "file": "do not demultiplex files and forward them as file PIDs (imply segstore=mem)",
                    "segb": "turn on split_as, segment and fragment bounds signaling (sigfrag) in sources and DASH cue insertion",
                    "mani": "same as segb and also forward manifests"
                }
            },
            "fmodefwd": {
                "type": "bool",
                "description": "forward packet rather than copy them in file forward mode. Packet copy might improve performances in low latency mode",
                "default": true
            },
            "skip_lqt": {
                "type": "bool",
                "description": "disable decoding of tiles with highest degradation hints (not visible, not gazed at) for debug purposes",
                "default": true
            },
            "llhls_merge": {
                "type": "bool",
                "description": "merge LL-HLS byte range parts into a single open byte range request",
                "default": true
            },
            "groupsel": {
                "type": "bool",
                "description": "select groups based on language (by default all playable groups are exposed)",
                "default": true
            },
            "chain_mode": {
                "type": "enum",
                "description": "MPD chaining mode",
                "default": "on",
                "enum": {
                    "off": "do not use MPD chaining",
                    "on": "use MPD chaining once over, fallback if MPD load failure",
                    "error": "use MPD chaining once over or if error (MPD or segment download)"
                }
            },
            "asloop": {
                "type": "bool",
                "description": "when auto switch is enabled, iterates back and forth from highest to lowest qualities",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["File", "Audio", "Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "cdcrypt",
            "cecrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "fin",
            "httpin",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "cdcrypt",
        "description": "CENC decryptor",
        "body": "The CENC decryptor supports decrypting CENC, ISMA, HLS Sample-AES (MPEG2 ts) and Adobe streams.\n\nFor HLS, key is retrieved according to the key URI in the manifest.\nOtherwise, the filter uses a configuration file.\nThe syntax is available at https://wiki.gpac.io/Common-Encryption\nThe DRM config file can be set per PID using the property DecryptInfo (highest priority), CryptInfo (lower priority) or set at the filter level using cfile (lowest priority).\nWhen the file is set per PID, the first CryptInfo with the same ID is used, otherwise the first CryptInfo is used.When the file is set globally (not per PID), the first CrypTrack in the DRM config file with the same ID is used, otherwise the first CrypTrack with ID 0 or not set is used.\n\n\n",
        "options": {
            "cfile": {
                "type": "str",
                "description": "crypt file location"
            },
            "decrypt": {
                "type": "enum",
                "description": "decrypt mode (CENC only)",
                "default": "full",
                "enum": {
                    "full": "decrypt everything, throwing error if keys are not found",
                    "nokey": "decrypt everything for which a key is found, skip decryption otherwise",
                    "skip": "decrypt nothing"
                }
            },
            "drop_keys": {
                "type": "uintl",
                "description": "consider keys with given 1-based indexes as not available (multi-key debug)"
            },
            "kids": {
                "type": "strl",
                "description": "define KIDs. If keys is empty, consider keys with given KID (as hex string) as not available (debug)"
            },
            "keys": {
                "type": "strl",
                "description": "define key values for each of the specified KID"
            },
            "hls_cenc_patch_iv": {
                "type": "bool",
                "description": "ignore IV updates in some broken HLS+CENC streams",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["Encrypted"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File", "Encrypted"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfadts",
            "rfac3",
            "m2tsdmx",
            "dashin",
            "cecrypt",
            "nhmlr",
            "rfnalu",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "fin",
            "httpin",
            "svgplay",
            "imgdec",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cecrypt",
            "mp4mx",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfmx",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "restamp",
            "oggmx",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "cecrypt",
        "description": "CENC  encryptor",
        "body": "The CENC encryptor supports CENC, ISMA and Adobe encryption. It uses a DRM config file for declaring keys.\nThe syntax is available at https://wiki.gpac.io/Common-Encryption\nThe DRM config file can be set per PID using the property CryptInfo, or set at the filter level using cfile.\nWhen the DRM config file is set per PID, the first CrypTrack in the DRM config file with the same ID is used, otherwise the first CrypTrack is used (regardless of the CrypTrack ID).\nWhen the DRM config file is set globally (not per PID), the first CrypTrack in the DRM config file with the same ID is used, otherwise the first CrypTrack with ID 0 or not set is used.\nIf no DRM config file is defined for a given PID, this PID will not be encrypted, or an error will be thrown if allc is specified.\n\n\n",
        "options": {
            "cfile": {
                "type": "str",
                "description": "crypt file location"
            },
            "allc": {
                "type": "bool",
                "description": "throw error if no DRM config file is found for a PID"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["File", "Encrypted"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Encrypted"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "reframer",
            "vobsubdmx",
            "jpgenc",
            "pngenc",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "rfadts",
            "rfac3",
            "dashin",
            "cdcrypt",
            "mp4mx",
            "rfnalu",
            "reframer",
            "writegen",
            "ufnalu",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "mp4mx",
        "description": "ISOBMFF/QT multiplexer",
        "body": "This filter multiplexes streams to ISOBMFF (14496-12 and derived specifications) or QuickTime\n  \n\nTracks and Items\n\nBy default all input PIDs with ItemID property set are multiplexed as items, otherwise they are multiplexed as tracks.\nTo prevent source items to be multiplexed as items, use -itemid option from ISOBMFF demultiplexer.\nExample:\ngpac -i source.mp4:itemid=false -o file.mp4\n  \nTo force non-item streams to be multiplexed as items, use #ItemID option on that PID:\nExample:\ngpac -i source.jpg:#ItemID=1 -o file.mp4\n  \n\nStorage\n\nThe store option allows controlling if the file is fragmented or not, and when not fragmented, how interleaving is done. For cases where disk requirements are tight and fragmentation cannot be used, it is recommended to use either flat or fstart modes.\n  \nThe vodcache option allows controlling how DASH onDemand segments are generated:\n- If set to on, file data is stored to a temporary file on disk and flushed upon completion, no padding is present.\n- If set to insert, SIDX/SSIX will be injected upon completion of the file by shifting bytes in file. In this case, no padding is required but this might not be compatible with all output sinks and will take longer to write the file.\n- If set to replace, SIDX/SSIX size will be estimated based on duration and DASH segment length, and padding will be used in the file before the final SIDX. If input PIDs have the properties DSegs set, this will used be as the number of segments.\nThe on and insert modes will produce exactly the same file, while the mode replace may inject a free box before the sidx.\n  \n\nCustom boxes\n\nCustom boxes can be specified as box patches:\nFor movie-level patch, the boxpatch option of the filter should be used.\nPer PID box patch can be specified through the PID property boxpatch.\nExample:\ngpac -i source:#boxpatch=myfile.xml -o mux.mp4\nPer Item box patch can be specified through the PID property boxpatch.\nExample:\ngpac -i source:1ItemID=1:#boxpatch=myfile.xml -o mux.mp4\n  \nThe box patch is applied before writing the initial moov box in fragmented mode, or when writing the complete file otherwise.\nThe box patch can either be a filename or the full XML string.\n  \n\nTagging\n\nWhen tagging is enabled, the filter will watch the property CoverArt and all custom properties on incoming PID.\nThe built-in tag names are indicated by MP4Box -h tags.\nQT tags can be specified using qtt_NAME property names, and will be added using formatting specified in MP4Box -h tags.\nOther tag class may be specified using tag_NAME property names, and will be added if tags is set to all using:\n- NAME as a box 4CC if NAME is four characters long\n- NAME as a box 4CC if NAME is 3 characters long, and will be prefixed by 0xA9\n- the CRC32 of the NAME as a box 4CC if NAME is not four characters long\n  \n\nUser data\n\nThe filter will look for the following PID properties to create user data entries:\n\t* `udtab`: set the track user-data box to the property value which must be a serialized box array blob\n\t* `mudtab`: set the movie user-data box to the property value which must be a serialized box array blob\n\t* `udta_U4CC`: set track user-data box entry of type U4CC to property value\n\t* `mudta_U4CC`: set movie user-data box entry of type U4CC to property value\n  \nExample:\ngpac -i src.mp4:#udta_tagc='My Awesome Tag' -o tag.mp4\ngpac -i src.mp4:#mudtab=data@box.bin -o tag.mp4\n  \n\nCustom sample group descriptions and sample auxiliary info\n\nThe filter watches the following custom data properties on incoming packets:\n\t* `grp_A4CC`: maps packet to sample group description of type A4CC and entry set to property payload\n\t* `grp_A4CC_param`: same as above and sets sample to group grouping_type_parameter to param\n\t* `sai_A4CC`: adds property payload as sample auxiliary information of type A4CC\n\t* `sai_A4CC_param`: same as above and sets aux_info_type_parameterto param\n  \nThe property grp_EMSG consists in one or more EventMessageBox as defined in MPEG-DASH.\n- in fragmented mode, presence of these boxes in a packet will start a new fragment, with the boxes written before the moof\n- in regular mode, an internal sample group of type EMSG is currently used for emsg box storage\n  \n\nNotes\n\nThe filter watches the property FileNumber on incoming packets to create new files (regular mode) or new segments (DASH mode).\n  \nThe filter watches the property DSIWrap (4CC as int or string) on incoming PID to wrap decoder configuration in a box of given type (unknown wrapping)\nExample:\n-i unkn.mkv:#ISOMSubtype=VIUK:#DSIWrap=cfgv -o t.mp4\nThis will wrap the unknown stream using VIUK code point in stsd and wrap any decoder configuration data in a cfgv box.\n\nIf pad_sparse is set, the filter watches the property Sparse on incoming PID to decide whether empty packets should be injected to keep packet duration info.\nSuch packets are only injected when a whole in the timeline is detected.\n- if Sparse is absent, empty packet is inserted for unknown text and metadata streams\n- if Sparse is true, empty packet is inserted for all stream types\n- if Sparse is false, empty packet is never injected\n\n\n",
        "options": {
            "m4sys": {
                "type": "bool",
                "description": "force MPEG-4 Systems signaling of tracks",
                "default": true
            },
            "dref": {
                "type": "bool",
                "description": "only reference data from source file - not compatible with all media sources",
                "default": true
            },
            "ctmode": {
                "type": "enum",
                "description": "set composition offset mode for video tracks",
                "default": "edit",
                "enum": {
                    "edit": "uses edit lists to shift first frame to presentation time 0",
                    "noedit": "ignore edit lists and does not shift timeline",
                    "negctts": "uses ctts v1 with possibly negative offsets and no edit lists"
                }
            },
            "dur": {
                "type": "frac",
                "description": "only import the specified duration. If negative, specify the number of coded frames to import",
                "default": "0"
            },
            "pack3gp": {
                "type": "uint",
                "description": "pack a given number of 3GPP audio frames in one sample",
                "default": 1
            },
            "importer": {
                "type": "bool",
                "description": "compatibility with old importer, displays import progress",
                "default": true
            },
            "pack_nal": {
                "type": "bool",
                "description": "repack NALU size length to minimum possible size for NALU-based video (AVC/HEVC/...)",
                "default": true
            },
            "xps_inband": {
                "type": "enum",
                "description": "use inband (in sample data) parameter set for NALU-based video (AVC/HEVC/...)",
                "default": "no",
                "enum": {
                    "no": "parameter sets are not inband, several sample descriptions might be created",
                    "pps": "picture parameter sets are inband, all other parameter sets are in sample description",
                    "all": "parameter sets are inband, no parameter sets in sample description",
                    "both": "parameter sets are inband, signaled as inband, and also first set is kept in sample description",
                    "mix": "creates non-standard files using single sample entry with first PSs found, and moves other PS inband",
                    "auto": "keep source config, or defaults to no if source is not ISOBMFF"
                }
            },
            "store": {
                "type": "enum",
                "description": "file storage mode",
                "default": "inter",
                "enum": {
                    "inter": "perform precise interleave of the file using cdur (requires temporary storage of all media)",
                    "flat": "write samples as they arrive and moov at end (fastest mode)",
                    "fstart": "write samples as they arrive and moov before mdat",
                    "tight": "uses per-sample interleaving of all tracks (requires temporary storage of all media)",
                    "frag": "fragments the file using cdur duration",
                    "sfrag": "fragments the file using cdur duration but adjusting to start with SAP1/3"
                }
            },
            "cdur": {
                "type": "frac",
                "description": "chunk duration for flat and interleaving modes or fragment duration for fragmentation modes",
                "default": "-1/1",
                "enum": {
                    "0": "no specific interleaving but moov first",
                    "negative": "defaults to 1.0 unless overridden by storage profile"
                }
            },
            "moovts": {
                "type": "sint",
                "description": "timescale to use for movie. A negative value picks the media timescale of the first track added",
                "default": "600"
            },
            "moof_first": {
                "type": "bool",
                "description": "generate fragments starting with moof then mdat",
                "default": true
            },
            "abs_offset": {
                "type": "bool",
                "description": "use absolute file offset in fragments rather than offsets from moof",
                "default": true
            },
            "fsap": {
                "type": "bool",
                "description": "split truns in video fragments at SAPs to reduce file size",
                "default": true
            },
            "subs_sidx": {
                "type": "sint",
                "description": "number of subsegments per sidx. negative value disables sidx, -2 removes sidx if present in source PID",
                "default": "-1"
            },
            "m4cc": {
                "type": "str",
                "description": "4 character code of empty box to append at the end of a segment"
            },
            "chain_sidx": {
                "type": "bool",
                "description": "use daisy-chaining of SIDX",
                "default": true
            },
            "msn": {
                "type": "uint",
                "description": "sequence number of first moof to N",
                "default": 1
            },
            "msninc": {
                "type": "uint",
                "description": "sequence number increase between moof boxes",
                "default": 1
            },
            "tfdt": {
                "type": "lfrac",
                "description": "set initial decode time (tfdt) of first traf",
                "default": "0"
            },
            "tfdt_traf": {
                "type": "bool",
                "description": "force tfdt box in each traf",
                "default": true
            },
            "nofragdef": {
                "type": "bool",
                "description": "disable default flags in fragments",
                "default": true
            },
            "straf": {
                "type": "bool",
                "description": "use a single traf per moof (smooth streaming and co)",
                "default": true
            },
            "strun": {
                "type": "bool",
                "description": "use a single trun per traf (smooth streaming and co)",
                "default": true
            },
            "psshs": {
                "type": "enum",
                "description": "set pssh boxes store mode",
                "default": "moov",
                "enum": {
                    "moof": "in first moof of each segments",
                    "moov": "in movie box",
                    "both": "in movie box and in first moof of each segment",
                    "none": "pssh is discarded"
                }
            },
            "sgpd_traf": {
                "type": "bool",
                "description": "store sample group descriptions in traf (duplicated for each traf). If not used, sample group descriptions are stored in the movie box",
                "default": true
            },
            "vodcache": {
                "type": "enum",
                "description": "enable temp storage for VoD dash modes",
                "default": "replace",
                "enum": {
                    "on": "use temp storage of complete file for sidx and ssix injection",
                    "insert": "insert sidx and ssix by shifting bytes in output file",
                    "replace": "precompute pace requirements for sidx and ssix and rewrite file range at end"
                }
            },
            "noinit": {
                "type": "bool",
                "description": "do not produce initial moov, used for DASH bitstream switching mode",
                "default": true
            },
            "tktpl": {
                "type": "enum",
                "description": "use track box from input if any as a template to create new track",
                "default": "yes",
                "enum": {
                    "no": "disables template",
                    "yes": "clones the track (except edits and decoder config)",
                    "udta": "only loads udta"
                }
            },
            "mudta": {
                "type": "enum",
                "description": "use udta and other moov extension boxes from input if any",
                "default": "yes",
                "enum": {
                    "no": "disables import",
                    "yes": "clones all extension boxes",
                    "udta": "only loads udta"
                }
            },
            "mvex": {
                "type": "bool",
                "description": "set mvex boxes after trak boxes",
                "default": true
            },
            "sdtp_traf": {
                "type": "enum",
                "description": "use sdtp box in traf box rather than using flags in trun sample entries",
                "default": "no",
                "enum": {
                    "no": "do not use sdtp",
                    "sdtp": "use sdtp box to indicate sample dependencies and do not write info in trun sample flags",
                    "both": "use sdtp box to indicate sample dependencies and also write info in trun sample flags"
                }
            },
            "trackid": {
                "type": "uint",
                "description": "track ID of created track for single track. Default 0 uses next available trackID",
                "default": 0
            },
            "fragdur": {
                "type": "bool",
                "description": "fragment based on fragment duration rather than CTS. Mostly used for MP4Box -frag option",
                "default": true
            },
            "btrt": {
                "type": "bool",
                "description": "set btrt box in sample description",
                "default": true
            },
            "styp": {
                "type": "str",
                "description": "set segment styp major brand (and optionally version) to the given 4CC[.version]"
            },
            "mediats": {
                "type": "sint",
                "description": "set media timescale. A value of 0 means inherit from PID, a value of -1 means derive from samplerate or frame rate",
                "default": "0"
            },
            "ase": {
                "type": "enum",
                "description": "set audio sample entry mode for more than stereo layouts",
                "default": "v0",
                "enum": {
                    "v0": "use v0 signaling but channel count from stream, recommended for backward compatibility",
                    "v0s": "use v0 signaling and force channel count to 2 (stereo) if more than 2 channels",
                    "v1": "use v1 signaling, ISOBMFF style (will mux raw PCM as ISOBMFF style)",
                    "v1qt": "use v1 signaling, QTFF style"
                }
            },
            "ssix": {
                "type": "bool",
                "description": "create ssix box when sidx box is present, level 1 mapping I-frames byte ranges, level 0xFF mapping the rest",
                "default": true
            },
            "ccst": {
                "type": "bool",
                "description": "insert coding constraint box for video tracks",
                "default": true
            },
            "maxchunk": {
                "type": "uint",
                "description": "set max chunk size in bytes for runs (only used in non-fragmented mode). 0 means no constraints",
                "default": 0
            },
            "noroll": {
                "type": "bool",
                "description": "disable roll sample grouping",
                "default": true
            },
            "norap": {
                "type": "bool",
                "description": "disable rap sample grouping",
                "default": true
            },
            "saio32": {
                "type": "bool",
                "description": "use 32 bit offset for side data location instead of 64 bit offset",
                "default": true
            },
            "tfdt64": {
                "type": "bool",
                "description": "use 64 bit tfdt and sidx even for 32 bits timestamps",
                "default": true
            },
            "compress": {
                "type": "enum",
                "description": "set top-level box compression mode",
                "default": "no",
                "enum": {
                    "no": "disable box compression",
                    "moov": "compress only moov box",
                    "moof": "compress only moof boxes",
                    "sidx": "compress moof and sidx boxes",
                    "ssix": "compress moof, sidx and ssix boxes",
                    "all": "compress moov, moof, sidx and ssix boxes"
                }
            },
            "fcomp": {
                "type": "bool",
                "description": "force using compress box even when compressed size is larger than uncompressed",
                "default": true
            },
            "otyp": {
                "type": "bool",
                "description": "inject original file type when using compressed boxes",
                "default": true
            },
            "trun_inter": {
                "type": "bool",
                "description": "interleave samples in trun based on the temporal level, the lowest level are stored first (this will create as many trun boxes as required)",
                "default": true
            },
            "truns_first": {
                "type": "bool",
                "description": "store track runs before sample group description and sample encryption information",
                "default": true
            },
            "block_size": {
                "type": "uint",
                "description": "target output block size, 0 for default internal value (10k)",
                "default": 10000
            },
            "boxpatch": {
                "type": "str",
                "description": "apply box patch before writing"
            },
            "deps": {
                "type": "bool",
                "description": "add samples dependencies information",
                "default": true
            },
            "mfra": {
                "type": "bool",
                "description": "enable movie fragment random access when fragmenting (ignored when dashing)",
                "default": true
            },
            "forcesync": {
                "type": "bool",
                "description": "force all SAP types to be considered sync samples (might produce non-compliant files)",
                "default": true
            },
            "refrag": {
                "type": "bool",
                "description": "use track fragment defaults from initial file if any rather than computing them from PID properties (used when processing standalone segments/fragments)",
                "default": true
            },
            "itags": {
                "type": "enum",
                "description": "tag injection mode",
                "default": "strict",
                "enum": {
                    "none": "do not inject tags",
                    "strict": "only inject recognized itunes tags",
                    "all": "inject all possible tags"
                }
            },
            "keep_utc": {
                "type": "bool",
                "description": "force all new files and tracks to keep the source UTC creation and modification times",
                "default": true
            },
            "pps_inband": {
                "type": "bool",
                "description": "when xps_inband is set, inject PPS in each non SAP 1/2/3 sample",
                "default": true
            },
            "moovpad": {
                "type": "uint",
                "description": "insert free box of given size after moov for future in-place editing",
                "default": 0
            },
            "cmaf": {
                "type": "enum",
                "description": "use CMAF guidelines (turns on mvex, truns_first, strun, straf, tfdt_traf, chain_sidx and restricts subs_sidx to -1 or 0)",
                "default": "no",
                "enum": {
                    "no": "CMAF not enforced",
                    "cmfc": "use CMAF cmfc guidelines",
                    "cmf2": "use CMAF cmf2 guidelines (turns on nofragdef)"
                }
            },
            "pad_sparse": {
                "type": "bool",
                "description": "inject sample with no data (size 0) to keep durations in unknown sparse text and metadata tracks",
                "default": true
            },
            "force_dv": {
                "type": "bool",
                "description": "force DV sample entry types even when AVC/HEVC compatibility is signaled",
                "default": true
            },
            "tsalign": {
                "type": "bool",
                "description": "enable timeline realignment to 0 for first sample in fragmented mode",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media", "Codec Not Supported"],
                "stream_type": ["ObjectDescriptor", "File", "Text", "SceneDescription"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": ["mp4dmx", "fout", "pout", "sockout", "httpout", "routeout", ""]
    },
    {
        "name": "rfqcp",
        "description": "QCP reframer",
        "body": "This filter parses QCP files/data and outputs corresponding audio PID and frames.\n\n\n",
        "options": {
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [
                    "QCELP Voice",
                    "SMV Voice",
                    "EVRC Voice",
                    "EVRC (PacketVideo MUX) Audio"
                ],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "writeqcp",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rfh263",
        "description": "H263 reframer",
        "body": "This filter parses H263 files/data and outputs corresponding visual PID and frames.\n\n\n",
        "options": {
            "fps": {
                "type": "frac",
                "description": "import frame rate",
                "default": "15000/1000"
            },
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            },
            "notime": {
                "type": "bool",
                "description": "ignore input timestamps, rebuild from 0",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["H263 Video"],
                "stream_type": ["File", "Visual"]
            },
            "output": {
                "codec_id": ["H263 Video"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "vtbdec",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rfmpgvid",
        "description": "M1V/M2V/M4V reframer",
        "body": "This filter parses MPEG-1/2 and MPEG-4 part 2 video files/data and outputs corresponding video PID and frames.\nNote: The filter uses negative CTS offsets: CTS is correct, but some frames may have DTS greater than CTS.\n\n\n",
        "options": {
            "fps": {
                "type": "frac",
                "description": "import frame rate (0 default to FPS from bitstream or 25 Hz)",
                "default": "0/1000"
            },
            "index": {
                "type": "dbl",
                "description": "indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 20M (slows down importers) unless a play with start range > 0 is issued",
                "default": "-1.0"
            },
            "vfr": {
                "type": "bool",
                "description": "set variable frame rate import",
                "default": true
            },
            "importer": {
                "type": "bool",
                "description": "compatibility with old importer, displays import results",
                "default": true
            },
            "notime": {
                "type": "bool",
                "description": "ignore input timestamps, rebuild from 0",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-1 Video",
                    "MPEG-4 Visual part 2",
                    "MPEG-2 Visual Main",
                    "MPEG-2 Visual High",
                    "MPEG-2 Visual SNR",
                    "MPEG-2 Visual 422",
                    "MPEG-2 Visual Spatial",
                    "MPEG-2 Visual Simple"
                ],
                "stream_type": ["File", "Visual"]
            },
            "output": {
                "codec_id": [
                    "MPEG-1 Video",
                    "MPEG-4 Visual part 2",
                    "MPEG-2 Visual Main",
                    "MPEG-2 Visual High",
                    "MPEG-2 Visual SNR",
                    "MPEG-2 Visual 422",
                    "MPEG-2 Visual Spatial",
                    "MPEG-2 Visual Simple"
                ],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "ufm4v",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "xviddec",
            "vtbdec",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "ufm4v",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "nvdec",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "nhntr",
        "description": "NHNT reader",
        "body": "This filter reads NHNT files/data to produce a media PID and frames.\nNHNT documentation is available at https://wiki.gpac.io/NHNT-Format\n\n\n",
        "options": {
            "reframe": {
                "type": "bool",
                "description": "force re-parsing of referenced content",
                "default": true
            },
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["Audio", "Visual", "SceneDescription"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "nhntw",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "nhmlr",
        "description": "NHML reader",
        "body": "This filter reads NHML files/data to produce a media PID and frames.\nNHML documentation is available at https://wiki.gpac.io/NHML-Format\n\n\n",
        "options": {
            "reframe": {
                "type": "bool",
                "description": "force re-parsing of referenced content",
                "default": true
            },
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["Unknown"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "writegen",
            "nhmlw",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "fin",
            "btplay",
            "httpin",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "fout",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "vobsubdmx",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "pout",
            "gsfmx",
            "gsfdmx",
            "sockout",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "rfnalu",
        "description": "AVC/HEVC reframer",
        "body": "This filter parses AVC|H264 and HEVC files/data and outputs corresponding video PID and frames.\nThis filter produces ISOBMFF-compatible output: start codes are removed, NALU length field added and avcC/hvcC config created.\nNote: The filter uses negative CTS offsets: CTS is correct, but some frames may have DTS greater than CTS.\n\n\n",
        "options": {
            "fps": {
                "type": "frac",
                "description": "import frame rate (0 default to FPS from bitstream or 25 Hz)",
                "default": "0/1000"
            },
            "index": {
                "type": "dbl",
                "description": "indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 20M (slows down importers) unless a play with start range > 0 is issued",
                "default": "-1.0"
            },
            "explicit": {
                "type": "bool",
                "description": "use explicit layered (SVC/LHVC) import",
                "default": true
            },
            "strict_poc": {
                "type": "enum",
                "description": "delay frame output of an entire GOP to ensure CTS info is correct when POC suddenly changes",
                "default": "off",
                "enum": {
                    "off": "disable GOP buffering",
                    "on": "enable GOP buffering, assuming no error in POC",
                    "error": "enable GOP buffering and try to detect lost frames"
                }
            },
            "nosei": {
                "type": "bool",
                "description": "remove all sei messages",
                "default": true
            },
            "nosvc": {
                "type": "bool",
                "description": "remove all SVC/MVC/LHVC data",
                "default": true
            },
            "novpsext": {
                "type": "bool",
                "description": "remove all VPS extensions",
                "default": true
            },
            "importer": {
                "type": "bool",
                "description": "compatibility with old importer, displays import results",
                "default": true
            },
            "nal_length": {
                "type": "uint",
                "description": "set number of bytes used to code length field: 1, 2 or 4",
                "default": 4
            },
            "subsamples": {
                "type": "bool",
                "description": "import subsamples information",
                "default": true
            },
            "deps": {
                "type": "bool",
                "description": "import sample dependency information",
                "default": true
            },
            "seirw": {
                "type": "bool",
                "description": "rewrite AVC sei messages for ISOBMFF constraints",
                "default": true
            },
            "audelim": {
                "type": "bool",
                "description": "keep Access Unit delimiter in payload",
                "default": true
            },
            "notime": {
                "type": "bool",
                "description": "ignore input timestamps, rebuild from 0",
                "default": true
            },
            "dv_mode": {
                "type": "enum",
                "description": "signaling for DolbyVision",
                "default": "auto",
                "enum": {
                    "none": "never signal DV profile",
                    "auto": "signal DV profile if RPU or EL are found",
                    "clean": "do not signal and remove RPU and EL NAL units",
                    "single": "signal DV profile if RPU are found and remove EL NAL units"
                }
            },
            "dv_profile": {
                "type": "uint",
                "description": "profile for DolbyVision (currently defined profiles are 4, 5, 7, 8, 9), 0 for auto-detect",
                "default": 0
            },
            "dv_compatid": {
                "type": "enum",
                "description": "cross-compatibility ID for DolbyVision",
                "default": "auto",
                "enum": {
                    "auto": "auto-detect",
                    "none": "no cross-compatibility",
                    "hdr10": "CTA HDR10, as specified by EBU TR 03",
                    "bt709": "SDR BT.709",
                    "hlg709": "HLG BT.709 gamut in ITU-R BT.2020",
                    "hlg2100": "HLG BT.2100 gamut in ITU-R BT.2020",
                    "bt2020": "SDR BT.2020",
                    "brd": "Ultra HD Blu-ray Disc HDR"
                }
            },
            "bsdbg": {
                "type": "enum",
                "description": "debug NAL parsing in parser@debug logs",
                "default": "off",
                "enum": {
                    "off": "not enabled",
                    "on": "enabled",
                    "full": "enable with number of bits dumped"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "VVC Video",
                    "MPEG-4 AVC|H264 Multiview Video Coding",
                    "MPEG-4 AVC|H264 Scalable Video Coding",
                    "HEVC Video Layered Extensions",
                    "MPEG-4 AVC|H264 Video Parameter Sets",
                    "MPEG-4 AVC|H264 Video",
                    "HEVC Video"
                ],
                "stream_type": ["File", "Encrypted", "Visual"]
            },
            "output": {
                "codec_id": [
                    "VVC Video",
                    "MPEG-4 AVC|H264 Multiview Video Coding",
                    "MPEG-4 AVC|H264 Scalable Video Coding",
                    "HEVC Video Layered Extensions",
                    "MPEG-4 AVC|H264 Video Parameter Sets",
                    "MPEG-4 AVC|H264 Video",
                    "HEVC Video"
                ],
                "stream_type": ["Encrypted", "Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "cecrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "ufnalu",
            "flist",
            "dasher",
            "tileagg",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "reframer",
            "ufnalu",
            "nhntw",
            "nhmlw",
            "dasher",
            "tilesplit",
            "gsfmx",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "m2psdmx",
        "description": "MPEG PS demultiplexer",
        "body": "This filter demultiplexes MPEG-2 program streams to produce media PIDs and frames.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "avimx",
            "ufm4v",
            "ufvc1",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "avidmx",
        "description": "AVI demultiplexer",
        "body": "This filter demultiplexes AVI files to produce media PIDs and frames.\n\n\n",
        "options": {
            "fps": {
                "type": "frac",
                "description": "import frame rate, default is AVI one",
                "default": "1/0"
            },
            "importer": {
                "type": "bool",
                "description": "compatibility with old importer, displays import results",
                "default": true
            },
            "noreframe": {
                "type": "bool",
                "description": "skip media reframer",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "txtin",
        "description": "Subtitle loader",
        "body": "This filter reads subtitle data from input PID to produce subtitle frames on a single PID.\nThe filter supports the following formats:\n\t* SRT: https://en.wikipedia.org/wiki/SubRip\n\t* WebVTT: https://www.w3.org/TR/webvtt1/\n\t* TTXT: https://wiki.gpac.io/TTXT-Format-Documentation\n\t* QT 3GPP Text XML (TexML): Apple QT6, likely deprecated\n\t* TTML: https://www.w3.org/TR/ttml2/\n\t* SUB: one subtitle per line formatted as {start_frame}{end_frame}text\n\t* SSA (Substation Alpha): basic parsing support for common files\n\nInput files must be in UTF-8 or UTF-16 format, with or without BOM. The internal frame format is: \n\t* WebVTT (and srt if desired): ISO/IEC 14496-30 VTT cues\n\t* TTML: ISO/IEC 14496-30 XML subtitles\n\t* Others: 3GPP/QT Timed Text\n\nTTML Support\n\nIf ttml_split option is set, the TTML document is split in independent time segments by inspecting all overlapping subtitles in the body.\nEmpty periods in TTML will result in empty TTML documents or will be skipped if no_empty option is set.\n\nThe first sample has a CTS assigned as indicated by ttml_cts:\n- a numerator of -2 indicates the first CTS is 0\n- a numerator of -1 indicates the first CTS is the first active time in document\n- a numerator >= 0 indicates the CTS to use for first sample\n\nWhen TTML splitting is disabled, the duration of the TTML sample is given by ttml_dur if not 0, or set to the document duration\n\nBy default, media resources are kept as declared in TTML2 documents.\n\nttml_embed can be used to embed inside the TTML sample the resources in <head> or <body>:\n- for <source>, <image>, <audio>, <font>, local URIs indicated in src will be loaded and src rewritten.\n- for <data> with base64 coding, the data will be decoded, <data> element removed and parent <source> rewritten with src attribute inserted.\n\nThe embedded data is added as a subsample to the TTML frame, and the referring elements will use src=urn:mpeg:14496-30:N with N the index of the subsample.\n\nA subtitle zero may be specified using ttml_zero. This will remove all subtitles before the given time T0, and rewrite each subtitle begin/end T to T-T0 using millisecond accuracy.\n\nWarning: Original time formatting (tick, frames/subframe ...) will be lost when this option is used, converted to HH:MM:SS.ms.\n\nThe subtitle zero time must be prefixed with T when the option is not set as a global argument:\nExample:\ngpac -i test.ttml:ttml_zero=T10:00:00 [...]\nMP4Box -add test.ttml:sopt:ttml_zero=T10:00:00 [...]\ngpac -i test.ttml --ttml_zero=10:00:00 [...]\ngpac -i test.ttml --ttml_zero=T10:00:00 [...]\nMP4Box -add test.ttml --ttml_zero=10:00:00 [...]\n\nSimple Text Support\n\nThe text loader can convert input files in simple text streams of a single packet, by forcing the codec type on the input:EX gpac -i test.txt:#CodecID=stxt  [...]\nExample:\ngpac fin:pck=\"Text Data\":#CodecID=stxt  [...]\n\nThe content of the source file will be the payload of the text sample. The stxtmod option allows specifying WebVTT, TX3G or simple text mode for output format.\nIn this mode, the stxtdur option is used to control the duration of the generated subtitle:\n- a positive value always forces the duration\n- a negative value forces the duration if input packet duration is not known\n\n\n",
        "options": {
            "webvtt": {
                "type": "bool",
                "description": "force WebVTT import of SRT files",
                "default": true
            },
            "nodefbox": {
                "type": "bool",
                "description": "skip default text box",
                "default": true
            },
            "noflush": {
                "type": "bool",
                "description": "skip final sample flush for srt",
                "default": true
            },
            "fontname": {
                "type": "str",
                "description": "default font"
            },
            "fontsize": {
                "type": "uint",
                "description": "default font size",
                "default": 18
            },
            "lang": {
                "type": "str",
                "description": "default language"
            },
            "width": {
                "type": "uint",
                "description": "default width of text area",
                "default": 0
            },
            "height": {
                "type": "uint",
                "description": "default height of text area",
                "default": 0
            },
            "txtx": {
                "type": "uint",
                "description": "default horizontal offset of text area: -1 (left), 0 (center) or 1 (right)",
                "default": 0
            },
            "txty": {
                "type": "uint",
                "description": "default vertical offset of text area: -1 (bottom), 0 (center) or 1 (top)",
                "default": 0
            },
            "zorder": {
                "type": "sint",
                "description": "default z-order of the PID",
                "default": "0"
            },
            "timescale": {
                "type": "uint",
                "description": "default timescale of the PID",
                "default": 1000
            },
            "ttml_split": {
                "type": "bool",
                "description": "split ttml doc in non-overlapping samples",
                "default": true
            },
            "ttml_cts": {
                "type": "lfrac",
                "description": "first sample cts - see filter help",
                "default": "-1/1"
            },
            "ttml_dur": {
                "type": "frac",
                "description": "sample duration when not spliting split - see filter help",
                "default": "0/1"
            },
            "ttml_embed": {
                "type": "bool",
                "description": "force embedding TTML resources",
                "default": true
            },
            "ttml_zero": {
                "type": "str",
                "description": "set subtitle zero time for TTML"
            },
            "no_empty": {
                "type": "bool",
                "description": "do not send empty samples",
                "default": true
            },
            "stxtdur": {
                "type": "frac",
                "description": "duration for simple text",
                "default": "1"
            },
            "stxtmod": {
                "type": "enum",
                "description": "simple text stream mode- none: declares output PID as simple text stream",
                "default": "none",
                "enum": {
                    "tx3g": "declares output PID as TX3G/Apple stream",
                    "vtt": "declares output PID as WebVTT stream"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "WebVTT Text",
                    "Subtitle text Stream",
                    "Simple Text Stream",
                    "SSA /ASS Subtitles"
                ],
                "stream_type": ["File", "Text"]
            },
            "output": {
                "codec_id": [
                    "Simple Text Stream",
                    "WebVTT Text",
                    "Subtitle text Stream",
                    "Subtitle XML Stream",
                    "Subtitle/text 3GPP/Apple Stream"
                ],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "dashin",
            "nhmlr",
            "rtpin",
            "reframer",
            "writegen",
            "ufvtt",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2vtt",
            "ttml2vtt",
            "ffdmx",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "reframer",
            "writegen",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffmx",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "ttxtdec",
        "description": "TTXT/TX3G decoder",
        "body": "This filter decodes TTXT/TX3G streams into a BIFS scene graph of the compositor filter.\nThe TTXT documentation is available at https://wiki.gpac.io/TTXT-Format-Documentation\n\nIn stand-alone rendering (no associated video), the filter will use:\n- Width and Height properties of input pid if any\n- otherwise, osize option of compositor if set\n- otherwise, txtw and txth\n\n\n",
        "options": {
            "texture": {
                "type": "bool",
                "description": "use texturing for output text",
                "default": true
            },
            "outline": {
                "type": "bool",
                "description": "draw text outline",
                "default": true
            },
            "txtw": {
                "type": "uint",
                "description": "default width in standalone rendering",
                "default": 400
            },
            "txth": {
                "type": "uint",
                "description": "default height in standalone rendering",
                "default": 200
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "Subtitle/text 3GPP/Apple Stream",
                    "MPEG-4 Streaming Text",
                    "Subtitle text Stream",
                    "Simple Text Stream"
                ],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "vttdec",
        "description": "WebVTT decoder",
        "body": "This filter decodes WebVTT streams into a SVG scene graph of the compositor filter.\nThe scene graph creation is done through JavaScript.\nThe filter options are used to override the JS global variables of the WebVTT renderer.\nIn stand-alone rendering (no associated video), the filter will use:\n- Width and Height properties of input pid if any\n- otherwise, osize option of compositor if set\n- otherwise, txtw and txth\n\n\n",
        "options": {
            "script": {
                "type": "str",
                "description": "location of WebVTT SVG JS renderer",
                "default": "$GSHARE/scripts/webvtt-renderer.js"
            },
            "font": {
                "type": "str",
                "description": "font",
                "default": "SANS"
            },
            "fontSize": {
                "type": "flt",
                "description": "font size",
                "default": 20.0
            },
            "color": {
                "type": "str",
                "description": "text color",
                "default": "white"
            },
            "lineSpacing": {
                "type": "flt",
                "description": "line spacing as scaling factor to font size",
                "default": 1.0
            },
            "txtw": {
                "type": "uint",
                "description": "default width in standalone rendering",
                "default": 400
            },
            "txth": {
                "type": "uint",
                "description": "default height in standalone rendering",
                "default": 200
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["WebVTT Text"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "ttmldec",
        "description": "TTML decoder",
        "body": "This filter decodes TTML streams into a SVG scene graph of the compositor filter.\nThe scene graph creation is done through JavaScript.\nThe filter options are used to override the JS global variables of the TTML renderer.\n\nIn stand-alone rendering (no associated video), the filter will use:\n- Width and Height properties of input pid if any\n- otherwise, osize option of compositor if set\n- otherwise, txtw and txth\n\n\n",
        "options": {
            "script": {
                "type": "str",
                "description": "location of TTML SVG JS renderer",
                "default": "$GSHARE/scripts/ttml-renderer.js"
            },
            "font": {
                "type": "str",
                "description": "font",
                "default": "SANS"
            },
            "fontSize": {
                "type": "flt",
                "description": "font size",
                "default": 20.0
            },
            "color": {
                "type": "str",
                "description": "text color",
                "default": "white"
            },
            "valign": {
                "type": "enum",
                "description": "vertical alignment",
                "default": "bottom",
                "enum": {
                    "bottom": "align text at bottom of text area",
                    "center": "align text at center of text area",
                    "top": "align text at top of text area"
                }
            },
            "lineSpacing": {
                "type": "flt",
                "description": "line spacing as scaling factor to font size",
                "default": 1.0
            },
            "txtw": {
                "type": "uint",
                "description": "default width in standalone rendering",
                "default": 400
            },
            "txth": {
                "type": "uint",
                "description": "default height in standalone rendering",
                "default": 200
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Subtitle XML Stream"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rtpin",
        "description": "RTP/RTSP/SDP input",
        "body": "This filter handles SDP/RTSP/RTP input reading. It supports:\n- SDP file reading\n- RTP direct url through rtp:// protocol scheme\n- RTSP session processing through rtsp:// and satip:// protocol schemes\n \nThe filter produces either PIDs with media frames, or file PIDs with multiplexed data (e.g. MPEG-2 TS). \nThe filter will use:\n- RTSP over HTTP tunnel if server port is 80 or 8080 or if protocol scheme is rtsph://.\n- RTSP over TLS if server port is 322 or if protocol scheme is rtsps://.\n- RTSP over HTTPS tunnel if server port is 443 and if protocol scheme is rtsph://.\n \nThe filter will attempt reconnecting in TLS mode after two consecutive initial connection failures.\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "location of source content (SDP, RTP or RTSP URL)"
            },
            "firstport": {
                "type": "uint",
                "description": "default first port number to use (0 lets the filter decide)",
                "default": 0
            },
            "ifce": {
                "type": "str",
                "description": "default interface IP to use for multicast. If NULL, the default system interface will be used"
            },
            "ttl": {
                "type": "uint",
                "description": "multicast TTL",
                "default": 127
            },
            "reorder_len": {
                "type": "uint",
                "description": "reorder length in packets",
                "default": 1000
            },
            "reorder_delay": {
                "type": "uint",
                "description": "max delay in RTP re-orderer, packets will be dispatched after that",
                "default": 50
            },
            "block_size": {
                "type": "uint",
                "description": "buffer size for RTP/UDP or RTSP when interleaved",
                "default": "0x100000"
            },
            "disable_rtcp": {
                "type": "bool",
                "description": "disable RTCP reporting",
                "default": true
            },
            "nat_keepalive": {
                "type": "uint",
                "description": "delay in ms of NAT keepalive, disabled by default (except for SatIP, set to 30s by default)",
                "default": 0
            },
            "force_mcast": {
                "type": "str",
                "description": "force multicast on indicated IP in RTSP setup"
            },
            "use_client_ports": {
                "type": "bool",
                "description": "force using client ports (hack for some RTSP servers overriding client ports)",
                "default": true
            },
            "bandwidth": {
                "type": "uint",
                "description": "set bandwidth param for RTSP requests",
                "default": 0
            },
            "default_port": {
                "type": "uint",
                "description": "set default RTSP port",
                "default": 554
            },
            "satip_port": {
                "type": "uint",
                "description": "set default port for SATIP",
                "default": 1400
            },
            "transport": {
                "type": "enum",
                "description": "set RTP over RTSP",
                "default": "auto",
                "enum": {
                    "auto": "set interleave on if HTTP tunnel is used, off otherwise and retry in interleaved mode if UDP timeout",
                    "tcp": "enable RTP over RTSP",
                    "udp": "disable RTP over RTSP"
                }
            },
            "udp_timeout": {
                "type": "uint",
                "description": "default timeout before considering UDP is down",
                "default": 10000
            },
            "rtcp_timeout": {
                "type": "uint",
                "description": "default timeout for RTCP traffic in ms. After this timeout, playback will start out of sync. If 0 always wait for RTCP",
                "default": 5000
            },
            "first_packet_drop": {
                "type": "uint",
                "description": "set number of first RTP packet to drop (0 if no drop)",
                "default": 0
            },
            "frequency_drop": {
                "type": "uint",
                "description": "drop 1 out of N packet (0 disable dropping)",
                "default": 0
            },
            "loss_rate": {
                "type": "sint",
                "description": "loss rate to signal in RTCP, -1 means real loss rate, otherwise a per-thousand of packet lost",
                "default": "-1"
            },
            "user_agent": {
                "type": "str",
                "description": "user agent string, by default solved from GPAC preferences",
                "default": "$GUA"
            },
            "languages": {
                "type": "str",
                "description": "user languages, by default solved from GPAC preferences",
                "default": "$GLANG"
            },
            "stats": {
                "type": "uint",
                "description": "update statistics to the user every given MS (0 disables reporting)",
                "default": 500
            },
            "max_sleep": {
                "type": "sint",
                "description": "set max sleep in milliseconds:",
                "default": "1000"
            },
            "rtcpsync": {
                "type": "bool",
                "description": "use RTCP to adjust synchronization",
                "default": true
            },
            "forceagg": {
                "type": "bool",
                "description": "force RTSP control aggregation (patch for buggy servers)",
                "default": true
            },
            "ssm": {
                "type": "strl",
                "description": "list of IP to include for source-specific multicast"
            },
            "ssmx": {
                "type": "strl",
                "description": "list of IP to exclude for source-specific multicast"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": [
                    "Audio",
                    "SceneDescription",
                    "ObjectDescriptor",
                    "File",
                    "Encrypted",
                    "Visual",
                    "Text",
                    "Metadata"
                ]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "rtpout",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "fout",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pout",
            "gsfmx",
            "sockout",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "routeout",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "fout",
        "description": "File output",
        "body": "This filter is used to write data to disk, and does not produce any output PID.\nIn regular mode, the filter only accept PID of type file. It will dump to file incoming packets (stream type file), starting a new file for each packet having a frame_start flag set, unless operating in cat mode.\nIf the output file name is std or stdout, writes to stdout.\nThe output file name can use gpac templating mechanism, see gpac -h doc.The filter watches the property FileNumber on incoming packets to create new files.\n\nDiscard sink mode\n\nWhen the destination is null, the filter is a sink dropping all input packets.\nIn this case it accepts ANY type of input PID, not just file ones.\n\nHTTP streaming recording\n\nWhen recording a DASH or HLS session, the number of segments to keep per quality can be set using max_cache_segs.\n- value 0  keeps everything (default behaviour)\n- a negative value N will keep -N files regardless of the time-shift buffer value\n- a positive value N will keep MAX(N, time-shift buffer) files\n\nExample:\ngpac -i LIVE_MPD dashin:forward=file -o rec/$File$:max_cache_segs=3\nThis will force keeping a maximum of 3 media segments while recording the DASH session.\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "location of destination file"
            },
            "append": {
                "type": "bool",
                "description": "open in append mode",
                "default": true
            },
            "dynext": {
                "type": "bool",
                "description": "indicate the file extension is set by filter chain, not dst",
                "default": true
            },
            "start": {
                "type": "dbl",
                "description": "set playback start offset. A negative value means percent of media duration with -1 equal to duration",
                "default": "0.0"
            },
            "speed": {
                "type": "dbl",
                "description": "set playback speed when vsync is on. If negative and start is 0, start is set to -1",
                "default": "1.0"
            },
            "ext": {
                "type": "cstr",
                "description": "set extension for graph resolution, regardless of file extension"
            },
            "mime": {
                "type": "cstr",
                "description": "set mime type for graph resolution"
            },
            "cat": {
                "type": "enum",
                "description": "cat each file of input PID rather than creating one file per filename",
                "default": "none",
                "enum": {
                    "none": "never cat files",
                    "auto": "only cat if files have same names",
                    "all": "always cat regardless of file names"
                }
            },
            "ow": {
                "type": "bool",
                "description": "overwrite output if existing",
                "default": true
            },
            "mvbk": {
                "type": "uint",
                "description": "block size used when moving parts of the file around in patch mode",
                "default": 8192
            },
            "redund": {
                "type": "bool",
                "description": "keep redundant packet in output file",
                "default": true
            },
            "max_cache_segs": {
                "type": "sint",
                "description": "maximum number of segments cached per HAS quality when recording live sessions (0 means no limit)",
                "default": "0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "mp4mx",
            "nhmlr",
            "rtpin",
            "writegen",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "pin",
            "gsfmx",
            "gsfdmx",
            "routein",
            "rtpout",
            "httpout",
            "tssplit",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx"
        ],
        "sinks": []
    },
    {
        "name": "uflatm",
        "description": "Raw AAC to LATM writer",
        "body": "This filter converts AAC streams into LATM encapsulated data.\n\n\n",
        "options": {
            "fdsi": {
                "type": "frac",
                "description": "set delay between two LATM Audio Config",
                "default": "0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-2 AAC Audio Main",
                    "MPEG-2 AAC Audio Scalable Sampling Rate",
                    "MPEG-4 AAC Audio",
                    "xHEAAC / USAC Audio",
                    "MPEG-2 AAC Audio Low Complexity"
                ],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": [
                    "MPEG-2 AAC Audio Main",
                    "MPEG-2 AAC Audio Scalable Sampling Rate",
                    "MPEG-4 AAC Audio",
                    "xHEAAC / USAC Audio",
                    "MPEG-2 AAC Audio Low Complexity"
                ],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfadts",
            "rflatm",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["rflatm", "writegen", ""]
    },
    {
        "name": "ufadts",
        "description": "ADTS writer",
        "body": "This filter converts AAC streams into ADTS encapsulated data.\n\n\n",
        "options": {
            "mpeg2": {
                "type": "enum",
                "description": "signal as MPEG2 AAC",
                "default": "auto",
                "enum": {
                    "auto": "selects based on AAC profile",
                    "no": "always signals as MPEG-4 AAC",
                    "yes": "always signals as MPEG-2 AAC"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-4 AAC Audio",
                    "MPEG-2 AAC Audio Main",
                    "MPEG-2 AAC Audio Low Complexity",
                    "MPEG-2 AAC Audio Scalable Sampling Rate"
                ],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": [
                    "MPEG-4 AAC Audio",
                    "MPEG-2 AAC Audio Main",
                    "MPEG-2 AAC Audio Low Complexity",
                    "MPEG-2 AAC Audio Scalable Sampling Rate"
                ],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfadts",
            "rflatm",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["rfadts", "rflatm", "writegen", "avimx", "unframer", ""]
    },
    {
        "name": "ufmhas",
        "description": "MHAS writer",
        "body": "This filter converts MPEG-H Audio streams into MHAS encapsulated data.\n\n\n",
        "options": {
            "syncp": {
                "type": "bool",
                "description": "if set, insert sync packet at each frame, otherwise only at SAP",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-H Audio", "MPEG-H AudioMux"],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": ["MPEG-H AudioMux"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "rfmhas",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["writegen", "m2tsmx", "rfmhas", "unframer", ""]
    },
    {
        "name": "reframer",
        "description": "Media Reframer",
        "body": "This filter provides various tools on inputs:\n- ensure reframing (1 packet = 1 Access Unit)\n- optionally force decoding\n- real-time regulation\n- packet filtering based on SAP types or frame numbers\n- time-range extraction and splitting\n  \nThis filter forces input PIDs to be properly framed (1 packet = 1 Access Unit).\nIt is typically needed to force remultiplexing in file to file operations when source and destination files use the same format.\n  \n\nSAP filtering\n\nThe filter can remove packets based on their SAP types using saps option.\nFor example, this can be used to extract only the key frame (SAP 1,2,3) of a video to create a trick mode version.\n  \n\nFrame filtering\n\nThis filter can keep only specific Access Units of the source using frames option.\nFor example, this can be used to extract only specific key pictures of a video to create a HEIF collection.\n  \n\nFrame decoding\n\nThis filter can force input media streams to be decoded using the raw option.\nExample:\ngpac -i m.mp4 reframer:raw=av [dst]\n\nReal-time Regulation\n\nThe filter can perform real-time regulation of input packets, based on their timescale and timestamps.\nFor example to simulate a live DASH:\nExample:\ngpac -i m.mp4 reframer:rt=on -o live.mpd:dynamic\n  \n\nRange extraction\n\nThe filter can perform time range extraction of the source using xs and xe options.\nThe formats allowed for times specifiers are:\n\t* 'T'H:M:S, 'T'M:S: specify time in hours, minutes, seconds\n\t* 'T'H:M:S.MS, 'T'M:S.MS, 'T'S.MS: specify time in hours, minutes, seconds and milliseconds\n\t* INT, FLOAT, NUM/DEN: specify time in seconds (number or fraction)\n\t* 'D'INT, 'D'FLOAT, 'D'NUM/DEN: specify end time as offset to start time in seconds (number or fraction) - only valid for xe\n\t* 'F'NUM: specify time as frame number\n\t* XML DateTime: specify absolute UTC time\n  \nIn this mode, the timestamps are rewritten to form a continuous timeline, unless xots is set.\nWhen multiple ranges are given, the filter will try to seek if needed and supported by source.\n\nExample:\ngpac -i m.mp4 reframer:xs=T00:00:10,T00:01:10,T00:02:00:xe=T00:00:20,T00:01:20 [dst]\nThis will extract the time ranges [10s,20s], [1m10s,1m20s] and all media starting from 2m\n\nIf no end range is found for a given start range:\n- if a following start range is set, the end range is set to this next start\n- otherwise, the end range is open\n\nExample:\ngpac -i m.mp4 reframer:xs=0,10,25:xe=5,20 [dst]\nThis will extract the time ranges [0s,5s], [10s,20s] and all media starting from 25s\nExample:\ngpac -i m.mp4 reframer:xs=0,10,25 [dst]\nThis will extract the time ranges [0s,10s], [10s,25s] and all media starting from 25s\n\nIt is possible to signal range boundaries in output packets using splitrange.\nThis will expose on the first packet of each range in each PID the following properties:\n\t* `FileNumber`: starting at 1 for the first range, to be used as replacement for $num$ in templates\n\t* `FileSuffix`: corresponding to StartRange_EndRange or StartRange for open ranges, to be used as replacement for $FS$ in templates\n\nExample:\ngpac -i m.mp4 reframer:xs=T00:00:10,T00:01:10:xe=T00:00:20:splitrange -o dump_$FS$.264 [dst]\nThis will create two output files dump_T00.00.10_T00.02.00.264 and dump_T00.01.10.264.\nNote: The : and / characters are replaced by . in FileSuffix property.\n\nIt is possible to modify PID properties per range using props. Each set of property must be specified using the active separator set.\n\nWarning: The option must be escaped using double separators in order to be parsed properly.\n\nExample:\ngpac -i m.mp4 reframer:xs=0,30::props=#Period=P1,#Period=P2:#foo=bar [dst]\nThis will assign to output PIDs\n\t* during the range [0,30]: property Period to P1\n\t* during the range [30, end]: properties Period to P2 and property foo to bar\n\nFor uncompressed audio PIDs, input frame will be split to closest audio sample number.\n\nWhen xround is set to seek, the following applies:\n- a single range shall be specified\n- the first I-frame preceding or matching the range start is used as split point\n- all packets before range start are marked as seek points\n- packets overlapping range start are forwarded with a SkipBegin property set to the amount of media to skip\n- packets overlapping range end are forwarded with an adjusted duration to match the range end\nThis mode is typically used to extract a range in a frame/sample accurate way, rather than a GOP-aligned way.\n\nWhen xround is not set to seek, compressed audio streams will still use seek mode.\nConsequently, these streams will have modified edit lists in ISOBMFF which might not be properly handled by players.\nThis can be avoided using no_audio_seek, but this will introduce audio delay.\n\nUTC-based range extraction\n\nThe filter can perform range extraction based on UTC time rather than media time. In this mode, the end time must be:\n\t* a UTC date: range extraction will stop after this date\n\t* a time in second: range extraction will stop after the specified duration\n\nThe UTC reference is specified using utc_ref.\nIf UTC signal from media source is used, the filter will probe for utc_probe before considering the source has no UTC signal.\n\nThe properties SenderNTP and, if absent, UTC of source packets are checked for establishing the UTC reference.\n\nOther split actions\n\nThe filter can perform splitting of the source using xs option.\nThe additional formats allowed for xs option are:\n\t* `SAP`: split source at each SAP/RAP\n\t* `D`VAL: split source by chunks of VAL seconds\n\t* `D`NUM/DEN: split source by chunks of NUM/DEN seconds\n\t* `S`VAL: split source by chunks of estimated size VAL bytes (can use property multipliers, e.g. m)\n\nNote: In these modes, splitrange and xadjust are implicitly set.\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            },
            "rt": {
                "type": "enum",
                "description": "real-time regulation mode of input",
                "default": "off",
                "enum": {
                    "off": "disables real-time regulation",
                    "on": "enables real-time regulation, one clock per PID",
                    "sync": "enables real-time regulation one clock for all PIDs"
                }
            },
            "saps": {
                "type": "uintl",
                "description": "list of SAP types (0,1,2,3,4) to forward, other packets are dropped (forwarding only sap 0 will break the decoding)"
            },
            "refs": {
                "type": "bool",
                "description": "forward only frames used as reference frames, if indicated in the input stream",
                "default": true
            },
            "speed": {
                "type": "dbl",
                "description": "speed for real-time regulation mode, a value of 0 uses speed from play commands",
                "default": "0.0"
            },
            "raw": {
                "type": "enum",
                "description": "force input AV streams to be in raw format",
                "default": "no",
                "enum": {
                    "no": "do not force decoding of inputs",
                    "av": "force decoding of audio and video inputs",
                    "a": "force decoding of audio inputs",
                    "v": "force decoding of video inputs"
                }
            },
            "frames": {
                "type": "sintl",
                "description": "drop all except listed frames (first being 1). A negative value -V keeps only first frame every V frames"
            },
            "xs": {
                "type": "strl",
                "description": "extraction start time(s)"
            },
            "xe": {
                "type": "strl",
                "description": "extraction end time(s). If less values than start times, the last time interval extracted is an open range"
            },
            "xround": {
                "type": "enum",
                "description": "adjust start time of extraction range to I-frame",
                "default": "before",
                "enum": {
                    "before": "use first I-frame preceding or matching range start",
                    "seek": "see filter help",
                    "after": "use first I-frame (if any) following or matching range start",
                    "closest": "use I-frame closest to range start"
                }
            },
            "xadjust": {
                "type": "bool",
                "description": "adjust end time of extraction range to be before next I-frame",
                "default": true
            },
            "xots": {
                "type": "bool",
                "description": "keep original timestamps after extraction",
                "default": true
            },
            "nosap": {
                "type": "bool",
                "description": "do not cut at SAP when extracting range (may result in broken streams)",
                "default": true
            },
            "splitrange": {
                "type": "bool",
                "description": "signal file boundary at each extraction first packet for template-base file generation",
                "default": true
            },
            "seeksafe": {
                "type": "dbl",
                "description": "rewind play requests by given seconds (to make sure the I-frame preceding start is catched)",
                "default": "10.0"
            },
            "tcmdrw": {
                "type": "bool",
                "description": "rewrite TCMD samples when splitting",
                "default": true
            },
            "props": {
                "type": "strl",
                "description": "extra output PID properties per extraction range"
            },
            "no_audio_seek": {
                "type": "bool",
                "description": "disable seek mode on audio streams (no change of priming duration)",
                "default": true
            },
            "probe_ref": {
                "type": "bool",
                "description": "allow extracted range to be longer in case of B-frames with reference frames presented outside of range",
                "default": true
            },
            "utc_ref": {
                "type": "enum",
                "description": "set reference mode for UTC range extraction",
                "default": "any",
                "enum": {
                    "local": "use UTC of local host",
                    "any": "use UTC of media, or UTC of local host if not found in media after probing time",
                    "media": "use UTC of media (abort if none found)"
                }
            },
            "utc_probe": {
                "type": "uint",
                "description": "timeout in milliseconds to try to acquire UTC reference from media",
                "default": 5000
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "fin",
            "httpin",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "writegen",
        "description": "Stream to file",
        "body": "Generic single stream to file converter, used when extracting/converting PIDs.\nThe writegen filter should usually not be explicitly loaded without a source ID specified, since the filter would likely match any PID connection.\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            },
            "pfmt": {
                "type": "pfmt",
                "description": "pixel format for raw extract. If not set, derived from extension",
                "default": "none"
            },
            "afmt": {
                "type": "afmt",
                "description": "audio format for raw extract. If not set, derived from extension",
                "default": "none"
            },
            "decinfo": {
                "type": "enum",
                "description": "decoder config insert mode",
                "default": "auto",
                "enum": {
                    "no": "never inserted",
                    "first": "inserted on first packet",
                    "sap": "inserted at each SAP",
                    "auto": "selects between no and first based on media type"
                }
            },
            "split": {
                "type": "bool",
                "description": "force one file per decoded frame",
                "default": true
            },
            "frame": {
                "type": "bool",
                "description": "force single frame dump with no rewrite. In this mode, all codec types are supported",
                "default": true
            },
            "sstart": {
                "type": "uint",
                "description": "start number of frame to forward. If 0, all samples are forwarded",
                "default": 0
            },
            "send": {
                "type": "uint",
                "description": "end number of frame to forward. If less than start frame, all samples after start are forwarded",
                "default": 0
            },
            "dur": {
                "type": "frac",
                "description": "duration of media to forward after first sample. If 0, all samples are forwarded",
                "default": "0"
            },
            "merge_region": {
                "type": "bool",
                "description": "merge TTML regions with same ID while reassembling TTML doc",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "JPEG Image",
                    "Dolby TrueHD",
                    "Simple Text Stream",
                    "MPEG-2 Audio",
                    "SMPTE VC-1 Video",
                    "MPEG-4 AAC Audio",
                    "SMV Voice",
                    "QCELP Voice",
                    "VVC Video",
                    "MPEG-4 BIFS v1 Scene Description",
                    "VP8 Video",
                    "AMR WideBand Audio",
                    "xHEAAC / USAC Audio",
                    "Theora Video",
                    "MPEG-H AudioMux",
                    "DTS-HD High Resolution Audio",
                    "MPEG-1 Audio Layer 1",
                    "MPEG-4 AVC|H264 Video",
                    "Subtitle text Stream",
                    "ProRes Video 422 STD",
                    "HEVC Video",
                    "AC3 Audio",
                    "Speex Audio",
                    "MPEG-2 AAC Audio Scalable Sampling Rate",
                    "PNG Image",
                    "MPEG-1 Video",
                    "ProRes Video 4444 XQ",
                    "JPEG2000 Image",
                    "MPEG-4 AVC|H264 Multiview Video Coding",
                    "VP10 Video",
                    "MPEG-2 Visual SNR",
                    "MPEG-2 Visual 422",
                    "ProRes Video 4444",
                    "Subtitle/text 3GPP/Apple Stream",
                    "MPEG-2 AAC Audio Main",
                    "Metadata XML Stream",
                    "Vorbis Audio",
                    "WebVTT Text",
                    "MPEG-2 Visual Main",
                    "Flac Audio",
                    "ProRes Video 422 HQ",
                    "MPEG-4 BIFS v2 Scene Description",
                    "Codec Not Supported",
                    "AMR Audio",
                    "AOM AV1 Video",
                    "VP9 Video",
                    "Subtitle XML Stream",
                    "DTS Express low bit rate Audio",
                    "H263 Video",
                    "Metadata Text Stream",
                    "MPEG-4 AVC|H264 Video Parameter Sets",
                    "MPEG-2 Visual Spatial",
                    "ProRes Video 422 Proxy",
                    "MPEG-H Audio",
                    "DTS-HD Master Audio",
                    "Enhanced AC3 Audio",
                    "MPEG-4 Visual part 2",
                    "EVRC (PacketVideo MUX) Audio",
                    "EVRC Voice",
                    "FFMPEG Video Codec 1",
                    "MPEG-2 Visual High",
                    "HEVC Video Layered Extensions",
                    "MPEG-4 AVC|H264 Scalable Video Coding",
                    "ProRes Video 422 LT",
                    "MPEG-2 AAC Audio Low Complexity",
                    "MPEG-1 Audio",
                    "Raw media",
                    "MPEG-2 Visual Simple",
                    "DTS Coherent Acoustics Audio"
                ],
                "stream_type": ["File", "Audio", "Visual", "Text"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "ufnalu",
            "ufvtt",
            "vobsubdmx",
            "ufm4v",
            "ufvc1",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "routeout",
            "rftruehd",
            ""
        ]
    },
    {
        "name": "ufnalu",
        "description": "AVC/HEVC to AnnexB writer",
        "body": "This filter converts AVC|H264 and HEVC streams into AnnexB format, with inband parameter sets and start codes.\n\n\n",
        "options": {
            "rcfg": {
                "type": "bool",
                "description": "force repeating decoder config at each I-frame",
                "default": true
            },
            "extract": {
                "type": "enum",
                "description": "layer extraction mode",
                "default": "all",
                "enum": {
                    "all": "extracts all layers",
                    "base": "extract base layer only",
                    "layer": "extract non-base layer(s) only"
                }
            },
            "delim": {
                "type": "bool",
                "description": "insert AU Delimiter NAL",
                "default": true
            },
            "pps_inband": {
                "type": "bool",
                "description": "inject PPS at each non SAP frame, ignored if rcfg is not set",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "VVC Video",
                    "MPEG-4 AVC|H264 Multiview Video Coding",
                    "MPEG-4 AVC|H264 Scalable Video Coding",
                    "HEVC Video Layered Extensions",
                    "MPEG-4 AVC|H264 Video Parameter Sets",
                    "MPEG-4 AVC|H264 Video",
                    "HEVC Video"
                ],
                "stream_type": ["Encrypted", "Visual"]
            },
            "output": {
                "codec_id": [
                    "VVC Video",
                    "MPEG-4 AVC|H264 Multiview Video Coding",
                    "MPEG-4 AVC|H264 Scalable Video Coding",
                    "HEVC Video Layered Extensions",
                    "MPEG-4 AVC|H264 Video Parameter Sets",
                    "MPEG-4 AVC|H264 Video",
                    "HEVC Video"
                ],
                "stream_type": ["Encrypted", "Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": ["rfnalu", "writegen", "avimx", "m2tsmx", "unframer", ""]
    },
    {
        "name": "writeqcp",
        "description": "QCP writer",
        "body": "This filter converts a single QCELP, EVRC or MSV stream to a QCP output file.\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "QCELP Voice",
                    "SMV Voice",
                    "EVRC Voice",
                    "EVRC (PacketVideo MUX) Audio"
                ],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "mp4dmx",
            "rfamr",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfqcp",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["rfqcp", "fout", "pout", "sockout", "httpout", "routeout", ""]
    },
    {
        "name": "ufvtt",
        "description": "WebVTT unframer",
        "body": "This filter converts a single ISOBMFF WebVTT stream to its unframed format.\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            },
            "merge_cues": {
                "type": "bool",
                "description": "merge VTT cues (undo ISOBMFF cue split)",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["WebVTT Text"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["WebVTT Text"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["txtin", "writegen", "vtt2tx3g", "ffmx", "unframer", ""]
    },
    {
        "name": "nhntw",
        "description": "NHNT writer",
        "body": "This filter converts a single stream to an NHNT output file.\nNHNT documentation is available at https://wiki.gpac.io/NHNT-Format\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            },
            "large": {
                "type": "bool",
                "description": "use large file mode",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": ["nhntr", "fout", "pout", "sockout", "httpout", "routeout", ""]
    },
    {
        "name": "nhmlw",
        "description": "NHML writer",
        "body": "This filter converts a single stream to an NHML output file.\nNHML documentation is available at https://wiki.gpac.io/NHML-Format\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            },
            "dims": {
                "type": "bool",
                "description": "use DIMS mode",
                "default": true
            },
            "name": {
                "type": "str",
                "description": "set output name of media and info files produced"
            },
            "nhmlonly": {
                "type": "bool",
                "description": "only dump NHML info, not media",
                "default": true
            },
            "pckp": {
                "type": "bool",
                "description": "full NHML dump",
                "default": true
            },
            "chksum": {
                "type": "enum",
                "description": "insert frame checksum",
                "default": "none",
                "enum": {
                    "none": "no checksum",
                    "crc": "CRC32 checksum",
                    "sha1": "SHA1 checksum"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": ["nhmlr", "fout", "pout", "sockout", "httpout", "routeout", ""]
    },
    {
        "name": "vobsubdmx",
        "description": "VobSub parser",
        "body": "This filter parses VobSub files/data to produce media PIDs and frames.\n\n\n",
        "options": {
            "blankframe": {
                "type": "bool",
                "description": "force inserting a blank frame if first subpic is not at 0",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["VobSub Subtitle"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "avimx",
        "description": "AVI multiplexer",
        "body": "This filter multiplexes raw or compressed audio and video to produce an AVI output.\n\nUnlike other multiplexing filters in GPAC, this filter is a sink filter and does not produce any PID to be redirected in the graph.\nThe filter can however use template names for its output, using the first input PID to resolve the final name.\nThe filter watches the property FileNumber on incoming packets to create new files.\n\nThe filter will look for property AVIType set on the input stream.\nThe value can either be a 4CC or a string, indicating the mux format for the PID.\nIf the string is prefixed with + and the decoder configuration is present and formatted as an ISOBMFF box, the box header will be removed.\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "location of destination file"
            },
            "fps": {
                "type": "frac",
                "description": "default framerate if none indicated in stream",
                "default": "25/1"
            },
            "noraw": {
                "type": "bool",
                "description": "disable raw output in AVI, only compressed ones allowed",
                "default": true
            },
            "opendml_size": {
                "type": "luint",
                "description": "force opendml format when chunks are larger than this amount (0 means 1.9Gb max size in each riff chunk)",
                "default": "0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-2 AAC Audio Main",
                    "MPEG-2 AAC Audio Scalable Sampling Rate",
                    "MPEG-4 AAC Audio",
                    "VVC Video",
                    "MPEG-4 Visual part 2",
                    "AOM AV1 Video",
                    "MPEG-2 AAC Audio Low Complexity",
                    "Raw media",
                    "MPEG-4 AVC|H264 Video",
                    "HEVC Video"
                ],
                "stream_type": ["Audio", "Visual"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "ufadts",
            "reframer",
            "ufnalu",
            "ufm4v",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": []
    },
    {
        "name": "aout",
        "description": "Audio output",
        "body": "This filter writes a single uncompressed audio input PID to a sound card or other audio output device.\n\nThe longer the audio buffering bdur is, the longer the audio latency will be (pause/resume). The quality of fast forward audio playback will also be degraded when using large audio buffers.\n\nIf clock is set, the filter will report system time (in us) and corresponding packet CTS for other filters to use for AV sync.\n\n\n",
        "options": {
            "drv": {
                "type": "cstr",
                "description": "audio driver name"
            },
            "bnum": {
                "type": "uint",
                "description": "number of audio buffers (0 for auto)",
                "default": 2
            },
            "bdur": {
                "type": "uint",
                "description": "total duration of all buffers in ms (0 for auto)",
                "default": 100
            },
            "threaded": {
                "type": "bool",
                "description": "force dedicated thread creation if sound card driver is not threaded",
                "default": true
            },
            "dur": {
                "type": "frac",
                "description": "only play the specified duration",
                "default": "0"
            },
            "clock": {
                "type": "bool",
                "description": "hint audio clock for this stream",
                "default": true
            },
            "speed": {
                "type": "dbl",
                "description": "set playback speed. If speed is negative and start is 0, start is set to -1",
                "default": "1.0"
            },
            "start": {
                "type": "dbl",
                "description": "set playback start offset. A negative value means percent of media duration with -1 equal to duration",
                "default": "0.0"
            },
            "vol": {
                "type": "uint",
                "description": "set default audio volume, as a percentage between 0 and 100",
                "default": 100
            },
            "pan": {
                "type": "uint",
                "description": "set stereo pan, as a percentage between 0 and 100, 50 being centered",
                "default": 50
            },
            "buffer": {
                "type": "uint",
                "description": "set playout buffer in ms",
                "default": 200
            },
            "mbuffer": {
                "type": "uint",
                "description": "set max buffer occupancy in ms. If less than buffer, use buffer",
                "default": 0
            },
            "rbuffer": {
                "type": "uint",
                "description": "rebuffer trigger in ms. If 0 or more than buffer, disable rebuffering",
                "default": 0
            },
            "adelay": {
                "type": "frac",
                "description": "set audio delay in sec",
                "default": "0"
            },
            "buffer_done": {
                "type": "bool",
                "description": "buffer done indication (readonly, for user app)"
            },
            "rebuffer": {
                "type": "luint",
                "description": "system time in us at which last rebuffer started, 0 if not rebuffering (readonly, for user app)"
            },
            "media_offset": {
                "type": "dbl",
                "description": "media offset (substract this value to CTS to get media time - readonly)",
                "default": "0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "faad",
            "maddec",
            "a52dec",
            "vorbisdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "resample",
            "rfpcm",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffavf",
            "jsf",
            "restamp"
        ],
        "sinks": []
    },
    {
        "name": "ufm4v",
        "description": "M4V writer",
        "body": "This filter converts MPEG-4 part 2 visual streams into writable format (reinsert decoder config).\n\n\n",
        "options": {
            "rcfg": {
                "type": "bool",
                "description": "force repeating decoder config at each I-frame",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-4 Visual part 2"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["MPEG-4 Visual part 2"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["rfmpgvid", "writegen", "avimx", "m2tsmx", "unframer", ""]
    },
    {
        "name": "ufvc1",
        "description": "VC1 writer",
        "body": "This filter converts VC1 visual streams into writable format (reinsert decoder config and start codes if needed).\n\n\n",
        "options": {
            "rcfg": {
                "type": "bool",
                "description": "force repeating decoder config at each I-frame",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["SMPTE VC-1 Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["SMPTE VC-1 Video"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["writegen", "m2tsmx", "unframer", ""]
    },
    {
        "name": "resample",
        "description": "Audio resampler",
        "body": "This filter resamples raw audio to a target sample rate, number of channels or audio format.\n\n\n",
        "options": {
            "och": {
                "type": "uint",
                "description": "desired number of output audio channels (0 for auto)",
                "default": 0
            },
            "osr": {
                "type": "uint",
                "description": "desired sample rate of output audio (0 for auto)",
                "default": 0
            },
            "osfmt": {
                "type": "afmt",
                "description": "desired sample format of output audio (none for auto)",
                "default": "none"
            },
            "olayout": {
                "type": "str",
                "description": "desired CICP layout of output audio (null for auto)"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "faad",
            "maddec",
            "a52dec",
            "vorbisdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "resample",
            "rfpcm",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffavf",
            "jsf",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "vout",
        "description": "Video output",
        "body": "This filter displays a single visual input PID in a window.\nThe window is created unless a window handle (HWND, xWindow, etc) is indicated in the config file ( [Temp]OSWnd=ptr).\nThe output uses GPAC video output module indicated in drv option or in the config file (see GPAC core help).\nThe video output module can be further configured (see GPAC core help).\nThe filter can use OpenGL or 2D blit of the graphics card, depending on the OS support.\nThe filter can be used do dump frames as written by the graphics card (GPU read-back) using dumpframes.\nIn this case, the window is not visible and only the listed frames are drawn to the GPU.\nThe pixel format of the dumped frame is always RGB in OpenGL and matches the video backbuffer format in 2D mode.\n\n\n",
        "options": {
            "drv": {
                "type": "cstr",
                "description": "video driver name"
            },
            "vsync": {
                "type": "bool",
                "description": "enable video screen sync",
                "default": true
            },
            "drop": {
                "type": "bool",
                "description": "enable dropping late frames",
                "default": true
            },
            "disp": {
                "type": "enum",
                "description": "display mode",
                "default": "gl",
                "enum": {
                    "gl": "OpenGL",
                    "pbo": "OpenGL with PBO",
                    "blit": "2D hardware blit",
                    "soft": "software blit"
                }
            },
            "start": {
                "type": "dbl",
                "description": "set playback start offset. A negative value means percent of media duration with -1 equal to duration",
                "default": "0.0"
            },
            "dur": {
                "type": "lfrac",
                "description": "only play the specified duration",
                "default": "0"
            },
            "speed": {
                "type": "dbl",
                "description": "set playback speed when vsync is on. If speed is negative and start is 0, start is set to -1",
                "default": "1.0"
            },
            "hold": {
                "type": "dbl",
                "description": "number of seconds to hold display for single-frame streams (a negative value force a hold on last frame for single or multi-frames streams)",
                "default": "1.0"
            },
            "linear": {
                "type": "bool",
                "description": "use linear filtering instead of nearest pixel for GL mode",
                "default": true
            },
            "back": {
                "type": "uint",
                "description": "back color for transparent images",
                "default": "0x808080"
            },
            "wsize": {
                "type": "v2di",
                "description": "default init window size",
                "default": "-1x-1"
            },
            "wpos": {
                "type": "v2di",
                "description": "default position (0,0 top-left)",
                "default": "-1x-1"
            },
            "vdelay": {
                "type": "frac",
                "description": "set delay in sec, positive value displays after audio clock",
                "default": "0"
            },
            "hide": {
                "type": "bool",
                "description": "hide output window",
                "default": true
            },
            "fullscreen": {
                "type": "bool",
                "description": "use fullscreen",
                "default": true
            },
            "buffer": {
                "type": "uint",
                "description": "set playout buffer in ms",
                "default": 100
            },
            "mbuffer": {
                "type": "uint",
                "description": "set max buffer occupancy in ms. If less than buffer, use buffer",
                "default": 0
            },
            "rbuffer": {
                "type": "uint",
                "description": "rebuffer trigger in ms. If 0 or more than buffer, disable rebuffering",
                "default": 0
            },
            "dumpframes": {
                "type": "uintl",
                "description": "ordered list of frames to dump, 1 being first frame. Special value 0 means dump all frames"
            },
            "out": {
                "type": "str",
                "description": "radical of dump frame filenames. If no extension provided, frames are exported as $OUT_%d.PFMT",
                "default": "dump"
            },
            "async": {
                "type": "bool",
                "description": "sync video to audio output if any",
                "default": true
            },
            "owsize": {
                "type": "v2di",
                "description": "output window size (readonly)"
            },
            "buffer_done": {
                "type": "bool",
                "description": "buffer done indication (readonly)"
            },
            "rebuffer": {
                "type": "luint",
                "description": "system time in us at which last rebuffer started, 0 if not rebuffering (readonly)"
            },
            "vjs": {
                "type": "bool",
                "description": "use default JS script for vout control",
                "default": true
            },
            "media_offset": {
                "type": "dbl",
                "description": "media offset (substract this value to CTS to get media time - readonly)",
                "default": "0"
            },
            "wid": {
                "type": "uint",
                "description": "window id (readonly)",
                "default": 0
            },
            "vflip": {
                "type": "enum",
                "description": "flip video (GL only)",
                "default": "no",
                "enum": {
                    "no": "no flipping",
                    "v": "vertical flip",
                    "h": "horizontal flip",
                    "vh": "horizontal and vertical",
                    "hv": "same as vh"
                }
            },
            "vrot": {
                "type": "enum",
                "description": "rotate video by given angle",
                "default": "0",
                "enum": {
                    "0": "no rotation",
                    "90": "rotate 90 degree counter clockwise",
                    "180": "rotate 180 degree",
                    "270": "rotate 90 degree clockwise"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual", "13"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "xviddec",
            "j2kdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": []
    },
    {
        "name": "vcrop",
        "description": "Video crop",
        "body": "This filter is used to crop raw video data.\n\n\n",
        "options": {
            "wnd": {
                "type": "str",
                "description": "size of output to crop, indicated as TxLxWxH. If % is indicated after a number, the value is in percent of the source width (for L and W) or height (for T and H). An absolute offset (+x, -x) can be added after percent"
            },
            "copy": {
                "type": "bool",
                "description": "copy the source pixels. By default the filter will try to forward crop frames by adjusting offsets and strides of the source if possible (window contained in frame)",
                "default": true
            },
            "round": {
                "type": "enum",
                "description": "adjust dimension to be a multiple of 2",
                "default": "up",
                "enum": {
                    "up": "up rounding",
                    "down": "down rounding",
                    "allup": "up rounding on formats that do not require it (RGB, YUV444)",
                    "alldown": "down rounding on formats that do not require it (RGB, YUV444)"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "xviddec",
            "j2kdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "vflip",
        "description": "Video flip",
        "body": "This filter flips uncompressed video frames vertically, horizontally, in both directions or no flip\n\n\n",
        "options": {
            "mode": {
                "type": "enum",
                "description": "flip mode",
                "default": "vert",
                "enum": {
                    "off": "no flipping (passthrough)",
                    "vert": "vertical flip",
                    "horiz": "horizontal flip",
                    "both": "horizontal and vertical flip"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "xviddec",
            "j2kdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "rfrawvid",
        "description": "RAW video reframer",
        "body": "This filter parses raw YUV and RGB files/data and outputs corresponding raw video PID and frames.\n\nThe filter also parses YUV4MPEG format.\n\n\n",
        "options": {
            "size": {
                "type": "v2di",
                "description": "source video resolution",
                "default": "0x0"
            },
            "spfmt": {
                "type": "pfmt",
                "description": "source pixel format. When not set, derived from file extension",
                "default": "none"
            },
            "fps": {
                "type": "frac",
                "description": "number of frames per second",
                "default": "25/1"
            },
            "copy": {
                "type": "bool",
                "description": "copy source bytes into output frame. If not set, source bytes are referenced only",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "rfpcm",
        "description": "PCM reframer",
        "body": "This filter parses raw PCM file/data or WAVE files and outputs corresponding raw audio PID and frames.\n\n\n",
        "options": {
            "sr": {
                "type": "uint",
                "description": "sample rate",
                "default": 44100
            },
            "safmt": {
                "type": "afmt",
                "description": "audio format",
                "default": "none"
            },
            "ch": {
                "type": "uint",
                "description": "number of channels",
                "default": 2
            },
            "framelen": {
                "type": "uint",
                "description": "number of samples to put in one audio frame. For planar formats, indicate plane size in samples",
                "default": 1024
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "jpgenc",
        "description": "JPG encoder",
        "body": "This filter encodes a single uncompressed video PID to JPEG using libjpeg.\n\n\n",
        "options": {
            "dctmode": {
                "type": "enum",
                "description": "type of DCT used",
                "default": "fast",
                "enum": {
                    "slow": "precise but slow integer DCT",
                    "fast": "less precise but faster integer DCT",
                    "float": "float DCT"
                }
            },
            "quality": {
                "type": "uint",
                "description": "compression quality",
                "default": 100
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["JPEG Image"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "xviddec",
            "j2kdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "imgdec",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "pngenc",
        "description": "PNG encoder",
        "body": "This filter encodes a single uncompressed video PID to PNG using libpng.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["PNG Image"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "xviddec",
            "j2kdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "imgdec",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rewind",
        "description": "Audio/Video rewinder",
        "body": "This filter reverses audio and video frames in negative playback speed.\nThe filter is in passthrough if speed is positive. Otherwise, it reverts decoded GOPs for video, or revert samples in decoded frame for audio (not really nice for most codecs).\n\n\n",
        "options": {
            "rbuffer": {
                "type": "uint",
                "description": "size of video rewind buffer in frames. If more frames than this, flush is performed",
                "default": 100
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "flist",
        "description": "Sources concatenator",
        "body": "This filter can be used to play playlist files or a list of sources.\n\nThe filter loads any source supported by GPAC: remote or local files or streaming sessions (TS, RTP, DASH or other).\nThe filter demultiplexes inputs and recomputes input timestamps into a continuous timeline.\nAt each new source, the filter tries to remap input PIDs to already declared output PIDs of the same type, if any, or declares new output PIDs otherwise. If no input PID matches the type of an output, no packets are send for that PID.\n\nSource list mode\n\nThe source list mode is activated by using flist:srcs=f1[,f2], where f1 can be a file or a directory to enumerate.\nThe syntax for directory enumeration is:\n\t* dir, dir/ or dir/*: enumerates everything in directory dir\n\t* foo/*.png: enumerates all files with extension png in directory foo\n\t* foo/*.png;*.jpg: enumerates all files with extension png or jpg in directory foo\n\nThe resulting file list can be sorted using fsort.\nIf the sort mode is datex and source files are images or single frame files, the following applies:\n- options floop, revert and fdur are ignored\n- the files are sorted by modification time\n- the first frame is assigned a timestamp of 0\n- each frame (coming from each file) is assigned a duration equal to the difference of modification time between the file and the next file\n- the last frame is assigned the same duration as the previous one\n\nWhen sorting by names:\n- shorter filenames are inserted before longer filenames\n- alphabetical sorting is used if same filename length\n\nPlaylist mode\n\nThe playlist mode is activated when opening a playlist file (m3u format, utf-8 encoding, no BOM, default extensions m3u, txt or pl).\nIn this mode, directives can be given in a comment line, i.e. a line starting with # before the line with the file name.\nLines stating with ## are ignored.\n\nThe playlist file is refreshed whenever the next source has to be reloaded in order to allow for dynamic pushing of sources in the playlist.\nIf the last URL played cannot be found in the playlist, the first URL in the playlist file will be loaded.\n\nWhen ka is used to keep refreshing the playlist on regular basis, the playlist must end with a new line.\nPlaylist refreshing will abort:\n- if the input playlist has a line not ending with a LF (\\n) character, in order to avoid asynchronous issues when reading the playlist.\n- if the input playlist has not been modified for the timeout option value (infinite by default).\n\nPlaylist directives\nA playlist directive line can contain zero or more directives, separated with space. The following directives are supported:\n\t* repeat=N: repeats N times the content (hence played N+1).\n\t* start=T: tries to play the file from start time T seconds (double format only). This may not work with some files/formats not supporting seeking.\n\t* stop=T: stops source playback after T seconds (double format only). This works on any source (implemented independently from seek support).\n\t* cat: specifies that the following entry should be concatenated to the previous source rather than opening a new source. This can optionally specify a byte range if desired, otherwise the full file is concatenated.\nNote: When sources are ISOBMFF files or segments on local storage or GF_FileIO objects, the concatenation will be automatically detected.\n\t* srange=T: when cat is set, indicates the start T (64 bit decimal, default 0) of the byte range from the next entry to concatenate.\n\t* send=T: when cat is set, indicates the end T (64 bit decimal, default 0) of the byte range from the next entry to concatenate.\n\t* props=STR: assigns properties described in STR to all PIDs coming from the listed sources on next line. STR is formatted according to gpac -h doc using the default parameter set.\n\t* del: specifies that the source file(s) must be deleted once processed, true by default if fdel is set.\n\t* out=V: specifies splicing start time (cf below).\n\t* in=V: specifies splicing end time (cf below).\n\t* nosync: prevents timestamp adjustments when joining sources (implied if cat is set).\n\t* keep: keeps spliced period in output (cf below).\n\t* mark: only inject marker for the splice period and do not load any replacement content (cf below).\n\t* sprops=STR: assigns properties described in STR to all PIDs of the main content during a splice (cf below). STR is formatted according to gpac -h doc using the default parameter set.\n\t* chap=NAME: assigns chapter name at the start of next URL (filter always removes source chapter names).\n\nThe following global options (applying to the filter, not the sources) may also be set in the playlist:\n\t* ka=N: force ka option to N millisecond refresh.\n\t* floop=N: set floop option from within playlist.\n\t* raw: set raw option from within playlist.\n\nThe default behavior when joining sources is to realign the timeline origin of the new source to the maximum time in all PIDs of the previous sources.\nThis may create gaps in the timeline in case previous source PIDs are not of equal duration (quite common with most audio codecs).\nUsing nosync directive will disable this realignment and provide a continuous timeline but may introduce synchronization errors depending in the source encoding (use with caution).\n\nSource syntax\nThe source lines follow the usual source syntax, see gpac -h.\nAdditional PID properties can be added per source (see gpac -h doc), but are valid only for the current source, and reset at next source.\nThe loaded sources do not inherit arguments from the parent playlist filter.\n\nThe URL given can either be a single URL, or a list of URLs separated by \" && \" to load several sources for the active entry.\n\nWarning: There shall not be any other space/tab characters between sources.\n\nExample:\naudio.mp4 && video.mp4\n\nSource with filter chains\nEach URL can be followed by a chain of one or more filters, using the @ link directive as used in gpac (see gpac -h doc).\nA negative link index (e.g. @-1) can be used to setup a new filter chain starting from the last specified source in the line.\n\nWarning: There shall be a single character, with value space (' '), before and after each link directive.\n\nExample:\nsrc.mp4 @ reframer:rt=on\nThis will inject a reframer with real-time regulation between source and flist filter.\nExample:\nsrc.mp4 @ reframer:saps=1 @1 reframer:saps=0,2,3\nsrc.mp4 @ reframer:saps=1 @-1 reframer:saps=0,2,3\nThis will inject a reframer filtering only SAP1 frames and a reframer filtering only non-SAP1 frames between source and flist filter\n\nLink options can be specified (see gpac -h doc).\nExample:\nsrc.mp4 @#video reframer:rt=on\nThis will inject a reframer with real-time regulation between video PID of source and flist filter.\n\nWhen using filter chains, the flist filter will only accept PIDs from the last declared filter in the chain.\nIn order to accept other PIDs from the source, you must specify a final link directive with no following filter.\nExample:\nsrc.mp4 @#video reframer:rt=on @-1#audio\nThis will inject a reframer with real-time regulation between video PID of source and flist filter, and will also allow audio PIDs from source to connect to flist filter.\n\nThe empty link directive can also be used on the last declared filter\nExample:\nsrc.mp4 @ reframer:rt=on @#audio\nThis will inject a reframer with real-time regulation between source and flist filter and only connect audio PIDs to flist filter.\n\nSplicing\nThe playlist can be used to splice content with other content following a media in the playlist.\nA source item is declared as main media in a splice operation if and only if it has an out directive set (possibly empty).\nDirective can be used for the main media except concatenation directives.\n\nThe splicing operations do not alter media frames and do not perform uncompressed domain operations such as cross-fade or mixing.\n\nThe out (resp. in) directive specifies the media splice start (resp. end) time. The value can be formatted as follows:\n\t* empty: the time is not yet assigned\n\t* `now`: the time is resolved to the next SAP point in the media\n\t* integer, float or fraction: set time in seconds\n\t* `+VAL`: used for in only, specify the end point as delta in seconds from the start point (VAL can be integer, float or fraction)\n\t* DATE: set splice time according to wall clock DATE, formatted as an XSD dateTime\nThe splice times (except wall clock) are expressed in the source (main media) timing, not the reconstructed output timeline.\n\nWhen a splice begins (out time reached), the source items following the main media are played until the end of the splice or the end of the main media.\nSources used during the splice period can use directives such as start, dur or repeat.\n\nOnce a splice is done (in time reached), the main media out splice time is reset to undefined.\n\nWhen the main media has undefined out or in splice times, the playlist is reloaded at each new main media packet to check for resolved values.\n- out can only be modified when no splice is active, otherwise it is ignored. If modified, it resets the next source to play to be the one following the modified main media.\n- in can only be modified when a splice is active with an undefined end time, otherwise it is ignored.\n\nWhen the main media is over:\n- if repeat directive is set, the main media is repeated, in and out set to their initial values and the next splicing content is the one following the main content,\n- otherwise, the next source queued is the one following the last source played during the last splice period.\n\nIt is allowed to defined several main media in the playlist, but a main media is not allowed as media for a splice period.\n\nThe filter will look for the property Period on the output PIDs of the main media for multi-period DASH.\nIf found, _N is appended to the period ID, with N starting from 1 and increased at each main media resume.\nIf no Period property is set on main or spliced media, period switch can still be forced using -pswitch DASH option.\n\nIf mark directive is set for a main media, no content replacement is done and the splice boundaries will be signaled in the main media.\nIf keep directive is set for a main media, the main media is forwarded along with the replacement content.\nWhen mark or keep directives are set, it is possible to alter the PID properties of the main media using sprops directive.\n\nExample:\n#out=2 in=4 mark sprops=#xlink=http://foo.bar/\nsrc:#Period=main\nThis will inject property xlink on the output PIDs in the splice zone (corresponding to period main_2) but not in the rest of the main media.\n\nDirectives mark, keep and sprops are reset at the end of the splice period.\n\n\n",
        "options": {
            "floop": {
                "type": "sint",
                "description": "loop playlist/list of files, 0 for one time, n for n+1 times, -1 for indefinitely",
                "default": "0"
            },
            "srcs": {
                "type": "strl",
                "description": "list of files to play"
            },
            "fdur": {
                "type": "frac",
                "description": "frame duration for source files with a single frame (0/NaN fraction means reuse source timing which is usually not set!)",
                "default": "1/25"
            },
            "revert": {
                "type": "bool",
                "description": "revert list of files (srcs, not playlist)",
                "default": true
            },
            "timescale": {
                "type": "uint",
                "description": "force output timescale on all PIDs (0 uses the timescale of the first PID found)",
                "default": 0
            },
            "ka": {
                "type": "uint",
                "description": "keep playlist alive (disable loop), waiting for a new input to be added or #end directive to end playlist. The value specifies the refresh rate in ms",
                "default": 0
            },
            "timeout": {
                "type": "luint",
                "description": "timeout in ms after which the playlist is considered dead (-1 means indefinitely)",
                "default": "-1"
            },
            "fsort": {
                "type": "enum",
                "description": "sort list of files",
                "default": "no",
                "enum": {
                    "no": "no sorting, use default directory enumeration of OS",
                    "name": "sort by alphabetical name",
                    "size": "sort by increasing size",
                    "date": "sort by increasing modification time",
                    "datex": "sort by increasing modification time"
                }
            },
            "sigcues": {
                "type": "bool",
                "description": "inject CueStart property at each source begin (new or repeated) for DASHing",
                "default": true
            },
            "fdel": {
                "type": "bool",
                "description": "delete source files after processing in playlist mode (does not delete the playlist)",
                "default": true
            },
            "raw": {
                "type": "enum",
                "description": "force input AV streams to be in raw format",
                "default": "no",
                "enum": {
                    "no": "do not force decoding of inputs",
                    "av": "force decoding of audio and video inputs",
                    "a": "force decoding of audio inputs",
                    "v": "force decoding of video inputs"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "fin",
            "httpin",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "m2tsmx",
        "description": "MPEG-2 TS multiplexer",
        "body": "This filter multiplexes one or more input PIDs into a MPEG-2 Transport Stream multiplex.\n\nPID selection\n\nThe MPEG-2 TS multiplexer assigns M2TS PID for media streams using the PID of the PMT plus the stream index.\nFor example, the default config creates the first program with a PMT PID 100, the first stream will have a PID of 101.\nStreams are grouped in programs based on input PID property ServiceID if present. If absent, stream will go in the program with service ID as indicated by sid option.\n- name option is overridden by input PID property ServiceName.\n- provider option is overridden by input PID property ServiceProvider.\n- pcr_offset option is overridden by input PID property \"tsmux:pcr_offset\"\n- first_pts option is overridden by input PID property \"tsmux:force_pts\"\n- temi option is overridden by input PID property \"tsmux:temi\"\n\nTime and External Media Information (TEMI)\n\nThe temi option allows specifying a list of URLs or timeline IDs to insert in streams of a program.\nOne or more TEMI timeline can be specified per PID.\nThe syntax is a comma-separated list of one or more TEMI description.\nEach TEMI description is formatted as ID_OR_URL or #OPT1[#OPT2]#ID_OR_URL. Options are:\n\t* S`N`: indicate the target service with ID N\n\t* T`N`: set timescale to use (default: PID timescale)\n\t* D`N`: set delay in ms between two TEMI url descriptors (default 1000)\n\t* O`N`: set offset (max 64 bits) to add to TEMI timecodes (default 0). If timescale is not specified, offset value is in ms, otherwise in timescale units.\n\t* I`N`: set initial value (max 64 bits) of TEMI timecodes. If not set, initial value will match first packet CTS. If timescale is not specified, value is in PID timescale units, otherwise in specified timescale units.\n\t* P`N`: indicate target PID in program. Possible values are\n\t  * `V`: only insert for video streams.\n\t  * `A`: only insert for audio streams.\n\t  * `T`: only insert for text streams.\n\t  * N: only insert for stream with index N (0-based) in the program.\n\t* L`C`: set 64bit timecode signaling. Possible values for C are:\n\t  * `A`: automatic switch between 32 and 64 bit depending on timecode value (default if not specified).\n\t  * `Y`: use 64 bit signaling only.\n\t  * `N`: use 32 bit signaling only and wrap around timecode value.\n\t* N: insert NTP timestamp in TEMI timeline descriptor\n\t* ID_OR_URL: If number, indicate the TEMI ID to use for external timeline. Otherwise, give the URL to insert\n  \nExample:\ntemi=\"url\"\nInserts a TEMI URL+timecode in the each stream of each program.\nExample:\ntemi=\"#P0#url,#P1#4\"\nInserts a TEMI URL+timecode in the first stream of all programs and an external TEMI with ID 4 in the second stream of all programs.\nExample:\ntemi=\"#P0#2,#P0#url,#P1#4\"\nInserts a TEMI with ID 2 and a TEMI URL+timecode in the first stream of all programs, and an external TEMI with ID 4 in the second stream of all programs.\nExample:\ntemi=\"#S20#4,#S10#URL\"\nInserts an external TEMI with ID 4 in the each stream of program with ServiceID 20 and a TEMI URL in each stream of program with ServiceID 10.\nExample:\ntemi=\"#N#D500#PV#T30000#4\"\nInserts an external TEMI with ID 4 and timescale 30000, NTP injection and carousel of 500 ms in the video stream of all programs.\n\nWarning: multipliers (k,m,g) are not supported in TEMI options.\n\nAdaptive Streaming\n\nIn DASH and HLS mode:\n- the PCR is always initialized at 0, and flush_rap is automatically set.\n- unless nb_pack is specified, 200 TS packets will be used as pack output in DASH mode.\n- pes_pack=none is forced since some demultiplexers have issues with non-aligned ADTS PES.\n\nThe filter watches the property FileNumber on incoming packets to create new files, or new segments in DASH mode.\nThe filter will look for property M2TSRA set on the input stream.\nThe value can either be a 4CC or a string, indicating the MP2G-2 TS Registration tag for unknown media types.\n\n\n",
        "options": {
            "breq": {
                "type": "uint",
                "description": "buffer requirements in ms for input PIDs",
                "default": 100
            },
            "pmt_id": {
                "type": "uint",
                "description": "define the ID of the first PMT to use in the mux",
                "default": 100
            },
            "rate": {
                "type": "uint",
                "description": "target rate in bps of the multiplex. If not set, variable rate is used",
                "default": 0
            },
            "pmt_rate": {
                "type": "uint",
                "description": "interval between PMT in ms",
                "default": 200
            },
            "pat_rate": {
                "type": "uint",
                "description": "interval between PAT in ms",
                "default": 200
            },
            "first_pts": {
                "type": "luint",
                "description": "force PTS value of first packet, in 90kHz",
                "default": "0"
            },
            "pcr_offset": {
                "type": "luint",
                "description": "offset all timestamps from PCR by V, in 90kHz (default value is computed based on input media)",
                "default": "-1"
            },
            "mpeg4": {
                "type": "enum",
                "description": "force usage of MPEG-4 signaling (IOD and SL Config)",
                "default": "none",
                "enum": {
                    "none": "disables 4on2",
                    "full": "sends AUs as SL packets over section for OD, section/pes for scene (cf bifs_pes)",
                    "scene": "sends only scene streams as 4on2 but uses regular PES without SL for audio and video"
                }
            },
            "pmt_version": {
                "type": "uint",
                "description": "set version number of the PMT",
                "default": 200
            },
            "disc": {
                "type": "bool",
                "description": "set the discontinuity marker for the first packet of each stream",
                "default": true
            },
            "repeat_rate": {
                "type": "uint",
                "description": "interval in ms between two carousel send for MPEG-4 systems (overridden by CarouselRate PID property if defined)",
                "default": 0
            },
            "repeat_img": {
                "type": "uint",
                "description": "interval in ms between re-sending (as PES) of single-image streams (if 0, image data is sent once only)",
                "default": 0
            },
            "max_pcr": {
                "type": "uint",
                "description": "set max interval in ms between 2 PCR",
                "default": 100
            },
            "nb_pack": {
                "type": "uint",
                "description": "pack N TS packets in output packets",
                "default": 4
            },
            "pes_pack": {
                "type": "enum",
                "description": "set AU to PES packing mode",
                "default": "audio",
                "enum": {
                    "audio": "will pack only multiple audio AUs in a PES",
                    "none": "make exactly one AU per PES",
                    "all": "will pack multiple AUs per PES for all streams"
                }
            },
            "realtime": {
                "type": "bool",
                "description": "use real-time output",
                "default": true
            },
            "bifs_pes": {
                "type": "enum",
                "description": "select BIFS streams packetization (PES vs sections)",
                "default": "off",
                "enum": {
                    "on": "uses BIFS PES",
                    "off": "uses BIFS sections",
                    "copy": "uses BIFS PES but removes timestamps in BIFS SL and only carries PES timestamps"
                }
            },
            "flush_rap": {
                "type": "bool",
                "description": "force flushing mux program when RAP is found on video, and injects PAT and PMT before the next video PES begin",
                "default": true
            },
            "pcr_only": {
                "type": "bool",
                "description": "enable PCR-only TS packets",
                "default": true
            },
            "pcr_init": {
                "type": "lsint",
                "description": "set initial PCR value for the programs. A negative value means random value is picked",
                "default": "-1"
            },
            "sid": {
                "type": "uint",
                "description": "set service ID for the program",
                "default": 0
            },
            "name": {
                "type": "str",
                "description": "set service name for the program"
            },
            "provider": {
                "type": "str",
                "description": "set service provider name for the program"
            },
            "sdt_rate": {
                "type": "uint",
                "description": "interval in ms between two DVB SDT tables (if 0, SDT is disabled)",
                "default": 0
            },
            "temi": {
                "type": "str",
                "description": "insert TEMI time codes in adaptation field"
            },
            "log_freq": {
                "type": "uint",
                "description": "delay between logs for realtime mux",
                "default": 500
            },
            "latm": {
                "type": "bool",
                "description": "use LATM AAC encapsulation instead of regular ADTS",
                "default": true
            },
            "subs_sidx": {
                "type": "sint",
                "description": "number of subsegments per sidx (negative value disables sidx)",
                "default": "-1"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "SMPTE VC-1 Video",
                    "VVC Video",
                    "MPEG-4 Visual part 2",
                    "AOM AV1 Video",
                    "HEVC Video Layered Extensions",
                    "MPEG-4 AVC|H264 Scalable Video Coding",
                    "MPEG-4 AVC|H264 Multiview Video Coding",
                    "Raw media",
                    "MPEG-H AudioMux",
                    "MPEG-H Audio",
                    "MPEG-4 AVC|H264 Video",
                    "HEVC Video"
                ],
                "stream_type": ["File", "Encrypted", "Audio", "Visual"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "ufmhas",
            "reframer",
            "ufnalu",
            "vobsubdmx",
            "ufm4v",
            "ufvc1",
            "jpgenc",
            "pngenc",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "ufobu",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "m2tsdmx",
            "fout",
            "pout",
            "sockout",
            "rtpout",
            "httpout",
            "tssplit",
            "routeout",
            ""
        ]
    },
    {
        "name": "dasher",
        "description": "DASH and HLS segmenter",
        "body": "This filter provides segmentation and manifest generation for MPEG-DASH and HLS formats.\nThe segmenter currently supports:\n- MPD and m3u8 generation (potentially in parallel)\n- ISOBMFF, MPEG-2 TS, MKV and raw bitstream segment formats\n- override of profiles and levels in manifest for codecs\n- most MPEG-DASH profiles\n- static and dynamic (live) manifest offering\n- context store and reload for batch processing of live/dynamic sessions\n\nThe filter does perform per-segment real-time regulation using sreg.\nIf you need per-frame real-time regulation on non-real-time inputs, insert a reframer before to perform real-time regulation.\nExample:\ngpac -i file.mp4 reframer:rt=on -o live.mpd:dmode=dynamic\n\nTemplate strings\nThe segmenter uses templates to derive output file names, regardless of the DASH mode (even when templates are not used). The default one is $File$_dash for ondemand and single file modes, and $File$_$Number$ for separate segment files\nExample:\ntemplate=Great_$File$_$Width$_$Number$\nIf input is foo.mp4 with 640x360 video resolution, this will resolve in Great_foo_640_$Number$ for the DASH template.\nExample:\ntemplate=Great_$File$_$Width$\nIf input is foo.mp4 with 640x360 video resolution, this will resolve in Great_foo_640.mp4 for onDemand case.\n\nStandard DASH replacement strings: \n\t* $Number[%%0Nd]$: replaced by the segment number, possibly prefixed with 0\n\t* $RepresentationID$: replaced by representation name\n\t* $Time$: replaced by segment start time\n\t* $Bandwidth$: replaced by representation bandwidth.\nNote: these strings are not replaced in the manifest templates elements.\n\nAdditional replacement strings (not DASH, not generic GPAC replacements but may occur multiple times in template):\n\t* $Init=NAME$: replaced by NAME for init segment, ignored otherwise\n\t* $XInit=NAME$: complete replace by NAME for init segment, ignored otherwise\n\t* $Index=NAME$: replaced by NAME for index segments, ignored otherwise\n\t* $Path=PATH$: replaced by PATH when creating segments, ignored otherwise\n\t* $Segment=NAME$: replaced by NAME for media segments, ignored for init segments\n\t* $FS$ (FileSuffix): replaced by _trackN in case the input is an AV multiplex, or kept empty otherwise\nNote: these strings are replaced in the manifest templates elements.\n\nPID assignment and configuration\nTo assign PIDs into periods and adaptation sets and configure the session, the segmenter looks for the following properties on each input PID:\n\t* `Representation`: assigns representation ID to input PID. If not set, the default behavior is to have each media component in different adaptation sets. Setting the Representation allows explicit multiplexing of the source(s)\n\t* `Period`: assigns period ID to input PID. If not set, the default behavior is to have all media in the same period with the same start time\n\t* `PStart`: assigns period start. If not set, 0 is assumed, and periods appear in the Period ID declaration order. If negative, this gives the period order (-1 first, then -2 ...). If positive, this gives the true start time and will abort DASHing at period end\nNote: When both positive and negative values are found, the by-order periods (negative) will be inserted AFTER the timed period (positive)\n\t* `ASID`: assigns parent adaptation set ID. If not 0, only sources with same AS ID will be in the same adaptation set\nNote: If multiple streams in source, only the first stream will have an AS ID assigned\n\t* `xlink`: for remote periods, only checked for null PID\n\t* `Role`, `PDesc`, `ASDesc`, `ASCDesc`, `RDesc`: various descriptors to set for period, AS or representation\n\t* `BUrl`: overrides segmenter [-base] with a set of BaseURLs to use for the PID (per representation)\n\t* `Template`: overrides segmenter template for this PID\n\t* `DashDur`: overrides segmenter segment duration for this PID\n\t* `StartNumber`: sets the start number for the first segment in the PID, default is 1\n\t* `IntraOnly`: indicates input PID follows HLS EXT-X-I-FRAMES-ONLY guidelines\n\t* `CropOrigin`: indicates x and y coordinates of video for SRD (size is video size)\n\t* `SRD`: indicates SRD position and size of video for SRD, ignored if CropOrigin is set\n\t* `SRDRef`: indicates global width and height of SRD, ignored if CropOrigin is set\n\t* `HLSMExt`: list of extensions to add to master playlist entries, ['foo','bar=val'] added as ,foo,bar=val\n\t* `HLSVExt`: list of extensions to add to variant playlist, ['#foo','#bar=val'] added as #foo \\n #bar=val\n\t* Non-dash properties: Bitrate, SAR, Language, Width, Height, SampleRate, NumChannels, Language, ID, DependencyID, FPS, Interlaced, Codec. These properties are used to setup each representation and can be overridden on input PIDs using the general PID property settings (cf global help).\n  \nExample:\ngpac -i test.mp4:#Bitrate=1M -o test.mpd\nThis will force declaring a bitrate of 1M for the representation, regardless of actual input bitrate.\nExample:\ngpac -i muxav.mp4 -o test.mpd\nThis will create un-multiplexed DASH segments.\nExample:\ngpac -i muxav.mp4:#Representation=1 -o test.mpd\nThis will create multiplexed DASH segments.\nExample:\ngpac -i m1.mp4 -i m2.mp4:#Period=Yep -o test.mpd\nThis will put src m1.mp4 in first period, m2.mp4 in second period.\nExample:\ngpac -i m1.mp4:#BUrl=http://foo/bar -o test.mpd\nThis will assign a baseURL to src m1.mp4.\nExample:\ngpac -i m1.mp4:#ASCDesc=<ElemName val=\"attval\">text</ElemName> -o test.mpd\nThis will assign the specified XML descriptor to the adaptation set.\nNote:  this can be used to inject most DASH descriptors not natively handled by the segmenter.\nThe segmenter handles the XML descriptor as a string and does not attempt to validate it. Descriptors, as well as some segmenter filter arguments, are string lists (comma-separated by default), so that multiple descriptors can be added:\nExample:\ngpac -i m1.mp4:#RDesc=<Elem attribute=\"1\"/>,<Elem2>text</Elem2> -o test.mpd\nThis will insert two descriptors in the representation(s) of m1.mp4.\nExample:\ngpac -i video.mp4:#Template=foo$Number$ -i audio.mp4:#Template=bar$Number$ -o test.mpd\nThis will assign different templates to the audio and video sources.\nExample:\ngpac -i null:#xlink=http://foo/bar.xml:#PDur=4 -i m.mp4:#PStart=-1 -o test.mpd\nThis will insert an create an MPD with first a remote period then a regular one.\nExample:\ngpac -i null:#xlink=http://foo/bar.xml:#PStart=6 -i m.mp4 -o test.mpd\nThis will create an MPD with first a regular period, dashing only 6s of content, then a remote one.\nExample:\ngpac -i v1:#SRD=0x0x1280x360:#SRDRef=1280x720 -i v2:#SRD=0x360x1280x360 -o test.mpd\nThis will layout the v2 below v1 using a global SRD size of 1280x720.\n\nThe segmenter will create multiplexing filter chains for each representation and will reassign PID IDs so that each media component (video, audio, ...) in an adaptation set has the same ID.\n\nFor HLS, the output PID will deliver the master playlist and the variant playlists.\nThe default variant playlist are $NAME_$N.m3u8, where $NAME is the radical of the output file name and $N is the 1-based index of the variant.\n\nSegmentation\nThe default behavior of the segmenter is to estimate the theoretical start time of each segment based on target segment duration, and start a new segment when a packet with SAP type 1,2,3 or 4 with time greater than the theoretical time is found.\nThis behavior can be changed to find the best SAP packet around a segment theoretical boundary using sbound:\n\t* `closest` mode: the segment will start at the closest SAP of the theoretical boundary\n\t* `in` mode: the segment will start at or before the theoretical boundary\n\nWarning: These modes will introduce delay in the segmenter (typically buffering of one GOP) and should not be used for low-latency modes.\n\nThe segmenter can also be configured to:\n- completely ignore SAP when segmenting using sap.\n- ignore SAP on non-video streams when segmenting using strict_sap.\n\nThe segmenter will by default announce a new segment in the manifest(s) as soon as its size/offset is known or its name is known, but the segment (or part in LL-HLS) may still not be completely written/sent.\nThis may result in temporary mismatches between segment/part size currently received versus size as advertized in manifest.\nIf the target destination cannot support this, use seg_sync to update manifest(s) only once segments/parts are completely flushed; this will however slightly increase the latency of manifest updates.\n\nDynamic (real-time live) Mode\nThe dasher does not perform real-time regulation by default.\nFor regular segmentation, you should enable segment regulation sreg if your sources are not real-time.\nExample:\ngpac -i source.mp4 -o live.mpd:segdur=2:profile=live:dmode=dynamic:sreg\n\nFor low latency segmentation with fMP4, you will need to specify the following options:\n\t* cdur: set the fMP4 fragment duration\n\t* asto: set the availability time offset for DASH. This value should be equal or slightly greater than segment duration minus cdur\n\t* llhls: enable low latency for HLS\n\nNote: llhls will force CMAF to cmfc if cmaf is not set.\n\nIf your sources are not real-time, insert a reframer filter with real-time regulation\nExample:\ngpac -i source.mp4 reframer:rt=on -o live.mpd:segdur=2:cdur=0.2:asto=1.8:profile=live:dmode=dynamic\nThis will create DASH segments of 2 seconds made of fragments of 200 ms and indicate to the client that requests can be made 1.8 seconds earlier than segment complete availability on server.\nExample:\ngpac -i source.mp4 reframer:rt=on -o live.m3u8:segdur=2:cdur=0.2:llhls=br:dmode=dynamic\nThis will create DASH segments of 2 seconds made of fragments of 200 ms and produce HLS low latency parts using byte ranges in the final segment.\nExample:\ngpac -i source.mp4 reframer:rt=on -o live.m3u8:segdur=2:cdur=0.2:llhls=sf:dmode=dynamic\nThis will create DASH segments of 2 seconds made of fragments of 200 ms and produce HLS low latency parts using dedicated files.\n\nYou can combine LL-HLS and DASH-LL generation:\nExample:\ngpac -i source.mp4 reframer:rt=on -o live.mpd:dual:segdur=2:cdur=0.2:asto=1.8:llhls=br:profile=live:dmode=dynamic\n\nFor DASH, the filter will use the local clock for UTC anchor points in DASH.\nThe filter can fetch and signal clock in other ways using utcs.\nExample:\n[opts]:utcs=inband\nThis will use the local clock and insert in the MPD a UTCTiming descriptor containing the local clock.\nExample:\n[opts]::utcs=http://time.akamai.com[::opts]\nThis will fetch time from http://time.akamai.com, use it as the UTC reference for segment generation and insert in the MPD a UTCTiming descriptor containing the time server URL.\nNote: if not set as a global option using --utcs=, you must escape the url using double :: or use other separators.\n\nCue-driven segmentation\nThe segmenter can take a list of instructions, or Cues, to use for the segmentation process, in which case only these are used to derive segment boundaries. Cues can be set through XML files or injected in input packets.\n\nCue files can be specified for the entire segmenter, or per PID using DashCue property.\nCues are given in an XML file with a root element called <DASHCues>, with currently no attribute specified. The children are one or more <Stream> elements, with attributes:\n\t* id: integer for stream/track/PID ID\n\t* timescale: integer giving the units of following timestamps\n\t* mode: if present and value is edit, the timestamp are in presentation time (edit list applied) otherwise they are in media time\n\t* ts_offset: integer giving a value (in timescale) to subtract to the DTS/CTS values listed\n\nThe children of <Stream> are one or more <Cue> elements, with attributes:\n\t* sample: integer giving the sample/frame number of a sample at which splitting shall happen\n\t* dts: long integer giving the decoding time stamp of a sample at which splitting shall happen\n\t* cts: long integer giving the composition / presentation time stamp of a sample at which splitting shall happen\n\nWarning: Cues shall be listed in decoding order.\n\nIf the DashCue property of a PID equals inband, the PID will be segmented according to the CueStart property of input packets.\nThis feature is typically combined with a list of files as input:\nExample:\ngpac -i list.m3u:sigcues -o res/live.mpd\nThis will load the flist filter in cue mode, generating continuous timelines from the sources and injecting a CueStart property at each new file.\n\nIf the cues option equals none, the DashCue property of input PIDs will be ignored.\n\nManifest Generation only mode\nThe segmenter can be used to generate manifests from already fragmented ISOBMFF inputs using sigfrag.\nIn this case, segment boundaries are attached to each packet starting a segment and used to drive the segmentation.\nThis can be used with single-track ISOBMFF sources, either single file or multi file.\nFor single file source:\n- if onDemand profile is requested, sources have to be formatted as a DASH self-initializing media segment with the proper sidx.\n- templates are disabled.\n- sseg is forced for all profiles except onDemand ones.\nFor multi files source:\n- input shall be a playlist containing the initial file followed by the ordered list of segments.\n- if no template is provided, the full or main profile will be used\n\t* if [-template]() is provided, it shall be correct: the filter will not try to guess one from the input file names and will not validate it either.\n\nThe manifest generation-only mode supports both MPD and HLS generation.\n\nExample:\ngpac -i ondemand_src.mp4 -o dash.mpd:sigfrag:profile=onDemand\nThis will generate a DASH manifest for onDemand Profile based on the input file.\nExample:\ngpac -i ondemand_src.mp4 -o dash.m3u8:sigfrag\nThis will generate a HLS manifest based on the input file.\nExample:\ngpac -i seglist.txt -o dash.mpd:sigfrag\nThis will generate a DASH manifest in Main Profile based on the input files.\nExample:\ngpac -i seglist.txt:Template=$XInit=init$$q1/$Number$ -o dash.mpd:sigfrag:profile=live\nThis will generate a DASH manifest in live Profile based on the input files. The input file will contain init.mp4, q1/1.m4s, q1/2.m4s...\n\nCue Generation only mode\nThe segmenter can be used to only generate segment boundaries from a set of inputs using gencues, without generating manifests or output files.\nIn this mode, output PIDs are declared directly rather than redirected to media segment files.\nThe segmentation logic is not changed, and packets are forwarded with the same information and timing as in regular mode.\n\nOutput PIDs are forwarded with DashCue=inband property, so that any subsequent dasher follows the same segmentation process (see above).\n\nThe first packet in a segment has:\n- property FileNumber (and, if multiple files, FileName) set as usual\n- property CueStart set\n- property DFPStart=0 set if this is the first packet in a period\n\nThis mode can be used to pre-segment the streams for later processing that must take place before final dashing.\nExample:\ngpac -i source.mp4 dasher:gencues cecrypt:cfile=roll_seg.xml -o live.mpd\nThis will allow the encrypter to locate dash boundaries and roll keys at segment boundaries.\nExample:\ngpac -i s1.mp4 -i s2.mp4:#CryptInfo=clear:#Period=3 -i s3.mp4:#Period=3 dasher:gencues cecrypt:cfile=roll_period.xml -o live.mpd\nIf the DRM file uses keyRoll=period, this will generate:\n- first period crypted with one key\n- second period clear\n- third period crypted with another key\n\nMultiplexer development considerations\nOutput multiplexers allowing segmented output must obey the following:\n- inspect packet properties\n\t * FileNumber: if set, indicate the start of a new DASH segment\n\t * FileName: if set, indicate the file name. If not present, output shall be a single file. This is only set for packet carrying the FileNumber property, and only on one PID (usually the first) for multiplexed outputs\n\t * IDXName: gives the optional index name. If not present, index shall be in the same file as dash segment. Only used for MPEG-2 TS for now\n\t * EODS: property is set on packets with no payload and no timestamp to signal the end of a DASH segment. This is only used when stopping/resuming the segmentation process, in order to flush segments without dispatching an EOS (see subdur )\n- for each segment done, send a downstream event on the first connected PID signaling the size of the segment and the size of its index if any\n- for multiplexers with init data, send a downstream event signaling the size of the init and the size of the global index if any\n- the following filter options are passed to multiplexers, which should declare them as arguments:\n\t * noinit: disables output of init segment for the multiplexer (used to handle bitstream switching with single init in DASH)\n\t * frag: indicates multiplexer shall use fragmented format (used for ISOBMFF mostly)\n\t * subs_sidx=0: indicates an SIDX shall be generated - only added if not already specified by user\n\t * xps_inband=all|no|both: indicates AVC/HEVC/... parameter sets shall be sent inband, out of band, or both\n\t * nofragdef: indicates fragment defaults should be set in each segment rather than in init segment\n\nThe segmenter adds the following properties to the output PIDs:\n\t* DashMode: identifies VoD (single file with global index) or regular DASH mode used by segmenter\n\t* DashDur: identifies target DASH segment duration - this can be used to estimate the SIDX size for example\n\t* LLHLS: identifies LLHLS is used; the multiplexer must send fragment size events back to the dasher, and set LLHLSFragNum on the first packet of each fragment\n\t* SegSync: indicates that fragments/segments must be completely flushed before sending back size events\n\n\n",
        "options": {
            "segdur": {
                "type": "frac",
                "description": "target segment duration in seconds. A value less than or equal to 0 defaults to 1.0 second",
                "default": "0/0"
            },
            "tpl": {
                "type": "bool",
                "description": "use template mode (multiple segment, template URLs)",
                "default": true
            },
            "stl": {
                "type": "bool",
                "description": "use segment timeline (ignored in on_demand mode)",
                "default": true
            },
            "dmode": {
                "type": "enum",
                "description": "dash content mode",
                "default": "static",
                "enum": {
                    "static": "static content",
                    "dynamic": "live generation",
                    "dynlast": "last call for live, will turn the MPD into static"
                }
            },
            "sseg": {
                "type": "bool",
                "description": "single segment is used",
                "default": true
            },
            "sfile": {
                "type": "bool",
                "description": "use a single file for all segments (default in on_demand)",
                "default": true
            },
            "align": {
                "type": "bool",
                "description": "enable segment time alignment between representations",
                "default": true
            },
            "sap": {
                "type": "bool",
                "description": "enable splitting segments at SAP boundaries",
                "default": true
            },
            "mix_codecs": {
                "type": "bool",
                "description": "enable mixing different codecs in an adaptation set",
                "default": true
            },
            "ntp": {
                "type": "enum",
                "description": "insert/override NTP clock at the beginning of each segment",
                "default": "rem",
                "enum": {
                    "rem": "removes NTP from all input packets",
                    "yes": "inserts NTP at each segment start",
                    "keep": "leaves input packet NTP untouched"
                }
            },
            "no_sar": {
                "type": "bool",
                "description": "do not check for identical sample aspect ratio for adaptation sets",
                "default": true
            },
            "bs_switch": {
                "type": "enum",
                "description": "bitstream switching mode (single init segment)",
                "default": "def",
                "enum": {
                    "def": "resolves to off for onDemand and inband for live",
                    "off": "disables BS switching",
                    "on": "enables it if same decoder configuration is possible",
                    "inband": "moves decoder config inband if possible",
                    "both": "inband and outband parameter sets",
                    "pps": "moves PPS and APS inband, keep VPS,SPS and DCI out of band (used for VVC RPR)",
                    "force": "enables it even if only one representation",
                    "multi": "uses multiple stsd entries in ISOBMFF"
                }
            },
            "template": {
                "type": "str",
                "description": "template string to use to generate segment name"
            },
            "segext": {
                "type": "str",
                "description": "file extension to use for segments"
            },
            "initext": {
                "type": "str",
                "description": "file extension to use for the init segment"
            },
            "muxtype": {
                "type": "enum",
                "description": "muxtype to use for the segments",
                "default": "auto",
                "enum": {
                    "mp4": "uses ISOBMFF format",
                    "ts": "uses MPEG-2 TS format",
                    "mkv": "uses Matroska format",
                    "webm": "uses WebM format",
                    "ogg": "uses OGG format",
                    "raw": "uses raw media format (disables multiplexed representations)",
                    "auto": "guess format based on extension, default to mp4 if no extension"
                }
            },
            "rawsub": {
                "type": "bool",
                "description": "use raw subtitle format instead of encapsulating in container",
                "default": true
            },
            "asto": {
                "type": "dbl",
                "description": "availabilityStartTimeOffset to use in seconds. A negative value simply increases the AST, a positive value sets the ASToffset to representations",
                "default": "0"
            },
            "profile": {
                "type": "enum",
                "description": "target DASH profile. This will set default option values to ensure conformance to the desired profile. For MPEG-2 TS, only main and live are used, others default to main",
                "default": "auto",
                "enum": {
                    "auto": "turns profile to live for dynamic and full for non-dynamic",
                    "live": "DASH live profile, using segment template",
                    "onDemand": "MPEG-DASH live profile",
                    "main": "MPEG-DASH main profile, using segment list",
                    "full": "MPEG-DASH full profile",
                    "hbbtv1.5.live": "HBBTV 1.5 DASH profile",
                    "dashavc264.live": "DASH-IF live profile",
                    "dashavc264.onDemand": "DASH-IF onDemand profile",
                    "dashif.ll": "DASH IF low-latency profile (set UTC server to time.akamai.com if none set)"
                }
            },
            "profX": {
                "type": "str",
                "description": "list of profile extensions, as used by DASH-IF and DVB. The string will be colon-concatenated with the profile used"
            },
            "cp": {
                "type": "enum",
                "description": "content protection element location",
                "default": "set",
                "enum": {
                    "set": "in adaptation set element",
                    "rep": "in representation element",
                    "both": "in both adaptation set and representation elements"
                }
            },
            "pssh": {
                "type": "enum",
                "description": "storage mode for PSSH box",
                "default": "v",
                "enum": {
                    "f": "stores in movie fragment only",
                    "v": "stores in movie only, or movie and fragments if key roll is detected",
                    "m": "stores in mpd only",
                    "mf": "stores in mpd and movie fragment",
                    "mv": "stores in mpd and movie",
                    "n": "discard pssh from mpd and segments"
                }
            },
            "buf": {
                "type": "sint",
                "description": "min buffer duration in ms. negative value means percent of segment duration (e.g. -150 = 1.5*seg_dur)",
                "default": "-100"
            },
            "spd": {
                "type": "sint",
                "description": "suggested presentation delay in ms",
                "default": "0"
            },
            "timescale": {
                "type": "sint",
                "description": "set timescale for timeline and segment list/template. A value of 0 picks up the first timescale of the first stream in an adaptation set. A negative value forces using stream timescales for each timed element (multiplication of segment list/template/timelines). A positive value enforces the MPD timescale",
                "default": "0"
            },
            "check_dur": {
                "type": "bool",
                "description": "check duration of sources in period, trying to have roughly equal duration. Enforced whenever period start times are used",
                "default": true
            },
            "skip_seg": {
                "type": "bool",
                "description": "increment segment number whenever an empty segment would be produced - NOT DASH COMPLIANT",
                "default": true
            },
            "title": {
                "type": "str",
                "description": "MPD title"
            },
            "source": {
                "type": "str",
                "description": "MPD Source"
            },
            "info": {
                "type": "str",
                "description": "MPD info url"
            },
            "cprt": {
                "type": "str",
                "description": "MPD copyright string"
            },
            "lang": {
                "type": "str",
                "description": "language of MPD Info"
            },
            "location": {
                "type": "strl",
                "description": "set MPD locations to given URL"
            },
            "base": {
                "type": "strl",
                "description": "set base URLs of MPD"
            },
            "refresh": {
                "type": "dbl",
                "description": "refresh rate for dynamic manifests, in seconds (a negative value sets the MPD duration, value 0 uses dash duration)",
                "default": "0"
            },
            "tsb": {
                "type": "dbl",
                "description": "time-shift buffer depth in seconds (a negative value means infinity)",
                "default": "30"
            },
            "subdur": {
                "type": "dbl",
                "description": "maximum duration of the input file to be segmented. This does not change the segment duration, segmentation stops once segments produced exceeded the duration",
                "default": "0"
            },
            "ast": {
                "type": "str",
                "description": "set start date (as xs:date, e.g. YYYY-MM-DDTHH:MM:SSZ) for live mode. Default is now. !! Do not use with multiple periods, nor when DASH duration is not a multiple of GOP size !!"
            },
            "state": {
                "type": "str",
                "description": "path to file used to store/reload state info when simulating live. This is stored as a valid MPD with GPAC XML extensions"
            },
            "loop": {
                "type": "bool",
                "description": "loop sources when dashing with subdur and state. If not set, a new period is created once the sources are over",
                "default": true
            },
            "split": {
                "type": "bool",
                "description": "enable cloning samples for text/metadata/scene description streams, marking further clones as redundant",
                "default": true
            },
            "hlsc": {
                "type": "bool",
                "description": "insert clock reference in variant playlist in live HLS",
                "default": true
            },
            "cues": {
                "type": "str",
                "description": "set cue file"
            },
            "strict_cues": {
                "type": "bool",
                "description": "strict mode for cues, complains if splitting is not on SAP type 1/2/3 or if unused cue is found",
                "default": true
            },
            "strict_sap": {
                "type": "enum",
                "description": "strict mode for sap",
                "default": "off",
                "enum": {
                    "off": "ignore SAP types for PID other than video, enforcing _startsWithSAP=1_",
                    "sig": "same as off but keep _startsWithSAP_ to the true SAP value",
                    "on": "warn if any PID uses SAP 3 or 4 and switch to FULL profile",
                    "intra": "ignore SAP types greater than 3 on all media types"
                }
            },
            "subs_sidx": {
                "type": "sint",
                "description": "number of subsegments per sidx. negative value disables sidx. Only used to inherit sidx option of destination",
                "default": "-1"
            },
            "cmpd": {
                "type": "bool",
                "description": "skip line feed and spaces in MPD XML for compactness",
                "default": true
            },
            "styp": {
                "type": "str",
                "description": "indicate the 4CC to use for styp boxes when using ISOBMFF output"
            },
            "dual": {
                "type": "bool",
                "description": "indicate to produce both MPD and M3U files"
            },
            "sigfrag": {
                "type": "bool",
                "description": "use manifest generation only mode"
            },
            "sbound": {
                "type": "enum",
                "description": "indicate how the theoretical segment start TSS (= segment_number * duration) should be handled",
                "default": "out",
                "enum": {
                    "out": "segment split as soon as TSS is exceeded (TSS <= segment_start)",
                    "closest": "segment split at closest SAP to theoretical bound",
                    "in": "TSS is always in segment (TSS >= segment_start)"
                }
            },
            "reschedule": {
                "type": "bool",
                "description": "reschedule sources with no period ID assigned once done (dynamic mode only)",
                "default": true
            },
            "sreg": {
                "type": "bool",
                "description": "regulate the session",
                "default": true
            },
            "scope_deps": {
                "type": "bool",
                "description": "scope PID dependencies to be within source. If disabled, PID dependencies will be checked across all input PIDs regardless of their sources",
                "default": true
            },
            "utcs": {
                "type": "str",
                "description": "URL to use as time server / UTCTiming source. Special value inband enables inband UTC (same as publishTime), special prefix xsd@ uses xsDateTime schemeURI rather than ISO"
            },
            "force_flush": {
                "type": "bool",
                "description": "force generating a single segment for each input. This can be useful in batch mode when average source duration is known and used as segment duration but actual duration may sometimes be greater",
                "default": true
            },
            "last_seg_merge": {
                "type": "bool",
                "description": "force merging last segment if less than half the target duration",
                "default": true
            },
            "mha_compat": {
                "type": "enum",
                "description": "adaptation set generation mode for compatible MPEG-H Audio profile",
                "default": "no",
                "enum": {
                    "no": "only generate the adaptation set for the main profile",
                    "comp": "only generate the adaptation sets for all compatible profiles",
                    "all": "generate the adaptation set for the main profile and all compatible profiles"
                }
            },
            "mname": {
                "type": "str",
                "description": "output manifest name for ATSC3 multiplexing"
            },
            "llhls": {
                "type": "enum",
                "description": "HLS low latency type",
                "default": "off",
                "enum": {
                    "off": "do not use LL-HLS",
                    "br": "use LL-HLS with byte-range for segment parts, pointing to full segment (DASH-LL compatible)",
                    "sf": "use separate files for segment parts (post-fixed .1, .2 etc.)",
                    "brsf": "generate two sets of manifest, one for byte-range and one for files (_IF added before extension of manifest)"
                }
            },
            "hlsdrm": {
                "type": "str",
                "description": "cryp file info for HLS full segment encryption"
            },
            "hlsx": {
                "type": "strl",
                "description": "list of string to append to master HLS header before variants with ['#foo','#bar=val'] added as #foo \\n #bar=val"
            },
            "ll_preload_hint": {
                "type": "bool",
                "description": "inject preload hint for LL-HLS",
                "default": true
            },
            "ll_rend_rep": {
                "type": "bool",
                "description": "inject rendition reports for LL-HLS",
                "default": true
            },
            "ll_part_hb": {
                "type": "dbl",
                "description": "user-defined part hold-back for LLHLS, negative value means 3 times max part duration in session",
                "default": "-1"
            },
            "ckurl": {
                "type": "str",
                "description": "set the ClearKey URL common to all encrypted streams (overriden by CKUrl pid property)"
            },
            "hls_absu": {
                "type": "enum",
                "description": "use absolute url in HLS generation using first URL in base",
                "default": "no",
                "enum": {
                    "no": "do not use absolute URL",
                    "var": "use absolute URL only in variant playlists",
                    "mas": "use absolute URL only in master playlist",
                    "both": "use absolute URL everywhere"
                }
            },
            "seg_sync": {
                "type": "bool",
                "description": "force waiting for last packet of fragment/segment to be written before announcing segment in DASH/HLS playlist",
                "default": true
            },
            "cmaf": {
                "type": "enum",
                "description": "use cmaf guidelines",
                "default": "no",
                "enum": {
                    "no": "CMAF not enforced",
                    "cmfc": "use CMAF cmfc guidelines",
                    "cmf2": "use CMAF cmf2 guidelines"
                }
            },
            "chain": {
                "type": "str",
                "description": "URL of next MPD for regular chaining"
            },
            "chain_fbk": {
                "type": "str",
                "description": "URL of fallback MPD"
            },
            "gencues": {
                "type": "bool",
                "description": "only insert segment boundaries and do not generate manifests",
                "default": true
            },
            "force_init": {
                "type": "bool",
                "description": "force init segment creation in bitstream switching mode",
                "default": true
            },
            "keep_src": {
                "type": "bool",
                "description": "keep source URLs in manifest generation mode",
                "default": true
            },
            "gxns": {
                "type": "bool",
                "description": "insert some gpac extensions in manifest (for now, only tfdt of first segment)",
                "default": true
            },
            "dkid": {
                "type": "enum",
                "description": "control injection of default KID in MPD",
                "default": "auto",
                "enum": {
                    "off": "default KID not injected",
                    "on": "default KID always injected",
                    "auto": "default KID only injected if no key roll is detected (as per DASH-IF guidelines)"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media", "Codec Not Supported"],
                "stream_type": ["File", "Audio", "Visual"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "fin",
            "btplay",
            "httpin",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "routein",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "fin",
            "httpin",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "fout",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "tileagg",
            "tilesplit",
            "pin",
            "pout",
            "gsfmx",
            "sockout",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "routeout",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "tileagg",
        "description": "HEVC tile aggregator",
        "body": "This filter aggregates a set of split tiled HEVC streams (hvt1 or hvt2 in ISOBMFF) into a single HEVC stream.\n\n\n",
        "options": {
            "tiledrop": {
                "type": "uintl",
                "description": "specify indexes of tiles to drop"
            },
            "ttimeout": {
                "type": "uint",
                "description": "number of milliseconds to wait until considering a tile packet lost, 0 waits forever",
                "default": 10000
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["VVC Subpicture Video", "VVC Video", "HEVC tiles Video", "HEVC Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["VVC Video", "HEVC Video"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tilesplit",
            "gsfdmx",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "vtbdec",
            "mcdec",
            "cecrypt",
            "mp4mx",
            "rfnalu",
            "reframer",
            "writegen",
            "ufnalu",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "tilesplit",
            "gsfmx",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "unframer",
            "writeuf",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "tilesplit",
        "description": "HEVC tile bitstream splitter",
        "body": "This filter splits an HEVC tiled stream into tiled HEVC streams (hvt1 or hvt2 in ISOBMFF).\nThe filter will move to passthrough mode if the bitstream is not tiled.\nIf the Bitrate property is set on the input PID, the output tile PIDs will have a bitrate set to (Bitrate - 10k)/nb_opids, 10 kbps being reserved for the base.\n\nEach tile PID will be assigned the following properties:\n\t* `ID`: equal to the base PID ID (same as input) plus the 1-based index of the tile in raster scan order.\n\t* `TileID`: equal to the 1-based index of the tile in raster scan order.\n\nWarning: The filter does not check if tiles are independently-coded (MCTS) !\n\nWarning: Support for dynamic changes of tiling grid has not been tested !\n\n\n",
        "options": {
            "tiledrop": {
                "type": "uintl",
                "description": "specify indexes of tiles to drop (0-based, in tile raster scan order)"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["HEVC Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["HEVC tiles Video", "HEVC Video"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "tileagg",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffmx",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "pin",
        "description": "pipe input",
        "body": "This filter handles generic input pipes (mono-directional) in blocking or non blocking mode.\n\nWarning: Input pipes cannot seek.\n\nData format of the pipe may be specified using extension (either in file name or through ext) or MIME type through mime.\nNote: Unless disabled at session level (see -no-probe ), file extensions are usually ignored and format probing is done on the first data block.\n\nstdin pipe\n\nThe filter can handle reading from stdin, by using - or stdin as input file name.\nExample:\ngpac -i - vout\ngpac -i stdin vout\n\nNamed pipes\n\nThe filter can handle reading from named pipes. The associated protocol scheme is pipe:// when loaded as a generic input (e.g. -i pipe://URL where URL is a relative or absolute pipe name).\nOn Windows hosts, the default pipe prefix is \\\\.\\pipe\\gpac\\ if no prefix is set.\ndst=mypipe resolves in \\\\.\\pipe\\gpac\\mypipe\ndst=\\\\.\\pipe\\myapp\\mypipe resolves in \\\\.\\pipe\\myapp\\mypipe\nAny destination name starting with \\\\ is used as is, with \\ translated in /.\n\nInput pipes are created by default in non-blocking mode.\n\nThe filter can create the pipe if not found using mkp. On windows hosts, this will create a pipe server.\nOn non windows hosts, the created pipe will delete the pipe file upon filter destruction.\n  \nInput pipes can be setup to run forever using ka. In this case:\n- any potential pipe close on the writing side will be ignored\n- end of stream will be triggered upon pipe close if sigeos is set\n- final end of stream will be triggered upon session close.\n  \nThis can be useful to pipe raw streams from different process into gpac:\n\t* Receiver side: gpac -i pipe://mypipe:ext=.264:mkp:ka\n\t* Sender side: cat raw1.264 > mypipe && gpac -i raw2.264 -o pipe://mypipe:ext=.264  \nThe pipe input can be created in blocking mode or non-blocking mode.\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "name of source pipe"
            },
            "block_size": {
                "type": "uint",
                "description": "buffer size used to read pipe",
                "default": 5000
            },
            "ext": {
                "type": "str",
                "description": "indicate file extension of pipe data"
            },
            "mime": {
                "type": "str",
                "description": "indicate mime type of pipe data"
            },
            "blk": {
                "type": "bool",
                "description": "open pipe in block mode",
                "default": true
            },
            "ka": {
                "type": "bool",
                "description": "keep-alive pipe when end of input is detected",
                "default": true
            },
            "mkp": {
                "type": "bool",
                "description": "create pipe if not found",
                "default": true
            },
            "sigeos": {
                "type": "bool",
                "description": "signal end of stream whenever a pipe breaks in keep-alive mode",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": []
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "dashin",
            "cdcrypt",
            "nhmlr",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            ""
        ]
    },
    {
        "name": "pout",
        "description": "pipe output",
        "body": "This filter handles generic output pipes (mono-directional) in blocking mode only.\n\nWarning: Output pipes do not currently support non blocking mode.\n\nThe associated protocol scheme is pipe:// when loaded as a generic output (e.g. -o pipe://URL where URL is a relative or absolute pipe name).\nData format of the pipe shall be specified using extension (either in filename or through ext option) or MIME type through mime\nThe pipe name indicated in dst can use template mechanisms from gpac, e.g. dst=pipe_$ServiceID$\n\nOn Windows hosts, the default pipe prefix is \\\\.\\pipe\\gpac\\ if no prefix is set \ndst=mypipe resolves in \\\\.\\pipe\\gpac\\mypipe\ndst=\\\\.\\pipe\\myapp\\mypipe resolves in \\\\.\\pipe\\myapp\\mypipe\nAny destination name starting with \\\\ is used as is, with \\ translated in /\n\nThe pipe input can create the pipe if not found using mkp. On windows hosts, this will create a pipe server.\nOn non windows hosts, the created pipe will delete the pipe file upon filter destruction.\nThe pipe can be kept alive after a broken pipe is detected using ka. This is typically used when clients crash/exits and resumes.\nWhen a keep-alive pipe is broken, input data is discarded and the filter will keep trashing data as fast as possible.\nIt is therefore recommended to use this mode with real-time inputs (use a reframer if needed).\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "name of destination pipe"
            },
            "ext": {
                "type": "str",
                "description": "indicate file extension of pipe data"
            },
            "mime": {
                "type": "str",
                "description": "indicate mime type of pipe data"
            },
            "dynext": {
                "type": "bool",
                "description": "indicate the file extension is set by filter chain, not dst",
                "default": true
            },
            "start": {
                "type": "dbl",
                "description": "set playback start offset. A negative value means percent of media duration with -1 equal to duration",
                "default": "0.0"
            },
            "speed": {
                "type": "dbl",
                "description": "set playback speed. If negative and start is 0, start is set to -1",
                "default": "1.0"
            },
            "mkp": {
                "type": "bool",
                "description": "create pipe if not found",
                "default": true
            },
            "block_size": {
                "type": "uint",
                "description": "buffer size used to write to pipe, windows only",
                "default": 5000
            },
            "ka": {
                "type": "bool",
                "description": "keep pipe alive when broken pipe is detected",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "mp4mx",
            "nhmlr",
            "rtpin",
            "writegen",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "pin",
            "gsfmx",
            "gsfdmx",
            "routein",
            "rtpout",
            "httpout",
            "tssplit",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx"
        ],
        "sinks": []
    },
    {
        "name": "gsfmx",
        "description": "GSF Multiplexer",
        "body": "This filter provides GSF (GPAC Serialized Format) multiplexing.\nIt serializes the stream states (config/reconfig/info update/remove/eos) and packets of input PIDs. This allows either saving to file a session, or forwarding the state/data of streams to another instance of GPAC using either pipes or sockets. Upstream events are not serialized.\n\nThe default behavior does not insert sequence numbers. When running over general protocols not ensuring packet order, this should be inserted.\nThe serializer sends tune-in packets (global and per PID) at the requested carousel rate - if 0, no carousel. These packets are marked as redundant so that they can be discarded by output filters if needed.\n\nEncryption\n\nThe stream format can be encrypted in AES 128 CBC mode. For all packets, the packet header (header, size, frame size/block offset and optional seq num) are in the clear and the following bytes until the last byte of the last multiple of block size (16) fitting in the payload are encrypted.\nFor data packets, each fragment is encrypted individually to avoid error propagation in case of losses.\nFor other packets, the entire packet is encrypted before fragmentation (fragments cannot be processed individually).\nFor header/tunein packets, the first 25 bytes after the header are in the clear (signature,version,IV and pattern).\nThe IV is constant to avoid packet overhead, randomly generated if not set and sent in the initial stream header. Pattern mode can be used (cf CENC cbcs) to encrypt K block and leave N blocks in the clear.\n\nFiltering properties\n\nThe header/tunein packet may get quite big when all PID properties are kept. In order to help reduce its size, the minp option can be used: this will remove all built-in properties marked as droppable (cf property help) as well as all non built-in properties.\nThe skp option may also be used to specify which property to drop:\nExample:\nskp=\"4CC1,Name2\nThis will remove properties of type 4CC1 and properties (built-in or not) of name Name2.\n\nFile mode\n\nBy default the filter only accepts framed media streams as input PID, not files. This can be changed by explicitly loading the filter with ext or dst set.\nExample:\ngpac -i source.mp4 gsfmx:dst=manifest.mpd -o dump.gsf\nThis will DASH the source and store every files produced as PIDs in the GSF mux.\nIn order to demultiplex such a file, the gsfdmxfilter will likely need to be explicitly loaded:\nExample:\ngpac -i mux.gsf gsfdmx -o dump/$File$:dynext:clone\nThis will extract all files from the GSF mux.\n\nBy default when working in file mode, the filter only accepts PIDs of type file as input.\nTo allow a mix of files and streams, use mixed:\nExample:\ngpac -i source.mp4 gsfmx:dst=manifest.mpd:mixed -o dump.gsf\nThis will DASH the source, store the manifest file and the media streams with their packet properties in the GSF mux.\n\n\n",
        "options": {
            "sigsn": {
                "type": "bool",
                "description": "signal packet sequence number after header field and before size field. Sequence number is per PID, encoded on 16 bits. Header packet does not have a SN",
                "default": true
            },
            "sigdur": {
                "type": "bool",
                "description": "signal duration",
                "default": true
            },
            "sigbo": {
                "type": "bool",
                "description": "signal byte offset",
                "default": true
            },
            "sigdts": {
                "type": "bool",
                "description": "signal decoding timestamp",
                "default": true
            },
            "dbg": {
                "type": "enum",
                "description": "set debug mode",
                "default": "no",
                "enum": {
                    "no": "disable debug",
                    "nodata": "force packet size to 0",
                    "nopck": "skip packet"
                }
            },
            "key": {
                "type": "mem",
                "description": "encrypt packets using given key"
            },
            "IV": {
                "type": "mem",
                "description": "set IV for encryption - a constant IV is used to keep packet overhead small (cbcs-like)"
            },
            "pattern": {
                "type": "frac",
                "description": "set nb_crypt / nb_skip block pattern. default is all encrypted",
                "default": "1/0"
            },
            "mpck": {
                "type": "uint",
                "description": "set max packet size. 0 means no fragmentation (each AU is sent in one packet)",
                "default": 0
            },
            "magic": {
                "type": "str",
                "description": "magic string to append in setup packet"
            },
            "skp": {
                "type": "str",
                "description": "comma separated list of PID property names to skip"
            },
            "minp": {
                "type": "bool",
                "description": "include only the minimum set of properties required for stream processing",
                "default": true
            },
            "crate": {
                "type": "dbl",
                "description": "carousel period for tune-in info in seconds",
                "default": "0"
            },
            "ext": {
                "type": "str",
                "description": "file extension for file mode"
            },
            "dst": {
                "type": "str",
                "description": "target URL in file mode"
            },
            "mixed": {
                "type": "bool",
                "description": "allow GSF to contain both files and media streams",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": ["fout", "pout", "gsfdmx", "sockout", "httpout", "routeout", ""]
    },
    {
        "name": "gsfdmx",
        "description": "GSF demultiplexer",
        "body": "This filter provides GSF (GPAC Serialized Format) demultiplexing.\nIt de-serializes the stream states (config/reconfig/info update/remove/eos) and packets in the GSF bytestream.\nThis allows either reading a session saved to file, or receiving the state/data of streams from another instance of GPAC using either pipes or sockets\n\nThe stream format can be encrypted in AES 128 CBC mode, in which case the demultiplexing filter must be given a 128 bit key.\n\n\n",
        "options": {
            "key": {
                "type": "mem",
                "description": "key for decrypting packets"
            },
            "magic": {
                "type": "str",
                "description": "magic string to check in setup packet"
            },
            "mq": {
                "type": "uint",
                "description": "set max packet queue length for loss detection. 0 will flush incomplete packet when a new one starts",
                "default": 4
            },
            "pad": {
                "type": "uint",
                "description": "byte value used to pad lost packets",
                "default": 0
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File", "Audio", "Visual", "Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "writegen",
            "pin",
            "gsfmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "fout",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "vobsubdmx",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pout",
            "gsfmx",
            "sockout",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "sockout",
        "description": "UDP/TCP output",
        "body": "This filter handles generic output sockets (mono-directional) in blocking mode only.\nThe filter can work in server mode, waiting for source connections, or in client mode, directly connecting to a server.\nIn server mode, the filter can be instructed to keep running at the end of the stream.\nIn server mode, the default behavior is to keep input packets when no more clients are connected; this can be adjusted though the kp option, however there is no realtime regulation of how fast packets are dropped.\nIf your sources are not real time, consider adding a real-time scheduler in the chain (cf reframer filter), or set the send rate option.\n\n- UDP sockets are used for destinations URLs formatted as udp://NAME\n- TCP sockets are used for destinations URLs formatted as tcp://NAME\n- UDP unix domain sockets are used for destinations URLs formatted as udpu://NAME\n- TCP unix domain sockets are used for destinations URLs formatted as tcpu://NAME\n\nWhen ports are specified in the URL and the default option separators are used (see gpac -h doc), the URL must either:\n- have a trailing '/', e.g. udp://localhost:1234/[:opts]\n- use gpac escape, e.g. udp://localhost:1234[:gpac:opts]\n\nThe socket output can be configured to drop or revert packet order for test purposes.\nA window size in packets is specified as the drop/revert fraction denominator, and the index of the packet to drop/revert is given as the numerator/\nIf the numerator is 0, a packet is randomly chosen in that window.\nExample:\n:pckd=4/10\nThis drops every 4th packet of each 10 packet window.\nExample:\n:pckr=0/100\nThis reverts the send order of one random packet in each 100 packet window.\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "URL of destination"
            },
            "sockbuf": {
                "type": "uint",
                "description": "block size used to read file",
                "default": 65536
            },
            "port": {
                "type": "uint",
                "description": "default port if not specified",
                "default": 1234
            },
            "ifce": {
                "type": "cstr",
                "description": "default multicast interface"
            },
            "ext": {
                "type": "str",
                "description": "file extension of pipe data"
            },
            "mime": {
                "type": "str",
                "description": "mime type of pipe data"
            },
            "listen": {
                "type": "bool",
                "description": "indicate the output socket works in server mode",
                "default": true
            },
            "maxc": {
                "type": "uint",
                "description": "max number of concurrent connections",
                "default": "+I"
            },
            "ka": {
                "type": "bool",
                "description": "keep socket alive if no more connections",
                "default": true
            },
            "kp": {
                "type": "bool",
                "description": "keep packets in queue if no more clients",
                "default": true
            },
            "start": {
                "type": "dbl",
                "description": "set playback start offset. A negative value means percent of media duration with -1 equal to duration",
                "default": "0.0"
            },
            "speed": {
                "type": "dbl",
                "description": "set playback speed. If negative and start is 0, start is set to -1",
                "default": "1.0"
            },
            "rate": {
                "type": "uint",
                "description": "set send rate in bps, disabled by default (as fast as possible)",
                "default": 0
            },
            "pckr": {
                "type": "frac",
                "description": "reverse packet every N",
                "default": "0/0"
            },
            "pckd": {
                "type": "frac",
                "description": "drop packet every N",
                "default": "0/0"
            },
            "ttl": {
                "type": "uint",
                "description": "multicast TTL",
                "default": 0
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "mp4mx",
            "nhmlr",
            "rtpin",
            "writegen",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "pin",
            "gsfmx",
            "gsfdmx",
            "routein",
            "rtpout",
            "httpout",
            "tssplit",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx"
        ],
        "sinks": []
    },
    {
        "name": "rfav1",
        "description": "AV1/IVF/VP9 reframer",
        "body": "This filter parses AV1 OBU, AV1 AnnexB or IVF with AV1 or VP9 files/data and outputs corresponding visual PID and frames.\n\n\n",
        "options": {
            "fps": {
                "type": "frac",
                "description": "import frame rate (0 default to FPS from bitstream or 25 Hz)",
                "default": "0/1000"
            },
            "index": {
                "type": "dbl",
                "description": "indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 20M (slows down importers) unless a play with start range > 0 is issued",
                "default": "-1.0"
            },
            "importer": {
                "type": "bool",
                "description": "compatibility with old importer",
                "default": true
            },
            "deps": {
                "type": "bool",
                "description": "import sample dependency information",
                "default": true
            },
            "notime": {
                "type": "bool",
                "description": "ignore input timestamps, rebuild from 0",
                "default": true
            },
            "temporal_delim": {
                "type": "bool",
                "description": "keep temporal delimiters in reconstructed frames",
                "default": true
            },
            "bsdbg": {
                "type": "enum",
                "description": "debug OBU parsing in media@debug logs",
                "default": "off",
                "enum": {
                    "off": "not enabled",
                    "on": "enabled",
                    "full": "enable with number of bits dumped"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["AOM AV1 Video", "VP10 Video", "VP9 Video", "VP8 Video"],
                "stream_type": ["File", "Visual"]
            },
            "output": {
                "codec_id": ["AOM AV1 Video", "VP10 Video", "VP9 Video", "VP8 Video"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "ufobu",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "ufobu",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "ufobu",
        "description": "IVF/OBU/annexB writer",
        "body": "This filter rewrites VPx or AV1 bitstreams into a IVF, annexB or OBU sequence.\nThe temporal delimiter OBU is re-inserted in annexB (.av1 and .av1bfiles, with obu_size set) and OBU sequences (.obufiles, without obu_size)\nNote: VP8/9 codecs will only use IVF output (equivalent to file extension .ivf or :ext=ivf set on output).\n\n\n",
        "options": {
            "rcfg": {
                "type": "bool",
                "description": "force repeating decoder config at each I-frame",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["AOM AV1 Video", "VP10 Video", "VP9 Video", "VP8 Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["AOM AV1 Video", "VP10 Video", "VP9 Video", "VP8 Video"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "rfav1",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["writegen", "avimx", "m2tsmx", "rfav1", "unframer", ""]
    },
    {
        "name": "nvdec",
        "description": "NVidia decoder",
        "body": "Warning: CUVID SDK NOT AVAILABLE ON THIS SYSTEM !\n\n\nThis filter decodes MPEG-2, MPEG-4 Part 2, AVC|H264 and HEVC streams through NVidia decoder. It allows GPU frame dispatch or direct frame copy.\nIf the SDK is not available, the configuration key nvdec@disabled will be written in configuration file to avoid future load attempts.\n\n\n",
        "options": {
            "num_surfaces": {
                "type": "uint",
                "description": "number of hardware surfaces to allocate",
                "default": 20
            },
            "unload": {
                "type": "enum",
                "description": "decoder unload mode",
                "default": "no",
                "enum": {
                    "no": "keep inactive decoder alive",
                    "destroy": "destroy inactive decoder",
                    "reuse": "detach decoder from inactive PIDs and reattach to active ones"
                }
            },
            "vmode": {
                "type": "enum",
                "description": "video decoder backend",
                "default": "cuvid",
                "enum": {
                    "cuvid": "use dedicated video engines directly",
                    "cuda": "use a CUDA-based decoder if faster than dedicated engines",
                    "dxva": "go through DXVA internally if possible (requires D3D9)"
                }
            },
            "fmode": {
                "type": "enum",
                "description": "frame output mode",
                "default": "gl",
                "enum": {
                    "copy": "each frame is copied and dispatched",
                    "single": "frame data is only retrieved when used, single memory space for all frames (not safe if multiple consumers)",
                    "gl": "frame data is mapped to an OpenGL texture"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-2 Visual Main",
                    "MPEG-4 Visual part 2",
                    "MPEG-2 Visual High",
                    "MPEG-2 Visual SNR",
                    "MPEG-2 Visual Spatial",
                    "MPEG-2 Visual 422",
                    "MPEG-4 AVC|H264 Video",
                    "HEVC Video"
                ],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "routein",
        "description": "ROUTE input",
        "body": "This filter is a receiver for ROUTE sessions (ATSC 3.0 and generic ROUTE).\n- ATSC 3.0 mode is identified by the URL atsc://.\n- Generic ROUTE mode is identified by the URL route://IP:PORT.\n\nThe filter can work in cached mode, source mode or standalone mode.\n\nCached mode\n\nThe cached mode is the default filter behavior. It populates GPAC HTTP Cache with the received files, using http://groute/serviceN/ as service root, N being the ROUTE service ID.\nIn cached mode, repeated files are always pushed to cache.\nThe maximum number of media segment objects in cache per service is defined by nbcached; this is a safety used to force object removal in case DASH client timing is wrong and some files are never requested at cache level.\n  \nThe cached MPD is assigned the following headers:\n\t* `x-route`: integer value, indicates the ROUTE service ID.\n\t* `x-route-first-seg`: string value, indicates the name of the first segment (completely or currently being) retrieved from the broadcast.\n\t* `x-route-ll`: boolean value, if yes indicates that the indicated first segment is currently being received (low latency signaling).\n\t* `x-route-loop`: boolean value, if yes indicates a loop in the service has been detected (usually pcap replay loop).\n  \nThe cached files are assigned the following headers:\n\t* `x-route`: boolean value, if yes indicates the file comes from an ROUTE session.\n\nIf max_segs is set, file deletion event will be triggered in the filter chain.\n\nSource mode\n\nIn source mode, the filter outputs files on a single output PID of type file. The files are dispatched once fully received, the output PID carries a sequence of complete files. Repeated files are not sent unless requested.\nIf needed, one PID per TSI can be used rather than a single PID. This avoids mixing files of different mime types on the same PID (e.g. HAS manifest and ISOBMFF).\nExample:\ngpac -i atsc://gcache=false -o $ServiceID$/$File$:dynext\nThis will grab the files and forward them as output PIDs, consumed by the fout filter.\n\nIf max_segs is set, file deletion event will be triggered in the filter chain.\n\nStandalone mode\n\nIn standalone mode, the filter does not produce any output PID and writes received files to the odir directory.\nExample:\ngpac -i atsc://:odir=output\nThis will grab the files and write them to output directory.\n\nIf max_segs is set, old files will be deleted.\n\nFile Repair\n\nIn case of losses or incomplete segment reception (during tune-in), the files are patched as follows:\n\t* MPEG-2 TS: all lost ranges are adjusted to 188-bytes boundaries, and transformed into NULL TS packets.\n\t* ISOBMFF: all top-level boxes are scanned, and incomplete boxes are transformed in free boxes, except mdat kept as is if repair is set to simple.\n\nIf kc option is set, corrupted files will be kept. If fullseg is not set and files are only partially received, they will be kept.\n\nInterface setup\n\nOn some systems (OSX), when using VM packet replay, you may need to force multicast routing on your local interface.\nFor ATSC, you will have to do this for the base signaling multicast (224.0.23.60):\nExample:\nroute add -net 224.0.23.60/32 -interface vboxnet0\nThen for each ROUTE service in the multicast:\nExample:\nroute add -net 239.255.1.4/32 -interface vboxnet0\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "URL of source content"
            },
            "ifce": {
                "type": "str",
                "description": "default interface to use for multicast. If NULL, the default system interface will be used"
            },
            "gcache": {
                "type": "bool",
                "description": "indicate the files should populate GPAC HTTP cache",
                "default": true
            },
            "tunein": {
                "type": "sint",
                "description": "service ID to bootstrap on for ATSC 3.0 mode (0 means tune to no service, -1 tune all services -2 means tune on first service found)",
                "default": "-2"
            },
            "buffer": {
                "type": "uint",
                "description": "receive buffer size to use in bytes",
                "default": "0x80000"
            },
            "timeout": {
                "type": "uint",
                "description": "timeout in ms after which tunein fails",
                "default": 5000
            },
            "nbcached": {
                "type": "uint",
                "description": "number of segments to keep in cache per service",
                "default": 8
            },
            "kc": {
                "type": "bool",
                "description": "keep corrupted file",
                "default": true
            },
            "skipr": {
                "type": "bool",
                "description": "skip repeated files (ignored in cache mode)",
                "default": true
            },
            "stsi": {
                "type": "bool",
                "description": "define one output PID per tsi/serviceID (ignored in cache mode)",
                "default": true
            },
            "stats": {
                "type": "uint",
                "description": "log statistics at the given rate in ms (0 disables stats)",
                "default": 1000
            },
            "tsidbg": {
                "type": "uint",
                "description": "gather only objects with given TSI (debug)",
                "default": 0
            },
            "max_segs": {
                "type": "uint",
                "description": "maximum number of segments to keep on disk",
                "default": 0
            },
            "odir": {
                "type": "str",
                "description": "output directory for standalone mode"
            },
            "reorder": {
                "type": "bool",
                "description": "ignore order flag in ROUTE/LCT packets, avoiding considering object done when TOI changes",
                "default": true
            },
            "rtimeout": {
                "type": "uint",
                "description": "default timeout in ms to wait when gathering out-of-order packets",
                "default": 5000
            },
            "fullseg": {
                "type": "bool",
                "description": "only dispatch full segments in cache mode (always true for other modes)",
                "default": true
            },
            "repair": {
                "type": "enum",
                "description": "repair mode for corrupted files",
                "default": "simple",
                "enum": {
                    "no": "no repair is performed",
                    "simple": "simple repair is performed (incomplete mdat boxes will be kept)",
                    "strict": "incomplete mdat boxes will be lost as well as preceding moof boxes",
                    "full": "HTTP-based repair, not yet implemented"
                }
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": []
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "dashin",
            "cdcrypt",
            "nhmlr",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            ""
        ]
    },
    {
        "name": "rtpout",
        "description": "RTP Streamer",
        "body": "The RTP streamer handles SDP/RTP output streaming.\n\nSDP mode\n\nWhen the destination URL is an SDP, the filter outputs an SDP on a file PID and streams RTP packets over UDP, starting from the indicated port.\n\nDirect RTP mode\n\nWhen the destination URL uses the protocol scheme rtp://IP:PORT, the filter does not output any SDP and streams a single input over RTP, using PORT indicated in the destination URL, or the first port configured.\nIn this mode, it is usually needed to specify the desired format using ext or mime.\nExample:\ngpac -i src -o rtp://localhost:1234/:ext=ts\nThis will indicate that the RTP streamer expects a MPEG-2 TS mux as an input.\n\nRTP Packets\n\nThe RTP packets produced have a maximum payload set by the mtu option (IP packet will be MTU + 40 bytes of IP+UDP+RTP headers).\nThe real-time scheduling algorithm works as follows:\n- first initialize the clock by:\n  - computing the smallest timestamp for all input PIDs\n  - mapping this media time to the system clock\n- determine the earliest packet to send next on each input PID, adding delay if any\n- finally compare the packet mapped timestamp TS to the system clock SC. When TS - SC is less than tt, the RTP packets for the source packet are sent\n\nThe filter does not check for RTCP timeout and will run until all input PIDs reach end of stream.\n\n\n",
        "options": {
            "ip": {
                "type": "str",
                "description": "destination IP address (NULL is 127.0.0.1)"
            },
            "port": {
                "type": "uint",
                "description": "port for first stream in session",
                "default": 7000
            },
            "loop": {
                "type": "bool",
                "description": "loop all streams in session (not always possible depending on source type)",
                "default": true
            },
            "mpeg4": {
                "type": "bool",
                "description": "send all streams using MPEG-4 generic payload format if possible",
                "default": true
            },
            "mtu": {
                "type": "uint",
                "description": "size of RTP MTU in bytes",
                "default": 1460
            },
            "ttl": {
                "type": "uint",
                "description": "time-to-live for multicast packets",
                "default": 2
            },
            "ifce": {
                "type": "str",
                "description": "default network interface to use"
            },
            "payt": {
                "type": "uint",
                "description": "payload type to use for dynamic decoder configurations",
                "default": 96
            },
            "delay": {
                "type": "sint",
                "description": "send delay for packet (negative means send earlier)",
                "default": "0"
            },
            "tt": {
                "type": "uint",
                "description": "time tolerance in microseconds. Whenever schedule time minus realtime is below this value, the packet is sent right away",
                "default": 1000
            },
            "runfor": {
                "type": "sint",
                "description": "run for the given time in ms. Negative value means run for ever (if loop) or source duration, 0 only outputs the sdp",
                "default": "-1"
            },
            "tso": {
                "type": "sint",
                "description": "set timestamp offset in microseconds. Negative value means random initial timestamp",
                "default": "-1"
            },
            "xps": {
                "type": "bool",
                "description": "force parameter set injection at each SAP. If not set, only inject if different from SDP ones",
                "default": true
            },
            "latm": {
                "type": "bool",
                "description": "use latm for AAC payload format",
                "default": true
            },
            "dst": {
                "type": "cstr",
                "description": "URL for direct RTP mode"
            },
            "ext": {
                "type": "str",
                "description": "file extension for direct RTP mode"
            },
            "mime": {
                "type": "cstr",
                "description": "set mime type for direct RTP mode"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "fin",
            "btplay",
            "httpin",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "writegen",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "routein",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": ["rtpin", "fout", "pout", "sockout", "httpout", "routeout", ""]
    },
    {
        "name": "rtspout",
        "description": "RTSP Server",
        "body": "The RTSP server partially implements RTSP 1.0, with support for OPTIONS, DESCRIBE, SETUP, PLAY, PAUSE and TEARDOWN.\nMultiple PLAY ranges are not supported, PLAY range end is not supported, PAUSE range is not supported.\nOnly aggregated control is supported for PLAY and PAUSE, PAUSE/PLAY on single stream is not supported.\nThe server only runs on TCP, and handles request in sequence: it will not probe for commands until previous response is sent.\nThe server supports both RTP over UDP delivery and RTP interleaved over RTSP delivery.\n\nThe scheduling algorithm and RTP options are the same as the RTP output filter, see gpac -h rtpout\nThe server will disconnect UDP streaming sessions if no RTCP traffic has been received for timeout seconds.\n\nThe server can run over TLS by specifying cert and pkey, in which case the default port is 322.\n\nSink mode\n\nThe filter can work as a simple output filter by specifying the dst option:\nExample:\ngpac -i source -o rtsp://myip/sessionname\ngpac -i source -o rtsp://myip/sessionname\nIn this mode, only one session is possible. It is possible to loop the input source(s).\n\nServer mode\n\nThe filter can work as a regular RTSP server by specifying the mounts option to indicate paths of media file to be served:\nExample:\ngpac rtspout:mounts=mydir1,mydir2\nIn this case, content RES from any of the specified directory is exposed as rtsp://SERVER/RES\n\nThe mounts option can also specify access rule file(s), see gpac -h creds. When rules are used:\n- if a directory has a name rule, it will be used in the URL\n- otherwise, the directory is directly available under server root /\n- only read access and multicast rights are checked\nExample:\n[foodir]\nname=bar\nContent RES of this directory is exposed as rtsp://SERVER/bar/RES.\n  \n\nIn this mode, it is possible to load any source supported by gpac by setting the option dynurl.\nThe expected syntax of the dynamic RTSP URLs is rtsp://servername/?URL1[&URLN] or rtsp://servername/@URL1[@URLN] \nEach URL can be absolute or local, in which case it is resolved against the mount point(s).\nExample:\ngpac -i rtsp://localhost/?pipe://mynamepipe&myfile.mp4 [dst filters]\nThe server will resolve this URL in a new session containing streams from myfile.mp4 and streams from pipe mynamepipe.\nWhen setting runfor in server mode, the server will exit at the end of the last session being closed.\n\nThe parameter name=VAL is reserved to assign a session name in case multicast mirroring is used.\nExample:\ngpac -i rtsp://localhost/?name=live?pipe://mynamepipe&myfile.mp4 [dst filters]\n\nUsage of dynamic URLs can also be configured using the specific directory $dynurl in an access rule file.\nEX[$dynurl]\nru=foo\nThis will allow dynamic URLs only for foo user.\n\nNote: If the dynurl is set, it is enabled for all users, without authentication.\n\nMulticasting\n\nIn both modes, clients can setup multicast if the mcast option is on or mirror.\nWhen mcast is set to mirror mode, any DESCRIBE command on a resource already delivered through a multicast session will use that multicast.\nConsequently, only DESCRIBE methods are processed for such sessions, other methods will return Unauthorized.\n\nIn server mode, multicast can be enabled per read directory using the mcast access rule of the directory configuration - see gpac -h creds.\n\nHTTP Tunnel\n\nThe server mode supports handling RTSP over HTTP tunnel by default. This can be disabled using htun.\nThe tunnel conforms to QT specification, and only HTTP 1.0 and 1.1 tunnels are supported.\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "location of destination resource"
            },
            "port": {
                "type": "uint",
                "description": "server port",
                "default": 554
            },
            "firstport": {
                "type": "uint",
                "description": "port for first stream in session",
                "default": 6000
            },
            "mtu": {
                "type": "uint",
                "description": "size of RTP MTU in bytes",
                "default": 1460
            },
            "ttl": {
                "type": "uint",
                "description": "time-to-live for multicast packets (a value of 0 uses client requested TTL, or 1)",
                "default": 0
            },
            "ifce": {
                "type": "str",
                "description": "default network interface to use"
            },
            "payt": {
                "type": "uint",
                "description": "payload type to use for dynamic decoder configurations",
                "default": 96
            },
            "mpeg4": {
                "type": "bool",
                "description": "send all streams using MPEG-4 generic payload format if possible",
                "default": true
            },
            "delay": {
                "type": "sint",
                "description": "send delay for packet (negative means send earlier)",
                "default": "0"
            },
            "tt": {
                "type": "uint",
                "description": "time tolerance in microsecond (whenever schedule time minus realtime is below this value, the packet is sent right away)",
                "default": 1000
            },
            "runfor": {
                "type": "sint",
                "description": "run the session for the given time in ms. A negative value means run for ever if loop or source duration, value 0 only outputs the sdp",
                "default": "-1"
            },
            "tso": {
                "type": "sint",
                "description": "set timestamp offset in microseconds (negative value means random initial timestamp)",
                "default": "-1"
            },
            "xps": {
                "type": "bool",
                "description": "force parameter set injection at each SAP. If not set, only inject if different from SDP ones",
                "default": true
            },
            "latm": {
                "type": "bool",
                "description": "use latm for AAC payload format",
                "default": true
            },
            "mounts": {
                "type": "strl",
                "description": "list of directories to expose in server mode"
            },
            "block_size": {
                "type": "uint",
                "description": "block size used to read TCP socket",
                "default": 10000
            },
            "maxc": {
                "type": "uint",
                "description": "maximum number of connections",
                "default": 100
            },
            "timeout": {
                "type": "uint",
                "description": "timeout in seconds for inactive sessions (0 disable timeout)",
                "default": 20
            },
            "user_agent": {
                "type": "str",
                "description": "user agent string, by default solved from GPAC preferences",
                "default": "$GUA"
            },
            "close": {
                "type": "bool",
                "description": "close RTSP connection after each request, except when RTP over RTSP is used",
                "default": true
            },
            "loop": {
                "type": "bool",
                "description": "loop all streams in session (not always possible depending on source type)",
                "default": true
            },
            "dynurl": {
                "type": "bool",
                "description": "allow dynamic service assembly",
                "default": true
            },
            "mcast": {
                "type": "enum",
                "description": "control multicast setup of a session",
                "default": "off",
                "enum": {
                    "off": "clients are never allowed to create a multicast",
                    "on": "clients can create multicast sessions",
                    "mirror": "clients can create a multicast session. Any later request to the same URL will use that multicast session"
                }
            },
            "quit": {
                "type": "bool",
                "description": "exit server once first session is over (for test purposes)",
                "default": true
            },
            "htun": {
                "type": "bool",
                "description": "enable RTSP over HTTP tunnel",
                "default": true
            },
            "trp": {
                "type": "enum",
                "description": "transport mode",
                "default": "both",
                "enum": {
                    "both": "allow TCP or UDP traffic",
                    "udp": "only allow UDP traffic",
                    "tcp": "only allow TCP traffic"
                }
            },
            "cert": {
                "type": "str",
                "description": "certificate file in PEM format to use for TLS mode"
            },
            "pkey": {
                "type": "str",
                "description": "private key file in PEM format to use for TLS mode"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": []
    },
    {
        "name": "httpout",
        "description": "HTTP Server",
        "body": "The HTTP output filter can act as:\n- a simple HTTP server\n- an HTTP server sink\n- an HTTP server file sink\n- an HTTP client sink\n- an HTTP server source\n  \nThe server currently handles GET, HEAD, PUT, POST, DELETE methods, and basic OPTIONS support.\nSingle or multiple byte ranges are supported for both GET and PUT/POST methods, in all server modes.\n- for GET, the resulting body is a single-part body formed by the concatenated byte ranges as requested (no overlap checking).\n- for PUT/POST, the received data is pushed to the target file according to the byte ranges specified in the client request.\n  \n\nWarning: the partial PUT request is RFC2616 compliant but not compliant with RFC7230. PATCH method is not yet implemented in GPAC.\n\n  \nWhen a single read directory is specified, the server root / is the content of this directory.\nWhen multiple read directories are specified, the server root / contains the list of the mount points with their directory names.\nWhen a write directory is specified, the upload resource name identifies a file in this directory (the write directory name is not present in the URL).\n  \nA directory rule file (cf gpac -h creds) can be specified in rdirs but NOT in wdir. When rules are used:\n- if a directory has a name rule, it will be used in the URL\n- otherwise, the directory is directly available under server root /\n- read and write access rights are checked\nExample:\n[foodir]\nname=bar\nContent RES of this directory is exposed as http://SERVER/bar/RES.\n  \nListing can be enabled on server using dlist.\nWhen disabled, a GET on a directory will fail.\nWhen enabled, a GET on a directory will return a simple HTML listing of the content inspired from Apache.\n  \n\nSimple HTTP server\n\nIn this mode, the filter does not need any input connection and exposes all files in the directories given by rdirs.\nPUT and POST methods are only supported if a write directory is specified by wdir option.\nExample:\ngpac httpout:rdirs=outcoming\nThis sets up a read-only server.\n  \nExample:\ngpac httpout:wdir=incoming\nThis sets up a write-only server.\n  \nExample:\ngpac httpout:rdirs=outcoming:wdir=incoming:port=8080\nThis sets up a read-write server running on port 8080.\n  \n\nHTTP server sink\n\nIn this mode, the filter will forward input PIDs to connected clients, trashing the data if no client is connected unless hold is specified.\nThe filter does not use any read directory in this mode.\nThis mode is mostly useful to setup live HTTP streaming of media sessions such as MP3, MPEG-2 TS or other multiplexed representations:\nExample:\ngpac -i MP3_SOURCE -o http://localhost/live.mp3 --hold\nIn this example, the server waits for client requests on /live.mp3 and will then push each input packet to all connected clients.\nIf the source is not real-time, you can inject a reframer filter performing realtime regulation.\nExample:\ngpac -i MP3_SOURCE reframer:rt=on -o http://localhost/live.mp3\nIn this example, the server will push each input packet to all connected clients, or trash the packet if no connected clients.\n  \nIn this mode, ICECast meta-data can be inserted using ice. The default inserted values are ice-audio-info, icy-br, icy-pub (set to 1) and icy-name if input ServiceName property is set.\nThe server will also look for any property called ice-* on the input PID and inject them.\nExample:\ngpac -i source.mp3:#ice-Genre=CoolRock -o http://IP/live.mp3 --ice\nThis will inject the header ice-Genre: CoolRock in the response.  \nOnce one complete input file is sent, it is no longer available for download unless reopen is set and input PID is not over.\n  \nThis mode should not be used with multiple files muxers such as DASH or HLS.\n  \n\nHTTP server file sink\n\nIn this mode, the filter will write input PIDs to files in the first read directory specified, acting as a file output sink.\nThe filter uses a read directory in this mode, which must be writable.\nUpon client GET request, the server will check if the requested URL matches the name of a file currently being written by the server.\n- If so, the server will:\n  - send the content using HTTP chunk transfer mode, starting with what is already written on disk\n  - push remaining data to the client as soon as received while writing it to disk, until source file is done\n- If not so, the server will simply send the file from the disk as a regular HTTP session, without chunk transfer.\n  \nThis mode is typically used for origin server in HAS sessions where clients may request files while they are being produced (low latency DASH).\nExample:\ngpac -i SOURCE reframer:rt=on -o http://localhost:8080/live.mpd --rdirs=temp --dmode=dynamic --cdur=0.1\nIn this example, a real-time dynamic DASH session with chunks of 100ms is created, writing files to temp. A client connecting to the live edge will receive segments as they are produced using HTTP chunk transfer.\n  \nThe server can store incoming files to memory mode by setting the read directory to gmem.\nIn this mode, max_cache_segs is always at least 1.\n  \nIf max_cache_segs value N is not 0, each incoming PID will store at most:\n- MIN(N, time-shift depth) files if stored in memory\n- -N files if stored locally and N is negative\n- MAX(N, time-shift depth) files if stored locally and N is positive\n- unlimited otherwise (files stored locally, N is positive and no time-shift info)\n  \n\nHTTP client sink\n\nIn this mode, the filter will upload input PIDs data to remote server using PUT (or POST if post is set).\nThis mode must be explicitly activated using hmode.\nThe filter uses no read or write directories in this mode.\nExample:\ngpac -i SOURCE -o http://targethost:8080/live.mpd:gpac:hmode=push\nIn this example, the filter will send PUT methods to the server running on port 8080 at targethost location (IP address or name).\n  \n\nHTTP server source\n\nIn this mode, the server acts as a source rather than a sink. It declares incoming PUT or POST methods as output PIDs\nThis mode must be explicitly activated using hmode.\nThe filter uses no read or write directories in this mode, and uploaded data is NOT stored by the server.\nExample:\ngpac httpout:hmode=source vout aout\nIn this example, the filter will try to play uploaded files through video and audio output.\n  \n\nHTTPS server\n\nThe server can run over TLS (https) for all the server modes. TLS is enabled by specifying cert and pkey options.\nBoth certificate and key must be in PEM format.\nThe server currently only operates in either HTTPS or HTTP mode and cannot run both modes at the same time. You will need to use two httpout filters for this, one operating in HTTPS and one operating in HTTP.\n  \n\nMultiple destinations on single server\n\nWhen running in server mode, multiple HTTP outputs with same URL/port may be used:\n- the first loaded HTTP output filter with same URL/port will be reused\n- all httpout options of subsequent httpout filters, except dst will be ignored, other options will be inherited as usual\n\nExample:\ngpac -i dash.mpd dashin:forward=file:SID=D1 dashin:forward=segb:SID=D2 -o http://localhost:80/live.mpd:SID=D1:rdirs=dash -o http://localhost:80/live_rw.mpd:SID=D2:sigfrag\nThis will:\n- load the HTTP server and forward (through D1) the dash session to this server using live.mpd as manifest name\n- reuse the HTTP server and regenerate the manifest (through D2 and sigfrag option), using live_rw.mpd as manifest name\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "location of destination resource"
            },
            "port": {
                "type": "uint",
                "description": "server port",
                "default": 0
            },
            "ifce": {
                "type": "str",
                "description": "default network interface to use"
            },
            "rdirs": {
                "type": "strl",
                "description": "list of directories to expose for read"
            },
            "wdir": {
                "type": "str",
                "description": "directory to expose for write"
            },
            "cert": {
                "type": "str",
                "description": "certificate file in PEM format to use for TLS mode"
            },
            "pkey": {
                "type": "str",
                "description": "private key file in PEM format to use for TLS mode"
            },
            "block_size": {
                "type": "uint",
                "description": "block size used to read and write TCP socket",
                "default": 10000
            },
            "user_agent": {
                "type": "str",
                "description": "user agent string, by default solved from GPAC preferences",
                "default": "$GUA"
            },
            "close": {
                "type": "bool",
                "description": "close HTTP connection after each request",
                "default": true
            },
            "maxc": {
                "type": "uint",
                "description": "maximum number of connections, 0 is unlimited",
                "default": 100
            },
            "maxp": {
                "type": "uint",
                "description": "maximum number of connections for one peer (0 is unlimited)",
                "default": 6
            },
            "cache_control": {
                "type": "str",
                "description": "specify the Cache-Control string to add (none disable cache control and ETag)"
            },
            "hold": {
                "type": "bool",
                "description": "hold packets until one client connects",
                "default": true
            },
            "hmode": {
                "type": "enum",
                "description": "filter operation mode, ignored if wdir is set",
                "default": "default",
                "enum": {
                    "default": "run in server mode",
                    "push": "run in client mode using PUT or POST",
                    "source": "use server as source filter on incoming PUT/POST"
                }
            },
            "timeout": {
                "type": "uint",
                "description": "timeout in seconds for persistent connections (0 disable timeout)",
                "default": 5
            },
            "ext": {
                "type": "cstr",
                "description": "set extension for graph resolution, regardless of file extension"
            },
            "mime": {
                "type": "cstr",
                "description": "set mime type for graph resolution"
            },
            "quit": {
                "type": "bool",
                "description": "exit server once all input PIDs are done and client disconnects (for test purposes)",
                "default": true
            },
            "post": {
                "type": "bool",
                "description": "use POST instead of PUT for uploading files",
                "default": true
            },
            "dlist": {
                "type": "bool",
                "description": "enable HTML listing for GET requests on directories",
                "default": true
            },
            "sutc": {
                "type": "bool",
                "description": "insert server UTC in response headers as Server-UTC: VAL_IN_MS",
                "default": true
            },
            "cors": {
                "type": "enum",
                "description": "insert CORS header allowing all domains",
                "default": "auto",
                "enum": {
                    "off": "disable CORS",
                    "on": "enable CORS",
                    "auto": "enable CORS when Origin is found in request"
                }
            },
            "reqlog": {
                "type": "str",
                "description": "provide short log of the requests indicated in this option (comma separated list, * for all) regardless of HTTP log settings. Value REC logs file writing start/end"
            },
            "ice": {
                "type": "bool",
                "description": "insert ICE meta-data in response headers in sink mode",
                "default": true
            },
            "max_client_errors": {
                "type": "uint",
                "description": "force disconnection after specified number of consecutive errors from HTTTP 1.1 client (ignored in H/2 or when close is set)",
                "default": 20
            },
            "max_cache_segs": {
                "type": "sint",
                "description": "maximum number of segments cached per HAS quality (see filter help)",
                "default": "5"
            },
            "reopen": {
                "type": "bool",
                "description": "in server mode with no read dir, accept requests on files already over but with input pid not in end of stream",
                "default": true
            },
            "max_async_buf": {
                "type": "uint",
                "description": "maximum async buffer size in bytes when sharing output over multiple connection without file IO",
                "default": 100000
            },
            "blockio": {
                "type": "bool",
                "description": "use blocking IO in push or source mode or in server mode with no read dir",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "dashin",
            "cdcrypt",
            "mp4mx",
            "nhmlr",
            "rtpin",
            "reframer",
            "writegen",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "flist",
            "m2tsmx",
            "dasher",
            "pin",
            "gsfmx",
            "gsfdmx",
            "routein",
            "rtpout",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx"
        ],
        "sinks": [
            "inspect",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            ""
        ]
    },
    {
        "name": "hevcsplit",
        "description": "HEVC tile splitter",
        "body": "This filter splits a motion-constrained tiled HEVC PID into N independent HEVC PIDs.\nUse hevcmerge filter to merge initially motion-constrained tiled HEVC PID in a single output.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["HEVC Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["HEVC Video"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "vtbdec",
            "mcdec",
            "cecrypt",
            "mp4mx",
            "rfnalu",
            "reframer",
            "writegen",
            "ufnalu",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "unframer",
            "writeuf",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "hevcmerge",
        "description": "HEVC Tile merger",
        "body": "This filter merges a set of HEVC PIDs into a single motion-constrained tiled HEVC PID.\nThe filter creates a tiling grid with a single row and as many columns as needed.\nIf mrows is set and tiles properly align on the final grid, multiple rows will be declared in the PPS.\nPositioning of tiles can be automatic (implicit) or explicit.\nThe filter will check the SPS and PPS configurations of input PID and warn if they are not aligned but will still process them unless strict is set.\nThe filter assumes that all input PIDs are synchronized (frames share the same timestamp) and will reassemble frames with the same decode time. If PIDs are of unequal duration, the filter will drop frames as soon as one PID is over.\n\nImplicit Positioning\nIn implicit positioning, results may vary based on the order of input PIDs declaration.\nIn this mode the filter will automatically allocate new columns for tiles with height not a multiple of max CU height.\n\nExplicit Positioning\nIn explicit positioning, the CropOrigin property on input PIDs is used to setup the tile grid. In this case, tiles shall not overlap in the final output.\nIf CropOrigin is used, it shall be set on all input sources.\nIf positive coordinates are used, they specify absolute positioning in pixels of the tiles. The coordinates are automatically adjusted to the next multiple of max CU width and height.\nIf negative coordinates are used, they specify relative positioning (e.g. 0x-1 indicates to place the tile below the tile 0x0).\nIn this mode, it is the caller responsibility to set coordinates so that all tiles in a column have the same width and only the last row/column uses non-multiple of max CU width/height values. The filter will complain and abort if this is not respected.\n- If an horizontal blank is detected in the layout, an empty column in the tiling grid will be inserted.\n- If a vertical blank is detected in the layout, it is ignored.\n  \n\nSpatial Relationship Description (SRD)\n\nThe filter will create an SRDMap property in the output PID if SRDRef and SRD or CropOrigin are set on all input PIDs.\nThe SRDMap allows forwarding the logical sources SRD in the merged PID.\nThe output PID SRDRef is set to the output video size.\nThe input SRDRef and SRD are usually specified in DASH MPD, but can be manually assigned to inputs.\n- SRDRef gives the size of the referential used for the input SRD (usually matches the original video size, but not always)\n- SRD gives the size and position of the input in the original video, expressed in SRDRef referential of the input.\nThe inputs do not need to have matching SRDRef\n.EX src1:SRD=0x0x640x480:SRDRef=1280x720\nThis indicates that src1 contains a video located at 0,0, with a size of 640x480 pixels in a virtual source of 1280x720 pixels.\nExample:\nsrc2:SRD=640x0x640x480:SRDRef=1280x720\nThis indicates that src1 contains a video located at 640,0, with a size of 640x480 pixels in a virtual source of 1280x720 pixels.\n \nEach merged input is described by 8 integers in the output SRDMap:\n- the source SRD is rescaled in the output SRDRef to form the first part (4 integers) of the SRDMap (i.e. where was the input ?)\n- the source location in the reconstructed video forms the second part (4 integers) of the SRDMap (i.e. where are the input pixels in the output ?)\n \nAssuming the two sources are encoded at 320x240 and merged as src2 above src1, the output will be a 320x480 video with a SRDMap of {0,160,160,240,0,0,320,240,0,0,160,240,0,240,320,240}\nNote: merged inputs are always listed in SRDMap in their tile order in the output bitstream.\n\nAlternatively to using SRD and SRDRef, it is possible to specify CropOrigin property on the inputs, in which case:\n- the CropOrigin gives the location in the source\n- the input size gives the size in the source, and no rescaling of referential is done\nExample:\nsrc1:CropOrigin=0x0  src1:CropOrigin=640x0 \nAssuming the two sources are encoded at 320x240 and merged as src1 above src2, the output will be a 320x480 video with a SRDMap of {0,0,320,240,0,0,320,240,640,0,320,240,0,240,320,240}\n\n\n",
        "options": {
            "strict": {
                "type": "bool",
                "description": "strict comparison of SPS and PPS of input PIDs",
                "default": true
            },
            "mrows": {
                "type": "bool",
                "description": "signal multiple rows in tile grid when possible",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["HEVC Video"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["HEVC Video"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "hevcsplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "vtbdec",
            "mcdec",
            "cecrypt",
            "mp4mx",
            "rfnalu",
            "reframer",
            "writegen",
            "ufnalu",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "unframer",
            "writeuf",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "rfflac",
        "description": "FLAC reframer",
        "body": "This filter parses FLAC files/data and outputs corresponding audio PID and frames.\n\nBy default the reframer will only check CRC footer of frames if a change in sample rate or channel mapping is detected.\nThis should accomodate for most configurations, but CRC check can be enforced using docrc.\n\n\n",
        "options": {
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            },
            "docrc": {
                "type": "bool",
                "description": "perform CRC check after each frame",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Flac Audio"],
                "stream_type": ["File", "Audio"]
            },
            "output": {
                "codec_id": ["Flac Audio"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "oggmx",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rfmhas",
        "description": "MPEH-H Audio Stream reframer",
        "body": "This filter parses MHAS files/data and outputs corresponding audio PID and frames.\nBy default, the filter expects a MHAS stream with SYNC packets set, otherwise tune-in will fail. Using nosync=false can help parsing bitstreams with no SYNC packets.\nThe default behavior is to dispatch a framed MHAS bitstream. To demultiplex into a raw MPEG-H Audio, use mpha.\n\n\n",
        "options": {
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            },
            "mpha": {
                "type": "bool",
                "description": "demultiplex MHAS and only forward audio frames",
                "default": true
            },
            "pcksync": {
                "type": "uint",
                "description": "number of unknown packets to tolerate before considering sync is lost",
                "default": 4
            },
            "nosync": {
                "type": "bool",
                "description": "initial sync state",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["MPEG-H AudioMux"],
                "stream_type": ["File", "Audio"]
            },
            "output": {
                "codec_id": ["MPEG-H AudioMux"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "ufmhas",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "ufmhas",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rfprores",
        "description": "ProRes reframer",
        "body": "This filter parses ProRes raw files/data and outputs corresponding visual PID and frames.\n\n\n",
        "options": {
            "fps": {
                "type": "frac",
                "description": "import frame rate (0 default to FPS from bitstream or 25 Hz)",
                "default": "0/1000"
            },
            "findex": {
                "type": "bool",
                "description": "index frames. If true, filter will be able to work in rewind mode",
                "default": true
            },
            "cid": {
                "type": "str",
                "description": "set QT 4CC for the imported media. If not set, default is 'ap4h' for YUV444 and 'apch' for YUV422"
            },
            "notime": {
                "type": "bool",
                "description": "ignore input timestamps, rebuild from 0",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "ProRes Video 4444 XQ",
                    "ProRes Video 422 HQ",
                    "ProRes Video 422 LT",
                    "ProRes Video 422 Proxy",
                    "ProRes Video 4444",
                    "ProRes Video 422 STD"
                ],
                "stream_type": ["File", "Visual"]
            },
            "output": {
                "codec_id": [
                    "ProRes Video 4444 XQ",
                    "ProRes Video 422 HQ",
                    "ProRes Video 422 LT",
                    "ProRes Video 422 Proxy",
                    "ProRes Video 4444",
                    "ProRes Video 422 STD"
                ],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "vtbdec",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "tssplit",
        "description": "MPEG Transport Stream splitter",
        "body": "This filter splits an MPEG-2 transport stream into several single program transport streams.\nOnly the PAT table is rewritten, other tables (PAT, PMT) and streams (PES) are forwarded as is.\nIf dvb is set, global DVB tables of the input multiplex are forwarded to each output mux; otherwise these tables are discarded.\n\n\n",
        "options": {
            "dvb": {
                "type": "bool",
                "description": "forward all packets from global DVB PIDs",
                "default": true
            },
            "mux_id": {
                "type": "sint",
                "description": "set initial ID of output mux; the first program will use mux_id, the second mux_id+1, etc. If not set, this value will be set to sourceMuxId*255",
                "default": "-1"
            },
            "avonly": {
                "type": "bool",
                "description": "do not forward programs with no AV component",
                "default": true
            },
            "nb_pack": {
                "type": "uint",
                "description": "pack N packets before sending",
                "default": 10
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "rtpin",
            "writegen",
            "m2tsmx",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": ["m2tsdmx", "fout", "pout", "sockout", "rtpout", "httpout", "routeout", ""]
    },
    {
        "name": "bsrw",
        "description": "Compressed bitstream rewriter",
        "body": "This filter rewrites some metadata of various bitstream formats.\nThe filter can currently modify the following properties in video bitstreams:\n- MPEG-4 Visual:\n  - sample aspect ratio\n  - profile and level\n- AVC|H264, HEVC and VVC:\n  - sample aspect ratio\n  - profile, level, profile compatibility\n  - video format, video fullrange\n  - color primaries, transfer characteristics and matrix coefficients (or remove all info)\n- ProRes:\n  - sample aspect ratio\n  - color primaries, transfer characteristics and matrix coefficients\n  \nValues are by default initialized to -1, implying to keep the related info (present or not) in the bitstream.\nA sar value of 0/0 will remove sample aspect ratio info from bitstream if possible.\n  \nThe filter can currently modify the following properties in the stream configuration but not in the bitstream:\n\t* HEVC: profile IDC, profile space, general compatibility flags\n\t* VVC: profile IDC, general profile and level indication\n  \nThe filter will work in passthrough mode for all other codecs and media types.\n\n\n",
        "options": {
            "cprim": {
                "type": "cprm",
                "description": "color primaries according to ISO/IEC 23001-8 / 23091-2",
                "default": "-1"
            },
            "ctfc": {
                "type": "ctfc",
                "description": "color transfer characteristics according to ISO/IEC 23001-8 / 23091-2",
                "default": "-1"
            },
            "cmx": {
                "type": "cmxc",
                "description": "color matrix coeficients according to ISO/IEC 23001-8 / 23091-2",
                "default": "-1"
            },
            "sar": {
                "type": "frac",
                "description": "aspect ratio to rewrite",
                "default": "-1/-1"
            },
            "m4vpl": {
                "type": "sint",
                "description": "set ProfileLevel for MPEG-4 video part two",
                "default": "-1"
            },
            "fullrange": {
                "type": "bool",
                "description": "video full range flag",
                "default": true
            },
            "novsi": {
                "type": "bool",
                "description": "remove video_signal_type from VUI in AVC|H264 and HEVC",
                "default": true
            },
            "novuitiming": {
                "type": "bool",
                "description": "remove timing_info from VUI in AVC|H264 and HEVC",
                "default": true
            },
            "prof": {
                "type": "sint",
                "description": "profile indication for AVC|H264",
                "default": "-1"
            },
            "lev": {
                "type": "sint",
                "description": "level indication for AVC|H264, level_idc for VVC",
                "default": "-1"
            },
            "pcomp": {
                "type": "sint",
                "description": "profile compatibility for AVC|H264",
                "default": "-1"
            },
            "pidc": {
                "type": "sint",
                "description": "profile IDC for HEVC and VVC",
                "default": "-1"
            },
            "pspace": {
                "type": "sint",
                "description": "profile space for HEVC",
                "default": "-1"
            },
            "gpcflags": {
                "type": "sint",
                "description": "general compatibility flags for HEVC",
                "default": "-1"
            },
            "rmsei": {
                "type": "bool",
                "description": "remove SEI messages from bitstream for AVC|H264, HEVC and VVC",
                "default": true
            },
            "vidfmt": {
                "type": "enum",
                "description": "video format for AVC|H264, HEVC and VVC (component|pal|ntsc|secam|mac|undef)",
                "default": "-1"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "fin",
            "httpin",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "bssplit",
        "description": "Compressed layered bitstream splitter",
        "body": "This filter splits input stream by layers and sublayers\n\nThe filter supports AVC|H264, HEVC and VVC stream splitting and is pass-through for other codec types.\n\nSplitting is based on temporalID value (start from 1) and layerID value (start from 0).\nFor AVC|H264, layerID is the dependency value, or quality value if svcqid is set.\n\nEach input stream is filtered according to the ltid option as follows:\n\t* no value set: input stream is split by layerID, i.e. each layer creates an output\n\t* `all`: input stream is split by layerID and temporalID, i.e. each {layerID,temporalID} creates an output\n\t* `lID`: input stream is split according to layer lID value, and temporalID is ignored\n\t* `.tID`: input stream is split according to temporal sub-layer tID value and layerID is ignored\n\t* `lID.tID`: input stream is split according to layer lID and sub-layer tID values\n\nNote: A tID value of 0 in ltid is equivalent to value 1.\n\nMultiple values can be given in ltid, in which case each value gives the maximum {layerID,temporalID} values for the current layer.\nA few examples on an input with 2 layers each with 2 temporal sublayers:\n\t* `ltid=0.2`: this will split the stream in:\n  - one stream with {lID=0,tID=1} and {lID=0,tID=2} NAL units\n  - one stream with all other layers/substreams\n\t* `ltid=0.1,1.1`: this will split the stream in:\n  - one stream with {lID=0,tID=1} NAL units\n  - one stream with {lID=0,tID=2}, {lID=1,tID=1} NAL units\n  - one stream with the rest {lID=0,tID=2}, {lID=1,tID=2} NAL units\n\t* `ltid=0.1,0.2`: this will split the stream in:\n  - one stream with {lID=0,tID=1} NAL units\n  - one stream with {lID=0,tID=2} NAL units\n  - one stream with the rest {lID=1,tID=1}, {lID=1,tID=2} NAL units\n\nThe filter can also be used on AVC and HEVC DolbyVision streams to split base stream and DV RPU/EL.\n\nThe filter does not create aggregator or extractor NAL units.\n\n\n",
        "options": {
            "ltid": {
                "type": "strl",
                "description": "temporal and layer ID of output streams"
            },
            "svcqid": {
                "type": "bool",
                "description": "use qualityID instead of dependencyID for SVC splitting",
                "default": true
            },
            "sig_ltid": {
                "type": "bool",
                "description": "signal maximum temporal (max_temporal_id) and layer ID (max_layer_id) of output streams (mostly used for debug)",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "fin",
            "httpin",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "bsagg",
        "description": "Compressed layered bitstream aggregator",
        "body": "This filter aggregates layers and sublayers into a single output PID.\n\nThe filter supports AVC|H264, HEVC and VVC stream reconstruction, and is passthrough for other codec types.\n\nAggregation is based on temporalID value (start from 1) and layerID value (start from 0).\nFor AVC|H264, layerID is the dependency value, or quality value if svcqid is set.\n\nThe filter can also be used on AVC and HEVC DolbyVision dual-streams to aggregate base stream and DV RPU/EL.\n\nThe filter does not forward aggregator or extractor NAL units.\n\n\n",
        "options": {
            "svcqid": {
                "type": "bool",
                "description": "use qualityID instead of dependencyID for SVC splitting",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "bifsdec",
            "odfdec",
            "fin",
            "httpin",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "ufttxt",
        "description": "TX3G unframer",
        "body": "This filter converts a single ISOBMFF TX3G stream to TTXT (xml format) unframed stream.\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Subtitle/text 3GPP/Apple Stream", "MPEG-4 Streaming Text"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Subtitle/text 3GPP/Apple Stream"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["writegen", "unframer", ""]
    },
    {
        "name": "tx3g2srt",
        "description": "TX3G to SRT",
        "body": "This filter converts a single ISOBMFF TX3G stream to an SRT unframed stream.\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Subtitle/text 3GPP/Apple Stream", "MPEG-4 Streaming Text"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Simple Text Stream"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["writegen", "rfsrt", "ffmx", "unframer", ""]
    },
    {
        "name": "tx3g2vtt",
        "description": "TX3G to WebVTT",
        "body": "This filter converts a single ISOBMFF TX3G stream to a WebVTT unframed stream.\n\n\n",
        "options": {
            "exporter": {
                "type": "bool",
                "description": "compatibility with old exporter, displays export results",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Subtitle/text 3GPP/Apple Stream", "MPEG-4 Streaming Text"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["WebVTT Text"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["txtin", "writegen", "vtt2tx3g", "ffmx", "unframer", ""]
    },
    {
        "name": "tx3g2ttml",
        "description": "TX3G to TTML",
        "body": "This filter converts ISOBMFF TX3G stream to a TTML stream.\n\nEach output TTML frame is a complete TTML document.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Subtitle/text 3GPP/Apple Stream", "MPEG-4 Streaming Text"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Subtitle XML Stream"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "ttmldec",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ttml2vtt",
            "ttml2srt",
            "restamp",
            "unframer",
            "writeuf",
            ""
        ]
    },
    {
        "name": "vtt2tx3g",
        "description": "WebVTT to TX3G",
        "body": "This filter rewrites unframed WebVTT to TX3G / QT Timed Text (binary format)\n\nUnframed WebVTT packets consist in single cues:\n- cue payload as packet payload\n- prefix as packet string property vtt_pre\n- cue ID as packet string property vtt_cueid\n- cue settings as packet string property vtt_settings\n- packet timing contains the cue timing (start and duration)\n\n\n",
        "options": {
            "fontname": {
                "type": "str",
                "description": "default font"
            },
            "fontsize": {
                "type": "uint",
                "description": "default font size",
                "default": 18
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["WebVTT Text"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Subtitle/text 3GPP/Apple Stream"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "m2tsdmx",
            "dashin",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "ufvtt",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2vtt",
            "ttml2vtt",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "ttxtdec",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "rfsrt",
        "description": "SRT reframer",
        "body": "This filter rewrites unframed SRT to TX3G / QT Timed Text (binary format)\n\nAn unframed SRT packet consists in a single SRT cue as packet payload and packet timing contains the cue timing (start and duration).\n\n\n",
        "options": {
            "fontname": {
                "type": "str",
                "description": "default font"
            },
            "fontsize": {
                "type": "uint",
                "description": "default font size",
                "default": 18
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Simple Text Stream"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Subtitle/text 3GPP/Apple Stream"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "m2tsdmx",
            "dashin",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2srt",
            "ttml2srt",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "ttxtdec",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "ttml2vtt",
        "description": "TTML to WebVTT",
        "body": "This filter converts TTML frames to unframed WebVTT\n.\nConversion is quite limited: only the first div is analyzed and only basic styling is implemented.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Subtitle XML Stream"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["WebVTT Text"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["txtin", "writegen", "vtt2tx3g", "ffmx", "unframer", ""]
    },
    {
        "name": "ttml2srt",
        "description": "TTML to SRT",
        "body": "This filter converts TTML frames to unframed SRT\n.\nConversion is quite limited: only the first div is analyzed and only basic styling is implemented.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Subtitle XML Stream"],
                "stream_type": ["Text"]
            },
            "output": {
                "codec_id": ["Simple Text Stream"],
                "stream_type": ["Text"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "dashin",
            "cdcrypt",
            "nhmlr",
            "txtin",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "ffdmx",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["writegen", "rfsrt", "ffmx", "unframer", ""]
    },
    {
        "name": "ffdmx",
        "description": "FFMPEG demultiplexer",
        "version": "Lavf58.29.100",
        "configuration": "--prefix=/usr/local/Cellar/ffmpeg/4.2.2_1 --enable-shared --enable-pthreads --enable-version3 --enable-avresample --cc=clang --host-cflags='-I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include/darwin' --host-ldflags= --enable-ffplay --enable-gnutls --enable-gpl --enable-libaom --enable-libbluray --enable-libmp3lame --enable-libopus --enable-librubberband --enable-libsnappy --enable-libtesseract --enable-libtheora --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-lzma --enable-libfontconfig --enable-libfreetype --enable-frei0r --enable-libass --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-librtmp --enable-libspeex --enable-libsoxr --enable-videotoolbox --disable-libjack --disable-indev=jack",
        "body": "This filter demultiplexes an input file or open a source protocol using FFMPEG.\nSee FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\nTo list all supported demultiplexers for your GPAC build, use gpac -h ffdmx:*.\nThis will list both supported input formats and protocols.\nInput protocols are listed with Description: Input protocol, and the subclass name identifies the protocol scheme.\nFor example, if ffdmx:rtmp is listed as input protocol, this means rtmp:// source URLs are supported.\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "URL of source content"
            },
            "avioflags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "direct": "reduce buffering"
                }
            },
            "probesize": {
                "type": "lsint",
                "description": "set probing size",
                "default": "5000000"
            },
            "formatprobesize": {
                "type": "sint",
                "description": "number of bytes to probe file format",
                "default": "1048576"
            },
            "fflags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "ignidx": "ignore index",
                    "genpts": "generate pts",
                    "nofillin": "do not fill in missing values that can be exactly calculated",
                    "noparse": "disable AVParsers, this needs nofillin too",
                    "igndts": "ignore dts",
                    "discardcorrupt": "discard corrupted frames",
                    "sortdts": "try to interleave outputted packets by dts",
                    "keepside": "deprecated, does nothing",
                    "fastseek": "fast but inaccurate seeks",
                    "nobuffer": "reduce the latency introduced by optional buffering"
                }
            },
            "seek2any": {
                "type": "bool",
                "description": "allow seeking to non-keyframes on demuxer level when supported",
                "default": true
            },
            "analyzeduration": {
                "type": "lsint",
                "description": "specify how many microseconds are analyzed to probe the input",
                "default": "0"
            },
            "cryptokey": {
                "type": "uint",
                "description": "decryption key"
            },
            "indexmem": {
                "type": "sint",
                "description": "max memory used for timestamp index (per stream)",
                "default": "1048576"
            },
            "rtbufsize": {
                "type": "sint",
                "description": "max memory used for buffering real-time frames",
                "default": "3041280"
            },
            "fdebug": {
                "type": "uint",
                "description": "print specific debug info"
            },
            "max_delay": {
                "type": "sint",
                "description": "maximum muxing or demuxing delay in microseconds",
                "default": "-1"
            },
            "fpsprobesize": {
                "type": "sint",
                "description": "number of frames used to probe fps",
                "default": "-1"
            },
            "f_err_detect": {
                "type": "uint",
                "description": "set error detection flags (deprecated; use err_detect, save via avconv)",
                "enum": {
                    "err_detect": "set error detection flags",
                    "crccheck": "verify embedded CRCs",
                    "bitstream": "detect bitstream specification deviations",
                    "buffer": "detect improper bitstream length",
                    "explode": "abort decoding on minor error detection",
                    "ignore_err": "ignore errors",
                    "careful": "consider things that violate the spec, are fast to check and have not been seen in the wild as errors",
                    "compliant": "consider all spec non compliancies as errors",
                    "aggressive": "consider things that a sane encoder shouldn't do as an error"
                }
            },
            "use_wallclock_as_timestamps": {
                "type": "bool",
                "description": "use wallclock as timestamps",
                "default": true
            },
            "skip_initial_bytes": {
                "type": "lsint",
                "description": "set number of bytes to skip before reading header and frames",
                "default": "0"
            },
            "correct_ts_overflow": {
                "type": "bool",
                "description": "correct single timestamp overflows",
                "default": true
            },
            "f_strict": {
                "type": "sint",
                "description": "how strictly to follow the standards (deprecated; use strict, save via avconv)",
                "enum": {
                    "strict": "strictly conform to all the things in the spec no matter what the consequences",
                    "very": "strictly conform to a older more strict version of the spec or reference software",
                    "unofficial": "allow unofficial extensions",
                    "experimental": "allow non-standardized experimental variants"
                }
            },
            "max_ts_probe": {
                "type": "sint",
                "description": "maximum number of packets to read while waiting for the first timestamp",
                "default": "50"
            },
            "dump_separator": {
                "type": "str",
                "description": "set information dump field separator",
                "default": ""
            },
            "codec_whitelist": {
                "type": "str",
                "description": "List of decoders that are allowed to be used"
            },
            "format_whitelist": {
                "type": "str",
                "description": "List of demuxers that are allowed to be used"
            },
            "protocol_whitelist": {
                "type": "str",
                "description": "List of protocols that are allowed to be used"
            },
            "protocol_blacklist": {
                "type": "str",
                "description": "List of protocols that are not allowed to be used"
            },
            "max_streams": {
                "type": "sint",
                "description": "maximum number of streams",
                "default": "1000"
            },
            "skip_estimate_duration_from_pts": {
                "type": "bool",
                "description": "skip duration calculation in estimate_timings_from_pts",
                "default": true
            },
            "*": {
                "type": "str",
                "description": "any possible options defined for AVFormatContext and sub-classes. See gpac -hx ffdmx and gpac -hx ffdmx:*"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": []
            },
            "output": {
                "codec_id": [],
                "stream_type": ["Audio", "Visual", "Text"]
            }
        },
        "sources": [
            "dashin",
            "cdcrypt",
            "nhmlr",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "ffdec",
        "description": "FFMPEG decoder",
        "version": "Lavc58.54.100",
        "configuration": "--prefix=/usr/local/Cellar/ffmpeg/4.2.2_1 --enable-shared --enable-pthreads --enable-version3 --enable-avresample --cc=clang --host-cflags='-I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include/darwin' --host-ldflags= --enable-ffplay --enable-gnutls --enable-gpl --enable-libaom --enable-libbluray --enable-libmp3lame --enable-libopus --enable-librubberband --enable-libsnappy --enable-libtesseract --enable-libtheora --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-lzma --enable-libfontconfig --enable-libfreetype --enable-frei0r --enable-libass --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-librtmp --enable-libspeex --enable-libsoxr --enable-videotoolbox --disable-libjack --disable-indev=jack",
        "body": "This filter decodes audio and video streams using FFMPEG.\nSee FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\nTo list all supported decoders for your GPAC build, use gpac -h ffdec:*.\n\nOptions can be passed from prompt using --OPT=VAL\nThe default threading mode is to let libavcodec decide how many threads to use. To enforce single thread, use --threads=1\n\nCodec Map\n\nThe ffcmap option allows specifying FFMPEG codecs for codecs not supported by GPAC.\nEach entry in the list is formatted as GID@name or GID@+name, with:\n\t* GID: 4CC or 32 bit identifier of codec ID, as indicated by gpac -i source inspect:full\n\t* name: FFMPEG codec name\n\t* `+': is set and extra data is set and formatted as an ISOBMFF box, removes box header\n\nExample:\ngpac -i source.mp4 --ffcmap=BKV1@binkvideo vout\nThis will map an ISOBMFF track declared with coding type BKV1 to binkvideo.\n\n\n",
        "options": {
            "flags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "unaligned": "allow decoders to produce unaligned output",
                    "gray": "only decode/encode grayscale",
                    "truncated": "Input bitstream might be randomly truncated",
                    "low_delay": "force low delay",
                    "bitexact": "use only bitexact functions (except (I)DCT)",
                    "output_corrupt": "Output even potentially corrupted frames",
                    "drop_changed": "Drop frames whose parameters differ from first decoded frame"
                }
            },
            "flags2": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "ignorecrop": "ignore cropping information from sps",
                    "chunks": "Frame data might be split into multiple chunks",
                    "showall": "Show all frames before the first keyframe",
                    "export_mvs": "export motion vectors through frame side data",
                    "skip_manual": "do not skip samples and export skip information as frame side data",
                    "ass_ro_flush_noop": "do not reset ASS ReadOrder field on flush"
                }
            },
            "ar": {
                "type": "sint",
                "description": "set audio sampling rate (in Hz)",
                "default": "0"
            },
            "ac": {
                "type": "sint",
                "description": "set number of audio channels",
                "default": "0"
            },
            "bug": {
                "type": "uint",
                "description": "work around not autodetected encoder bugs",
                "enum": {
                    "xvid_ilace": "Xvid interlacing bug (autodetected if FOURCC == XVIX)",
                    "ump4": "(autodetected if FOURCC == UMP4)",
                    "no_padding": "padding bug (autodetected)",
                    "std_qpel": "old standard qpel (autodetected per FOURCC/version)",
                    "direct_blocksize": "direct-qpel-blocksize bug (autodetected per FOURCC/version)",
                    "edge": "edge padding bug (autodetected per FOURCC/version)",
                    "ms": "work around various bugs in Microsoft's broken decoders",
                    "trunc": "truncated frames"
                }
            },
            "strict": {
                "type": "sint",
                "description": "how strictly to follow the standards",
                "enum": {
                    "very": "strictly conform to a older more strict version of the spec or reference software",
                    "strict": "strictly conform to all the things in the spec no matter what the consequences",
                    "unofficial": "allow unofficial extensions",
                    "experimental": "allow non-standardized experimental things"
                }
            },
            "err_detect": {
                "type": "uint",
                "description": "set error detection flags",
                "enum": {
                    "crccheck": "verify embedded CRCs",
                    "bitstream": "detect bitstream specification deviations",
                    "buffer": "detect improper bitstream length",
                    "explode": "abort decoding on minor error detection",
                    "ignore_err": "ignore errors",
                    "careful": "consider things that violate the spec, are fast to check and have not been seen in the wild as errors",
                    "compliant": "consider all spec non compliancies as errors",
                    "aggressive": "consider things that a sane encoder should not do as an error"
                }
            },
            "idct": {
                "type": "sint",
                "description": "select IDCT implementation",
                "enum": {
                    "xvidmmx": "deprecated, for compatibility only",
                    "faani": "floating point AAN IDCT"
                }
            },
            "ec": {
                "type": "uint",
                "description": "set error concealment strategy",
                "enum": {
                    "guess_mvs": "iterative motion vector (MV) search (slow)",
                    "deblock": "use strong deblock filter for damaged MBs",
                    "favor_inter": "favor predicting from the previous frame"
                }
            },
            "debug": {
                "type": "uint",
                "description": "print specific debug info",
                "enum": {
                    "pict": "picture info",
                    "mb_type": "macroblock (MB) type",
                    "qp": "per-block quantization parameter (QP)",
                    "er": "error recognition",
                    "mmco": "memory management control operations (H.264)",
                    "buffers": "picture buffer allocations",
                    "thread_ops": "threading operations",
                    "nomc": "skip motion compensation"
                }
            },
            "threads": {
                "type": "sint",
                "description": "set the number of threads",
                "enum": {
                    "auto": "autodetect a suitable number of threads to use"
                }
            },
            "skip_top": {
                "type": "sint",
                "description": "number of macroblock rows at the top which are skipped",
                "default": "0"
            },
            "skip_bottom": {
                "type": "sint",
                "description": "number of macroblock rows at the bottom which are skipped",
                "default": "0"
            },
            "lowres": {
                "type": "sint",
                "description": "decode at 1= 1/2, 2=1/4, 3=1/8 resolutions",
                "default": "0"
            },
            "skip_loop_filter": {
                "type": "sint",
                "description": "skip loop filtering process for the selected frames",
                "enum": {
                    "skip_idct": "skip IDCT/dequantization for the selected frames",
                    "skip_frame": "skip decoding for the selected frames",
                    "none": "discard no frame",
                    "default": "discard useless frames",
                    "noref": "discard all non-reference frames",
                    "bidir": "discard all bidirectional frames",
                    "nokey": "discard all frames except keyframes",
                    "nointra": "discard all frames except I frames",
                    "all": "discard all frames"
                }
            },
            "channel_layout": {
                "type": "luint",
                "description": "(null)",
                "default": "0"
            },
            "request_channel_layout": {
                "type": "luint",
                "description": "(null)",
                "default": "0"
            },
            "ticks_per_frame": {
                "type": "sint",
                "description": "(null)",
                "default": "1"
            },
            "color_primaries": {
                "type": "sint",
                "description": "color primaries",
                "enum": {
                    "bt709": "BT.709",
                    "unknown": "Unspecified",
                    "bt470m": "BT.470 M",
                    "bt470bg": "BT.470 BG",
                    "smpte170m": "SMPTE 170 M",
                    "smpte240m": "SMPTE 240 M",
                    "film": "Film",
                    "bt2020": "BT.2020",
                    "smpte428": "SMPTE 428-1",
                    "smpte428_1": "SMPTE 428-1",
                    "smpte431": "SMPTE 431-2",
                    "smpte432": "SMPTE 422-1",
                    "jedec-p22": "JEDEC P22",
                    "unspecified": "Unspecified"
                }
            },
            "color_trc": {
                "type": "sint",
                "description": "color transfer characteristics",
                "enum": {
                    "bt709": "BT.709",
                    "unknown": "Unspecified",
                    "gamma22": "BT.470 M",
                    "gamma28": "BT.470 BG",
                    "smpte170m": "SMPTE 170 M",
                    "smpte240m": "SMPTE 240 M",
                    "linear": "Linear",
                    "log100": "Log",
                    "log316": "Log square root",
                    "iec61966-2-4": "IEC 61966-2-4",
                    "bt1361e": "BT.1361",
                    "iec61966-2-1": "IEC 61966-2-1",
                    "bt2020-10": "BT.2020 - 10 bit",
                    "bt2020-12": "BT.2020 - 12 bit",
                    "smpte2084": "SMPTE 2084",
                    "smpte428": "SMPTE 428-1",
                    "arib-std-b67": "ARIB STD-B67",
                    "unspecified": "Unspecified",
                    "log": "Log",
                    "log_sqrt": "Log square root",
                    "iec61966_2_4": "IEC 61966-2-4",
                    "bt1361": "BT.1361",
                    "iec61966_2_1": "IEC 61966-2-1",
                    "bt2020_10bit": "BT.2020 - 10 bit",
                    "bt2020_12bit": "BT.2020 - 12 bit",
                    "smpte428_1": "SMPTE 428-1"
                }
            },
            "colorspace": {
                "type": "sint",
                "description": "color space",
                "enum": {
                    "rgb": "RGB",
                    "bt709": "BT.709",
                    "unknown": "Unspecified",
                    "fcc": "FCC",
                    "bt470bg": "BT.470 BG",
                    "smpte170m": "SMPTE 170 M",
                    "smpte240m": "SMPTE 240 M",
                    "ycgco": "YCGCO",
                    "bt2020nc": "BT.2020 NCL",
                    "bt2020c": "BT.2020 CL",
                    "smpte2085": "SMPTE 2085",
                    "unspecified": "Unspecified",
                    "ycocg": "YCGCO",
                    "bt2020_ncl": "BT.2020 NCL",
                    "bt2020_cl": "BT.2020 CL"
                }
            },
            "color_range": {
                "type": "sint",
                "description": "color range",
                "enum": {
                    "unknown": "Unspecified",
                    "tv": "MPEG (219*2^(n-8))",
                    "pc": "JPEG (2^n-1)",
                    "unspecified": "Unspecified",
                    "mpeg": "MPEG (219*2^(n-8))",
                    "jpeg": "JPEG (2^n-1)"
                }
            },
            "chroma_sample_location": {
                "type": "sint",
                "description": "chroma sample location",
                "enum": {
                    "unknown": "Unspecified",
                    "left": "Left",
                    "center": "Center",
                    "topleft": "Top-left",
                    "top": "Top",
                    "bottomleft": "Bottom-left",
                    "bottom": "Bottom",
                    "unspecified": "Unspecified"
                }
            },
            "thread_type": {
                "type": "uint",
                "description": "select multithreading type"
            },
            "request_sample_fmt": {
                "type": "enum",
                "description": "sample format audio decoders should prefer (u8|s16|s32|flt|dbl|u8p|s16p|s32p|fltp|dblp)",
                "default": "s16"
            },
            "sub_charenc": {
                "type": "str",
                "description": "set input text subtitles character encoding"
            },
            "sub_charenc_mode": {
                "type": "uint",
                "description": "set input text subtitles character encoding mode"
            },
            "sub_text_format": {
                "type": "sint",
                "description": "set decoded text subtitle format"
            },
            "refcounted_frames": {
                "type": "bool",
                "description": "(null)",
                "default": true
            },
            "apply_cropping": {
                "type": "bool",
                "description": "(null)",
                "default": true
            },
            "skip_alpha": {
                "type": "bool",
                "description": "Skip processing alpha",
                "default": true
            },
            "field_order": {
                "type": "sint",
                "description": "Field order"
            },
            "dump_separator": {
                "type": "str",
                "description": "set information dump field separator"
            },
            "codec_whitelist": {
                "type": "str",
                "description": "List of decoders that are allowed to be used"
            },
            "max_pixels": {
                "type": "lsint",
                "description": "Maximum number of pixels",
                "default": "+I"
            },
            "hwaccel_flags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "ignore_level": "ignore level even if the codec level used is unknown or higher than the maximum supported level reported by the hardware driver",
                    "allow_high_depth": "allow to output YUV pixel formats with a different chroma sampling than 4:2:0 and/or other than 8 bits per component",
                    "allow_profile_mismatch": "attempt to decode anyway if HW accelerated decoder's supported profiles do not exactly match the stream"
                }
            },
            "extra_hw_frames": {
                "type": "sint",
                "description": "Number of extra hardware frames to allocate for the user",
                "default": "-1"
            },
            "discard_damaged_percentage": {
                "type": "sint",
                "description": "Percentage of damaged samples to discard a frame",
                "default": "95"
            },
            "ffcmap": {
                "type": "strl",
                "description": "codec map"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "MPEG-4 Streaming Text",
                    "Simple Text Stream",
                    "WebVTT Text",
                    "Subtitle text Stream",
                    "Codec Not Supported",
                    "Subtitle XML Stream",
                    "HEVC Video Layered Extensions",
                    "MPEG-4 AVC|H264 Scalable Video Coding",
                    "SSA /ASS Subtitles",
                    "HEVC tiles Video",
                    "VVC Subpicture Video",
                    "Raw media",
                    "Subtitle/text 3GPP/Apple Stream"
                ],
                "stream_type": ["Audio", "Visual", "Text"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual", "Text"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "jpgenc",
            "pngenc",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "rfav1",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "ffavin",
        "description": "FFMPEG AV Capture",
        "version": "Lavd58.8.100",
        "configuration": "--prefix=/usr/local/Cellar/ffmpeg/4.2.2_1 --enable-shared --enable-pthreads --enable-version3 --enable-avresample --cc=clang --host-cflags='-I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include/darwin' --host-ldflags= --enable-ffplay --enable-gnutls --enable-gpl --enable-libaom --enable-libbluray --enable-libmp3lame --enable-libopus --enable-librubberband --enable-libsnappy --enable-libtesseract --enable-libtheora --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-lzma --enable-libfontconfig --enable-libfreetype --enable-frei0r --enable-libass --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-librtmp --enable-libspeex --enable-libsoxr --enable-videotoolbox --disable-libjack --disable-indev=jack",
        "body": "Reads from audio/video capture devices using FFMPEG.\nSee FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\nTo list all supported grabbers for your GPAC build, use gpac -h ffavin:*.\n\nDevice identification\n\nTypical classes are dshow on windows, avfoundation on OSX, video4linux2 or x11grab on linux\n\nTypical device name can be the webcam name:\n- FaceTime HD Camera on OSX, device name on windows, /dev/video0 on linux\n- screen-capture-recorder, see http://screencapturer.sf.net/ on windows\n- Capture screen 0 on OSX (0=first screen), or screenN for short\n- X display name (e.g. :0.0) on linux\n\nThe general mapping from ffmpeg command line is:\n- ffmpeg -f maps to fmt option\n- ffmpeg -i maps to dev option\n\nExample:\nffmpeg -f libndi_newtek -i MY_NDI_TEST ...\ngpac -i av://:fmt=libndi_newtek:dev=MY_NDI_TEST ...\n\nYou may need to escape the dev option if the format uses ':' as separator, as is the case for AVFoundation:\nExample:\ngpac -i av://::dev=0:1 ...\n\n\n",
        "options": {
            "src": {
                "type": "str",
                "description": "url of device, video://, audio:// or av://"
            },
            "fmt": {
                "type": "str",
                "description": "name of device class. If not set, defaults to first device class"
            },
            "dev": {
                "type": "str",
                "description": "name of device or index of device",
                "default": "0"
            },
            "copy": {
                "type": "enum",
                "description": "set copy mode of raw frames",
                "default": "A",
                "enum": {
                    "N": "frames are only forwarded (shared memory, no copy)",
                    "A": "audio frames are copied, video frames are forwarded",
                    "V": "video frames are copied, audio frames are forwarded",
                    "AV": "all frames are copied"
                }
            },
            "sclock": {
                "type": "bool",
                "description": "use system clock (us) instead of device timestamp (for buggy devices)",
                "default": true
            },
            "probes": {
                "type": "uint",
                "description": "probe a given number of video frames before emitting (this usually helps with bad timing of the first frames)",
                "default": 10
            },
            "block_size": {
                "type": "uint",
                "description": "block size used to read file when using avio context",
                "default": 4096
            },
            "avioflags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "direct": "reduce buffering"
                }
            },
            "probesize": {
                "type": "lsint",
                "description": "set probing size",
                "default": "5000000"
            },
            "formatprobesize": {
                "type": "sint",
                "description": "number of bytes to probe file format",
                "default": "1048576"
            },
            "fflags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "ignidx": "ignore index",
                    "genpts": "generate pts",
                    "nofillin": "do not fill in missing values that can be exactly calculated",
                    "noparse": "disable AVParsers, this needs nofillin too",
                    "igndts": "ignore dts",
                    "discardcorrupt": "discard corrupted frames",
                    "sortdts": "try to interleave outputted packets by dts",
                    "keepside": "deprecated, does nothing",
                    "fastseek": "fast but inaccurate seeks",
                    "nobuffer": "reduce the latency introduced by optional buffering"
                }
            },
            "seek2any": {
                "type": "bool",
                "description": "allow seeking to non-keyframes on demuxer level when supported",
                "default": true
            },
            "analyzeduration": {
                "type": "lsint",
                "description": "specify how many microseconds are analyzed to probe the input",
                "default": "0"
            },
            "cryptokey": {
                "type": "uint",
                "description": "decryption key"
            },
            "indexmem": {
                "type": "sint",
                "description": "max memory used for timestamp index (per stream)",
                "default": "1048576"
            },
            "rtbufsize": {
                "type": "sint",
                "description": "max memory used for buffering real-time frames",
                "default": "3041280"
            },
            "fdebug": {
                "type": "uint",
                "description": "print specific debug info"
            },
            "max_delay": {
                "type": "sint",
                "description": "maximum muxing or demuxing delay in microseconds",
                "default": "-1"
            },
            "fpsprobesize": {
                "type": "sint",
                "description": "number of frames used to probe fps",
                "default": "-1"
            },
            "f_err_detect": {
                "type": "uint",
                "description": "set error detection flags (deprecated; use err_detect, save via avconv)",
                "enum": {
                    "err_detect": "set error detection flags",
                    "crccheck": "verify embedded CRCs",
                    "bitstream": "detect bitstream specification deviations",
                    "buffer": "detect improper bitstream length",
                    "explode": "abort decoding on minor error detection",
                    "ignore_err": "ignore errors",
                    "careful": "consider things that violate the spec, are fast to check and have not been seen in the wild as errors",
                    "compliant": "consider all spec non compliancies as errors",
                    "aggressive": "consider things that a sane encoder shouldn't do as an error"
                }
            },
            "use_wallclock_as_timestamps": {
                "type": "bool",
                "description": "use wallclock as timestamps",
                "default": true
            },
            "skip_initial_bytes": {
                "type": "lsint",
                "description": "set number of bytes to skip before reading header and frames",
                "default": "0"
            },
            "correct_ts_overflow": {
                "type": "bool",
                "description": "correct single timestamp overflows",
                "default": true
            },
            "f_strict": {
                "type": "sint",
                "description": "how strictly to follow the standards (deprecated; use strict, save via avconv)",
                "enum": {
                    "strict": "strictly conform to all the things in the spec no matter what the consequences",
                    "very": "strictly conform to a older more strict version of the spec or reference software",
                    "unofficial": "allow unofficial extensions",
                    "experimental": "allow non-standardized experimental variants"
                }
            },
            "max_ts_probe": {
                "type": "sint",
                "description": "maximum number of packets to read while waiting for the first timestamp",
                "default": "50"
            },
            "dump_separator": {
                "type": "str",
                "description": "set information dump field separator",
                "default": ""
            },
            "codec_whitelist": {
                "type": "str",
                "description": "List of decoders that are allowed to be used"
            },
            "format_whitelist": {
                "type": "str",
                "description": "List of demuxers that are allowed to be used"
            },
            "protocol_whitelist": {
                "type": "str",
                "description": "List of protocols that are allowed to be used"
            },
            "protocol_blacklist": {
                "type": "str",
                "description": "List of protocols that are not allowed to be used"
            },
            "max_streams": {
                "type": "sint",
                "description": "maximum number of streams",
                "default": "1000"
            },
            "skip_estimate_duration_from_pts": {
                "type": "bool",
                "description": "skip duration calculation in estimate_timings_from_pts",
                "default": true
            },
            "*": {
                "type": "str",
                "description": "any possible options defined for AVInputFormat and AVFormatContext (see gpac -hx ffavin and gpac -hx ffavin:*)"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": []
            },
            "output": {
                "codec_id": [],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": [
            "dashin",
            "cdcrypt",
            "nhmlr",
            "reframer",
            "flist",
            "dasher",
            "bsrw",
            "bssplit",
            "bsagg",
            "jsf",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "ffsws",
        "description": "FFMPEG video rescaler",
        "version": "SwS5.5.100",
        "body": "This filter rescales raw video data using FFMPEG to the specified size and pixel format.\n\nOutput size assignment\nIf osize is {0,0}, the output dimensions will be set to the input size, and input aspect ratio will be ignored.\n\nIf osize is {0,H} (resp. {W,0}), the output width (resp. height) will be set to respect input aspect ratio. If keepar=nosrc, input sample aspect ratio is ignored.\n\nAspect Ratio and Sample Aspect Ratio\nWhen output sample aspect ratio is set, the output dimensions are divided by the output sample aspect ratio.\nExample:\nffsws:osize=288x240:osar=3/2\nThe output dimensions will be 192x240.\n\nWhen aspect ratio is not kept (keepar=off):\n- source is resampled to desired dimensions\n- if output aspect ratio is not set, output will use source sample aspect ratio\n\nWhen aspect ratio is partially kept (keepar=nosrc):\n- resampling is done on the input data without taking input sample aspect ratio into account\n- if output sample aspect ratio is not set (osar=0/N), source aspect ratio is forwarded to output.\n\nWhen aspect ratio is fully kept (keepar=full), output aspect ratio is force to 1/1 if not set.\n\nWhen sample aspect ratio is kept, the filter will:\n- center the rescaled input frame on the output frame\n- fill extra pixels with padclr\n\nAlgorithms options\n- for bicubic, to tune the shape of the basis function, p1 tunes f(1) and p2 f\u00b4(1)\n- for gauss p1 tunes the exponent and thus cutoff frequency\n- for lanczos p1 tunes the width of the window function\n\nSee FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details\n\n\n",
        "options": {
            "osize": {
                "type": "v2di",
                "description": "osize of output video"
            },
            "ofmt": {
                "type": "pfmt",
                "description": "pixel format for output video. When not set, input format is used",
                "default": "none"
            },
            "scale": {
                "type": "enum",
                "description": "scaling mode (see filter help) (fastbilinear|bilinear|bicubic|X|point|area|bicublin|gauss|sinc|lanzcos|spline)",
                "default": "bicubic"
            },
            "p1": {
                "type": "dbl",
                "description": "scaling algo param1",
                "default": "+I"
            },
            "p2": {
                "type": "dbl",
                "description": "scaling algo param2",
                "default": "+I"
            },
            "ofr": {
                "type": "bool",
                "description": "force output full range",
                "default": true
            },
            "brightness": {
                "type": "bool",
                "description": "16.16 fixed point brightness correction, 0 means use default",
                "default": true
            },
            "contrast": {
                "type": "uint",
                "description": "16.16 fixed point brightness correction, 0 means use default",
                "default": 0
            },
            "saturation": {
                "type": "uint",
                "description": "16.16 fixed point brightness correction, 0 means use default",
                "default": 0
            },
            "otable": {
                "type": "sintl",
                "description": "the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x], use default if not set"
            },
            "itable": {
                "type": "sintl",
                "description": "the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x], use default if not set"
            },
            "keepar": {
                "type": "enum",
                "description": "keep aspect ratio",
                "default": "off",
                "enum": {
                    "off": "ignore aspect ratio",
                    "full": "respect aspect ratio, applying input sample aspect ratio info",
                    "nosrc": "respect aspect ratio but ignore input sample aspect ratio"
                }
            },
            "padclr": {
                "type": "str",
                "description": "clear color when aspect ration preservation is used",
                "default": "black"
            },
            "osar": {
                "type": "frac",
                "description": "force output pixel aspect ratio",
                "default": "0/1"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "xviddec",
            "j2kdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "ffenc",
        "description": "FFMPEG encoder",
        "version": "Lavc58.54.100",
        "configuration": "--prefix=/usr/local/Cellar/ffmpeg/4.2.2_1 --enable-shared --enable-pthreads --enable-version3 --enable-avresample --cc=clang --host-cflags='-I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include/darwin' --host-ldflags= --enable-ffplay --enable-gnutls --enable-gpl --enable-libaom --enable-libbluray --enable-libmp3lame --enable-libopus --enable-librubberband --enable-libsnappy --enable-libtesseract --enable-libtheora --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-lzma --enable-libfontconfig --enable-libfreetype --enable-frei0r --enable-libass --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-librtmp --enable-libspeex --enable-libsoxr --enable-videotoolbox --disable-libjack --disable-indev=jack",
        "body": "This filter encodes audio and video streams using FFMPEG.\nSee FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\nTo list all supported encoders for your GPAC build, use gpac -h ffenc:*.\n\nThe filter will try to resolve the codec name in c against a libavcodec codec name (e.g. libx264) and use it if found.\nIf not found, it will consider the name to be a GPAC codec name and find a codec for it. In that case, if no pixel format is given, codecs will be enumerated to find a matching pixel format.\n\nOptions can be passed from prompt using --OPT=VAL (global options) or appending ::OPT=VAL to the desired encoder filter.\n\nThe filter will look for property TargetRate on input PID to set the desired bitrate per PID.\n\nThe filter will force a closed gop boundary:\n- at each packet with a FileNumber property set or a CueStart property set to true.\n- if fintra and rc is set.\n\nWhen forcing a closed GOP boundary, the filter will flush, destroy and recreate the encoder to make sure a clean context is used, as currently many encoders in libavcodec do not support clean reset when forcing picture types.\nIf fintra is not set and the output of the encoder is a DASH session in live profile without segment timeline, fintra will be set to the target segment duration and rc will be set.\n\nThe filter will look for property logpass on input PID to set 2-pass log filename, otherwise defaults to ffenc2pass-PID.log.\n\nArguments may be updated at runtime. If rld is set, the encoder will be flushed then reloaded with new options.\nIf codec is video and fintra is set, reload will happen at next forced intra; otherwise, reload happens at next encode.\nThe rld option is usually needed for dynamic updates of rate control parameters, since most encoders in ffmpeg do not support it.\n\n\n",
        "options": {
            "c": {
                "type": "str",
                "description": "codec identifier. Can be any supported GPAC codec name or ffmpeg codec name - updated to ffmpeg codec name after initialization"
            },
            "pfmt": {
                "type": "pfmt",
                "description": "pixel format for input video. When not set, input format is used",
                "default": "none"
            },
            "fintra": {
                "type": "frac",
                "description": "force intra / IDR frames at the given period in sec, e.g. fintra=2 will force an intra every 2 seconds and fintra=1001/1000 will force an intra every 30 frames on 30000/1001=29.97 fps video; ignored for audio",
                "default": "-1/1"
            },
            "all_intra": {
                "type": "bool",
                "description": "only produce intra frames",
                "default": true
            },
            "ls": {
                "type": "bool",
                "description": "log stats",
                "default": true
            },
            "rc": {
                "type": "bool",
                "description": "reset encoder when forcing intra frame (some encoders might not support intra frame forcing)",
                "default": true
            },
            "rld": {
                "type": "bool",
                "description": "force reloading of encoder when arguments are updated",
                "default": true
            },
            "b": {
                "type": "lsint",
                "description": "set bitrate (in bits/s)",
                "default": "200000"
            },
            "ab": {
                "type": "lsint",
                "description": "set bitrate (in bits/s)",
                "default": "128000"
            },
            "bt": {
                "type": "sint",
                "description": "Set video bitrate tolerance (in bits/s). In 1-pass mode, bitrate tolerance specifies how far ratecontrol is willing to deviate from the target average bitrate value. This is not related to minimum/maximum bitrate. Lowering tolerance too much has an adverse effect on quality.",
                "default": "4000000"
            },
            "flags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "mv4": "use four motion vectors per macroblock (MPEG-4)",
                    "qpel": "use 1/4-pel motion compensation",
                    "loop": "use loop filter",
                    "gray": "only decode/encode grayscale",
                    "psnr": "error[?] variables will be set during encoding",
                    "ildct": "use interlaced DCT",
                    "low_delay": "force low delay",
                    "global_header": "place global headers in extradata instead of every keyframe",
                    "bitexact": "use only bitexact functions (except (I)DCT)",
                    "aic": "H.263 advanced intra coding / MPEG-4 AC prediction",
                    "ilme": "interlaced motion estimation",
                    "cgop": "closed GOP"
                }
            },
            "flags2": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "fast": "allow non-spec-compliant speedup tricks",
                    "noout": "skip bitstream encoding",
                    "local_header": "place global headers at every keyframe instead of in extradata"
                }
            },
            "g": {
                "type": "sint",
                "description": "set the group of picture (GOP) size",
                "default": "12"
            },
            "ar": {
                "type": "sint",
                "description": "set audio sampling rate (in Hz)",
                "default": "0"
            },
            "ac": {
                "type": "sint",
                "description": "set number of audio channels",
                "default": "0"
            },
            "cutoff": {
                "type": "sint",
                "description": "set cutoff bandwidth",
                "default": "0"
            },
            "frame_size": {
                "type": "sint",
                "description": "(null)",
                "default": "0"
            },
            "qcomp": {
                "type": "flt",
                "description": "video quantizer scale compression (VBR). Constant of ratecontrol equation. Recommended range for default rc_eq: 0.0-1.0",
                "default": 0.5
            },
            "qblur": {
                "type": "flt",
                "description": "video quantizer scale blur (VBR)",
                "default": 0.5
            },
            "qmin": {
                "type": "sint",
                "description": "minimum video quantizer scale (VBR)",
                "default": "2"
            },
            "qmax": {
                "type": "sint",
                "description": "maximum video quantizer scale (VBR)",
                "default": "31"
            },
            "qdiff": {
                "type": "sint",
                "description": "maximum difference between the quantizer scales (VBR)",
                "default": "3"
            },
            "bf": {
                "type": "sint",
                "description": "set maximum number of B-frames between non-B-frames",
                "default": "0"
            },
            "b_qfactor": {
                "type": "flt",
                "description": "QP factor between P- and B-frames",
                "default": 1.25
            },
            "b_strategy": {
                "type": "sint",
                "description": "strategy to choose between I/P/B-frames",
                "default": "0"
            },
            "ps": {
                "type": "sint",
                "description": "RTP payload size in bytes",
                "default": "0"
            },
            "strict": {
                "type": "sint",
                "description": "how strictly to follow the standards",
                "enum": {
                    "very": "strictly conform to a older more strict version of the spec or reference software",
                    "strict": "strictly conform to all the things in the spec no matter what the consequences",
                    "unofficial": "allow unofficial extensions",
                    "experimental": "allow non-standardized experimental things"
                }
            },
            "b_qoffset": {
                "type": "flt",
                "description": "QP offset between P- and B-frames",
                "default": 1.25
            },
            "mpeg_quant": {
                "type": "sint",
                "description": "use MPEG quantizers instead of H.263",
                "default": "0"
            },
            "maxrate": {
                "type": "lsint",
                "description": "maximum bitrate (in bits/s). Used for VBV together with bufsize.",
                "default": "0"
            },
            "minrate": {
                "type": "lsint",
                "description": "minimum bitrate (in bits/s). Most useful in setting up a CBR encode. It is of little use otherwise.",
                "default": "0"
            },
            "bufsize": {
                "type": "sint",
                "description": "set ratecontrol buffer size (in bits)",
                "default": "0"
            },
            "i_qfactor": {
                "type": "flt",
                "description": "QP factor between P- and I-frames",
                "default": -0.8
            },
            "i_qoffset": {
                "type": "flt",
                "description": "QP offset between P- and I-frames",
                "default": 0.0
            },
            "dct": {
                "type": "sint",
                "description": "DCT algorithm",
                "enum": {
                    "auto": "autoselect a good one",
                    "fastint": "fast integer",
                    "int": "accurate integer",
                    "faan": "floating point AAN DCT"
                }
            },
            "lumi_mask": {
                "type": "flt",
                "description": "compresses bright areas stronger than medium ones",
                "default": 0.0
            },
            "tcplx_mask": {
                "type": "flt",
                "description": "temporal complexity masking",
                "default": 0.0
            },
            "scplx_mask": {
                "type": "flt",
                "description": "spatial complexity masking",
                "default": 0.0
            },
            "p_mask": {
                "type": "flt",
                "description": "inter masking",
                "default": 0.0
            },
            "dark_mask": {
                "type": "flt",
                "description": "compresses dark areas stronger than medium ones",
                "default": 0.0
            },
            "idct": {
                "type": "sint",
                "description": "select IDCT implementation",
                "enum": {
                    "xvidmmx": "deprecated, for compatibility only",
                    "faani": "floating point AAN IDCT"
                }
            },
            "pred": {
                "type": "sint",
                "description": "prediction method"
            },
            "aspect": {
                "type": "frac",
                "description": "sample aspect ratio",
                "default": "0/0"
            },
            "sar": {
                "type": "frac",
                "description": "sample aspect ratio",
                "default": "0/0"
            },
            "debug": {
                "type": "uint",
                "description": "print specific debug info",
                "enum": {
                    "rc": "rate control"
                }
            },
            "dia_size": {
                "type": "sint",
                "description": "diamond type & size for motion estimation",
                "default": "0"
            },
            "last_pred": {
                "type": "sint",
                "description": "amount of motion predictors from the previous frame",
                "default": "0"
            },
            "preme": {
                "type": "sint",
                "description": "pre motion estimation",
                "default": "0"
            },
            "pre_dia_size": {
                "type": "sint",
                "description": "diamond type & size for motion estimation pre-pass",
                "default": "0"
            },
            "subq": {
                "type": "sint",
                "description": "sub-pel motion estimation quality",
                "default": "8"
            },
            "me_range": {
                "type": "sint",
                "description": "limit motion vectors range (1023 for DivX player)",
                "default": "0"
            },
            "global_quality": {
                "type": "sint",
                "description": "(null)",
                "default": "0"
            },
            "coder": {
                "type": "sint",
                "description": " ",
                "enum": {
                    "vlc": "variable length coder / Huffman coder",
                    "ac": "arithmetic coder",
                    "raw": "raw (no encoding)",
                    "rle": "run-length coder"
                }
            },
            "context": {
                "type": "sint",
                "description": "context model",
                "default": "0"
            },
            "mbd": {
                "type": "sint",
                "description": "macroblock decision algorithm (high quality mode)",
                "enum": {
                    "simple": "use mbcmp",
                    "bits": "use fewest bits",
                    "rd": "use best rate distortion"
                }
            },
            "sc_threshold": {
                "type": "sint",
                "description": "scene change threshold",
                "default": "0"
            },
            "nr": {
                "type": "sint",
                "description": "noise reduction",
                "default": "0"
            },
            "rc_init_occupancy": {
                "type": "sint",
                "description": "number of bits which should be loaded into the rc buffer before decoding starts",
                "default": "0"
            },
            "threads": {
                "type": "sint",
                "description": "set the number of threads",
                "enum": {
                    "auto": "autodetect a suitable number of threads to use"
                }
            },
            "dc": {
                "type": "sint",
                "description": "intra_dc_precision",
                "default": "0"
            },
            "nssew": {
                "type": "sint",
                "description": "nsse weight",
                "default": "8"
            },
            "profile": {
                "type": "sint",
                "description": " "
            },
            "level": {
                "type": "sint",
                "description": " "
            },
            "skip_threshold": {
                "type": "sint",
                "description": "frame skip threshold",
                "default": "0"
            },
            "skip_factor": {
                "type": "sint",
                "description": "frame skip factor",
                "default": "0"
            },
            "skip_exp": {
                "type": "sint",
                "description": "frame skip exponent",
                "default": "0"
            },
            "skipcmp": {
                "type": "sint",
                "description": "frame skip compare function",
                "enum": {
                    "cmp": "full-pel ME compare function",
                    "subcmp": "sub-pel ME compare function",
                    "mbcmp": "macroblock compare function",
                    "ildctcmp": "interlaced DCT compare function",
                    "precmp": "pre motion estimation compare function",
                    "sad": "sum of absolute differences, fast",
                    "sse": "sum of squared errors",
                    "satd": "sum of absolute Hadamard transformed differences",
                    "dct": "sum of absolute DCT transformed differences",
                    "psnr": "sum of squared quantization errors (avoid, low quality)",
                    "bit": "number of bits needed for the block",
                    "rd": "rate distortion optimal, slow",
                    "zero": "0",
                    "vsad": "sum of absolute vertical differences",
                    "vsse": "sum of squared vertical differences",
                    "nsse": "noise preserving sum of squared differences",
                    "w53": "5/3 wavelet, only used in snow",
                    "w97": "9/7 wavelet, only used in snow",
                    "msad": "sum of absolute differences, median predicted"
                }
            },
            "mblmin": {
                "type": "sint",
                "description": "minimum macroblock Lagrange factor (VBR)",
                "default": "236"
            },
            "mblmax": {
                "type": "sint",
                "description": "maximum macroblock Lagrange factor (VBR)",
                "default": "3658"
            },
            "mepc": {
                "type": "sint",
                "description": "motion estimation bitrate penalty compensation (1.0 = 256)",
                "default": "256"
            },
            "bidir_refine": {
                "type": "sint",
                "description": "refine the two motion vectors used in bidirectional macroblocks",
                "default": "1"
            },
            "brd_scale": {
                "type": "sint",
                "description": "downscale frames for dynamic B-frame decision",
                "default": "0"
            },
            "keyint_min": {
                "type": "sint",
                "description": "minimum interval between IDR-frames",
                "default": "25"
            },
            "refs": {
                "type": "sint",
                "description": "reference frames to consider for motion compensation",
                "default": "1"
            },
            "chromaoffset": {
                "type": "sint",
                "description": "chroma QP offset from luma",
                "default": "0"
            },
            "trellis": {
                "type": "sint",
                "description": "rate-distortion optimal quantization",
                "default": "0"
            },
            "mv0_threshold": {
                "type": "sint",
                "description": "(null)",
                "default": "256"
            },
            "b_sensitivity": {
                "type": "sint",
                "description": "adjust sensitivity of b_frame_strategy 1",
                "default": "40"
            },
            "compression_level": {
                "type": "sint",
                "description": "(null)",
                "default": "-1"
            },
            "min_prediction_order": {
                "type": "sint",
                "description": "(null)",
                "default": "-1"
            },
            "max_prediction_order": {
                "type": "sint",
                "description": "(null)",
                "default": "-1"
            },
            "timecode_frame_start": {
                "type": "lsint",
                "description": "GOP timecode frame start number, in non-drop-frame format",
                "default": "-1"
            },
            "channel_layout": {
                "type": "luint",
                "description": "(null)",
                "default": "0"
            },
            "rc_max_vbv_use": {
                "type": "flt",
                "description": "(null)",
                "default": 0.0
            },
            "rc_min_vbv_use": {
                "type": "flt",
                "description": "(null)",
                "default": 3.0
            },
            "ticks_per_frame": {
                "type": "sint",
                "description": "(null)",
                "default": "1"
            },
            "color_primaries": {
                "type": "sint",
                "description": "color primaries",
                "enum": {
                    "bt709": "BT.709",
                    "unknown": "Unspecified",
                    "bt470m": "BT.470 M",
                    "bt470bg": "BT.470 BG",
                    "smpte170m": "SMPTE 170 M",
                    "smpte240m": "SMPTE 240 M",
                    "film": "Film",
                    "bt2020": "BT.2020",
                    "smpte428": "SMPTE 428-1",
                    "smpte428_1": "SMPTE 428-1",
                    "smpte431": "SMPTE 431-2",
                    "smpte432": "SMPTE 422-1",
                    "jedec-p22": "JEDEC P22",
                    "unspecified": "Unspecified"
                }
            },
            "color_trc": {
                "type": "sint",
                "description": "color transfer characteristics",
                "enum": {
                    "bt709": "BT.709",
                    "unknown": "Unspecified",
                    "gamma22": "BT.470 M",
                    "gamma28": "BT.470 BG",
                    "smpte170m": "SMPTE 170 M",
                    "smpte240m": "SMPTE 240 M",
                    "linear": "Linear",
                    "log100": "Log",
                    "log316": "Log square root",
                    "iec61966-2-4": "IEC 61966-2-4",
                    "bt1361e": "BT.1361",
                    "iec61966-2-1": "IEC 61966-2-1",
                    "bt2020-10": "BT.2020 - 10 bit",
                    "bt2020-12": "BT.2020 - 12 bit",
                    "smpte2084": "SMPTE 2084",
                    "smpte428": "SMPTE 428-1",
                    "arib-std-b67": "ARIB STD-B67",
                    "unspecified": "Unspecified",
                    "log": "Log",
                    "log_sqrt": "Log square root",
                    "iec61966_2_4": "IEC 61966-2-4",
                    "bt1361": "BT.1361",
                    "iec61966_2_1": "IEC 61966-2-1",
                    "bt2020_10bit": "BT.2020 - 10 bit",
                    "bt2020_12bit": "BT.2020 - 12 bit",
                    "smpte428_1": "SMPTE 428-1"
                }
            },
            "colorspace": {
                "type": "sint",
                "description": "color space",
                "enum": {
                    "rgb": "RGB",
                    "bt709": "BT.709",
                    "unknown": "Unspecified",
                    "fcc": "FCC",
                    "bt470bg": "BT.470 BG",
                    "smpte170m": "SMPTE 170 M",
                    "smpte240m": "SMPTE 240 M",
                    "ycgco": "YCGCO",
                    "bt2020nc": "BT.2020 NCL",
                    "bt2020c": "BT.2020 CL",
                    "smpte2085": "SMPTE 2085",
                    "unspecified": "Unspecified",
                    "ycocg": "YCGCO",
                    "bt2020_ncl": "BT.2020 NCL",
                    "bt2020_cl": "BT.2020 CL"
                }
            },
            "color_range": {
                "type": "sint",
                "description": "color range",
                "enum": {
                    "unknown": "Unspecified",
                    "tv": "MPEG (219*2^(n-8))",
                    "pc": "JPEG (2^n-1)",
                    "unspecified": "Unspecified",
                    "mpeg": "MPEG (219*2^(n-8))",
                    "jpeg": "JPEG (2^n-1)"
                }
            },
            "chroma_sample_location": {
                "type": "sint",
                "description": "chroma sample location",
                "enum": {
                    "unknown": "Unspecified",
                    "left": "Left",
                    "center": "Center",
                    "topleft": "Top-left",
                    "top": "Top",
                    "bottomleft": "Bottom-left",
                    "bottom": "Bottom",
                    "unspecified": "Unspecified"
                }
            },
            "slices": {
                "type": "sint",
                "description": "set the number of slices, used in parallelized encoding",
                "default": "0"
            },
            "thread_type": {
                "type": "uint",
                "description": "select multithreading type"
            },
            "audio_service_type": {
                "type": "sint",
                "description": "audio service type",
                "enum": {
                    "ma": "Main Audio Service",
                    "ef": "Effects",
                    "vi": "Visually Impaired",
                    "hi": "Hearing Impaired",
                    "di": "Dialogue",
                    "co": "Commentary",
                    "em": "Emergency",
                    "vo": "Voice Over",
                    "ka": "Karaoke"
                }
            },
            "side_data_only_packets": {
                "type": "bool",
                "description": "(null)",
                "default": true
            },
            "field_order": {
                "type": "sint",
                "description": "Field order"
            },
            "dump_separator": {
                "type": "str",
                "description": "set information dump field separator"
            },
            "max_pixels": {
                "type": "lsint",
                "description": "Maximum number of pixels",
                "default": "+I"
            },
            "*": {
                "type": "str",
                "description": "any possible options defined for AVCodecContext and sub-classes. see gpac -hx ffenc and gpac -hx ffenc:*"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "dashin",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "avimx",
            "ufm4v",
            "ufvc1",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "jsf",
            "rftruehd",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "ffmx",
        "description": "FFMPEG multiplexer",
        "version": "Lavf58.29.100",
        "configuration": "--prefix=/usr/local/Cellar/ffmpeg/4.2.2_1 --enable-shared --enable-pthreads --enable-version3 --enable-avresample --cc=clang --host-cflags='-I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include/darwin' --host-ldflags= --enable-ffplay --enable-gnutls --enable-gpl --enable-libaom --enable-libbluray --enable-libmp3lame --enable-libopus --enable-librubberband --enable-libsnappy --enable-libtesseract --enable-libtheora --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-lzma --enable-libfontconfig --enable-libfreetype --enable-frei0r --enable-libass --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-librtmp --enable-libspeex --enable-libsoxr --enable-videotoolbox --disable-libjack --disable-indev=jack",
        "body": "Multiplexes files and open output protocols using FFMPEG.\nSee FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\nTo list all supported multiplexers for your GPAC build, use gpac -h ffmx:*.This will list both supported output formats and protocols.\nOutput protocols are listed with Description: Output protocol, and the subclass name identifies the protocol scheme.\nFor example, if ffmx:rtmp is listed as output protocol, this means rtmp:// destination URLs are supported.\n\nSome URL formats may not be sufficient to derive the multiplexing format, you must then use ffmt to specify the desired format.\n\nUnlike other multiplexing filters in GPAC, this filter is a sink filter and does not produce any PID to be redirected in the graph.\nThe filter can however use template names for its output, using the first input PID to resolve the final name.\nThe filter watches the property FileNumber on incoming packets to create new files.\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "location of destination file or remote URL"
            },
            "start": {
                "type": "dbl",
                "description": "set playback start offset. A negative value means percent of media duration with -1 equal to duration",
                "default": "0.0"
            },
            "speed": {
                "type": "dbl",
                "description": "set playback speed. If negative and start is 0, start is set to -1",
                "default": "1.0"
            },
            "ileave": {
                "type": "frac",
                "description": "interleave window duration in second, a value of 0 disable interleaving",
                "default": "1"
            },
            "nodisc": {
                "type": "bool",
                "description": "ignore stream configuration changes while multiplexing, may result in broken streams",
                "default": true
            },
            "mime": {
                "type": "cstr",
                "description": "set mime type for graph resolution"
            },
            "ffiles": {
                "type": "bool",
                "description": "force complete files to be created for each segment in DASH modes",
                "default": true
            },
            "ffmt": {
                "type": "str",
                "description": "force ffmpeg output format for the given URL"
            },
            "block_size": {
                "type": "uint",
                "description": "block size used to read file when using avio context",
                "default": 4096
            },
            "keepts": {
                "type": "bool",
                "description": "do not shift input timeline back to 0",
                "default": true
            },
            "avioflags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "direct": "reduce buffering"
                }
            },
            "packetsize": {
                "type": "sint",
                "description": "set packet size",
                "default": "0"
            },
            "fflags": {
                "type": "uint",
                "description": " ",
                "enum": {
                    "flush_packets": "reduce the latency by flushing out packets immediately",
                    "latm": "deprecated, does nothing",
                    "bitexact": "do not write random/volatile data",
                    "shortest": "stop muxing with the shortest stream",
                    "autobsf": "add needed bsfs automatically"
                }
            },
            "fdebug": {
                "type": "uint",
                "description": "print specific debug info"
            },
            "max_delay": {
                "type": "sint",
                "description": "maximum muxing or demuxing delay in microseconds",
                "default": "-1"
            },
            "start_time_realtime": {
                "type": "lsint",
                "description": "wall-clock time when stream begins (PTS==0)",
                "default": "-9223372036854775808"
            },
            "audio_preload": {
                "type": "sint",
                "description": "microseconds by which audio packets should be interleaved earlier",
                "default": "0"
            },
            "chunk_duration": {
                "type": "sint",
                "description": "microseconds for each chunk",
                "default": "0"
            },
            "chunk_size": {
                "type": "sint",
                "description": "size in bytes for each chunk",
                "default": "0"
            },
            "flush_packets": {
                "type": "sint",
                "description": "enable flushing of the I/O context after each packet",
                "default": "-1"
            },
            "metadata_header_padding": {
                "type": "sint",
                "description": "set number of bytes to be written as padding in a metadata header",
                "default": "-1"
            },
            "output_ts_offset": {
                "type": "uint",
                "description": "set output timestamp offset"
            },
            "max_interleave_delta": {
                "type": "lsint",
                "description": "maximum buffering duration for interleaving",
                "default": "10000000"
            },
            "f_strict": {
                "type": "sint",
                "description": "how strictly to follow the standards (deprecated; use strict, save via avconv)",
                "enum": {
                    "strict": "strictly conform to all the things in the spec no matter what the consequences",
                    "very": "strictly conform to a older more strict version of the spec or reference software",
                    "unofficial": "allow unofficial extensions",
                    "experimental": "allow non-standardized experimental variants"
                }
            },
            "avoid_negative_ts": {
                "type": "sint",
                "description": "shift timestamps so they start at 0",
                "enum": {
                    "auto": "enabled when required by target format",
                    "disabled": "do not change timestamps",
                    "make_non_negative": "shift timestamps so they are non negative",
                    "make_zero": "shift timestamps so they start at 0"
                }
            },
            "dump_separator": {
                "type": "str",
                "description": "set information dump field separator",
                "default": ""
            },
            "*": {
                "type": "str",
                "description": "any possible options defined for AVFormatContext and sub-classes (see gpac -hx ffmx and gpac -hx ffmx:*)"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "Simple Text Stream",
                    "WebVTT Text",
                    "Codec Not Supported",
                    "DVB Subtitles",
                    "Subtitle text Stream"
                ],
                "stream_type": ["Audio", "Visual", "Text"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "reframer",
            "ufvtt",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2srt",
            "tx3g2vtt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": []
    },
    {
        "name": "ffavf",
        "description": "FFMPEG AVFilter",
        "version": "Lavf58.29.100",
        "configuration": "--prefix=/usr/local/Cellar/ffmpeg/4.2.2_1 --enable-shared --enable-pthreads --enable-version3 --enable-avresample --cc=clang --host-cflags='-I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/adoptopenjdk-13.0.1.jdk/Contents/Home/include/darwin' --host-ldflags= --enable-ffplay --enable-gnutls --enable-gpl --enable-libaom --enable-libbluray --enable-libmp3lame --enable-libopus --enable-librubberband --enable-libsnappy --enable-libtesseract --enable-libtheora --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-lzma --enable-libfontconfig --enable-libfreetype --enable-frei0r --enable-libass --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-librtmp --enable-libspeex --enable-libsoxr --enable-videotoolbox --disable-libjack --disable-indev=jack",
        "body": "This filter provides libavfilter raw audio and video tools.\nSee FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details\nTo list all supported avfilters for your GPAC build, use gpac -h ffavf:*.\n\nDeclaring a filter\n\nThe filter loads a filter or a filter chain description from the f option.\nExample:\nffavf:f=showspectrum\n\nUnlike other FFMPEG bindings in GPAC, this filter does not parse other libavfilter options, you must specify them directly in the filter chain, and the f option will have to be escaped.\nExample:\nffavf::f=showspectrum=size=320x320 or ffavf::f=showspectrum=size=320x320::pfmt=rgb\nffavf::f=anullsrc=channel_layout=5.1:sample_rate=48000\n\nFor complex filter graphs, it is possible to store options in a file (e.g. opts.txt):\nExample:\n:f=anullsrc=channel_layout=5.1:sample_rate=48000\nAnd load arguments from file:\nExample:\nffavf:opts.txt aout\n\nThe filter will automatically create buffer and buffersink AV filters for data exchange between GPAC and libavfilter.\nThe builtin options ( pfmt, afmt ...) can be used to configure the buffersink filter to set the output format of the filter.\n\nNaming of PIDs\n\nFor simple filter graphs with only one input and one output, the input PID is assigned the avfilter name in and the output PID is assigned the avfilter name out\n\nWhen a graph has several inputs, input PID names shall be assigned by the user using the ffid property, and mapping must be done in the filter.\nExample:\ngpac -i video:#ffid=a -i logo:#ffid=b ffavf::f=[a][b]overlay=main_w-overlay_w-10:main_h-overlay_h-10 vout\nIn this example:\n- the video source is identified as a\n- the logo source is identified as b\n- the filter declaration maps a to its first input (in this case, main video) and b to its second input (in this case the overlay)\n\nWhen a graph has several outputs, output PIDs will be identified using the ffid property set to the output avfilter name.\nExample:\ngpac -i source ffavf::f=split inspect:SID=#ffid=out0 vout#SID=out1\nIn this example:\n- the splitter produces 2 video streams out0 and out1\n- the inspector only process stream with ffid out0\n- the video output only displays stream with ffid out1\n\nThe name(s) of the final output of the avfilter graph cannot be configured in GPAC. You can however name intermediate output(s) in a complex filter chain as usual.\n\nFilter graph commands\n\nThe filter handles option updates as commands passed to the AV filter graph. The syntax expected in the option name is:\n\t* com_name=value: sends command com_name with value value to all filters\n\t* name#com_name=value: sends command com_name with value value to filter named name\n\n\n",
        "options": {
            "f": {
                "type": "str",
                "description": "filter or filter chain description"
            },
            "pfmt": {
                "type": "pfmt",
                "description": "pixel format of output. If not set, let AVFilter decide",
                "default": "none"
            },
            "afmt": {
                "type": "afmt",
                "description": "audio format of output. If not set, let AVFilter decide",
                "default": "none"
            },
            "sr": {
                "type": "uint",
                "description": "sample rate of output. If not set, let AVFilter decide",
                "default": 0
            },
            "ch": {
                "type": "uint",
                "description": "number of channels of output. If not set, let AVFilter decide",
                "default": 0
            },
            "dump": {
                "type": "bool",
                "description": "dump graph as log media@info or stderr if not set",
                "default": true
            },
            "thread_type": {
                "type": "uint",
                "description": "Allowed thread types"
            },
            "enable": {
                "type": "str",
                "description": "set enable expression"
            },
            "threads": {
                "type": "sint",
                "description": "Allowed number of threads",
                "default": "0"
            },
            "extra_hw_frames": {
                "type": "sint",
                "description": "Number of extra hardware frames to allocate for the user",
                "default": "-1"
            },
            "*": {
                "type": "str",
                "description": "any possible options defined for AVFilter and sub-classes (see gpac -hx ffavf and gpac -hx ffavf:*)"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "jsf",
        "description": "JavaScript filter",
        "body": "This filter runs a javascript file specified in js defining a new JavaScript filter.\n  \nFor more information on how to use JS filters, please check https://wiki.gpac.io/jsfilter\n\n\n",
        "options": {
            "js": {
                "type": "cstr",
                "description": "location of script source"
            },
            "*": {
                "type": "str",
                "description": "any possible options defined for the script (see gpac -hx jsf:js=$YOURSCRIPT or gpac -hx $YOURSCRIPT)"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["Unknown"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["Unknown"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "cryptin",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "fin",
            "btplay",
            "httpin",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "fout",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "vobsubdmx",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "pout",
            "gsfmx",
            "gsfdmx",
            "sockout",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "routeout",
        "description": "ROUTE output",
        "body": "The ROUTE output filter is used to distribute a live file-based session using ROUTE.\nThe filter supports DASH and HLS inputs, ATSC3.0 signaling and generic ROUTE signaling.\n\nThe filter is identified using the following URL schemes:\n\t* `atsc://`: session is a full ATSC 3.0 session\n\t* `route://IP:port`: session is a ROUTE session running on given multicast IP and port\n\nThe filter only accepts input PIDs of type FILE.\n- HAS Manifests files are detected by file extension and/or MIME types, and sent as part of the signaling bundle or as LCT object files for HLS child playlists.\n- HAS Media segments are detected using the OrigStreamType property, and send as LCT object files using the DASH template string.\n- A PID without OrigStreamType property set is delivered as a regular LCT object file (called raw hereafter).\n  \nFor raw file PIDs, the filter will look for the following properties:\n\t* `ROUTEName`: set resource name. If not found, uses basename of URL\n\t* `ROUTECarousel`: set repeat period. If not found, uses carousel. If 0, the file is only sent once\n\t* `ROUTEUpload`: set resource upload time. If not found, uses carousel. If 0, the file will be sent as fast as possible.\n\nWhen DASHing for ROUTE or single service ATSC, a file extension, either in dst or in ext, may be used to identify the HAS session type (DASH or HLS).\nExample:\n\"route://IP:PORT/manifest.mpd\", \"route://IP:PORT/:ext=mpd\"\n\nWhen DASHing for multi-service ATSC, forcing an extension will force all service to use the same formats.\nExample:\n\"atsc://:ext=mpd\", \"route://IP:PORT/manifest.mpd\"\nIf multiple services with different formats are needed, you will need to explicit your filters:\nExample:\ngpac -i DASH_URL:#ServiceID=1 dashin:forward=file:FID=1 -i HLS_URL:#ServiceID=2 dashin:forward=file:FID=2 -o atsc://:SID=1,2\ngpac -i MOVIE1:#ServiceID=1 dasher:FID=1:mname=manifest.mpd -i MOVIE2:#ServiceID=2 dasher:FID=2:mname=manifest.m3u8 -o atsc://:SID=1,2\n\nWarning: When forwarding an existing DASH/HLS session, do NOT set any extension or manifest name.\n\nBy default, all streams in a service are assigned to a single route session, and differentiated by ROUTE TSI (see splitlct).\nTSI are assigned as follows:\n- signaling TSI is always 0\n- raw files are assigned TSI 1 and increasing number of TOI\n- otherwise, the first PID found is assigned TSI 10, the second TSI 20 etc ...\n\nInit segments and HLS child playlists are sent before each new segment, independently of carousel.\n\nATSC 3.0 mode\n\nIn this mode, the filter allows multiple service multiplexing, identified through the ServiceID property.\nBy default, a single multicast IP is used for route sessions, each service will be assigned a different port.\nThe filter will look for ROUTEIP and ROUTEPort properties on the incoming PID. If not found, the default ip and port will be used.\n\nThe ATSC short service name can be set using PID property ShortServiceName. If not found, ServiceName is checked, otherwise default to GPAC.\n\nROUTE mode\n\nIn this mode, only a single service can be distributed by the ROUTE session.\nNote: ip is ignored, and first_port is used if no port is specified in dst.\nThe ROUTE session will include a multi-part MIME unsigned package containing manifest and S-TSID, sent on TSI=0.\n\nLow latency mode\n\nWhen using low-latency mode, the input media segments are not re-assembled in a single packet but are instead sent as they are received.\nIn order for the real-time scheduling of data chunks to work, each fragment of the segment should have a CTS and timestamp describing its timing.\nIf this is not the case (typically when used with an existing DASH session in file mode), the scheduler will estimate CTS and duration based on the stream bitrate and segment duration. The indicated bitrate is increased by brinc percent for safety.\nIf this fails, the filter will trigger warnings and send as fast as possible.\nNote: The LCT objects are sent with no length (TOL header) assigned until the final segment size is known, potentially leading to a final 0-size LCT fragment signaling only the final size.\n\nExamples\n\nSince the ROUTE filter only consumes files, it is required to insert:\n- the dash demultiplexer in file forwarding mode when loading a DASH session\n- the dash multiplexer when creating a DASH session\n\nMultiplexing an existing DASH session in route:\nExample:\ngpac -i source.mpd dashin:forward=file -o route://225.1.1.0:6000/\nMultiplexing an existing DASH session in atsc:\nExample:\ngpac -i source.mpd dashin:forward=file -o atsc://\nDashing and multiplexing in route:\nExample:\ngpac -i source.mp4 dasher:profile=live -o route://225.1.1.0:6000/manifest.mpd\nDashing and multiplexing in route Low Latency:\nExample:\ngpac -i source.mp4 dasher -o route://225.1.1.0:6000/manifest.mpd:profile=live:cdur=0.2:llmode\n\nSending a single file in ROUTE using half a second upload time, 2 seconds carousel:\nExample:\ngpac -i URL:#ROUTEUpload=0.5:#ROUTECarousel=2 -o route://225.1.1.0:6000/\n\nCommon mistakes:\nExample:\ngpac -i source.mpd -o route://225.1.1.0:6000/\nThis will only send the manifest file as a regular object and will not load the dash session.\nExample:\ngpac -i source.mpd dashin:forward=file -o route://225.1.1.0:6000/manifest.mpd\nThis will force the ROUTE multiplexer to only accept .mpd files, and will drop all segment files (same if ext is used).\nExample:\ngpac -i source.mpd dasher -o route://225.1.1.0:6000/\ngpac -i source.mpd dasher -o route://225.1.1.0:6000/manifest.mpd\nThese will demultiplex the input, re-dash it and send the output of the dasher to ROUTE\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "destination URL"
            },
            "ext": {
                "type": "cstr",
                "description": "set extension for graph resolution, regardless of file extension"
            },
            "mime": {
                "type": "cstr",
                "description": "set mime type for graph resolution"
            },
            "ifce": {
                "type": "str",
                "description": "default interface to use for multicast. If NULL, the default system interface will be used"
            },
            "carousel": {
                "type": "uint",
                "description": "carousel period in ms for repeating signaling and raw file data",
                "default": 1000
            },
            "first_port": {
                "type": "uint",
                "description": "port number of first ROUTE session in ATSC mode",
                "default": 6000
            },
            "ip": {
                "type": "str",
                "description": "multicast IP address for ROUTE session in ATSC mode",
                "default": "225.1.1.0"
            },
            "ttl": {
                "type": "uint",
                "description": "time-to-live for multicast packets",
                "default": 0
            },
            "bsid": {
                "type": "uint",
                "description": "ID for ATSC broadcast stream",
                "default": 800
            },
            "mtu": {
                "type": "uint",
                "description": "size of LCT MTU in bytes",
                "default": 1472
            },
            "splitlct": {
                "type": "enum",
                "description": "split mode for LCT channels",
                "default": "off",
                "enum": {
                    "off": "all streams are in the same LCT channel",
                    "type": "each new stream type results in a new LCT channel",
                    "all": "all streams are in dedicated LCT channel, the first stream being used for STSID signaling"
                }
            },
            "korean": {
                "type": "bool",
                "description": "use Korean version of ATSC 3.0 spec instead of US",
                "default": true
            },
            "llmode": {
                "type": "bool",
                "description": "use low-latency mode",
                "default": true
            },
            "brinc": {
                "type": "uint",
                "description": "bitrate increase in percent when estimating timing in low latency mode",
                "default": 10
            },
            "noreg": {
                "type": "bool",
                "description": "disable rate regulation for media segments, pushing them as fast as received",
                "default": true
            },
            "runfor": {
                "type": "uint",
                "description": "run for the given time in ms",
                "default": 0
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "mp4mx",
            "nhmlr",
            "rtpin",
            "writegen",
            "writeqcp",
            "nhntw",
            "nhmlw",
            "m2tsmx",
            "dasher",
            "pin",
            "gsfmx",
            "gsfdmx",
            "routein",
            "rtpout",
            "httpout",
            "tssplit",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx"
        ],
        "sinks": []
    },
    {
        "name": "rftruehd",
        "description": "TrueHD reframer",
        "body": "This filter parses Dolby TrueHD files/data and outputs corresponding audio PID and frames.\n\n\n",
        "options": {
            "index": {
                "type": "dbl",
                "description": "indexing window length",
                "default": "1.0"
            },
            "auxac3": {
                "type": "bool",
                "description": "expose auxiliary AC-3 stream if present",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Dolby TrueHD"],
                "stream_type": ["File", "Audio"]
            },
            "output": {
                "codec_id": ["Dolby TrueHD"],
                "stream_type": ["Audio"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "m2tsdmx",
            "sockin",
            "safdmx",
            "dashin",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "writegen",
            "flist",
            "dasher",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "cryptin",
            "cryptout",
            "restamp",
            "unframer",
            "writeuf"
        ],
        "sinks": [
            "inspect",
            "probe",
            "cecrypt",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "m2tsmx",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdec",
            "ffmx",
            "restamp",
            "writeuf",
            ""
        ]
    },
    {
        "name": "cryptin",
        "description": "CryptFile input",
        "body": "This filter dispatch raw blocks from encrypted files with AES 128 CBC in PKCS7 to clear input files\n\nThe filter is automatically loaded by the DASH/HLS demultiplexer and should not be explicitly loaded by your application.\n\nThe filter accepts URL with scheme gcryp://URL, where URL is the URL to decrypt.\n\nThe filter can process http(s) and local file key URLs (setup through HLS manifest), and expects a full key (16 bytes) as result of resource fetching.\n\n\n",
        "options": {
            "src": {
                "type": "cstr",
                "description": "location of source file"
            },
            "fullfile": {
                "type": "bool",
                "description": "reassemble full file before decryption",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptout",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptout",
            ""
        ]
    },
    {
        "name": "cryptout",
        "description": "CryptFile output",
        "body": "This filter dispatch raw blocks from clear input files to encrypted files with AES 128 CBC in PKCS7\n\nThe filter is automatically loaded by the DASH/HLS multiplexer and should not be explicitly loaded by your application.\n\nThe filter accepts URL with scheme gcryp://URL, where URL is the URL to encrypt.\n\n\n",
        "options": {
            "dst": {
                "type": "cstr",
                "description": "location of source file"
            },
            "fullfile": {
                "type": "bool",
                "description": "reassemble full file before decryption",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "mp4dmx",
            "fin",
            "httpin",
            "rfmp3",
            "oggdmx",
            "sockin",
            "nhmlr",
            "pin",
            "gsfdmx",
            "routein",
            "httpout",
            "jsf",
            "cryptin",
            "restamp"
        ],
        "sinks": [
            "inspect",
            "mp4dmx",
            "btplay",
            "svgplay",
            "rfimg",
            "rfadts",
            "rflatm",
            "rfmp3",
            "rfac3",
            "rfamr",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "rtpin",
            "fout",
            "vobsubdmx",
            "rfrawvid",
            "rfpcm",
            "flist",
            "dasher",
            "pout",
            "gsfdmx",
            "sockout",
            "rfav1",
            "rtpout",
            "httpout",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            ""
        ]
    },
    {
        "name": "restamp",
        "description": "Packet timestamp rewriter",
        "body": "This filter rewrites timing (offsets and rate) of packets.\n\nThe delays (global or per stream class) can be either positive (stream presented later) or negative (stream presented sooner).\n\nThe specified fps can be either 0, positive or negative.\n- if 0 or if the stream is audio, stream rate is not modified.\n- otherwise if negative, stream rate is multiplied by -fps.num/fps.den.\n- otherwise if positive and the stream is not video, stream rate is not modified.\n- otherwise (video PID), constant frame rate is assumed and:\n  - if rawv=no, video frame rate is changed to the specified rate (speed-up or slow-down).\n  - if rawv=force, input video stream is decoded and video frames are dropped/copied to match the new rate.\n  - if rawv=dyn, input video stream is decoded if not all-intra and video frames are dropped/copied to match the new rate.\n\nNote: frames are simply copied or dropped with no motion compensation.\n\n\n",
        "options": {
            "fps": {
                "type": "frac",
                "description": "target fps",
                "default": "0/1"
            },
            "delay": {
                "type": "frac",
                "description": "delay to add to all streams",
                "default": "0/1"
            },
            "delay_v": {
                "type": "frac",
                "description": "delay to add to video streams",
                "default": "0/1"
            },
            "delay_a": {
                "type": "frac",
                "description": "delay to add to audio streams",
                "default": "0/1"
            },
            "delay_t": {
                "type": "frac",
                "description": "delay to add to text streams",
                "default": "0/1"
            },
            "delay_o": {
                "type": "frac",
                "description": "delay to add to other streams",
                "default": "0/1"
            },
            "rawv": {
                "type": "enum",
                "description": "copy video frames",
                "default": "no",
                "enum": {
                    "no": "no raw frame copy/drop",
                    "force": "force decoding all video streams",
                    "dyn": "decoding video streams if not all intra"
                }
            },
            "tsinit": {
                "type": "lfrac",
                "description": "initial timestamp to resync to, negative values disables resync",
                "default": "-1/1"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File", "Visual"]
            },
            "output": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File", "Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "fin",
            "btplay",
            "httpin",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "sockin",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "fout",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "vobsubdmx",
            "avimx",
            "aout",
            "ufm4v",
            "ufvc1",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "pin",
            "pout",
            "gsfmx",
            "gsfdmx",
            "sockout",
            "rfav1",
            "ufobu",
            "nvdec",
            "routein",
            "rtpout",
            "rtspout",
            "httpout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "tssplit",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "jsf",
            "routeout",
            "rftruehd",
            "cryptin",
            "cryptout",
            "restamp",
            "oggmx",
            "unframer",
            "writeuf",
            "dtout",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "oggmx",
        "description": "OGG multiplexer",
        "body": "This filter multiplexes audio and video to produce an OGG stream.\n\nThe cdur option allows specifiying the interleaving duration (max time difference between consecutive packets of different streams). \n\n\n",
        "options": {
            "cdur": {
                "type": "frac",
                "description": "stream interleaving duration in seconds",
                "default": "1/10"
            },
            "rcfg": {
                "type": "frac",
                "description": "stream config re-injection frequency in seconds",
                "default": "0/1"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "Vorbis Audio",
                    "Flac Audio",
                    "Opus Audio",
                    "Theora Video",
                    "Speex Audio"
                ],
                "stream_type": ["Audio", "Visual"]
            },
            "output": {
                "codec_id": [],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "mp4dmx",
            "oggdmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "gsfdmx",
            "rfflac",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": ["oggdmx", "fout", "pout", "sockout", "httpout", "routeout", ""]
    },
    {
        "name": "unframer",
        "description": "Stream unframer",
        "body": "This filter is used to force reframing of input sources using the same internal framing as GPAC (e.g. ISOBMFF) but with broken framing or signaling.\nExample:\ngpac -i src.mp4 unframer -o dst.mp4\nThis will:\n- force input PIDs of unframer to be in serialized form (AnnexB, ADTS, ...)\n- trigger reframers to be instanciated after the unframer filter.\nUsing the unframer filter avoids doing a dump to disk then reimport or other complex data piping.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "a52dec",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cecrypt",
            "nhntr",
            "nhmlr",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "ufadts",
            "ufmhas",
            "reframer",
            "ufnalu",
            "ufvtt",
            "vobsubdmx",
            "ufm4v",
            "ufvc1",
            "resample",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "ufobu",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "ttml2vtt",
            "ttml2srt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "restamp",
            "writeuf",
            "ohevcdec"
        ],
        "sinks": [
            "probe",
            "bifsdec",
            "odfdec",
            "svgplay",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "mp4mx",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "uflatm",
            "ufadts",
            "ufmhas",
            "reframer",
            "writegen",
            "ufnalu",
            "writeqcp",
            "ufvtt",
            "nhntw",
            "nhmlw",
            "avimx",
            "ufm4v",
            "ufvc1",
            "m2tsmx",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfmx",
            "rfav1",
            "ufobu",
            "nvdec",
            "rtpout",
            "rtspout",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "ufttxt",
            "tx3g2srt",
            "tx3g2vtt",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ttml2vtt",
            "ttml2srt",
            "ffdec",
            "ffenc",
            "ffmx",
            "rftruehd",
            "restamp",
            "oggmx",
            "writeuf",
            "ohevcdec",
            ""
        ]
    },
    {
        "name": "writeuf",
        "description": "Stream to unframed format",
        "body": "Generic single stream to unframed format converter, used when converting PIDs. This filter should not be explicitly loaded.\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            },
            "output": {
                "codec_id": ["Codec Not Supported"],
                "stream_type": ["File"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "bifsdec",
            "odfdec",
            "btplay",
            "svgplay",
            "rfimg",
            "imgdec",
            "rfadts",
            "rflatm",
            "rfmp3",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "rfac3",
            "a52dec",
            "rfamr",
            "oggdmx",
            "vorbisdec",
            "theoradec",
            "m2tsdmx",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "lsrdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "cecrypt",
            "rfqcp",
            "rfh263",
            "rfmpgvid",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "txtin",
            "ttxtdec",
            "vttdec",
            "ttmldec",
            "rtpin",
            "reframer",
            "vobsubdmx",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "jpgenc",
            "pngenc",
            "rewind",
            "flist",
            "dasher",
            "tileagg",
            "tilesplit",
            "gsfdmx",
            "rfav1",
            "nvdec",
            "hevcsplit",
            "hevcmerge",
            "rfflac",
            "rfmhas",
            "rfprores",
            "bsrw",
            "bssplit",
            "bsagg",
            "tx3g2ttml",
            "vtt2tx3g",
            "rfsrt",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffenc",
            "ffavf",
            "jsf",
            "rftruehd",
            "restamp",
            "unframer",
            "ohevcdec"
        ],
        "sinks": [
            "rfadts",
            "rflatm",
            "rfac3",
            "rfh263",
            "rfmpgvid",
            "rfnalu",
            "ufnalu",
            "m2tsmx",
            "rfav1",
            "rfflac",
            "rfmhas",
            "rfprores",
            "rftruehd",
            "unframer",
            ""
        ]
    },
    {
        "name": "dtout",
        "description": "DekTec SDIOut",
        "body": "Warning: DekTek SDK NOT AVAILABLE IN THIS BUILD !\n\n\nThis filter provides SDI output to be used with DTA 2174 or DTA 2154 cards.\n\n\n",
        "options": {
            "bus": {
                "type": "sint",
                "description": "PCI bus number. If not set, device discovery is used",
                "default": "-1"
            },
            "slot": {
                "type": "sint",
                "description": "PCI bus number. If not set, device discovery is used",
                "default": "-1"
            },
            "fps": {
                "type": "frac",
                "description": "default FPS to use if input stream fps cannot be detected",
                "default": "30/1"
            },
            "clip": {
                "type": "bool",
                "description": "clip YUV data to valid SDI range, slower",
                "default": true
            },
            "port": {
                "type": "uint",
                "description": "set sdi output port of card",
                "default": 1
            },
            "start": {
                "type": "dbl",
                "description": "set playback start offset, [-1, 0] means percent of media dur, e.g. -1 == dur",
                "default": "0.0"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            },
            "output": {
                "codec_id": [],
                "stream_type": []
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "jsf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": []
    },
    {
        "name": "ohevcdec",
        "description": "OpenHEVC decoder",
        "body": "This filter decodes HEVC and LHVC (HEVC scalable extensions) from one or more PIDs through the OpenHEVC library\n\n\n",
        "options": {
            "threading": {
                "type": "enum",
                "description": "set threading mode",
                "default": "frame",
                "enum": {
                    "frameslice": "parallel decoding of both frames and slices",
                    "frame": "parallel decoding of frames",
                    "slice": "parallel decoding of slices"
                }
            },
            "nb_threads": {
                "type": "uint",
                "description": "set number of threads (if 0, uses number of cores minus one)",
                "default": 0
            },
            "no_copy": {
                "type": "bool",
                "description": "directly dispatch internal decoded frame without copy",
                "default": true
            },
            "pack_hfr": {
                "type": "bool",
                "description": "pack 4 consecutive frames in a single output",
                "default": true
            },
            "seek_reset": {
                "type": "bool",
                "description": "reset decoder when seeking",
                "default": true
            },
            "force_stereo": {
                "type": "bool",
                "description": "use stereo output for multiview (top-bottom only)",
                "default": true
            },
            "reset_switch": {
                "type": "bool",
                "description": "reset decoder at config change",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [
                    "HEVC Video Layered Extensions",
                    "MPEG-4 AVC|H264 Video",
                    "HEVC Video"
                ],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "mp4dmx",
            "m2tsdmx",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "rfnalu",
            "m2psdmx",
            "avidmx",
            "rtpin",
            "reframer",
            "flist",
            "dasher",
            "tileagg",
            "gsfdmx",
            "hevcsplit",
            "hevcmerge",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffavin",
            "ffenc",
            "jsf",
            "restamp",
            "unframer"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout",
            ""
        ]
    },
    {
        "name": "glpush",
        "description": "GPU texture uploader",
        "version": "1.0",
        "author": "GPAC team",
        "body": "This filter pushes input video streams to GPU as OpenGL textures. It can be used to simulate hardware decoders dispatching OpenGL textures\n\n",
        "options": {},
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "xviddec",
            "j2kdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout"
        ]
    },
    {
        "name": "thumbs",
        "description": "Thumbnail collection generator",
        "version": "1.0",
        "author": "GPAC team",
        "body": "This filter generates screenshots from a video stream.\n\nThe input video is downsampled by the scale factor. The output size is configured based on the number of images per line and per column in the grid. \nOnce configured, the output size is no longer modified.\n\nThe snap option indicates to use one video frame every given seconds. If value is 0, all input frames are used.\n\nIf the number of rows is 0, it will be computed based on the source duration and desired snap time, and will default to 10 if it cannot be resolved.\n\nTo output one image per input frame, use :grid=1x1.\n\nIf a single image per output frame is used, the default value for snap is 0 and for scale is 1.\nOtherwise, the default value for snap is 1 second and for scale is 10.\n\nA single line of text can be inserted over each frame. Predefined keywords can be used in input text, identified as $KEYWORD$:\n\t* ts: replaced by packet timestamp\n\t* timescale: replaced by PID timescale\n\t* time: replaced by packet time as HH:MM:SS.ms\n\t* cpu: replaced by current CPU usage of process\n\t* mem: replaced by current memory usage of process\n\t* version: replaced by GPAC version\n\t* fversion: replaced by GPAC full version\n\t* mae: replaced by Mean Absolute Error with previous frame\n\t* mse: replaced by Mean Square Error with previous frame\n\t* P4CC, PropName: replaced by corresponding PID property\n\nExample:\ngpac -i src reframer:saps=1 thumbs:snap=30:grid=6x30 -o dump/$num$.png\nThis will generate images from key-frames only, inserting one image every 30 seconds. Using key-frame filtering is much faster but may give unexpected results if there are not enough key-frames in the source.\n\nExample:\ngpac -i src thumbs:snap=0:grid=5x5 -o dump/$num$.png\nThis will generate one image containing 25 frames every second at 25 fps.\n\nIf a single image per output frame is used and the scaling factor is 1, the input packet is reused as input with text and graphics overlaid.\n\nExample:\ngpac -i src thumbs:grid=1x1:txt='Frame $time$' -o dump/$num$.png\nThis will inject text over each frame and keep timing and other packet properties.\n\nA json output can be specified in input list to let applications retrieve frame position in output image from its timing.\n\nScene change detection\n\nThe filter can compute the absolute and/or square error metrics between consecutive images and drop image if the computed metric is less than the given threshold.\nIf both mae and mse thresholds are 0, scene detection is not performed (default).\nIf both mae and mse thresholds are not 0, the frame is added if it passes both thresholds.\n\nFor both metrics, a value of 0 means all pixels are the same, a value of 100 means all pixels have 100% intensity difference (e.g. black versus white).\n\nThe scene detection is performed after the snap filtering and uses:\n- the previous frame in the stream, whether it was added or not, if scref is not set,\n- the last added frame otherwise.\n\nTypical thresholds for scene cut detection are 14 to 20 for mae and 5 to 7 for mse.\n\nSince this is a costly process, it is recommended to use it combined with key-frames selection:\n\nExample:\ngpac -i src reframer:saps=1 thumbs:mae=15 -o dump/$num$.png\n\nThe maxsnap option can be used to force insertion after the given time if no scene cut is found.\n\n\n",
        "options": {
            "grid": {
                "type": "v2di",
                "description": "number of images per lines and columns",
                "default": "6x0"
            },
            "scale": {
                "type": "dbl",
                "description": "scale factor for input size",
                "default": "-1"
            },
            "mae": {
                "type": "uint",
                "description": "scene diff threshold using Mean Absolute Error",
                "default": 0
            },
            "mse": {
                "type": "uint",
                "description": "scene diff threshold using Mean Square Error",
                "default": 0
            },
            "lw": {
                "type": "dbl",
                "description": "line width between images in pixels",
                "default": "0.0"
            },
            "lc": {
                "type": "str",
                "description": "line color",
                "default": "white"
            },
            "clear": {
                "type": "str",
                "description": "clear color",
                "default": "white"
            },
            "snap": {
                "type": "dbl",
                "description": "duration between images, 0 for all images",
                "default": "-1"
            },
            "maxsnap": {
                "type": "dbl",
                "description": "maximum duration between two thumbnails when scene change detection is enabled",
                "default": "-1"
            },
            "pfmt": {
                "type": "pfmt",
                "description": "output pixel format",
                "default": "rgb"
            },
            "txt": {
                "type": "str",
                "description": "text to insert per thumbnail",
                "default": ""
            },
            "tc": {
                "type": "str",
                "description": "text color",
                "default": "white"
            },
            "tb": {
                "type": "str",
                "description": "text shadow",
                "default": "black"
            },
            "font": {
                "type": "str",
                "description": "font to use",
                "default": "SANS"
            },
            "fs": {
                "type": "dbl",
                "description": "font size to use in percent of scaled height",
                "default": "10"
            },
            "tv": {
                "type": "dbl",
                "description": "text vertical position in percent of scaled height",
                "default": "0"
            },
            "thread": {
                "type": "sint",
                "description": "number of threads for software rasterizer, -1 for all available cores",
                "default": "-1"
            },
            "blt": {
                "type": "bool",
                "description": "use blit instead of software rasterizer",
                "default": true
            },
            "scref": {
                "type": "bool",
                "description": "use last inserted image as reference for scene change detection",
                "default": true
            },
            "dropfirst": {
                "type": "bool",
                "description": "drop first image",
                "default": true
            },
            "list": {
                "type": "str",
                "description": "export json list of frame times and positions to given file",
                "default": "null"
            },
            "lxy": {
                "type": "bool",
                "description": "add explict x and y in json export",
                "default": true
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "xviddec",
            "j2kdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout"
        ]
    },
    {
        "name": "avmix",
        "description": "Audio Video Mixer",
        "author": "GPAC team",
        "body": "AVMix is an audio video mixer controlled by an updatable JSON playlist format. The filter can be used to:\n- schedule video sequence(s) over time\n- mix videos together\n- layout of multiple videos\n- overlay images, text and graphics over source videos\n\nAll input streams are decoded prior to entering the mixer.\n- audio streams are mixed in software\n- video streams are composed according to the gpu option\n- other stream types are not yet supported\n\nOpenGL hardware acceleration can be used, but the supported feature set is currently not the same with or without GPU.\n\nIn software mode, the mixer will detect whether any of the currently active video sources can be used as a base canvas for the output to save processing time.\nThe default behavior is to do this detection only at the first generated frame, use dynpfmt to modify this.\n\nThe filter can be extended through JavaScript modules. Currently only scenes and transition effects use this feature.\n\nLive vs offline\n\nWhen operating offline, the mixer will wait for video frames to be ready for 10 times lwait. After this timeout, the filter will abort if no input is available.\nThis implies that there shall always be a media to compose, i.e. no \"holes\" in the timeline.\nNote: The playlist is still refreshed in offline mode.\n\nWhen operating live, the mixer will initially wait for video frames to be ready for lwait seconds. After this initial timeout, the output frames will indicate:\n- 'No signal' if no input is available (no source frames) or no scene is defined\n- 'Signal lost' if no new input data has been received for lwait on a source\n\nPlaylist Format\n\nOverview\nThe main components in a playlist are:\n\t* Media sources and sequences: each source is described by one or more URL to the media data, and each sequence is a set of sources to be played continuously \n\t* Transitions: sources in a sequence can be combined using transitions\n\t* Scenes: a scene describes one graphical object to put on screen and if and how input video are mapped on objects\n\t* Groups: a group is a hierarchy of scenes and groups with positioning properties, and can also be used to create offscreen images reused by other elements\n\t* Timers: a timer can be used to animate scene parameters in various fashions\n\nThe playlist content shall be either a single JSON object or an array of JSON objects, hereafter called root objects.\nRoot objects types can be indicated through a type property:\n\t* seq: a sequence object\n\t* url: a source object (if used as root, a default sequence object will be created)\n\t* scene: a scene object\n\t* group: a group object\n\t* timer: a timer object\n\t* script: a script object\n\t* config: a config object\n\t* watch: a watcher object\n\t* style: a style object\n\nExcept for style, the type property of root objects is usually not needed as the parser guesses the object types from its properties.\n\nA root object with a property skip set to anything but 0 or false is ignored.\nWithin a group hierarchy, any scene or group object with a property skip set to anything but 0 or false is ignored.\n\nAny unrecognized property not starting with _ will be reported as warning.\n\nColors\nColors are handled as strings, formatted as:\n- the DOM color name (see gpac -h colors)\n- HTML codes $RRGGBB or #RRGGBB\n- RGB hex vales 0xRRGGBB\n- RGBA hex values 0xAARRGGBB\n- the color none is 0x00000000, its signification depends on the object using it.\n\nIf JS code needs to manipulate colors, use sys.color_lerp and sys.color_component functions.\n\nJS Hooks\n\nSome object types allow for custom JS code to be executed. \nThe script code can either be the value of the property, or located in a file indicated in the property. \nThe code is turned into a function (i.e. new Function(args, js_code)) upon initial playlist parsing or reload, hereafter called JSFun.\nThe JSFun arguments and return value are dependent on the parent object type.\nThe parent object is exposed as this in JSFun and can be used to store context information for the JS code.\n\nThe code can use the global functions and modules defined, especially:\n\t* sys: GPAC system module\n\t* evg: GPAC EVG module\n\t* os: QuickJS OS module \n\t* video_playing: video playing state\n\t* audio_playing: audio playing state\n\t* video_time: output video time\n\t* video_timescale: output video timescale\n\t* video_width: output video width\n\t* video_height: output video height\n\t* audio_time: output audio time\n\t* audio_timescale: output audio timescale\n\t* samplerate: output audio samplerate\n\t* channels: output audio channels\n\t* current_utc_clock: current UTC clock in ms\n\t* get_media_time: gets media time of output (no argument) or of source with id matching the first argument. Return\n\t  * -4: not found\n\t  * -3: not playing\n\t  * -2: in prefetch\n\t  * -1: timing not yet known\n\t  * value: media time in seconds (float)\n\t* resolve_url: resolves URL given in first argument against media playlist URL and returns the resolved url (string)\n\t* get_scene(id): gets scene with given ID\n\t* get_group(id): gets group with given ID\n\t* mouse_over(evt): returns scene under mouse described by a GPAC event, or null if no scene (picking for scenes with perspective projection is not supported)\n\t* mouse_over(x, y): returns scene under coordinates {x, y} in pixels, {0,0} representing the center of the frame, x axis oriented towards the right and y axis oriented towards the top\n\nScene and group options must be accessed through getters and setters:\n\t* scene.get(prop_name): gets the scene option\n\t* scene.set(prop_name, value): sets the scene option\n\t* group.get(prop_name): gets the group option\n\t* group.set(prop_name, value): sets the group option\n\nWarning: Results are undefined if JS code modifies the scene/group objects in any other way.\n\nOther playlist objects (as well as scene and group objects) can be queried using query_element(ID, propName) or modified using update_element(ID, propName, value) (see playlist update below).   \n\nWarning: There is no protection of global variables and state, write your script carefully!\n\nAdditionally, scripts executed within scene modules can modify the internal playlist using:\n\t* remove_element(ID):  removes a scene, group, sequence, timer, script or watcher with given ID from playlist\n\t* parse_element(JSON): parses a root playlist element and add it to the current playlist\n\t* parse_scene(JSON, parent): parses a scene and add it to parent group if not null or root otherwise\n\t* parse_group(JSON, parent): parses a group and add it to parent group if not null or root otherwise\n\t* reload_playlist(JSON): parses a new playlist (an empty JSON array will reset the playlist). If the calling scene is no longer in the resulting scene tree, it will be added to the root of the scene tree.\n\nAll these playlist-related functions must be called within the update() callback of the scene module.\n\nSequences\nProperties for sequence objects:\n\n\t * id (null): sequence identifier\n\t * loop (0): number of loops for the sequence (0 means no loop, -1 will loop forever)\n\t * start (0): sequence start time (see notes). If negative, the sequence is not active\n\t * stop (0): sequence stop time (see notes). If less than start, the sequence will stop only when over\n\t * transition (null): a transition object to apply between sources of the sequence\n\t * seq ([]): array of one or more source objects\n\nNotes\n\nMedia source timing does not depend on the media being used by a scene or not, it is only governed by the sequence parameters.\nThis means that a sequence not used by any active scene will not be rendered (video nor audio).\n\nThe syntax for start and  stop fields is:\n\t* `now`: resolves to current UTC clock in live mode, and to 0 for non-live mode\n\t* date: converted to UTC date in live mode, and to 0 for non-live mode\n\t* N: converted to current utc clock (or 0 for non-live mode) plus N seconds UTC\n\t* \"N\": converted to current utc clock (or 0 for non-live mode) plus N seconds UTC\n\nIn 'live' mode, if start is set using a UTC date, the sequence will have a start range equal to MAX(current_UTC - start_in_UTC, 0). Some sources may be skipped to fulfill this condition.\nThis allows different instances of the filter using the same playlist to initialize media time in the same fashion.\n\nWhen reloading the playlist:\n- if the sequence is active, start value is ignored \n- if the sequence was not started, start value is updated \n- if the sequence was over, start value is updated only of greater than previous resolved UTC start time. \n\nSources\nProperties for source objects\n\n\t* id (null): source identifier, used when reloading the playlist\n\t* src ([]): list of sourceURL describing the URLs to play. Multiple sources will be played in parallel\n\t* start (0.0): media start time in source\n\t* stop (0.0): media stop time in source, ignored if less than or equal to start\n\t* mix (true): if true, apply sequence transition or mix effect ratio as audio volume. Otherwise volume is not modified by transitions.\n\t* fade ('inout'): indicate how audio should be faded at stream start/end:\n\t  * in: audio fade-in when playing first frame\n\t  * out: audio fade-out when playing last frame\n\t  * inout: both fade-in and fade-out are enabled\n\t  * other: no audio fade\n\t* keep_alive (false): if using a dedicated gpac process for one or more input, relaunch process(es) at source end if exit code is greater than 2 or if not responding after rtimeout\n\t* seek (false): if true and keep_alive is active, adjust start according to the time elapsed since source start when relaunching process(es)\n\t* prefetch (500): prefetch duration in ms (play before start time of source), 0 for no prefetch\n\t* hold (false): if media duration is known and media stop time is greater than media duration, activate no signal mode until desired stop time is reached (disable transition), otherwise move to next source at end of stream\n\nSource Locations\nProperties for sourceURL objects\n\n\t* id (null): source URL identifier, used when reloading the playlist\n\t* in (null): input URL or filter chain to load as string. Words starting with - are ignored. The first entry must specify a source URL, and additional filters and links can be specified using @N[#LINKOPT] and @@N[#LINKOPT] syntax, as in gpac\n\t* port (null): input port for source. Possible values are:\n\t  * pipe: launch a gpac process to play the source using GSF format over pipe\n\t  * tcp, tcpu: launch a gpac process to play the source using GSF format over TCP socket (tcp) or unix domain TCP socket (tcpu)\n\t  * not specified or empty string: loads source using the current process\n\t  * other: use value as input filter declaration and launch in as a dedicated process (e.g. in=\"ffmpeg ...\" port=\"pipe://...\")\n\t* opts (null): options for the gpac process instance when using a dedicated gpac process, ignored otherwise\n\t* media ('all'): filter input media by type, a for audio, v for video, t for text (several characters allowed, e.g. av or va), all accept all input media\n\t* raw (true): indicate if input port is decoded AV (true) or compressed AV (false) when using a dedicated gpac process, ignored otherwise\n\nNotes\n\nWhen launching a child process, the input filter is created first and the child process launched afterwards.\n\nWarning: When launching a child process directly (e.g. in=\"ffmpeg ...\"), any relative URL used in in must be relative to the current working directory.\n\n2D and 3D transformation\nCommon properties for group and scene objects\n\n\t* active (true): indicate if the object is active or not. An inactive object will not be refreshed nor rendered\n\t* x (0): horizontal translation\n\t* y (0): vertical translation\n\t* cx (0): horizontal coordinate of rotation center\n\t* cy (0): vertical coordinate of rotation center\n\t* units ('rel'): unit type for x, y, cx, cy, width and height. Possible values are:\n\t  * rel: units are expressed in percent of current reference (see below)\n\t  * pix: units are expressed in pixels\n\t* rotation (0): rotation angle of the scene in degrees\n\t* hscale (1): horizontal scaling factor to apply to the group\n\t* vscale (1): vertical skewing factor to apply to the scene\n\t* hskew (0): horizontal skewing factor to apply to the scene\n\t* vskew (0): vertical skewing factor to apply to the scene\n\t* zorder (0): display order of the scene or of the offscreen group (ignored for regular groups)\n\t* untransform (false): if true, reset parent tree matrix to identity before computing matrix\n\t* mxjs (null): JS code for matrix evaluation\n\t* z (0): depth translation\n\t* cz (0): depth coordinate of rotation center\n\t* zscale (1): depth scaling factor to apply to the group\n\t* orientation ([0, 0, 1, 0]): scale along the given orientation axis [x, y, z, angle] - see VRML scaleOrientation\n\t* axis ([0, 0, 1]): rotation axis\n\t* position ([0, 0, auto]): camera location\n\t* target ([0, 0, 0]): point where the camera is looking\n\t* up ([0, 1, 0]): camera up vector\n\t* viewport ([0, 0, 100, 100]): viewport for camera\n\t* fov (45): field of view in degrees\n\t* ar (0): camera aspect ratio, 0 means default\n\t* znear (0): near Z plane distance, 0 means default\n\t* zfar (0): far Z plane distance, 0 means default\n\nCoordinate System\n\nEach group or scene is specified in a local coordinate system for which:\n- {0,0} represents the center\n- X values increase to the right\n- Y values increase to the top\n- Z values increase  towards the eye of a viewer (Z=X^Y)\n\nThe 2D local transformation matrix is computed as rotate(cx, cy, rotation) * hskew * vskew * scale(hscale, vscale) * translate(x, y).\nThe 3D local transformation matrix is computed as translate(x, y, z) * rotate(cx, cy, cz, rotation) * scale(hscale, vscale, zscale). Skewing is not supported for 3D.\n\nThe default unit system (rel) is relative to the current established reference space:\n- by default, the reference space is {output_width, output_height}, the origin {0,0} being the center of the output frame \n- any group with reference=true, width>0 and height>0 establishes a new reference space {group.width, group.height}\n\nInside a reference space R, relative coordinates are interpreted as follows:\n- For horizontal coordinates, 0 means center, -50 means left edge (-R.width/2), 50 means right edge (+R.width/2).\n- For vertical coordinates, 0 means center, -50 means bottom edge (-R.height/2), 50 means top edge (+R.height/2).\n- For width, 100 means R.width.\n- For height, 100 means R.height.\n- For depth (z and cz) coordinates, the value is a percent of the reference height (+R.height).\n\nIf width=height, the width is set to the computed height of the object.\nIf height=width, the height is set to the computed width of the object.\nFor x property, the following special values are defined:\n- y will set the value to the computed y  of the object.\n- -y will set the value to the computed -y of the object.\nFor y property, the following special values are defined:\n- x will set the value to the computed x of the object.\n- -x will set the value to the computed -x of the object.\n\nChanging reference is typically needed when creating offscreen groups, so that children relative coordinates are resolved against the offscreen canvas size.\n\nThe selection between 2D and 3D is done automatically based on z, cz, axis and orientation values.\nThe default projection is:\n- viewport is the entire output frame\n- field of view is PI/4 and aspect ratio is output width/height\n- zNear is 0.1 and zFar is 10 times maximum(output width, output height)\n- camera up direction is Y axis and camera distance is so that a rectangle facing the camera with z=0 and size equal to output size covers exactly the output frame.\n- depth buffer is disabled\n\nThe default projection can be changed by setting camera properties at group or scene level. When set on a group, all children of the group will use the given camera properties (camera parameters on children are ignored).\nThe viewport parameter is specified as an array [x, y, w, h], where:\n\t* x: horizontal coordinate of the viewport center, in group or scene units, or 'y' to use y value, or '-y' to use -y value.\n\t* y: vertical coordinate of the viewport center, in group or scene units, or 'x' to use x value, or '-x' to use -x value.\n\t* w: width of the viewport, in group or scene units, or 'height' to use h value.\n\t* h: height of the viewport, in group or scene units, or 'width' to use w value.\n\nz-ordering\n\nzorder specifies the display order of the element in the offscreen canvas of the enclosing offscreen group, or on the output frame if no offscreen group in parent tree.\nThis order is independent of the parent group z-ordering. This allows moving objects of a group up and down the display stack without modifying the groups.\n\nCoordinate modifications through JS\n\nThe JSFun specified in mxjs has a single parameter tr.\n\nThe tr parameter is an object containing the following variables that the code can modify:\n\t* x, y, z, cx, cy, cz, hscale, vscale, zscale, hskew, vskew, rotation, untransform, axis, orientation: these values are initialized to the current group values in local coordinate system units\n\t* update: if set to true, the object matrix will be recomputed at each frame even if no change in the group or scene parameters (always enforced to true if use is set)\n\t* depth: for groups with use, indicates the recursion level of the used element. A value of 0 indicates this is a direct render of the element, otherwise it is a render through use\n\nThe JSFun may return false to indicate that the scene should be considered as inactive. Any other return value (undefined or not false) will mark the scene as active.\n\nEX: \"mxjs\": \"tr.rotation = (get_media_time() % 8) * 360 / 8; tr.update=true;\"\n\nGrouping\nProperties for group objects\n\n\t* id (null): group identifier\n\t* scenes ([]): zero or more group or scene objects, cannot be animated or updated\n\t* opacity (1): group opacity\n\t* offscreen ('none'): set group in offscreen mode, cannot be animated or updated. An offscreen mode is not directly visible but can be used in some texture operations. Possible values are:\n\t  * none: regular group\n\t  * mask: offscreen surface is alpha+grey\n\t  * color: offscreen surface is alpha+colors or colors if back_color is set\n\t  * dual: same as color but allows group to be displayed\n\t* scaler (1): when opacity or offscreen rendering is used, offscreen canvas size is divided by this factor (>=1)\n\t* back_color ('none'): when opacity or offscreen rendering is used, fill offscreen canvas with the given color.\n\t* width (-1): when opacity or offscreen rendering is used, limit offscreen width to given value (see below)\n\t* height (-1): when opacity or offscreen rendering is used, limit offscreen height to given value (see below)\n\t* use (null): id of group or scene to re-use\n\t* use_depth (-1): number of recursion allowed for the used element, negative means global max branch depth as indicated by maxdepth\n\t* reverse (false): reverse scenes order before draw\n\t* reference (false): group is a reference space for relative coordinate of children nodes \n\nNotes\n\nThe maximum depth of a branch in the scene graph is maxdepth (traversing aborts after this limit).\n\nIn offscreen mode, the bounds of the enclosed objects are computed to allocate the offscreen surface, unless width and height are both greater or equal to 0.\nEnforcing offscreen size is useful when generating textures for later effects.\n\nOffscreen rendering is always done in software.\n\nWhen enforcing scaler>1 on a group with opacity==1, offscreen rendering will be used and the scaler applied.\n\nWhen enforcing width and height on a group with opacity<1, the display may be truncated if children objects are out of the offscreen canvas bounds.\n\nScenes\nProperties for scene objects\n\n\t* id (null): scene identifier\n\t* js ('shape'): scene type, either builtin (see below) or path to a JS module, cannot be animated or updated\n\t* sources ([]): list of identifiers of sequences or offscreen groups used by this scene\n\t* width (-1): width of the scene, -1 means reference space width\n\t* height (-1): height of the scene, -1 means reference space height\n\t* mix (null): a transition object to apply if more than one source is set, ignored otherwise\n\t* mix_ratio (-1): mix ratio for transition effect, <=0 means first source only, >=1 means second source only\n\t* volume (1.0): audio volume (0: silence, 1: input volume), this value is not clamped by the mixer.\n\t* fade ('inout'): indicate how audio should be faded at scene activate/deactivate:\n\t  * in: audio fade-in when playing first frame after scene activation\n\t  * out: audio fade-out when playing last frame at scene activation\n\t  * inout: both fade-in and fade-out are enabled\n\t  * other: no audio fade\n\t* autoshow (true): automatically deactivate scene when sequences set in sources are not active\n\t* nosig ('lost'): enable no-signal message for scenes using sequences:\n\t  * no: disable message\n\t  * lost: display message when signal is lost\n\t  * before: display message if source is not yet active\n\t  * all: always display message if source is inactive\n\t* styles ([]): list of style IDs to use\n- any other property exposed by the underlying scene JS module.\n\nNotes\n\nInputs to a scene, whether sequence or offscreen group, must be declared prior to the scene itself.\n\nA default scene will be injected if none is found when initially loading the playlist. If you need to start with an empty output, use a scene with no sequence associated.\n\nIf a scene uses one or more sequences and autoshow is not set, the scene will be drawn with no sequence attached if all sequences are inactive (not yet started or over).\n\nTransitions and Mixing effects\nJSON syntax\n\nProperties for transition objects:\n\t* id (null): transition identifier\n\t* type: transition type, either builtin (see below) or path to a JS module\n\t* dur: transition duration (transitions always end at source stop time). Ignored if transition is specified for a scene mix.\n\t* fun (null): JS code modifying the ratio effect\n- any other property exposed by the underlying transition module.\n\nNotes\n\nA sequence of two media with playback duration (as indicated in source) of D1 and D2 using a transition of duration DT will result in a sequence lasting D1 + D2 - DT.\n\nThe JSFun specified by fun takes one argument ratio and must return the recomputed ratio.\n\nExample:\n\"fun\": \"return ratio*ratio;\"\n\nTimers and animations\nProperties for timer objects\n\n\t* id (null): id of the timer\n\t* dur (0): duration of the timer in seconds\n\t* loop (false): loops timer when stop is not set\n\t* pause (false): pause timer\n\t* start (-1): start time (see notes), negative value means inactive\n\t* stop (-1): stop time (see notes), ignored if less than start\n\t* keys ([]): list of keys used for interpolation, ordered list between 0.0 and 1.0\n\t* anims ([]): list of animation objects\n\nProperties for animation objects\n\n\t* values ([]): list of values to interpolate, there must be as many values as there are keys\n\t* color (false): indicate the values are color (as strings)\n\t* angle (false): indicate the interpolation factor is an angle in degree, to convert to radians (interpolation ratio multiplied by PI and divided by 180) before interpolation\n\t* mode ('linear') : interpolation mode:\n\t  * linear: linear interpolation between the values\n\t  * discrete: do not interpolate\n\t  * other: JS code modifying the interpolation ratio\n\t* postfun (null): JS code modifying the interpolation result\n\t* end ('freeze'): behavior at end of animation:\n\t  * freeze: keep last animated values\n\t  * restore: restore targets to their initial values\n\t* targets ([]): list of strings indicating targets properties to modify. Syntax is:\n\t  * ID@option: modifies property option of object with given ID\n\t  * ID@option[IDX]: modifies value at index IDX of array property option of object with given ID\n\nNotes\n\nCurrently, only scene, group, transition and script objects can be modified through timers (see playlist updates).\n\nThe syntax for start and  stop fields is:\n\t* `now`: resolves to current UTC clock in live mode, and to 0 for non-live mode\n\t* date: converted to UTC date in live mode, and to 0 for non-live mode\n\t* N: converted to UTC clock at init plus N seconds for timer objects (absolute offset from timeline init)\n\t* \"N\": converted to current UTC clock plus N seconds (relative offset from current time) with N a positive or negative number\n\nThe JSFun specified by mode has one input parameter interp equal to the interpolation factor and must return the new interpolation factor.\nExample:\n\"mode\":\"return interp*interp;\" \n\nThe JSFun specified by postfun has two input parameters res (the current interplation result) and interp (the interpolation factor), and must return the new interpolated value.\nExample:\n\"postfun\": \"if (interp<0.5) return res*res; return res;\" \n\nScripts\nProperties for script objects\n\n\t* id (null): id of the script\n\t* script (null): JavaScript code or path to JavaScript file to execute, cannot be animated or updated\n\t* active (true): indicate if script is active or not\n\nNotes\n\nScript objects allow read and write access to the playlist from script. They currently can only be used to modify scenes and groups and to activate/deactivate other scripts.\n\nThe JSFun function specified by fun has no input parameter. The return value (default 0) is the number of seconds (float) to wait until next evaluation of the script.\n\nEX: { \"script\": \"let s=get_scene('s1'); let rot = s.get('rotation'); rot += 10; s.set('rotation', rot); return 2;\" }\nThis will change scene s1 rotation every 2 seconds \n\nWatchers\nProperties for watcher objects\n\n\t* id (null): ID of the watcher\n\t* active (true): indicate if watcher is active or not\n\t* watch (\"\"): element watched, formatted as ID@prop, with ID the element ID and prop the property name to watch\n\t* target (\"\"): action for watcher. Allowed syntaxes are:\n\t  * `ID@prop`, `ID@prop[idx]`: copy value to property prop of the element ID (potentially at index idx if specified for arrays)\n\t  * `ID.fun_name`: call function fun_name exported from scene module ID, using three arguments ['value', 'watchID', 'watchPropName'], no return value check\n\t  * otherwise: action must be JS code, and the resulting JSFun has one argument value containing the watched value, and no return value check\n\t* with (undefined): for targets in the form ID@prop, use this value instead of the watched value\n\nNotes\n\nA watcher can be used to monitor changes in an object in the playlist.\nAny object property that can be animated or updated can be monitored by a watcher.\n\nIn addition, the following virtual properties (cannot be read or write) can be watched:\n\t* sequence.active: value is set to true when sequence is activated, and false when deactivated\n\t* source.active: value is set to true when source playback starts, and false when source playback stops\n\t* timer.active: value is set to true when timer starts, and false when timer stops\n\nOnly the active property can be animated or updated in a watcher.\n\nExample:\n{'watch': 's1@rotation', 'target': 's2@rotation'}\nThis will copy s1.rotation to s2.rotation.\n\nExample:\n{'watch': 's1@rotation', 'target': 'get_scene('s2').set('rotation', -value); }\nThis will copy the -1*s1.rotation to s2.rotation.\n\nWatching UI events\n\nWatchers can also be used to monitor GPAC user events by setting watch to:\n- an event name to monitor, one of keydown, keyup, mousemove, mouseup, mousedown, wheel, textInput\n- events to monitor all events (including internal events).\n\nFor keyup and keydown events, the key code to watch may additionally be given in parenthesis, e.g. 'watch': 'keyup(T)'.\n\nNote: User events are only sent if the output of the filter is consumed by the vout filter.\n\nWhen event monitoring is used, the target must be a javascript callback (i.e. it cannot be ID@prop).\nThe javascript function will be called with a single argument evt containing the GPAC event.\n\nExample:\n{'watch': 'mousemove', 'target': 'let s = mouse_over(evt); get_scene('s2').set('fill', (s && (s.id=='s1') ? 'white' : 'black' );'}\nThis will set s1 fill color to white of mouse is over s2 and to black otherwise.\n\nStyles\nProperties for style objects\n\n\t* id (null): ID of the style\n\t* forced (false): always apply style even when no modifications\n\t* other: any property to share between scene\n\nNotes\n\nA style object allows scenes to share the same values for a given set of properties.\n\nIf a scene property has the same name as a style property, the scene property is replaced by the style property.\nStyles only apply to scene properties as follows:\n- volume, fade, mix_ratio can use style\n- all options defined by the scene module can use style\n- transformation or other scene properties cannot use style\n\nProperties of a style object can be animated or updated, but a style object cannot be watched.\n\nStyles are applied to each associated scene in order of declaration, e.g. ['st1', 'st2'] and ['st2', 'st1'] will likely give different results.\n\nIf force is not set for a style, the style is only applied after being modified (load, animation, update); if a scene uses ['st1', 'st2'] and only st1 is\nmodified (animation, update), st2 will only be applied once.\n\nFilter configuration\nThe playlist may specify configuration options of the filter, using a root object of type 'config':\n- property names are the same as the filter options\n- property values are given in the native type, or as strings for fractions (format N/D), vectors (format WxH) or enums\n- each declared property overrides the filter option of the same name (whether default or set at filter creation)\n\nA configuration object in the playlist is only parsed when initially loading the playlist, and ignored when reloading it.\n\nThe following additional properties are defined for testing:\n\t* reload_tests([]): list of playlists to reload\n\t* reload_timeout(1.0): timeout in seconds before playlist reload\n\t* reload_loop (0): number of times to repeat the reload tests (not including original playlist which is not reloaded)\n\nPlaylist modification\nThe playlist file can be modified at any time.\nObjects are identified across playlist reloads through their id property.\nObjects that are not present after reloading a playlist are removed from the mixer. This implies that reloading a playlist will recreate most objects with no ID associated.\n\nA sequence object modified between two reloads is refreshed, except for its start field if sequence active.\n\nA source object shall have the same parent sequence between two reloads. Any modification on the object will only be taken into consideration when (re)loading the source.\n\nA sourceURL object is not tracked for modification, only evaluated when activating the parent source object.\n\nA scene or group object modified between two reloads is notified of each changed value.\n\nA timer object modified between two reloads is shut down and restarted. Consequently, animation objects are not tracked between reloads.\n\nA transition object may change between two reloads, but any modification on the object will only be taken into consideration when restarting the effect.\n\nA script object modified between two reloads has its code re-evaluated\n\nA watcher object modified between two reloads has its watch source and code re-evaluated\n\nA style object is not tracked (all styles are reloaded when reloading a playlist).\n\nPlaylist example\n\nThe following is an example playlist using a sequence of two videos with a mix transition and an animated video area:\n\nExample:\n[\n {\"id\": \"seq1\", \"loop\": -1, \"start\": 0,  \"seq\":\n  [\n   { \"id\": \"V1\", \"src\": [{\"in\": \"s1.mp4\"}], \"start\": 60, \"stop\": 80},\n   { \"id\": \"V2\", \"src\": [{\"in\": \"s2.mp4\"}], \"stop\": 100}\n  ],\n  \"transition\": { \"dur\": 1, \"type\": \"mix\"}\n },\n {\"id\": \"scene1\", \"sources\": [\"seq1\"]},\n {\"start\": 0, \"dur\": 10, \"keys\": [0, 1], \"anims\":\n  [\n   {\"values\": [50, 0],  \"targets\": [\"scene1@x\", \"scene1@y\"]},\n   {\"values\": [0, 100],  \"targets\": [\"scene1@width\", \"scene1@height\"]}\n  ]\n }\n]\n\nUpdates Format\n\nUpdates can be sent to modify the playlist, rather than reloading the entire playlist.\nUpdates are read from a separate file specified in updates, inactive by default.\n\nWarning: The updates file is only read when modified AFTER the initialization of the filter.\n\nThe updates file content shall be either a single JSON object or an array of JSON objects.\nThe properties of these objects are:\n\t* skip: if true or 1, ignores the update, otherwise apply it\n\t* replace: string identifying the target replacement. Syntax is:\n\t  * ID@name: indicate property name of element with given ID to replace\n\t  * ID@name[idx]: indicate the index in the property name of element with given ID to replace\n\t* with: replacement value, must be of the same type as the target value.\n\nAn id property cannot be updated.\n\nThe following playlist elements of a playlist can be updated:\n\t* scene: all properties except js and read-only module properties\n\t* group: all properties except scenes and  offscreen\n\t* sequence: start, stop, loop and transition properties\n\t* timer: start, stop, loop, pause and dur properties\n\t* transition: all properties\n\t  * for sequence transitions: most of these properties will only be updated at next reload\n\t  * for active scene transitions: whether these changes are applied right away depend on the transition module\n\nExample:\n[\n {\"replace\": \"scene1@x\", \"with\": 20},\n {\"replace\": \"seq1@start\", \"with\": \"now\"}\n]\n\nScene modules\n\nScene mask\nThis scene sets the canvas alpha mask mode.\n\nThe canvas alpha mask is always full screen.\n\nIn software mode, combining mask effect in record mode and reverse group drawing allows drawing front to back while writing pixels only once.\n\nOptions:\n\t* mode ('off'): if set, reset clipper otherwise set it to scene position and size\n\t  * off: mask is disabled\n\t  * on: mask is enabled and cleared, further draw operations will take place on mask\n\t  * onkeep: mask is enabled but not cleared, further draw operations will take place on mask\n\t  * use: mask is enabled, further draw operations will be filtered by mask\n\t  * use_inv: mask is enabled, further draw operations will be filtered by 1-mask\n\t  * rec: mask is in record mode, further draw operations will be drawn on output and will set mask value to 0 \n \n\nScene clear\nThis scene clears the canvas area covered by the scene with a given color. \n\nThe default clear color of the mixer is black.\n\nThe clear area is always axis-aligned in output frame, so when skew/rotation are present, the axis-aligned bounding box of the transformed scene area will be cleared.\n\nOptions:\n\t* color ('none'): clear color\n\nScene clip\nThis scene resets the canvas clipper or sets the canvas clipper to the scene area.\n\nThe clipper is always axis-aligned in output frame, so when skew/rotation are present, the axis-aligned bounding box of the transformed clipper will be used.\n\nClippers are handled through a stack, resetting the clipper pops the stack and restores previous clipper.\nIf a clipper is already defined when setting the clipper, the clipper set is the intersection of the two clippers.\n\nOptions:\n\t* reset (false): if set, reset clipper otherwise set it to scene position and size\n\t* stack (true): if false, clipper is set/reset independently of the clipper stack (no intersection, no push/pop of the stack)\n\nScene shape\nThis scene can be used to setup a shape, its outline and specify the fill and strike modes.\nSupported shapes include:\n- a variety of rectangles, ellipse and other polygons\n- custom paths specified from JS\n- text\n\nThe color modes for shapes and outlines include:\n- texturing using data from input media streams (shape fill only)\n- texturing using local JPEG and PNG files (shape fill only)\n- solid color\n- linear and radial gradients\n\nThe default scene is optimized to fallback to fast blit when no transformations are used on a straight rectangle shape.\n\nAll options can be updated at run time.\n\nThe module accepts 0, 1 or 2 sequences as input.\n\nColor replacement operations can be specified for base scenes using source videos by specifying the replace option. The replacement source is:\n- the image data if img is set, potentially altered using *_rep options\n- otherwise a linear gradient if fill=linear or a radial gradient if fill=radial (NOT supported in GPU mode, use an offscreen group for this).\n\nWarning: Color replacement operations cannot be used with transition or mix effects.\n\nText options \n\nText can be loaded from file if text[0] is an existing local file.\nBy default all lines are loaded. The number of loaded lines can be specified using text[1] as follows:\n\t* 0 or not present: all lines are loaded\n\t* N > 0: only keep the last N lines\n\t* N < 0: only keep the first N lines\n\nText loaded from file will be refreshed whenever the file is modified.\n\nPredefined keywords can be used in input text, identified as $KEYWORD$. The following keywords (case insensitive) are defined:\n\t* time: replaced by UTC date\n\t* ltime: replaced by locale date\n\t* date: replaced by date (Y/M/D)\n\t* ldate: replaced by locale date (Y/M/D)\n\t* mtime: replaced by output media time \n\t* mtime_SRC: replaced by media time of input source SRC \n\t* cpu: replaced by current CPU usage of process\n\t* mem: replaced by current memory usage of process\n\t* version: replaced by GPAC version\n\t* fversion: replaced by GPAC full version\n\t* P4CC, PropName: replaced by corresponding PID property\n\nCustom paths\n\nCustom paths (shapes) can be created through JS code indicated in 'shape', either inline or through a file.\nThe following GPAC JS modules are imported:\n - Sys as sys\n - All EVG as evg\n - os form QuickJS\n\nSee https://doxygen.gpac.io for more information on EVG and Sys JS APIs.\n\nThe code is exposed the scene as this. The variable this.path is created, representing an empty path.\nExample:\n\"shape\": \"this.path.add_rectangle(0, 0, this.width, this.height); let el = new evg.Path().ellipse(0, 0, this.width, this.height/3); this.path.add_path(el);\"\n\nThe default behaviour is to use the shape width and height as reference size for texture mapping.\nIf your custom path is textured, with bounding rectangle size different from the indicated shape size, set the variable this.tx_adjust to true.\n\nIn the previous example, the texture mapping will not be impacted by the custom path size.\n\nExample:\n\"shape\": \"this.path.add_rectangle(0, 0, this.width, this.height); let el = new evg.Path().ellipse(0, 0, this.width, this.height/3); this.path.add_path(el); this.tx_adjust = true;\"\nIn this example, the texture mapping will be adjusted to the desired size.\n\nThe global variables and functions are available (c.f. gpac -h avmix:global):\n\t * get_media_time(): return media time in seconds (float) of output\n\t * get_media_time(SRC): get time of source with id SRC, return -4 if not found, -3 if not playing, -2 if in prefetch, -1 if timing not yet known, media time in seconds (float) otherwise\n\t * current_utc_clock: current UTC time in ms\n\t * video_time: output video time\n\t * video_timescale: output video timescale\n\t * video_width: output video width\n\t * video_height: output video height\n\nIf your path needs to be reevaluated on regular basis, set the value this.reload to the timeout to next reload, in milliseconds.\n\nOptions:\n\t* rx (0): horizontal radius for rounded rect in percent of object width if positive, in absolute value if negative, value y means use ry\n\t* ry (0): vertical radius for rounded rect in percent of object height if positive, in absolute value if negative, value x means use rx\n\t* tl (1): top-left corner scaler (positive, 0 disables corner)\n\t* bl (1): bottom-left corner scaler (positive, 0 disables corner)\n\t* tr (1): top-right corner scaler (positive, 0 disables corner)\n\t* br (1): bottom-right corner scaler (positive, 0 disables corner)\n\t* rs (false): repeat texture horizontally\n\t* rt (false): repeat texture vertically\n\t* keep_ar (true): keep aspect ratio\n\t* pad_color ('0x00FFFFFF'): color to use for texture padding if rs or rt are false. Use none to use texture edge, 0x00FFFFFF for transparent (always enforced if source is transparent)\n\t* txmx ([]): texture matrix - all 6 coefficients must be set, i.e. [xx xy tx yx yy ty]\n\t* cmx ([]): color transform - all 20 coefficients must be set in order, i.e. [Mrr, Mrg, Mrb, Mra, Tr, Mgr, Mgg ...]\n\t* line_width (0): line width in percent of width if positive, or absolute value if negative\n\t* line_color ('white'): line color, linear for linear gradient and radial for radial gradient\n\t* line_pos ('center'): line/shape positioning. Possible values are:\n\t  * center: line is centered around shape\n\t  * outside: line is outside the shape\n\t  * inside: line is inside the shape\n\t* line_dash ('plain'): line dashing mode. Possible values are:\n\t  * plain: no dash\n\t  * dash: predefined dash pattern is used\n\t  * dot:  predefined dot pattern is used\n\t  * dashdot:  predefined dash-dot pattern is used\n\t  * dashdashdot:  predefined dash-dash-dot pattern is used\n\t  * dashdotdot:  predefined dash-dot-dot pattern is used\n\t* dashes ([]): dash/dot pattern lengths for custom dashes (these will be multiplied by line size)\n\t* cap ('flat'): line end style. Possible values are:\n\t  * flat: flat end\n\t  * round: round end\n\t  * square: square end (extends limit compared to flat)\n\t  * triangle: triangle end\n\t* join ('miter'): line joint style. Possible values are:\n\t  * miter: miter join (straight lines)\n\t  * round: round join\n\t  * bevel: bevel join\n\t  * bevelmiter: bevel+miter join\n\t* miter_limit (2): miter limit for joint styles\n\t* dash_length (-1): length of path to outline, negative values mean full path\n\t* dash_offset (0): offset in path at which the outline starts\n\t* blit (true): use blit if possible, otherwise EVG texturing. If disabled, always use texturing\n\t* fill ('none'): fill color if used without sources, linear for linear gradient and radial for radial gradient\n\t* img (''): image for scene without sources or when replace is set. Accepts either a path to a local image (JPG or PNG), the ID of an offscreen group or the ID of a sequence\n\t* alpha (1): global texture transparency\n\t* replace (''): if img or fill is set and shape is using source, set multi texture option. Possible modes are:\n\t * a, r, g or b: replace alpha source component by indicated component from img . If prefix - is set, replace by one minus the indicated component\n\t * m: mix using mix_ratio the color components of source and img and set alpha to full opacity\n\t * M: mix using mix_ratio all components of source and img, including alpha\n\t * xC: mix source 1 and source 2 using img component C (a, r, g or b) and force alpha to full opacity\n\t * XC: mix source 1 and source 2 using img component C (a, r, g or b), including alpha\n\n\t* shape ('rect'): shape type. Possible values are:\n\t  * rect: rounded rectangle\n\t  * square: square using smaller width/height value\n\t  * ellipse: ellipse\n\t  * circle: circle using smaller width/height value\n\t  * rhombus: axis-aligned rhombus\n\t  * text: force text mode even if text field is empty\n\t  * rects: same as rounded rectangle but use straight lines for corners\n\t  * other value: JS code for custom path creation, either string or local file name (dynamic reload possible)\n\t* grad_p ([]): gradient positions between 0 and 1\n\t* grad_c ([]): gradient colors for each position, as strings\n\t* grad_start ([]): start point for linear gradient or center point for radial gradient\n\t* grad_end ([]): end point for linear gradient or radius value for radial gradient\n\t* grad_focal ([]): focal point for radial gradient\n\t* grad_mode ('pad'): gradient mode. Possible values are:\n\t  * pad: color padding outside of gradient bounds\n\t  * spread: mirror gradient outside of bounds\n\t  * repeat: repeat gradient outside of bounds\n\t* text ([]): text lines (UTF-8 only). If not empty, force shape=text\n\t* font ([]): font name(s)\n\t* size (20): font size in percent of height (horizontal text) or width (vertical text), or absolute value if negative\n\t* baseline ('alphabetic'): baseline position. Possible values are:\n\t  * alphabetic: alphabetic position of baseline\n\t  * top: baseline at top of EM Box\n\t  * hanging: reserved, not implemented\n\t  * middle: baseline at middle of EM Box\n\t  * ideograph: reserved, not implemented\n\t  * bottom: baseline at bottom of EM Box\n\t* align ('center'): horizontal text alignment. Possible values are:\n\t  * center: center of shape\n\t  * start: start of shape (left or right depending on text direction)\n\t  * end: end of shape (right or left depending on text direction)\n\t  * left: left of shape\n\t  * right: right of shape\n\t* spacing (0): line spacing in percent of height (horizontal text) or width (vertical text), or absolute value if negative\n\t* bold (false): use bold version of font\n\t* italic (false): use italic version of font\n\t* underline (false): underline text\n\t* vertical (false): draw text vertically\n\t* flip (false): flip text vertically\n\t* extend (0): maximum text width in percent of width (for horizontal) or height (for vertical), or absolute value if negative\n\t* keep_ar_rep (true): same as keep_ar for local image in replace mode\n\t* txmx_rep ([]): same as txmx for  local image in replace mode\n\t* cmx_rep ([]): same as cmx for local image in replace mode\n\t* pad_color_rep ('none'): same as pad_color for local image in replace mode\n\t* rs_rep (false): same as rs for local image in replace mode\n\t* rt_rep (false): same as rt for local image in replace mode\n\nTransition modules\n\nTransition gltrans - GPU only\nThis transition module wraps gl-transitions, see https://gl-transitions.com/ and gpac -h avmix:gltrans for builtin transitions\nOptions:\n\t* fx (''): effect name for built-in effects, or path to gl-transition GLSL file\n\nTransition swipe - software/GPU\nThis transition performs simple 2D affine transformations for source videos transitions, with configurable effect origin\nOptions:\n\t* from ('left'): direction of video 2 entry. Possible values are:\n\t  * left: from left to right edges\n\t  * right: from right to left edges\n\t  * top: from top to bottom edges\n\t  * bottom: from bottom to top edges\n\t  * topleft: from top-left to bottom-right corners\n\t  * topright: from top-right to bottom-left corners\n\t  * bottomleft: from bottom-left to top-right corners\n\t  * bottomright: from bottom-right to top-left corners\n\n\t* mode ('slide'): how video 2 entry impacts video 1. Possible values are:\n\t  * slide: video 1 position is not modified\n\t  * push: video 2 pushes video 1 away\n\t  * squeeze: video 2 squeezes video 1 along opposite edge\n\t  * grow: video 2 size increases, video 1 not modified\n\t  * swap: video 2 size increases, video 1 size decreases\n\nTransition mix - software/GPU\nThis transition performs cross-fade of source videos\n\nTransition fade - software/GPU\nThis transition performs fade to/from color of source videos\nOptions:\n\t* color ('black'): fade color\n\n\n",
        "options": {
            "pl": {
                "type": "str",
                "description": "local playlist file to load",
                "default": "avmix.json"
            },
            "live": {
                "type": "bool",
                "description": "live mode",
                "default": true
            },
            "gpu": {
                "type": "enum",
                "description": "enable GPU usage",
                "default": "off",
                "enum": {
                    "off": "no GPU",
                    "mix": "only render textured path to GPU, use software rasterizer for the outlines, solid fills and gradients",
                    "all": "try to use GPU for everything"
                }
            },
            "thread": {
                "type": "sint",
                "description": "use threads for software rasterizer (-1 for all available cores)",
                "default": "-1"
            },
            "lwait": {
                "type": "uint",
                "description": "timeout in ms before considering no signal is present",
                "default": 1000
            },
            "ltimeout": {
                "type": "uint",
                "description": "timeout in ms before restarting child processes",
                "default": 4000
            },
            "maxdur": {
                "type": "dbl",
                "description": "run for given seconds and exit, will not abort if 0 (used for live mode tests)",
                "default": "0"
            },
            "updates": {
                "type": "str",
                "description": "local JSON files for playlist updates"
            },
            "maxdepth": {
                "type": "uint",
                "description": "maximum depth of a branch in the scene graph",
                "default": 100
            },
            "vsize": {
                "type": "v2d",
                "description": "output video size, 0 disable video output",
                "default": "1920x1080"
            },
            "fps": {
                "type": "frac",
                "description": "output video frame rate",
                "default": "25"
            },
            "pfmt": {
                "type": "pfmt",
                "description": "output pixel format. Use rgba in GPU mode to force alpha channel",
                "default": "yuv"
            },
            "dynpfmt": {
                "type": "enum",
                "description": "allow dynamic change of output pixel format in software mode",
                "default": "init",
                "enum": {
                    "off": "pixel format is forced to desired value",
                    "init": "pixel format is forced to format of fullscreen input in first generated frame",
                    "all": "pixel format changes each time a full-screen input PID at same resolution is used"
                }
            },
            "sr": {
                "type": "uint",
                "description": "output audio sample rate, 0 disable audio output",
                "default": 44100
            },
            "ch": {
                "type": "uint",
                "description": "number of output audio channels, 0 disable audio output",
                "default": 2
            },
            "afmt": {
                "type": "afmt",
                "description": "output audio format (only s16, s32, flt and dbl are supported)",
                "default": "s16"
            },
            "alen": {
                "type": "uint",
                "description": "default number of samples per frame",
                "default": 1024
            }
        },
        "capabilities": {
            "input": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": [
            "compositor",
            "mp4dmx",
            "rfimg",
            "imgdec",
            "faad",
            "maddec",
            "xviddec",
            "j2kdec",
            "a52dec",
            "vorbisdec",
            "theoradec",
            "osvcdec",
            "vtbdec",
            "mcdec",
            "safdmx",
            "dashin",
            "cdcrypt",
            "nhntr",
            "nhmlr",
            "avidmx",
            "rtpin",
            "reframer",
            "resample",
            "vcrop",
            "vflip",
            "rfrawvid",
            "rfpcm",
            "rewind",
            "flist",
            "dasher",
            "gsfdmx",
            "nvdec",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffdmx",
            "ffdec",
            "ffavin",
            "ffsws",
            "ffavf",
            "restamp",
            "ohevcdec"
        ],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout"
        ]
    },
    {
        "name": "avgen",
        "description": "AV Counter Generator",
        "version": "1.0",
        "author": "GPAC Team",
        "body": "This filter generates AV streams representing a counter. Streams can be enabled or disabled using type.\nThe filter is software-based and does not use GPU.\n\nWhen adjust is set, the first video frame is adjusted such that a full circle happens at each exact second according to the system UTC clock.\nBy default, video UTC and date are computed at each frame generation from current clock and not from frame number.\nThis will result in broken timing when playing at speeds other than 1.0.\nThis can be changed using lock.\n\nAudio beep is generated every second, with octave (2xfreq) of even beep used every 10 seconds.\nWhen video is generated, beep is synchronized to video at each exact second.\n\nIf NTP injection is used, each video packet (but not audio ones) has a SenderNTP property set; if video is not used, each audio packet has a SenderNTP property set.\n\nMultiple output stream generation\n\nMore than one output size can be specified. This will result in multiple sources being generated, one per size.\nA size can be specified more than once, resulting in packet references when copy is not set, or full copies otherwise.\nTarget encoding bitrates can be assigned to each output using rates. This can be useful when generating dash:\nExample:\ngpac avgen:sizes=1280x720,1920x1080:rates=2M,5M c=aac:FID=1 c=264:FID=2:clone -o live.mpd:SID=1,2\n\nMultiview generation\n\nIn multiview mode, only the animated counter will move in depth backward and forward, as indicated by the disparity value.\nWhen pack is set, a packed stereo couple is generated for each video packet.\nOtherwise, when views is greater than 2, each view is generated on a dedicated output PID with the property ViewIdx set in [1, views].\nMulti-view output forces usage of copy mode.\n\nPID Naming\n\nThe audio PID is assigned the name audio and ID 1.\nIf a single video PID is produced, it is assigned the name video and ID 2.\nIf multiple video PIDs are produced, they are assigned the names videoN and ID N+1, N in [1, sizes].\nIf multiple views are generated, they are assigned the names videoN_vK and ID N*views+K-1, N in [1, sizes], K in [1, views].\n\n\n",
        "options": {
            "type": {
                "type": "enum",
                "description": "output selection",
                "default": "av",
                "enum": {
                    "a": "audio only",
                    "v": "video only",
                    "av": "audio and video"
                }
            },
            "freq": {
                "type": "uint",
                "description": "frequency of beep",
                "default": 440
            },
            "freq2": {
                "type": "uint",
                "description": "frequency of odd beep",
                "default": 659
            },
            "sr": {
                "type": "uint",
                "description": "output samplerate",
                "default": 44100
            },
            "flen": {
                "type": "uint",
                "description": "output frame length in samples",
                "default": 1024
            },
            "ch": {
                "type": "uint",
                "description": "number of channels",
                "default": 1
            },
            "alter": {
                "type": "bool",
                "description": "beep alternatively on each channel",
                "default": true
            },
            "blen": {
                "type": "uint",
                "description": "length of beep in milliseconds",
                "default": 50
            },
            "fps": {
                "type": "frac",
                "description": "video frame rate",
                "default": "25"
            },
            "sizes": {
                "type": "v2il",
                "description": "video size in pixels",
                "default": "1280x720"
            },
            "pfmt": {
                "type": "pfmt",
                "description": "output pixel format",
                "default": "yuv"
            },
            "lock": {
                "type": "bool",
                "description": "lock timing to video generation",
                "default": true
            },
            "dyn": {
                "type": "bool",
                "description": "move bottom banner",
                "default": true
            },
            "ntp": {
                "type": "bool",
                "description": "send NTP along with packets",
                "default": true
            },
            "copy": {
                "type": "bool",
                "description": "copy the framebuffer into each video packet instead of using packet references",
                "default": true
            },
            "dur": {
                "type": "frac",
                "description": "run for the given time in second",
                "default": "0/0"
            },
            "adjust": {
                "type": "bool",
                "description": "adjust start time to synchronize counter and UTC",
                "default": true
            },
            "pack": {
                "type": "enum",
                "description": "packing mode for stereo views",
                "default": "no",
                "enum": {
                    "no": "no packing",
                    "ss": "side by side packing, forces views to 2",
                    "tb": "top-bottom packing, forces views to 2"
                }
            },
            "disparity": {
                "type": "uint",
                "description": "disparity in pixels between left-most and right-most views",
                "default": 20
            },
            "views": {
                "type": "uint",
                "description": "number of views",
                "default": 1
            },
            "rates": {
                "type": "strl",
                "description": "number of target bitrates to assign, one per size"
            },
            "logt": {
                "type": "bool",
                "description": "log frame time to console"
            }
        },
        "capabilities": {
            "input": {
                "codec_id": [],
                "stream_type": []
            },
            "output": {
                "codec_id": ["Raw media"],
                "stream_type": ["Audio", "Visual"]
            }
        },
        "sources": ["no", "sources"],
        "sinks": [
            "inspect",
            "probe",
            "compositor",
            "mp4mx",
            "reframer",
            "writegen",
            "nhntw",
            "nhmlw",
            "avimx",
            "aout",
            "resample",
            "vout",
            "vcrop",
            "vflip",
            "jpgenc",
            "pngenc",
            "rewind",
            "dasher",
            "gsfmx",
            "rtpout",
            "rtspout",
            "bsrw",
            "bssplit",
            "bsagg",
            "ffsws",
            "ffenc",
            "ffmx",
            "ffavf",
            "restamp",
            "unframer",
            "writeuf",
            "dtout"
        ]
    }
]
